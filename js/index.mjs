function __esmScriptDynamicImportRuntime__(path){const pathname=new URL(path).pathname;const[,...relativePath]=pathname.split("/esm-scripts/");const specifier=["",relativePath].join("./esm-scripts/");switch(specifier){case"./esm-scripts/scripts/game.mjs":return import('./esm-DcdHCHkg.js').then(function (n) { return n.j; });case"./esm-scripts/scripts/character.mjs":return import('./esm-DcdHCHkg.js').then(function (n) { return n.l; });case"./esm-scripts/scripts/player.mjs":return import('./esm-DcdHCHkg.js').then(function (n) { return n.m; });case"./esm-scripts/scripts/enemy.mjs":return import('./esm-DcdHCHkg.js').then(function (n) { return n.n; });case"./esm-scripts/scripts/utils.mjs":return import('./esm-DcdHCHkg.js').then(function (n) { return n.u; });case"./esm-scripts/scripts/constants.mjs":return import('./esm-DcdHCHkg.js').then(function (n) { return n.c; });case"./esm-scripts/scripts/box2d_utils.mjs":return import('./esm-DcdHCHkg.js').then(function (n) { return n.i; });case"./esm-scripts/scripts/joystick.mjs":return import('./esm-DcdHCHkg.js').then(function (n) { return n.o; });case"./esm-scripts/scripts/desktop_input.mjs":return import('./esm-DcdHCHkg.js').then(function (n) { return n.q; });case"./esm-scripts/scripts/mobile_input.mjs":return import('./esm-DcdHCHkg.js').then(function (n) { return n.r; });case"./esm-scripts/scripts/game_camera.mjs":return import('./esm-DcdHCHkg.js').then(function (n) { return n.v; });case"./esm-scripts/scripts/transform2d.mjs":return import('./esm-DcdHCHkg.js').then(function (n) { return n.t; });case"./esm-scripts/scripts/shape_type.mjs":return import('./esm-DcdHCHkg.js').then(function (n) { return n.s; });case"./esm-scripts/scripts/anim_transition_data.mjs":return import('./esm-DcdHCHkg.js').then(function (n) { return n.w; });case"./esm-scripts/scripts/enemy_grid.mjs":return import('./esm-DcdHCHkg.js').then(function (n) { return n.e; });case"./esm-scripts/scripts/actor.mjs":return import('./esm-DcdHCHkg.js').then(function (n) { return n.k; });case"./esm-scripts/scripts/tower.mjs":return import('./esm-DcdHCHkg.js').then(function (n) { return n.x; });case"./esm-scripts/scripts/projectile.mjs":return import('./esm-DcdHCHkg.js').then(function (n) { return n.y; });case"./esm-scripts/scripts/trail.mjs":return import('./esm-DcdHCHkg.js').then(function (n) { return n.z; });case"./esm-scripts/scripts/effect.mjs":return import('./esm-DcdHCHkg.js').then(function (n) { return n.A; });case"./esm-scripts/scripts/path.mjs":return import('./esm-DcdHCHkg.js').then(function (n) { return n.p; });case"./esm-scripts/scripts/bezier_path.mjs":return import('./esm-DcdHCHkg.js').then(function (n) { return n.b; });case"./esm-scripts/scripts/enemy_ai.mjs":return import('./esm-DcdHCHkg.js').then(function (n) { return n.a; });case"./esm-scripts/scripts/follow_path_enemy_ai.mjs":return import('./esm-DcdHCHkg.js').then(function (n) { return n.f; });case"./esm-scripts/scripts/enemy_spawner.mjs":return import('./esm-DcdHCHkg.js').then(function (n) { return n.d; });case"./esm-scripts/scripts/enemy_path_spawner.mjs":return import('./esm-DcdHCHkg.js').then(function (n) { return n.g; });case"./esm-scripts/scripts/enemy_point_spawner.mjs":return import('./esm-DcdHCHkg.js').then(function (n) { return n.h; });case"./esm-scripts/scripts/tower_placement.mjs":return import('./esm-DcdHCHkg.js').then(function (n) { return n.B; });case"./esm-scripts/scripts/coin.mjs":return import('./esm-DcdHCHkg.js').then(function (n) { return n.C; });case"./esm-scripts/scripts/coin_info.mjs":return import('./esm-DcdHCHkg.js').then(function (n) { return n.D; });case"./esm-scripts/scripts/end_screen.mjs":return import('./esm-DcdHCHkg.js').then(function (n) { return n.E; });case"./esm-scripts/scripts/character_data.mjs":return import('./esm-DcdHCHkg.js').then(function (n) { return n.G; });case"./esm-scripts/scripts/enemy_data.mjs":return import('./esm-DcdHCHkg.js').then(function (n) { return n.H; });case"./esm-scripts/scripts/player_data.mjs":return import('./esm-DcdHCHkg.js').then(function (n) { return n.I; });case"./esm-scripts/scripts/tower_data.mjs":return import('./esm-DcdHCHkg.js').then(function (n) { return n.J; });case"./esm-scripts/scripts/projectile_data.mjs":return import('./esm-DcdHCHkg.js').then(function (n) { return n.K; });case"./esm-scripts/scripts/actor_data.mjs":return import('./esm-DcdHCHkg.js').then(function (n) { return n.F; });case"./esm-scripts/scripts/coin_data.mjs":return import('./esm-DcdHCHkg.js').then(function (n) { return n.L; });case"./esm-scripts/scripts/base.mjs":return import('./esm-DcdHCHkg.js').then(function (n) { return n.M; });case"./esm-scripts/scripts/base_data.mjs":return import('./esm-DcdHCHkg.js').then(function (n) { return n.N; });default:return import(path)}}/**
 * @license
 * PlayCanvas Engine v1.77.0 revision f90da0d (RELEASE)
 * Copyright 2011-2025 PlayCanvas Ltd. All rights reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */const TRACEID_RENDER_FRAME="RenderFrame";const TRACEID_RENDER_FRAME_TIME="RenderFrameTime";const TRACEID_RENDER_PASS="RenderPass";const TRACEID_RENDER_PASS_DETAIL="RenderPassDetail";const TRACEID_RENDER_ACTION="RenderAction";const TRACEID_RENDER_TARGET_ALLOC="RenderTargetAlloc";const TRACEID_TEXTURE_ALLOC="TextureAlloc";const TRACEID_SHADER_ALLOC="ShaderAlloc";const TRACEID_SHADER_COMPILE="ShaderCompile";const TRACEID_VRAM_TEXTURE="VRAM.Texture";const TRACEID_VRAM_VB="VRAM.Vb";const TRACEID_VRAM_IB="VRAM.Ib";const TRACEID_VRAM_SB="VRAM.Sb";const TRACEID_BINDGROUP_ALLOC="BindGroupAlloc";const TRACEID_BINDGROUPFORMAT_ALLOC="BindGroupFormatAlloc";const TRACEID_RENDERPIPELINE_ALLOC="RenderPipelineAlloc";const TRACEID_COMPUTEPIPELINE_ALLOC="ComputePipelineAlloc";const TRACEID_PIPELINELAYOUT_ALLOC="PipelineLayoutAlloc";const TRACE_ID_ELEMENT="Element";const TRACEID_TEXTURES="Textures";const TRACEID_RENDER_QUEUE="RenderQueue";const TRACEID_GPU_TIMINGS="GpuTimings";const version="1.77.0";const revision="f90da0d";const config={};const common={};const apps={};const data$1={};const typeofs=["undefined","number","string","boolean"];const objectTypes={"[object Array]":"array","[object Object]":"object","[object Function]":"function","[object Date]":"date","[object RegExp]":"regexp","[object Float32Array]":"float32array"};function type(obj){if(obj===null){return "null"}const typeString=typeof obj;if(typeofs.includes(typeString)){return typeString}return objectTypes[Object.prototype.toString.call(obj)]}function extend(target,ex){for(const prop in ex){const copy=ex[prop];if(type(copy)==="object"){target[prop]=extend({},copy);}else if(type(copy)==="array"){target[prop]=extend([],copy);}else {target[prop]=copy;}}return target}class EventHandle{off(){if(this._removed)return;this.handler.offByHandle(this);}on(name,callback,scope=this){return this.handler._addCallback(name,callback,scope,false)}once(name,callback,scope=this){return this.handler._addCallback(name,callback,scope,true)}set removed(value){if(!value)return;this._removed=true;}get removed(){return this._removed}constructor(handler,name,callback,scope,once=false){this.handler=void 0;this.name=void 0;this.callback=void 0;this.scope=void 0;this._once=void 0;this._removed=false;this.handler=handler;this.name=name;this.callback=callback;this.scope=scope;this._once=once;}}class EventHandler{initEventHandler(){this._callbacks=new Map;this._callbackActive=new Map;}_addCallback(name,callback,scope,once){if(!this._callbacks.has(name)){this._callbacks.set(name,[]);}if(this._callbackActive.has(name)){const callbackActive=this._callbackActive.get(name);if(callbackActive&&callbackActive===this._callbacks.get(name)){this._callbackActive.set(name,callbackActive.slice());}}const evt=new EventHandle(this,name,callback,scope,once);this._callbacks.get(name).push(evt);return evt}on(name,callback,scope=this){return this._addCallback(name,callback,scope,false)}once(name,callback,scope=this){return this._addCallback(name,callback,scope,true)}off(name,callback,scope){if(name){if(this._callbackActive.has(name)&&this._callbackActive.get(name)===this._callbacks.get(name)){this._callbackActive.set(name,this._callbackActive.get(name).slice());}}else {for(const[key,callbacks]of this._callbackActive){if(!this._callbacks.has(key)){continue}if(this._callbacks.get(key)!==callbacks){continue}this._callbackActive.set(key,callbacks.slice());}}if(!name){for(const callbacks of this._callbacks.values()){for(let i=0;i<callbacks.length;i++){callbacks[i].removed=true;}}this._callbacks.clear();}else if(!callback){const callbacks=this._callbacks.get(name);if(callbacks){for(let i=0;i<callbacks.length;i++){callbacks[i].removed=true;}this._callbacks.delete(name);}}else {const callbacks=this._callbacks.get(name);if(!callbacks){return this}for(let i=0;i<callbacks.length;i++){if(callbacks[i].callback!==callback){continue}if(scope&&callbacks[i].scope!==scope){continue}callbacks[i].removed=true;callbacks.splice(i,1);i--;}if(callbacks.length===0){this._callbacks.delete(name);}}return this}offByHandle(handle){const name=handle.name;handle.removed=true;if(this._callbackActive.has(name)&&this._callbackActive.get(name)===this._callbacks.get(name)){this._callbackActive.set(name,this._callbackActive.get(name).slice());}const callbacks=this._callbacks.get(name);if(!callbacks){return this}const ind=callbacks.indexOf(handle);if(ind!==-1){callbacks.splice(ind,1);if(callbacks.length===0){this._callbacks.delete(name);}}return this}fire(name,arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8){if(!name){return this}const callbacksInitial=this._callbacks.get(name);if(!callbacksInitial){return this}let callbacks;if(!this._callbackActive.has(name)){this._callbackActive.set(name,callbacksInitial);}else if(this._callbackActive.get(name)!==callbacksInitial){callbacks=callbacksInitial.slice();}for(let i=0;(callbacks||this._callbackActive.get(name))&&i<(callbacks||this._callbackActive.get(name)).length;i++){const evt=(callbacks||this._callbackActive.get(name))[i];if(!evt.callback)continue;evt.callback.call(evt.scope,arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);if(evt._once){const existingCallback=this._callbacks.get(name);const ind=existingCallback?existingCallback.indexOf(evt):-1;if(ind!==-1){if(this._callbackActive.get(name)===existingCallback){this._callbackActive.set(name,this._callbackActive.get(name).slice());}const _callbacks=this._callbacks.get(name);if(!_callbacks)continue;_callbacks[ind].removed=true;_callbacks.splice(ind,1);if(_callbacks.length===0){this._callbacks.delete(name);}}}}if(!callbacks){this._callbackActive.delete(name);}return this}hasEvent(name){var _this$_callbacks$get;return !!((_this$_callbacks$get=this._callbacks.get(name))!=null&&_this$_callbacks$get.length)}constructor(){this._callbacks=new Map;this._callbackActive=new Map;}}const events={attach(target){const ev=events;target._addCallback=ev._addCallback;target.on=ev.on;target.off=ev.off;target.fire=ev.fire;target.once=ev.once;target.hasEvent=ev.hasEvent;EventHandler.prototype.initEventHandler.call(target);return target},_addCallback:EventHandler.prototype._addCallback,on:EventHandler.prototype.on,off:EventHandler.prototype.off,fire:EventHandler.prototype.fire,once:EventHandler.prototype.once,hasEvent:EventHandler.prototype.hasEvent};const guid={create(){return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,c=>{const r=Math.random()*16|0;const v=c==="x"?r:r&3|8;return v.toString(16)})}};const path={delimiter:"/",join(...sections){let result=sections[0];for(let i=0;i<sections.length-1;i++){const one=sections[i];const two=sections[i+1];if(two[0]===path.delimiter){result=two;continue}if(one&&two&&one[one.length-1]!==path.delimiter&&two[0]!==path.delimiter){result+=path.delimiter+two;}else {result+=two;}}return result},normalize(pathname){const lead=pathname.startsWith(path.delimiter);const trail=pathname.endsWith(path.delimiter);const parts=pathname.split("/");let result="";let cleaned=[];for(let i=0;i<parts.length;i++){if(parts[i]==="")continue;if(parts[i]===".")continue;if(parts[i]===".."&&cleaned.length>0){cleaned=cleaned.slice(0,cleaned.length-2);continue}if(i>0)cleaned.push(path.delimiter);cleaned.push(parts[i]);}result=cleaned.join("");if(!lead&&result[0]===path.delimiter){result=result.slice(1);}if(trail&&result[result.length-1]!==path.delimiter){result+=path.delimiter;}return result},split(pathname){const lastDelimiterIndex=pathname.lastIndexOf(path.delimiter);if(lastDelimiterIndex!==-1){return [pathname.substring(0,lastDelimiterIndex),pathname.substring(lastDelimiterIndex+1)]}return ["",pathname]},getBasename(pathname){return path.split(pathname)[1]},getDirectory(pathname){return path.split(pathname)[0]},getExtension(pathname){const ext=pathname.split("?")[0].split(".").pop();if(ext!==pathname){return `.${ext}`}return ""},isRelativePath(pathname){return pathname.charAt(0)!=="/"&&pathname.match(/:\/\//)===null},extractPath(pathname){let result="";const parts=pathname.split("/");let i=0;if(parts.length>1){if(path.isRelativePath(pathname)){if(parts[0]==="."){for(i=0;i<parts.length-1;++i){result+=i===0?parts[i]:`/${parts[i]}`;}}else if(parts[0]===".."){for(i=0;i<parts.length-1;++i){result+=i===0?parts[i]:`/${parts[i]}`;}}else {result=".";for(i=0;i<parts.length-1;++i){result+=`/${parts[i]}`;}}}else {for(i=0;i<parts.length-1;++i){result+=i===0?parts[i]:`/${parts[i]}`;}}}return result}};var _ref,_ref2,_ref3;const detectPassiveEvents=()=>{let result=false;try{const opts=Object.defineProperty({},"passive",{get:function(){result=true;return false}});window.addEventListener("testpassive",null,opts);window.removeEventListener("testpassive",null,opts);}catch(e){}return result};const ua=typeof navigator!=="undefined"?navigator.userAgent:"";const environment=typeof window!=="undefined"?"browser":typeof global!=="undefined"?"node":"worker";const platformName=/android/i.test(ua)?"android":/ip(?:[ao]d|hone)/i.test(ua)?"ios":/windows/i.test(ua)?"windows":/mac os/i.test(ua)?"osx":/linux/i.test(ua)?"linux":/cros/i.test(ua)?"cros":null;const browserName=environment!=="browser"?null:/Chrome\/|Chromium\/|Edg.*\//.test(ua)?"chrome":/Safari\//.test(ua)?"safari":/Firefox\//.test(ua)?"firefox":"other";const xbox=/xbox/i.test(ua);const touch=environment==="browser"&&("ontouchstart"in window||"maxTouchPoints"in navigator&&navigator.maxTouchPoints>0);const gamepads=environment==="browser"&&(!!navigator.getGamepads||!!navigator.webkitGetGamepads);const workers=typeof Worker!=="undefined";const passiveEvents=detectPassiveEvents();const platform={name:platformName,environment:environment,global:(_ref=(_ref2=(_ref3=typeof globalThis!=="undefined"&&globalThis)!=null?_ref3:environment==="browser"&&window)!=null?_ref2:environment==="node"&&global)!=null?_ref:environment==="worker"&&self,browser:environment==="browser",worker:environment==="worker",desktop:["windows","osx","linux","cros"].includes(platformName),mobile:["android","ios"].includes(platformName),ios:platformName==="ios",android:platformName==="android",xbox:xbox,gamepads:gamepads,touch:touch,workers:workers,passiveEvents:passiveEvents,browserName:browserName};const ASCII_LOWERCASE="abcdefghijklmnopqrstuvwxyz";const ASCII_UPPERCASE="ABCDEFGHIJKLMNOPQRSTUVWXYZ";const ASCII_LETTERS=ASCII_LOWERCASE+ASCII_UPPERCASE;const HIGH_SURROGATE_BEGIN=55296;const HIGH_SURROGATE_END=56319;const LOW_SURROGATE_BEGIN=56320;const LOW_SURROGATE_END=57343;const ZERO_WIDTH_JOINER=8205;const REGIONAL_INDICATOR_BEGIN=127462;const REGIONAL_INDICATOR_END=127487;const FITZPATRICK_MODIFIER_BEGIN=127995;const FITZPATRICK_MODIFIER_END=127999;const DIACRITICAL_MARKS_BEGIN=8400;const DIACRITICAL_MARKS_END=8447;const VARIATION_MODIFIER_BEGIN=65024;const VARIATION_MODIFIER_END=65039;function getCodePointData(string,i=0){const size=string.length;if(i<0||i>=size){return null}const first=string.charCodeAt(i);if(size>1&&first>=HIGH_SURROGATE_BEGIN&&first<=HIGH_SURROGATE_END){const second=string.charCodeAt(i+1);if(second>=LOW_SURROGATE_BEGIN&&second<=LOW_SURROGATE_END){return {code:(first-HIGH_SURROGATE_BEGIN)*1024+second-LOW_SURROGATE_BEGIN+65536,long:true}}}return {code:first,long:false}}function isCodeBetween(string,begin,end){if(!string){return false}const codeData=getCodePointData(string);if(codeData){const code=codeData.code;return code>=begin&&code<=end}return false}function numCharsToTakeForNextSymbol(string,index){if(index===string.length-1){return 1}if(isCodeBetween(string[index],HIGH_SURROGATE_BEGIN,HIGH_SURROGATE_END)){const first=string.substring(index,index+2);const second=string.substring(index+2,index+4);if(isCodeBetween(second,FITZPATRICK_MODIFIER_BEGIN,FITZPATRICK_MODIFIER_END)||isCodeBetween(first,REGIONAL_INDICATOR_BEGIN,REGIONAL_INDICATOR_END)&&isCodeBetween(second,REGIONAL_INDICATOR_BEGIN,REGIONAL_INDICATOR_END)){return 4}if(isCodeBetween(second,VARIATION_MODIFIER_BEGIN,VARIATION_MODIFIER_END)){return 3}return 2}if(isCodeBetween(string[index+1],VARIATION_MODIFIER_BEGIN,VARIATION_MODIFIER_END)){return 2}return 1}const string={ASCII_LOWERCASE:ASCII_LOWERCASE,ASCII_UPPERCASE:ASCII_UPPERCASE,ASCII_LETTERS:ASCII_LETTERS,format(s,...args){for(let i=0;i<args.length;i++){s=s.replace(`{${i}}`,args[i]);}return s},getCodePoint(string,i){const codePointData=getCodePointData(string,i);return codePointData&&codePointData.code},getCodePoints(string){if(typeof string!=="string"){throw new TypeError("Not a string")}let i=0;const arr=[];let codePoint;while(!!(codePoint=getCodePointData(string,i))){arr.push(codePoint.code);i+=codePoint.long?2:1;}return arr},getSymbols(string){if(typeof string!=="string"){throw new TypeError("Not a string")}let index=0;const length=string.length;const output=[];let take=0;let ch;while(index<length){take+=numCharsToTakeForNextSymbol(string,index+take);ch=string[index+take];if(isCodeBetween(ch,DIACRITICAL_MARKS_BEGIN,DIACRITICAL_MARKS_END)){ch=string[index+take++];}if(isCodeBetween(ch,VARIATION_MODIFIER_BEGIN,VARIATION_MODIFIER_END)){ch=string[index+take++];}if(ch&&ch.charCodeAt(0)===ZERO_WIDTH_JOINER){ch=string[index+take++];continue}const char=string.substring(index,index+take);output.push(char);index+=take;take=0;}return output},fromCodePoint(){const chars=[];let current;let codePoint;let units;for(let i=0;i<arguments.length;++i){current=Number(arguments[i]);codePoint=current-65536;units=current>65535?[(codePoint>>10)+55296,codePoint%1024+56320]:[current];chars.push(String.fromCharCode.apply(null,units));}return chars.join("")}};class IndexedList{push(key,item){if(this._index[key]){throw Error(`Key already in index ${key}`)}const location=this._list.push(item)-1;this._index[key]=location;}has(key){return this._index[key]!==undefined}get(key){const location=this._index[key];if(location!==undefined){return this._list[location]}return null}remove(key){const location=this._index[key];if(location!==undefined){this._list.splice(location,1);delete this._index[key];for(key in this._index){const idx=this._index[key];if(idx>location){this._index[key]=idx-1;}}return true}return false}list(){return this._list}clear(){this._list.length=0;for(const prop in this._index){delete this._index[prop];}}constructor(){this._list=[];this._index={};}}const cachedResult=func=>{const uninitToken={};let result=uninitToken;return ()=>{if(result===uninitToken){result=func();}return result}};class Impl{static loadScript(url,callback){const s=document.createElement("script");s.setAttribute("src",url);s.onload=()=>{callback(null);};s.onerror=()=>{callback(`Failed to load script='${url}'`);};document.body.appendChild(s);}static loadWasm(moduleName,config,callback){const loadUrl=Impl.wasmSupported()&&config.glueUrl&&config.wasmUrl?config.glueUrl:config.fallbackUrl;if(loadUrl){Impl.loadScript(loadUrl,err=>{if(err){callback(err,null);}else {const module=window[moduleName];window[moduleName]=undefined;module({locateFile:()=>config.wasmUrl,onAbort:()=>{callback("wasm module aborted.");}}).then(instance=>{callback(null,instance);});}});}else {callback("No supported wasm modules found.",null);}}static getModule(name){if(!Impl.modules.hasOwnProperty(name)){Impl.modules[name]={config:null,initializing:false,instance:null,callbacks:[]};}return Impl.modules[name]}static initialize(moduleName,module){if(module.initializing){return}const config=module.config;if(config.glueUrl||config.wasmUrl||config.fallbackUrl){module.initializing=true;Impl.loadWasm(moduleName,config,(err,instance)=>{if(err){if(config.errorHandler){config.errorHandler(err);}else {console.error(`failed to initialize module=${moduleName} error=${err}`);}}else {module.instance=instance;module.callbacks.forEach(callback=>{callback(instance);});}});}}}Impl.modules={};Impl.wasmSupported=cachedResult(()=>{try{if(typeof WebAssembly==="object"&&typeof WebAssembly.instantiate==="function"){const module=new WebAssembly.Module(Uint8Array.of(0,97,115,109,1,0,0,0));if(module instanceof WebAssembly.Module){return new WebAssembly.Instance(module) instanceof WebAssembly.Instance}}}catch(e){}return false});class WasmModule{static setConfig(moduleName,config){const module=Impl.getModule(moduleName);module.config=config;if(module.callbacks.length>0){Impl.initialize(moduleName,module);}}static getConfig(moduleName){var _Impl$modules;return (_Impl$modules=Impl.modules)==null||(_Impl$modules=_Impl$modules[moduleName])==null?void 0:_Impl$modules.config}static getInstance(moduleName,callback){const module=Impl.getModule(moduleName);if(module.instance){callback(module.instance);}else {module.callbacks.push(callback);if(module.config){Impl.initialize(moduleName,module);}}}}class ReadStream{get remainingBytes(){return this.dataView.byteLength-this.offset}reset(offset=0){this.offset=offset;}skip(bytes){this.offset+=bytes;}align(bytes){this.offset=this.offset+bytes-1&~(bytes-1);}_inc(amount){this.offset+=amount;return this.offset-amount}readChar(){return String.fromCharCode(this.dataView.getUint8(this.offset++))}readChars(numChars){let result="";for(let i=0;i<numChars;++i){result+=this.readChar();}return result}readU8(){return this.dataView.getUint8(this.offset++)}readU16(){return this.dataView.getUint16(this._inc(2),true)}readU32(){return this.dataView.getUint32(this._inc(4),true)}readU64(){return this.readU32()+2**32*this.readU32()}readU32be(){return this.dataView.getUint32(this._inc(4),false)}readArray(result){for(let i=0;i<result.length;++i){result[i]=this.readU8();}}readLine(){const view=this.dataView;let result="";while(true){if(this.offset>=view.byteLength){break}const c=String.fromCharCode(this.readU8());if(c==="\n"){break}result+=c;}return result}constructor(arraybuffer){this.arraybuffer=void 0;this.dataView=void 0;this.offset=0;this.arraybuffer=arraybuffer;this.dataView=new DataView(arraybuffer);}}class SortedLoopArray{_binarySearch(item){let left=0;let right=this.items.length-1;const search=item[this._sortBy];let middle;let current;while(left<=right){middle=Math.floor((left+right)/2);current=this.items[middle][this._sortBy];if(current<=search){left=middle+1;}else if(current>search){right=middle-1;}}return left}_doSort(a,b){const sortBy=this._sortBy;return a[sortBy]-b[sortBy]}insert(item){const index=this._binarySearch(item);this.items.splice(index,0,item);this.length++;if(this.loopIndex>=index){this.loopIndex++;}}append(item){this.items.push(item);this.length++;}remove(item){const idx=this.items.indexOf(item);if(idx<0)return;this.items.splice(idx,1);this.length--;if(this.loopIndex>=idx){this.loopIndex--;}}sort(){const current=this.loopIndex>=0?this.items[this.loopIndex]:null;this.items.sort(this._sortHandler);if(current!==null){this.loopIndex=this.items.indexOf(current);}}constructor(args){this.items=[];this.length=0;this.loopIndex=-1;this._sortBy=void 0;this._sortHandler=void 0;this._sortBy=args.sortBy;this._sortHandler=this._doSort.bind(this);}}class Tags extends EventHandler{add(...args){let changed=false;const tags=this._processArguments(args,true);if(!tags.length){return changed}for(let i=0;i<tags.length;i++){if(this._index[tags[i]]){continue}changed=true;this._index[tags[i]]=true;this._list.push(tags[i]);this.fire("add",tags[i],this._parent);}if(changed){this.fire("change",this._parent);}return changed}remove(...args){let changed=false;if(!this._list.length){return changed}const tags=this._processArguments(args,true);if(!tags.length){return changed}for(let i=0;i<tags.length;i++){if(!this._index[tags[i]]){continue}changed=true;delete this._index[tags[i]];this._list.splice(this._list.indexOf(tags[i]),1);this.fire("remove",tags[i],this._parent);}if(changed){this.fire("change",this._parent);}return changed}clear(){if(!this._list.length){return}const tags=this._list.slice(0);this._list=[];this._index={};for(let i=0;i<tags.length;i++){this.fire("remove",tags[i],this._parent);}this.fire("change",this._parent);}has(...query){if(!this._list.length){return false}return this._has(this._processArguments(query))}_has(tags){if(!this._list.length||!tags.length){return false}for(let i=0;i<tags.length;i++){if(tags[i].length===1){if(this._index[tags[i][0]]){return true}}else {let multiple=true;for(let t=0;t<tags[i].length;t++){if(this._index[tags[i][t]]){continue}multiple=false;break}if(multiple){return true}}}return false}list(){return this._list.slice(0)}_processArguments(args,flat){const tags=[];let tmp=[];if(!args||!args.length){return tags}for(let i=0;i<args.length;i++){if(args[i]instanceof Array){if(!flat){tmp=[];}for(let t=0;t<args[i].length;t++){if(typeof args[i][t]!=="string"){continue}if(flat){tags.push(args[i][t]);}else {tmp.push(args[i][t]);}}if(!flat&&tmp.length){tags.push(tmp);}}else if(typeof args[i]==="string"){if(flat){tags.push(args[i]);}else {tags.push([args[i]]);}}}return tags}get size(){return this._list.length}constructor(parent){super();this._index={};this._list=[];this._parent=parent;}}Tags.EVENT_ADD="add";Tags.EVENT_REMOVE="remove";Tags.EVENT_CHANGE="change";const now=typeof window!=="undefined"&&window.performance&&window.performance.now?performance.now.bind(performance):Date.now;function createURI(options){let s="";if((options.authority||options.scheme)&&(options.host||options.hostpath)){throw new Error("Can't have 'scheme' or 'authority' and 'host' or 'hostpath' option")}if(options.host&&options.hostpath){throw new Error("Can't have 'host' and 'hostpath' option")}if(options.path&&options.hostpath){throw new Error("Can't have 'path' and 'hostpath' option")}if(options.scheme){s+=`${options.scheme}:`;}if(options.authority){s+=`//${options.authority}`;}if(options.host){s+=options.host;}if(options.path){s+=options.path;}if(options.hostpath){s+=options.hostpath;}if(options.query){s+=`?${options.query}`;}if(options.fragment){s+=`#${options.fragment}`;}return s}const re=/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;class URI{toString(){let s="";if(this.scheme){s+=`${this.scheme}:`;}if(this.authority){s+=`//${this.authority}`;}s+=this.path;if(this.query){s+=`?${this.query}`;}if(this.fragment){s+=`#${this.fragment}`;}return s}getQuery(){const result={};if(this.query){const queryParams=decodeURIComponent(this.query).split("&");for(const queryParam of queryParams){const pair=queryParam.split("=");result[pair[0]]=pair[1];}}return result}setQuery(params){let q="";for(const key in params){if(params.hasOwnProperty(key)){if(q!==""){q+="&";}q+=`${encodeURIComponent(key)}=${encodeURIComponent(params[key])}`;}}this.query=q;}constructor(uri){this.scheme=void 0;this.authority=void 0;this.path=void 0;this.query=void 0;this.fragment=void 0;const result=uri.match(re);this.scheme=result[2];this.authority=result[4];this.path=result[5];this.query=result[7];this.fragment=result[9];}}class Tracing{static set(channel,enabled=true){}static get(channel){return Tracing._traceChannels.has(channel)}}Tracing._traceChannels=new Set;Tracing.stack=false;const CURVE_LINEAR=0;const CURVE_SMOOTHSTEP=1;const CURVE_CATMULL=2;const CURVE_CARDINAL=3;const CURVE_SPLINE=4;const CURVE_STEP=5;const math={DEG_TO_RAD:Math.PI/180,RAD_TO_DEG:180/Math.PI,clamp(value,min,max){if(value>=max)return max;if(value<=min)return min;return value},intToBytes24(i){const r=i>>16&255;const g=i>>8&255;const b=i&255;return [r,g,b]},intToBytes32(i){const r=i>>24&255;const g=i>>16&255;const b=i>>8&255;const a=i&255;return [r,g,b,a]},bytesToInt24(r,g,b){if(r.length){b=r[2];g=r[1];r=r[0];}return r<<16|g<<8|b},bytesToInt32(r,g,b,a){if(r.length){a=r[3];b=r[2];g=r[1];r=r[0];}return (r<<24|g<<16|b<<8|a)>>>0},lerp(a,b,alpha){return a+(b-a)*math.clamp(alpha,0,1)},lerpAngle(a,b,alpha){if(b-a>180){b-=360;}if(b-a<-180){b+=360;}return math.lerp(a,b,math.clamp(alpha,0,1))},powerOfTwo(x){return x!==0&&!(x&x-1)},nextPowerOfTwo(val){val--;val|=val>>1;val|=val>>2;val|=val>>4;val|=val>>8;val|=val>>16;val++;return val},nearestPowerOfTwo(val){return Math.pow(2,Math.round(Math.log(val)/Math.log(2)))},random(min,max){const diff=max-min;return Math.random()*diff+min},smoothstep(min,max,x){if(x<=min)return 0;if(x>=max)return 1;x=(x-min)/(max-min);return x*x*(3-2*x)},smootherstep(min,max,x){if(x<=min)return 0;if(x>=max)return 1;x=(x-min)/(max-min);return x*x*x*(x*(x*6-15)+10)},roundUp(numToRound,multiple){if(multiple===0){return numToRound}return Math.ceil(numToRound/multiple)*multiple},between(num,a,b,inclusive){const min=Math.min(a,b);const max=Math.max(a,b);return inclusive?num>=min&&num<=max:num>min&&num<max}};var _Color;class Color{clone(){const cstr=this.constructor;return new cstr(this.r,this.g,this.b,this.a)}copy(rhs){this.r=rhs.r;this.g=rhs.g;this.b=rhs.b;this.a=rhs.a;return this}equals(rhs){return this.r===rhs.r&&this.g===rhs.g&&this.b===rhs.b&&this.a===rhs.a}set(r,g,b,a=1){this.r=r;this.g=g;this.b=b;this.a=a;return this}lerp(lhs,rhs,alpha){this.r=lhs.r+alpha*(rhs.r-lhs.r);this.g=lhs.g+alpha*(rhs.g-lhs.g);this.b=lhs.b+alpha*(rhs.b-lhs.b);this.a=lhs.a+alpha*(rhs.a-lhs.a);return this}fromString(hex){const i=parseInt(hex.replace("#","0x"),16);let bytes;if(hex.length>7){bytes=math.intToBytes32(i);}else {bytes=math.intToBytes24(i);bytes[3]=255;}this.set(bytes[0]/255,bytes[1]/255,bytes[2]/255,bytes[3]/255);return this}fromArray(arr,offset=0){var _arr$offset,_arr,_arr2,_arr3;this.r=(_arr$offset=arr[offset])!=null?_arr$offset:this.r;this.g=(_arr=arr[offset+1])!=null?_arr:this.g;this.b=(_arr2=arr[offset+2])!=null?_arr2:this.b;this.a=(_arr3=arr[offset+3])!=null?_arr3:this.a;return this}toString(alpha){let s=`#${((1<<24)+(Math.round(this.r*255)<<16)+(Math.round(this.g*255)<<8)+Math.round(this.b*255)).toString(16).slice(1)}`;if(alpha===true){const a=Math.round(this.a*255).toString(16);if(this.a<16/255){s+=`0${a}`;}else {s+=a;}}return s}toArray(arr=[],offset=0,alpha=true){arr[offset]=this.r;arr[offset+1]=this.g;arr[offset+2]=this.b;if(alpha){arr[offset+3]=this.a;}return arr}constructor(r=0,g=0,b=0,a=1){this.r=void 0;this.g=void 0;this.b=void 0;this.a=void 0;const length=r.length;if(length===3||length===4){this.r=r[0];this.g=r[1];this.b=r[2];this.a=r[3]!==undefined?r[3]:1;}else {this.r=r;this.g=g;this.b=b;this.a=a;}}}_Color=Color;Color.BLACK=Object.freeze(new _Color(0,0,0,1));Color.BLUE=Object.freeze(new _Color(0,0,1,1));Color.CYAN=Object.freeze(new _Color(0,1,1,1));Color.GRAY=Object.freeze(new _Color(.5,.5,.5,1));Color.GREEN=Object.freeze(new _Color(0,1,0,1));Color.MAGENTA=Object.freeze(new _Color(1,0,1,1));Color.RED=Object.freeze(new _Color(1,0,0,1));Color.WHITE=Object.freeze(new _Color(1,1,1,1));Color.YELLOW=Object.freeze(new _Color(1,1,0,1));class CurveEvaluator{evaluate(time,forceReset=false){if(forceReset||time<this._left||time>=this._right){this._reset(time);}let result;const type=this._curve.type;if(type===CURVE_STEP){result=this._p0;}else {const t=this._recip===0?0:(time-this._left)*this._recip;if(type===CURVE_LINEAR){result=math.lerp(this._p0,this._p1,t);}else if(type===CURVE_SMOOTHSTEP){result=math.lerp(this._p0,this._p1,t*t*(3-2*t));}else {result=this._evaluateHermite(this._p0,this._p1,this._m0,this._m1,t);}}return result}_reset(time){const keys=this._curve.keys;const len=keys.length;if(!len){this._left=-Infinity;this._right=Infinity;this._recip=0;this._p0=this._p1=this._m0=this._m1=0;}else {if(time<keys[0][0]){this._left=-Infinity;this._right=keys[0][0];this._recip=0;this._p0=this._p1=keys[0][1];this._m0=this._m1=0;}else if(time>=keys[len-1][0]){this._left=keys[len-1][0];this._right=Infinity;this._recip=0;this._p0=this._p1=keys[len-1][1];this._m0=this._m1=0;}else {let index=0;while(time>=keys[index+1][0]){index++;}this._left=keys[index][0];this._right=keys[index+1][0];const diff=1/(this._right-this._left);this._recip=isFinite(diff)?diff:0;this._p0=keys[index][1];this._p1=keys[index+1][1];if(this._isHermite()){this._calcTangents(keys,index);}}}}_isHermite(){return this._curve.type===CURVE_CATMULL||this._curve.type===CURVE_CARDINAL||this._curve.type===CURVE_SPLINE}_calcTangents(keys,index){let a;const b=keys[index];const c=keys[index+1];let d;if(index===0){a=[keys[0][0]+(keys[0][0]-keys[1][0]),keys[0][1]+(keys[0][1]-keys[1][1])];}else {a=keys[index-1];}if(index===keys.length-2){d=[keys[index+1][0]+(keys[index+1][0]-keys[index][0]),keys[index+1][1]+(keys[index+1][1]-keys[index][1])];}else {d=keys[index+2];}if(this._curve.type===CURVE_SPLINE){const s1_=2*(c[0]-b[0])/(c[0]-a[0]);const s2_=2*(c[0]-b[0])/(d[0]-b[0]);this._m0=this._curve.tension*(isFinite(s1_)?s1_:0)*(c[1]-a[1]);this._m1=this._curve.tension*(isFinite(s2_)?s2_:0)*(d[1]-b[1]);}else {const s1=(c[0]-b[0])/(b[0]-a[0]);const s2=(c[0]-b[0])/(d[0]-c[0]);const a_=b[1]+(a[1]-b[1])*(isFinite(s1)?s1:0);const d_=c[1]+(d[1]-c[1])*(isFinite(s2)?s2:0);const tension=this._curve.type===CURVE_CATMULL?.5:this._curve.tension;this._m0=tension*(c[1]-a_);this._m1=tension*(d_-b[1]);}}_evaluateHermite(p0,p1,m0,m1,t){const t2=t*t;const twot=t+t;const omt=1-t;const omt2=omt*omt;return p0*((1+twot)*omt2)+m0*(t*omt2)+p1*(t2*(3-twot))+m1*(t2*(t-1))}constructor(curve,time=0){this._curve=void 0;this._left=-Infinity;this._right=Infinity;this._recip=0;this._p0=0;this._p1=0;this._m0=0;this._m1=0;this._curve=curve;this._reset(time);}}class Curve{get length(){return this.keys.length}add(time,value){const keys=this.keys;const len=keys.length;let i=0;for(;i<len;i++){if(keys[i][0]>time){break}}const key=[time,value];this.keys.splice(i,0,key);return key}get(index){return this.keys[index]}sort(){this.keys.sort((a,b)=>a[0]-b[0]);}value(time){return this._eval.evaluate(time,true)}closest(time){const keys=this.keys;const length=keys.length;let min=2;let result=null;for(let i=0;i<length;i++){const diff=Math.abs(time-keys[i][0]);if(min>=diff){min=diff;result=keys[i];}else {break}}return result}clone(){const result=new this.constructor;result.keys=this.keys.map(key=>[...key]);result.type=this.type;result.tension=this.tension;return result}quantize(precision){precision=Math.max(precision,2);const values=new Float32Array(precision);const step=1/(precision-1);values[0]=this._eval.evaluate(0,true);for(let i=1;i<precision;i++){values[i]=this._eval.evaluate(step*i);}return values}quantizeClamped(precision,min,max){const result=this.quantize(precision);for(let i=0;i<result.length;++i){result[i]=Math.min(max,Math.max(min,result[i]));}return result}constructor(data){this.keys=[];this.type=CURVE_SMOOTHSTEP;this.tension=.5;this._eval=new CurveEvaluator(this);if(data){for(let i=0;i<data.length-1;i+=2){this.keys.push([data[i],data[i+1]]);}}this.sort();}}class CurveSet{get length(){return this.curves.length}set type(value){this._type=value;for(let i=0;i<this.curves.length;i++){this.curves[i].type=value;}}get type(){return this._type}get(index){return this.curves[index]}value(time,result=[]){const length=this.curves.length;result.length=length;for(let i=0;i<length;i++){result[i]=this.curves[i].value(time);}return result}clone(){const result=new this.constructor;result.curves=[];for(let i=0;i<this.curves.length;i++){result.curves.push(this.curves[i].clone());}result._type=this._type;return result}quantize(precision){precision=Math.max(precision,2);const numCurves=this.curves.length;const values=new Float32Array(precision*numCurves);const step=1/(precision-1);for(let c=0;c<numCurves;c++){const ev=new CurveEvaluator(this.curves[c]);for(let i=0;i<precision;i++){values[i*numCurves+c]=ev.evaluate(step*i);}}return values}quantizeClamped(precision,min,max){const result=this.quantize(precision);for(let i=0;i<result.length;++i){result[i]=Math.min(max,Math.max(min,result[i]));}return result}constructor(){this.curves=[];this._type=CURVE_SMOOTHSTEP;if(arguments.length>1){for(let i=0;i<arguments.length;i++){this.curves.push(new Curve(arguments[i]));}}else {if(arguments.length===0){this.curves.push(new Curve);}else {const arg=arguments[0];if(typeof arg==="number"){for(let i=0;i<arg;i++){this.curves.push(new Curve);}}else {for(let i=0;i<arg.length;i++){this.curves.push(new Curve(arg[i]));}}}}}}const oneDiv255=1/255;const floatView=new Float32Array(1);const int32View=new Int32Array(floatView.buffer);class FloatPacking{static float2Half(value){floatView[0]=value;const x=int32View[0];let bits=x>>16&32768;let m=x>>12&2047;const e=x>>23&255;if(e<103){return bits}if(e>142){bits|=31744;bits|=(e===255?0:1)&&x&8388607;return bits}if(e<113){m|=2048;bits|=(m>>114-e)+(m>>113-e&1);return bits}bits|=e-112<<10|m>>1;bits+=m&1;return bits}static float2Bytes(value,array,offset,numBytes){const enc1=255*value%1;array[offset+0]=Math.round((value%1-oneDiv255*enc1)*255);if(numBytes>1){const enc2=65025*value%1;array[offset+1]=Math.round((enc1-oneDiv255*enc2)*255);if(numBytes>2){const enc3=16581375*value%1;array[offset+2]=Math.round((enc2-oneDiv255*enc3)*255);if(numBytes>3){array[offset+3]=Math.round(enc3*255);}}}}static float2BytesRange(value,array,offset,min,max,numBytes){value=math.clamp((value-min)/(max-min),0,1);FloatPacking.float2Bytes(value,array,offset,numBytes);}static float2MantissaExponent(value,array,offset,numBytes){const exponent=Math.floor(Math.log2(Math.abs(value)))+1;value/=Math.pow(2,exponent);FloatPacking.float2BytesRange(value,array,offset,-1,1,numBytes-1);array[offset+numBytes-1]=Math.round(exponent+127);}}var _Vec$2;class Vec3{add(rhs){this.x+=rhs.x;this.y+=rhs.y;this.z+=rhs.z;return this}add2(lhs,rhs){this.x=lhs.x+rhs.x;this.y=lhs.y+rhs.y;this.z=lhs.z+rhs.z;return this}addScalar(scalar){this.x+=scalar;this.y+=scalar;this.z+=scalar;return this}addScaled(rhs,scalar){this.x+=rhs.x*scalar;this.y+=rhs.y*scalar;this.z+=rhs.z*scalar;return this}clone(){const cstr=this.constructor;return new cstr(this.x,this.y,this.z)}copy(rhs){this.x=rhs.x;this.y=rhs.y;this.z=rhs.z;return this}cross(lhs,rhs){const lx=lhs.x;const ly=lhs.y;const lz=lhs.z;const rx=rhs.x;const ry=rhs.y;const rz=rhs.z;this.x=ly*rz-ry*lz;this.y=lz*rx-rz*lx;this.z=lx*ry-rx*ly;return this}distance(rhs){const x=this.x-rhs.x;const y=this.y-rhs.y;const z=this.z-rhs.z;return Math.sqrt(x*x+y*y+z*z)}div(rhs){this.x/=rhs.x;this.y/=rhs.y;this.z/=rhs.z;return this}div2(lhs,rhs){this.x=lhs.x/rhs.x;this.y=lhs.y/rhs.y;this.z=lhs.z/rhs.z;return this}divScalar(scalar){this.x/=scalar;this.y/=scalar;this.z/=scalar;return this}dot(rhs){return this.x*rhs.x+this.y*rhs.y+this.z*rhs.z}equals(rhs){return this.x===rhs.x&&this.y===rhs.y&&this.z===rhs.z}equalsApprox(rhs,epsilon=1e-6){return Math.abs(this.x-rhs.x)<epsilon&&Math.abs(this.y-rhs.y)<epsilon&&Math.abs(this.z-rhs.z)<epsilon}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}lerp(lhs,rhs,alpha){this.x=lhs.x+alpha*(rhs.x-lhs.x);this.y=lhs.y+alpha*(rhs.y-lhs.y);this.z=lhs.z+alpha*(rhs.z-lhs.z);return this}mul(rhs){this.x*=rhs.x;this.y*=rhs.y;this.z*=rhs.z;return this}mul2(lhs,rhs){this.x=lhs.x*rhs.x;this.y=lhs.y*rhs.y;this.z=lhs.z*rhs.z;return this}mulScalar(scalar){this.x*=scalar;this.y*=scalar;this.z*=scalar;return this}normalize(src=this){const lengthSq=src.x*src.x+src.y*src.y+src.z*src.z;if(lengthSq>0){const invLength=1/Math.sqrt(lengthSq);this.x=src.x*invLength;this.y=src.y*invLength;this.z=src.z*invLength;}return this}floor(src=this){this.x=Math.floor(src.x);this.y=Math.floor(src.y);this.z=Math.floor(src.z);return this}ceil(src=this){this.x=Math.ceil(src.x);this.y=Math.ceil(src.y);this.z=Math.ceil(src.z);return this}round(src=this){this.x=Math.round(src.x);this.y=Math.round(src.y);this.z=Math.round(src.z);return this}min(rhs){if(rhs.x<this.x)this.x=rhs.x;if(rhs.y<this.y)this.y=rhs.y;if(rhs.z<this.z)this.z=rhs.z;return this}max(rhs){if(rhs.x>this.x)this.x=rhs.x;if(rhs.y>this.y)this.y=rhs.y;if(rhs.z>this.z)this.z=rhs.z;return this}project(rhs){const a_dot_b=this.x*rhs.x+this.y*rhs.y+this.z*rhs.z;const b_dot_b=rhs.x*rhs.x+rhs.y*rhs.y+rhs.z*rhs.z;const s=a_dot_b/b_dot_b;this.x=rhs.x*s;this.y=rhs.y*s;this.z=rhs.z*s;return this}set(x,y,z){this.x=x;this.y=y;this.z=z;return this}sub(rhs){this.x-=rhs.x;this.y-=rhs.y;this.z-=rhs.z;return this}sub2(lhs,rhs){this.x=lhs.x-rhs.x;this.y=lhs.y-rhs.y;this.z=lhs.z-rhs.z;return this}subScalar(scalar){this.x-=scalar;this.y-=scalar;this.z-=scalar;return this}fromArray(arr,offset=0){var _arr$offset,_arr,_arr2;this.x=(_arr$offset=arr[offset])!=null?_arr$offset:this.x;this.y=(_arr=arr[offset+1])!=null?_arr:this.y;this.z=(_arr2=arr[offset+2])!=null?_arr2:this.z;return this}toString(){return `[${this.x}, ${this.y}, ${this.z}]`}toArray(arr=[],offset=0){arr[offset]=this.x;arr[offset+1]=this.y;arr[offset+2]=this.z;return arr}constructor(x=0,y=0,z=0){this.x=void 0;this.y=void 0;this.z=void 0;if(x.length===3){this.x=x[0];this.y=x[1];this.z=x[2];}else {this.x=x;this.y=y;this.z=z;}}}_Vec$2=Vec3;Vec3.ZERO=Object.freeze(new _Vec$2(0,0,0));Vec3.ONE=Object.freeze(new _Vec$2(1,1,1));Vec3.UP=Object.freeze(new _Vec$2(0,1,0));Vec3.DOWN=Object.freeze(new _Vec$2(0,-1,0));Vec3.RIGHT=Object.freeze(new _Vec$2(1,0,0));Vec3.LEFT=Object.freeze(new _Vec$2(-1,0,0));Vec3.FORWARD=Object.freeze(new _Vec$2(0,0,-1));Vec3.BACK=Object.freeze(new _Vec$2(0,0,1));var _Mat$1;class Mat3{clone(){const cstr=this.constructor;return new cstr().copy(this)}copy(rhs){const src=rhs.data;const dst=this.data;dst[0]=src[0];dst[1]=src[1];dst[2]=src[2];dst[3]=src[3];dst[4]=src[4];dst[5]=src[5];dst[6]=src[6];dst[7]=src[7];dst[8]=src[8];return this}set(src){const dst=this.data;dst[0]=src[0];dst[1]=src[1];dst[2]=src[2];dst[3]=src[3];dst[4]=src[4];dst[5]=src[5];dst[6]=src[6];dst[7]=src[7];dst[8]=src[8];return this}getX(x=new Vec3){return x.set(this.data[0],this.data[1],this.data[2])}getY(y=new Vec3){return y.set(this.data[3],this.data[4],this.data[5])}getZ(z=new Vec3){return z.set(this.data[6],this.data[7],this.data[8])}equals(rhs){const l=this.data;const r=rhs.data;return l[0]===r[0]&&l[1]===r[1]&&l[2]===r[2]&&l[3]===r[3]&&l[4]===r[4]&&l[5]===r[5]&&l[6]===r[6]&&l[7]===r[7]&&l[8]===r[8]}isIdentity(){const m=this.data;return m[0]===1&&m[1]===0&&m[2]===0&&m[3]===0&&m[4]===1&&m[5]===0&&m[6]===0&&m[7]===0&&m[8]===1}setIdentity(){const m=this.data;m[0]=1;m[1]=0;m[2]=0;m[3]=0;m[4]=1;m[5]=0;m[6]=0;m[7]=0;m[8]=1;return this}toString(){return `[${this.data.join(", ")}]`}transpose(src=this){const s=src.data;const t=this.data;if(s===t){let tmp;tmp=s[1];t[1]=s[3];t[3]=tmp;tmp=s[2];t[2]=s[6];t[6]=tmp;tmp=s[5];t[5]=s[7];t[7]=tmp;}else {t[0]=s[0];t[1]=s[3];t[2]=s[6];t[3]=s[1];t[4]=s[4];t[5]=s[7];t[6]=s[2];t[7]=s[5];t[8]=s[8];}return this}setFromMat4(m){const src=m.data;const dst=this.data;dst[0]=src[0];dst[1]=src[1];dst[2]=src[2];dst[3]=src[4];dst[4]=src[5];dst[5]=src[6];dst[6]=src[8];dst[7]=src[9];dst[8]=src[10];return this}setFromQuat(r){const qx=r.x;const qy=r.y;const qz=r.z;const qw=r.w;const x2=qx+qx;const y2=qy+qy;const z2=qz+qz;const xx=qx*x2;const xy=qx*y2;const xz=qx*z2;const yy=qy*y2;const yz=qy*z2;const zz=qz*z2;const wx=qw*x2;const wy=qw*y2;const wz=qw*z2;const m=this.data;m[0]=1-(yy+zz);m[1]=xy+wz;m[2]=xz-wy;m[3]=xy-wz;m[4]=1-(xx+zz);m[5]=yz+wx;m[6]=xz+wy;m[7]=yz-wx;m[8]=1-(xx+yy);return this}invertMat4(src){const s=src.data;const a0=s[0];const a1=s[1];const a2=s[2];const a4=s[4];const a5=s[5];const a6=s[6];const a8=s[8];const a9=s[9];const a10=s[10];const b11=a10*a5-a6*a9;const b21=-a10*a1+a2*a9;const b31=a6*a1-a2*a5;const b12=-a10*a4+a6*a8;const b22=a10*a0-a2*a8;const b32=-a6*a0+a2*a4;const b13=a9*a4-a5*a8;const b23=-a9*a0+a1*a8;const b33=a5*a0-a1*a4;const det=a0*b11+a1*b12+a2*b13;if(det===0){this.setIdentity();}else {const invDet=1/det;const t=this.data;t[0]=b11*invDet;t[1]=b21*invDet;t[2]=b31*invDet;t[3]=b12*invDet;t[4]=b22*invDet;t[5]=b32*invDet;t[6]=b13*invDet;t[7]=b23*invDet;t[8]=b33*invDet;}return this}transformVector(vec,res=new Vec3){const m=this.data;const{x,y,z}=vec;res.x=x*m[0]+y*m[3]+z*m[6];res.y=x*m[1]+y*m[4]+z*m[7];res.z=x*m[2]+y*m[5]+z*m[8];return res}constructor(){this.data=new Float32Array(9);this.data[0]=this.data[4]=this.data[8]=1;}}_Mat$1=Mat3;Mat3.IDENTITY=Object.freeze(new _Mat$1);Mat3.ZERO=Object.freeze(new _Mat$1().set([0,0,0,0,0,0,0,0,0]));var _Vec$1;class Vec2{add(rhs){this.x+=rhs.x;this.y+=rhs.y;return this}add2(lhs,rhs){this.x=lhs.x+rhs.x;this.y=lhs.y+rhs.y;return this}addScalar(scalar){this.x+=scalar;this.y+=scalar;return this}addScaled(rhs,scalar){this.x+=rhs.x*scalar;this.y+=rhs.y*scalar;return this}clone(){const cstr=this.constructor;return new cstr(this.x,this.y)}copy(rhs){this.x=rhs.x;this.y=rhs.y;return this}cross(rhs){return this.x*rhs.y-this.y*rhs.x}distance(rhs){const x=this.x-rhs.x;const y=this.y-rhs.y;return Math.sqrt(x*x+y*y)}div(rhs){this.x/=rhs.x;this.y/=rhs.y;return this}div2(lhs,rhs){this.x=lhs.x/rhs.x;this.y=lhs.y/rhs.y;return this}divScalar(scalar){this.x/=scalar;this.y/=scalar;return this}dot(rhs){return this.x*rhs.x+this.y*rhs.y}equals(rhs){return this.x===rhs.x&&this.y===rhs.y}equalsApprox(rhs,epsilon=1e-6){return Math.abs(this.x-rhs.x)<epsilon&&Math.abs(this.y-rhs.y)<epsilon}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSq(){return this.x*this.x+this.y*this.y}lerp(lhs,rhs,alpha){this.x=lhs.x+alpha*(rhs.x-lhs.x);this.y=lhs.y+alpha*(rhs.y-lhs.y);return this}mul(rhs){this.x*=rhs.x;this.y*=rhs.y;return this}mul2(lhs,rhs){this.x=lhs.x*rhs.x;this.y=lhs.y*rhs.y;return this}mulScalar(scalar){this.x*=scalar;this.y*=scalar;return this}normalize(src=this){const lengthSq=src.x*src.x+src.y*src.y;if(lengthSq>0){const invLength=1/Math.sqrt(lengthSq);this.x=src.x*invLength;this.y=src.y*invLength;}return this}rotate(degrees){const angle=Math.atan2(this.x,this.y)+degrees*math.DEG_TO_RAD;const len=Math.sqrt(this.x*this.x+this.y*this.y);this.x=Math.sin(angle)*len;this.y=Math.cos(angle)*len;return this}angle(){return Math.atan2(this.x,this.y)*math.RAD_TO_DEG}angleTo(rhs){return Math.atan2(this.x*rhs.y+this.y*rhs.x,this.x*rhs.x+this.y*rhs.y)*math.RAD_TO_DEG}floor(src=this){this.x=Math.floor(src.x);this.y=Math.floor(src.y);return this}ceil(src=this){this.x=Math.ceil(src.x);this.y=Math.ceil(src.y);return this}round(src=this){this.x=Math.round(src.x);this.y=Math.round(src.y);return this}min(rhs){if(rhs.x<this.x)this.x=rhs.x;if(rhs.y<this.y)this.y=rhs.y;return this}max(rhs){if(rhs.x>this.x)this.x=rhs.x;if(rhs.y>this.y)this.y=rhs.y;return this}set(x,y){this.x=x;this.y=y;return this}sub(rhs){this.x-=rhs.x;this.y-=rhs.y;return this}sub2(lhs,rhs){this.x=lhs.x-rhs.x;this.y=lhs.y-rhs.y;return this}subScalar(scalar){this.x-=scalar;this.y-=scalar;return this}fromArray(arr,offset=0){var _arr$offset,_arr;this.x=(_arr$offset=arr[offset])!=null?_arr$offset:this.x;this.y=(_arr=arr[offset+1])!=null?_arr:this.y;return this}toString(){return `[${this.x}, ${this.y}]`}toArray(arr=[],offset=0){arr[offset]=this.x;arr[offset+1]=this.y;return arr}static angleRad(lhs,rhs){return Math.atan2(lhs.x*rhs.y-lhs.y*rhs.x,lhs.x*rhs.x+lhs.y*rhs.y)}constructor(x=0,y=0){this.x=void 0;this.y=void 0;if(x.length===2){this.x=x[0];this.y=x[1];}else {this.x=x;this.y=y;}}}_Vec$1=Vec2;Vec2.ZERO=Object.freeze(new _Vec$1(0,0));Vec2.ONE=Object.freeze(new _Vec$1(1,1));Vec2.UP=Object.freeze(new _Vec$1(0,1));Vec2.DOWN=Object.freeze(new _Vec$1(0,-1));Vec2.RIGHT=Object.freeze(new _Vec$1(1,0));Vec2.LEFT=Object.freeze(new _Vec$1(-1,0));var _Vec;class Vec4{add(rhs){this.x+=rhs.x;this.y+=rhs.y;this.z+=rhs.z;this.w+=rhs.w;return this}add2(lhs,rhs){this.x=lhs.x+rhs.x;this.y=lhs.y+rhs.y;this.z=lhs.z+rhs.z;this.w=lhs.w+rhs.w;return this}addScalar(scalar){this.x+=scalar;this.y+=scalar;this.z+=scalar;this.w+=scalar;return this}addScaled(rhs,scalar){this.x+=rhs.x*scalar;this.y+=rhs.y*scalar;this.z+=rhs.z*scalar;this.w+=rhs.w*scalar;return this}clone(){const cstr=this.constructor;return new cstr(this.x,this.y,this.z,this.w)}copy(rhs){this.x=rhs.x;this.y=rhs.y;this.z=rhs.z;this.w=rhs.w;return this}div(rhs){this.x/=rhs.x;this.y/=rhs.y;this.z/=rhs.z;this.w/=rhs.w;return this}div2(lhs,rhs){this.x=lhs.x/rhs.x;this.y=lhs.y/rhs.y;this.z=lhs.z/rhs.z;this.w=lhs.w/rhs.w;return this}divScalar(scalar){this.x/=scalar;this.y/=scalar;this.z/=scalar;this.w/=scalar;return this}dot(rhs){return this.x*rhs.x+this.y*rhs.y+this.z*rhs.z+this.w*rhs.w}equals(rhs){return this.x===rhs.x&&this.y===rhs.y&&this.z===rhs.z&&this.w===rhs.w}equalsApprox(rhs,epsilon=1e-6){return Math.abs(this.x-rhs.x)<epsilon&&Math.abs(this.y-rhs.y)<epsilon&&Math.abs(this.z-rhs.z)<epsilon&&Math.abs(this.w-rhs.w)<epsilon}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}lerp(lhs,rhs,alpha){this.x=lhs.x+alpha*(rhs.x-lhs.x);this.y=lhs.y+alpha*(rhs.y-lhs.y);this.z=lhs.z+alpha*(rhs.z-lhs.z);this.w=lhs.w+alpha*(rhs.w-lhs.w);return this}mul(rhs){this.x*=rhs.x;this.y*=rhs.y;this.z*=rhs.z;this.w*=rhs.w;return this}mul2(lhs,rhs){this.x=lhs.x*rhs.x;this.y=lhs.y*rhs.y;this.z=lhs.z*rhs.z;this.w=lhs.w*rhs.w;return this}mulScalar(scalar){this.x*=scalar;this.y*=scalar;this.z*=scalar;this.w*=scalar;return this}normalize(src=this){const lengthSq=src.x*src.x+src.y*src.y+src.z*src.z+src.w*src.w;if(lengthSq>0){const invLength=1/Math.sqrt(lengthSq);this.x=src.x*invLength;this.y=src.y*invLength;this.z=src.z*invLength;this.w=src.w*invLength;}return this}floor(src=this){this.x=Math.floor(src.x);this.y=Math.floor(src.y);this.z=Math.floor(src.z);this.w=Math.floor(src.w);return this}ceil(src=this){this.x=Math.ceil(src.x);this.y=Math.ceil(src.y);this.z=Math.ceil(src.z);this.w=Math.ceil(src.w);return this}round(src=this){this.x=Math.round(src.x);this.y=Math.round(src.y);this.z=Math.round(src.z);this.w=Math.round(src.w);return this}min(rhs){if(rhs.x<this.x)this.x=rhs.x;if(rhs.y<this.y)this.y=rhs.y;if(rhs.z<this.z)this.z=rhs.z;if(rhs.w<this.w)this.w=rhs.w;return this}max(rhs){if(rhs.x>this.x)this.x=rhs.x;if(rhs.y>this.y)this.y=rhs.y;if(rhs.z>this.z)this.z=rhs.z;if(rhs.w>this.w)this.w=rhs.w;return this}set(x,y,z,w){this.x=x;this.y=y;this.z=z;this.w=w;return this}sub(rhs){this.x-=rhs.x;this.y-=rhs.y;this.z-=rhs.z;this.w-=rhs.w;return this}sub2(lhs,rhs){this.x=lhs.x-rhs.x;this.y=lhs.y-rhs.y;this.z=lhs.z-rhs.z;this.w=lhs.w-rhs.w;return this}subScalar(scalar){this.x-=scalar;this.y-=scalar;this.z-=scalar;this.w-=scalar;return this}fromArray(arr,offset=0){var _arr$offset,_arr,_arr2,_arr3;this.x=(_arr$offset=arr[offset])!=null?_arr$offset:this.x;this.y=(_arr=arr[offset+1])!=null?_arr:this.y;this.z=(_arr2=arr[offset+2])!=null?_arr2:this.z;this.w=(_arr3=arr[offset+3])!=null?_arr3:this.w;return this}toString(){return `[${this.x}, ${this.y}, ${this.z}, ${this.w}]`}toArray(arr=[],offset=0){arr[offset]=this.x;arr[offset+1]=this.y;arr[offset+2]=this.z;arr[offset+3]=this.w;return arr}constructor(x=0,y=0,z=0,w=0){this.x=void 0;this.y=void 0;this.z=void 0;this.w=void 0;if(x.length===4){this.x=x[0];this.y=x[1];this.z=x[2];this.w=x[3];}else {this.x=x;this.y=y;this.z=z;this.w=w;}}}_Vec=Vec4;Vec4.ZERO=Object.freeze(new _Vec(0,0,0,0));Vec4.ONE=Object.freeze(new _Vec(1,1,1,1));var _Mat;const _halfSize$1=new Vec2;const x$1=new Vec3;const y=new Vec3;const z=new Vec3;const scale=new Vec3;class Mat4{static _getPerspectiveHalfSize(halfSize,fov,aspect,znear,fovIsHorizontal){if(fovIsHorizontal){halfSize.x=znear*Math.tan(fov*Math.PI/360);halfSize.y=halfSize.x/aspect;}else {halfSize.y=znear*Math.tan(fov*Math.PI/360);halfSize.x=halfSize.y*aspect;}}add2(lhs,rhs){const a=lhs.data,b=rhs.data,r=this.data;r[0]=a[0]+b[0];r[1]=a[1]+b[1];r[2]=a[2]+b[2];r[3]=a[3]+b[3];r[4]=a[4]+b[4];r[5]=a[5]+b[5];r[6]=a[6]+b[6];r[7]=a[7]+b[7];r[8]=a[8]+b[8];r[9]=a[9]+b[9];r[10]=a[10]+b[10];r[11]=a[11]+b[11];r[12]=a[12]+b[12];r[13]=a[13]+b[13];r[14]=a[14]+b[14];r[15]=a[15]+b[15];return this}add(rhs){return this.add2(this,rhs)}clone(){const cstr=this.constructor;return new cstr().copy(this)}copy(rhs){const src=rhs.data,dst=this.data;dst[0]=src[0];dst[1]=src[1];dst[2]=src[2];dst[3]=src[3];dst[4]=src[4];dst[5]=src[5];dst[6]=src[6];dst[7]=src[7];dst[8]=src[8];dst[9]=src[9];dst[10]=src[10];dst[11]=src[11];dst[12]=src[12];dst[13]=src[13];dst[14]=src[14];dst[15]=src[15];return this}equals(rhs){const l=this.data,r=rhs.data;return l[0]===r[0]&&l[1]===r[1]&&l[2]===r[2]&&l[3]===r[3]&&l[4]===r[4]&&l[5]===r[5]&&l[6]===r[6]&&l[7]===r[7]&&l[8]===r[8]&&l[9]===r[9]&&l[10]===r[10]&&l[11]===r[11]&&l[12]===r[12]&&l[13]===r[13]&&l[14]===r[14]&&l[15]===r[15]}isIdentity(){const m=this.data;return m[0]===1&&m[1]===0&&m[2]===0&&m[3]===0&&m[4]===0&&m[5]===1&&m[6]===0&&m[7]===0&&m[8]===0&&m[9]===0&&m[10]===1&&m[11]===0&&m[12]===0&&m[13]===0&&m[14]===0&&m[15]===1}mul2(lhs,rhs){const a=lhs.data;const b=rhs.data;const r=this.data;const a00=a[0];const a01=a[1];const a02=a[2];const a03=a[3];const a10=a[4];const a11=a[5];const a12=a[6];const a13=a[7];const a20=a[8];const a21=a[9];const a22=a[10];const a23=a[11];const a30=a[12];const a31=a[13];const a32=a[14];const a33=a[15];let b0,b1,b2,b3;b0=b[0];b1=b[1];b2=b[2];b3=b[3];r[0]=a00*b0+a10*b1+a20*b2+a30*b3;r[1]=a01*b0+a11*b1+a21*b2+a31*b3;r[2]=a02*b0+a12*b1+a22*b2+a32*b3;r[3]=a03*b0+a13*b1+a23*b2+a33*b3;b0=b[4];b1=b[5];b2=b[6];b3=b[7];r[4]=a00*b0+a10*b1+a20*b2+a30*b3;r[5]=a01*b0+a11*b1+a21*b2+a31*b3;r[6]=a02*b0+a12*b1+a22*b2+a32*b3;r[7]=a03*b0+a13*b1+a23*b2+a33*b3;b0=b[8];b1=b[9];b2=b[10];b3=b[11];r[8]=a00*b0+a10*b1+a20*b2+a30*b3;r[9]=a01*b0+a11*b1+a21*b2+a31*b3;r[10]=a02*b0+a12*b1+a22*b2+a32*b3;r[11]=a03*b0+a13*b1+a23*b2+a33*b3;b0=b[12];b1=b[13];b2=b[14];b3=b[15];r[12]=a00*b0+a10*b1+a20*b2+a30*b3;r[13]=a01*b0+a11*b1+a21*b2+a31*b3;r[14]=a02*b0+a12*b1+a22*b2+a32*b3;r[15]=a03*b0+a13*b1+a23*b2+a33*b3;return this}mulAffine2(lhs,rhs){const a=lhs.data;const b=rhs.data;const r=this.data;const a00=a[0];const a01=a[1];const a02=a[2];const a10=a[4];const a11=a[5];const a12=a[6];const a20=a[8];const a21=a[9];const a22=a[10];const a30=a[12];const a31=a[13];const a32=a[14];let b0,b1,b2;b0=b[0];b1=b[1];b2=b[2];r[0]=a00*b0+a10*b1+a20*b2;r[1]=a01*b0+a11*b1+a21*b2;r[2]=a02*b0+a12*b1+a22*b2;r[3]=0;b0=b[4];b1=b[5];b2=b[6];r[4]=a00*b0+a10*b1+a20*b2;r[5]=a01*b0+a11*b1+a21*b2;r[6]=a02*b0+a12*b1+a22*b2;r[7]=0;b0=b[8];b1=b[9];b2=b[10];r[8]=a00*b0+a10*b1+a20*b2;r[9]=a01*b0+a11*b1+a21*b2;r[10]=a02*b0+a12*b1+a22*b2;r[11]=0;b0=b[12];b1=b[13];b2=b[14];r[12]=a00*b0+a10*b1+a20*b2+a30;r[13]=a01*b0+a11*b1+a21*b2+a31;r[14]=a02*b0+a12*b1+a22*b2+a32;r[15]=1;return this}mul(rhs){return this.mul2(this,rhs)}transformPoint(vec,res=new Vec3){const m=this.data;const{x,y,z}=vec;res.x=x*m[0]+y*m[4]+z*m[8]+m[12];res.y=x*m[1]+y*m[5]+z*m[9]+m[13];res.z=x*m[2]+y*m[6]+z*m[10]+m[14];return res}transformVector(vec,res=new Vec3){const m=this.data;const{x,y,z}=vec;res.x=x*m[0]+y*m[4]+z*m[8];res.y=x*m[1]+y*m[5]+z*m[9];res.z=x*m[2]+y*m[6]+z*m[10];return res}transformVec4(vec,res=new Vec4){const m=this.data;const{x,y,z,w}=vec;res.x=x*m[0]+y*m[4]+z*m[8]+w*m[12];res.y=x*m[1]+y*m[5]+z*m[9]+w*m[13];res.z=x*m[2]+y*m[6]+z*m[10]+w*m[14];res.w=x*m[3]+y*m[7]+z*m[11]+w*m[15];return res}setLookAt(position,target,up){z.sub2(position,target).normalize();y.copy(up).normalize();x$1.cross(y,z).normalize();y.cross(z,x$1);const r=this.data;r[0]=x$1.x;r[1]=x$1.y;r[2]=x$1.z;r[3]=0;r[4]=y.x;r[5]=y.y;r[6]=y.z;r[7]=0;r[8]=z.x;r[9]=z.y;r[10]=z.z;r[11]=0;r[12]=position.x;r[13]=position.y;r[14]=position.z;r[15]=1;return this}setFrustum(left,right,bottom,top,znear,zfar){const temp1=2*znear;const temp2=right-left;const temp3=top-bottom;const temp4=zfar-znear;const r=this.data;r[0]=temp1/temp2;r[1]=0;r[2]=0;r[3]=0;r[4]=0;r[5]=temp1/temp3;r[6]=0;r[7]=0;r[8]=(right+left)/temp2;r[9]=(top+bottom)/temp3;r[10]=(-zfar-znear)/temp4;r[11]=-1;r[12]=0;r[13]=0;r[14]=-temp1*zfar/temp4;r[15]=0;return this}setPerspective(fov,aspect,znear,zfar,fovIsHorizontal){Mat4._getPerspectiveHalfSize(_halfSize$1,fov,aspect,znear,fovIsHorizontal);return this.setFrustum(-_halfSize$1.x,_halfSize$1.x,-_halfSize$1.y,_halfSize$1.y,znear,zfar)}setOrtho(left,right,bottom,top,near,far){const r=this.data;r[0]=2/(right-left);r[1]=0;r[2]=0;r[3]=0;r[4]=0;r[5]=2/(top-bottom);r[6]=0;r[7]=0;r[8]=0;r[9]=0;r[10]=-2/(far-near);r[11]=0;r[12]=-(right+left)/(right-left);r[13]=-(top+bottom)/(top-bottom);r[14]=-(far+near)/(far-near);r[15]=1;return this}setFromAxisAngle(axis,angle){angle*=math.DEG_TO_RAD;const{x,y,z}=axis;const c=Math.cos(angle);const s=Math.sin(angle);const t=1-c;const tx=t*x;const ty=t*y;const m=this.data;m[0]=tx*x+c;m[1]=tx*y+s*z;m[2]=tx*z-s*y;m[3]=0;m[4]=tx*y-s*z;m[5]=ty*y+c;m[6]=ty*z+s*x;m[7]=0;m[8]=tx*z+s*y;m[9]=ty*z-x*s;m[10]=t*z*z+c;m[11]=0;m[12]=0;m[13]=0;m[14]=0;m[15]=1;return this}setTranslate(x,y,z){const m=this.data;m[0]=1;m[1]=0;m[2]=0;m[3]=0;m[4]=0;m[5]=1;m[6]=0;m[7]=0;m[8]=0;m[9]=0;m[10]=1;m[11]=0;m[12]=x;m[13]=y;m[14]=z;m[15]=1;return this}setScale(x,y,z){const m=this.data;m[0]=x;m[1]=0;m[2]=0;m[3]=0;m[4]=0;m[5]=y;m[6]=0;m[7]=0;m[8]=0;m[9]=0;m[10]=z;m[11]=0;m[12]=0;m[13]=0;m[14]=0;m[15]=1;return this}setViewport(x,y,width,height){const m=this.data;m[0]=width*.5;m[1]=0;m[2]=0;m[3]=0;m[4]=0;m[5]=height*.5;m[6]=0;m[7]=0;m[8]=0;m[9]=0;m[10]=.5;m[11]=0;m[12]=x+width*.5;m[13]=y+height*.5;m[14]=.5;m[15]=1;return this}setReflection(normal,distance){const a=normal.x;const b=normal.y;const c=normal.z;const data=this.data;data[0]=1-2*a*a;data[1]=-2*a*b;data[2]=-2*a*c;data[3]=0;data[4]=-2*a*b;data[5]=1-2*b*b;data[6]=-2*b*c;data[7]=0;data[8]=-2*a*c;data[9]=-2*b*c;data[10]=1-2*c*c;data[11]=0;data[12]=-2*a*distance;data[13]=-2*b*distance;data[14]=-2*c*distance;data[15]=1;return this}invert(src=this){const s=src.data;const a00=s[0];const a01=s[1];const a02=s[2];const a03=s[3];const a10=s[4];const a11=s[5];const a12=s[6];const a13=s[7];const a20=s[8];const a21=s[9];const a22=s[10];const a23=s[11];const a30=s[12];const a31=s[13];const a32=s[14];const a33=s[15];const b00=a00*a11-a01*a10;const b01=a00*a12-a02*a10;const b02=a00*a13-a03*a10;const b03=a01*a12-a02*a11;const b04=a01*a13-a03*a11;const b05=a02*a13-a03*a12;const b06=a20*a31-a21*a30;const b07=a20*a32-a22*a30;const b08=a20*a33-a23*a30;const b09=a21*a32-a22*a31;const b10=a21*a33-a23*a31;const b11=a22*a33-a23*a32;const det=b00*b11-b01*b10+b02*b09+b03*b08-b04*b07+b05*b06;if(det===0){this.setIdentity();}else {const invDet=1/det;const t=this.data;t[0]=(a11*b11-a12*b10+a13*b09)*invDet;t[1]=(-a01*b11+a02*b10-a03*b09)*invDet;t[2]=(a31*b05-a32*b04+a33*b03)*invDet;t[3]=(-a21*b05+a22*b04-a23*b03)*invDet;t[4]=(-a10*b11+a12*b08-a13*b07)*invDet;t[5]=(a00*b11-a02*b08+a03*b07)*invDet;t[6]=(-a30*b05+a32*b02-a33*b01)*invDet;t[7]=(a20*b05-a22*b02+a23*b01)*invDet;t[8]=(a10*b10-a11*b08+a13*b06)*invDet;t[9]=(-a00*b10+a01*b08-a03*b06)*invDet;t[10]=(a30*b04-a31*b02+a33*b00)*invDet;t[11]=(-a20*b04+a21*b02-a23*b00)*invDet;t[12]=(-a10*b09+a11*b07-a12*b06)*invDet;t[13]=(a00*b09-a01*b07+a02*b06)*invDet;t[14]=(-a30*b03+a31*b01-a32*b00)*invDet;t[15]=(a20*b03-a21*b01+a22*b00)*invDet;}return this}set(src){const dst=this.data;dst[0]=src[0];dst[1]=src[1];dst[2]=src[2];dst[3]=src[3];dst[4]=src[4];dst[5]=src[5];dst[6]=src[6];dst[7]=src[7];dst[8]=src[8];dst[9]=src[9];dst[10]=src[10];dst[11]=src[11];dst[12]=src[12];dst[13]=src[13];dst[14]=src[14];dst[15]=src[15];return this}setIdentity(){const m=this.data;m[0]=1;m[1]=0;m[2]=0;m[3]=0;m[4]=0;m[5]=1;m[6]=0;m[7]=0;m[8]=0;m[9]=0;m[10]=1;m[11]=0;m[12]=0;m[13]=0;m[14]=0;m[15]=1;return this}setTRS(t,r,s){const qx=r.x;const qy=r.y;const qz=r.z;const qw=r.w;const sx=s.x;const sy=s.y;const sz=s.z;const x2=qx+qx;const y2=qy+qy;const z2=qz+qz;const xx=qx*x2;const xy=qx*y2;const xz=qx*z2;const yy=qy*y2;const yz=qy*z2;const zz=qz*z2;const wx=qw*x2;const wy=qw*y2;const wz=qw*z2;const m=this.data;m[0]=(1-(yy+zz))*sx;m[1]=(xy+wz)*sx;m[2]=(xz-wy)*sx;m[3]=0;m[4]=(xy-wz)*sy;m[5]=(1-(xx+zz))*sy;m[6]=(yz+wx)*sy;m[7]=0;m[8]=(xz+wy)*sz;m[9]=(yz-wx)*sz;m[10]=(1-(xx+yy))*sz;m[11]=0;m[12]=t.x;m[13]=t.y;m[14]=t.z;m[15]=1;return this}transpose(src=this){const s=src.data;const t=this.data;if(s===t){let tmp;tmp=s[1];t[1]=s[4];t[4]=tmp;tmp=s[2];t[2]=s[8];t[8]=tmp;tmp=s[3];t[3]=s[12];t[12]=tmp;tmp=s[6];t[6]=s[9];t[9]=tmp;tmp=s[7];t[7]=s[13];t[13]=tmp;tmp=s[11];t[11]=s[14];t[14]=tmp;}else {t[0]=s[0];t[1]=s[4];t[2]=s[8];t[3]=s[12];t[4]=s[1];t[5]=s[5];t[6]=s[9];t[7]=s[13];t[8]=s[2];t[9]=s[6];t[10]=s[10];t[11]=s[14];t[12]=s[3];t[13]=s[7];t[14]=s[11];t[15]=s[15];}return this}getTranslation(t=new Vec3){return t.set(this.data[12],this.data[13],this.data[14])}getX(x=new Vec3){return x.set(this.data[0],this.data[1],this.data[2])}getY(y=new Vec3){return y.set(this.data[4],this.data[5],this.data[6])}getZ(z=new Vec3){return z.set(this.data[8],this.data[9],this.data[10])}getScale(scale=new Vec3){this.getX(x$1);this.getY(y);this.getZ(z);scale.set(x$1.length(),y.length(),z.length());return scale}get scaleSign(){this.getX(x$1);this.getY(y);this.getZ(z);x$1.cross(x$1,y);return x$1.dot(z)<0?-1:1}setFromEulerAngles(ex,ey,ez){ex*=math.DEG_TO_RAD;ey*=math.DEG_TO_RAD;ez*=math.DEG_TO_RAD;const s1=Math.sin(-ex);const c1=Math.cos(-ex);const s2=Math.sin(-ey);const c2=Math.cos(-ey);const s3=Math.sin(-ez);const c3=Math.cos(-ez);const m=this.data;m[0]=c2*c3;m[1]=-c2*s3;m[2]=s2;m[3]=0;m[4]=c1*s3+c3*s1*s2;m[5]=c1*c3-s1*s2*s3;m[6]=-c2*s1;m[7]=0;m[8]=s1*s3-c1*c3*s2;m[9]=c3*s1+c1*s2*s3;m[10]=c1*c2;m[11]=0;m[12]=0;m[13]=0;m[14]=0;m[15]=1;return this}getEulerAngles(eulers=new Vec3){this.getScale(scale);const sx=scale.x;const sy=scale.y;const sz=scale.z;if(sx===0||sy===0||sz===0){return eulers.set(0,0,0)}const m=this.data;const y=Math.asin(-m[2]/sx);const halfPi=Math.PI*.5;let x,z;if(y<halfPi){if(y>-halfPi){x=Math.atan2(m[6]/sy,m[10]/sz);z=Math.atan2(m[1]/sx,m[0]/sx);}else {z=0;x=-Math.atan2(m[4]/sy,m[5]/sy);}}else {z=0;x=Math.atan2(m[4]/sy,m[5]/sy);}return eulers.set(x,y,z).mulScalar(math.RAD_TO_DEG)}toString(){return `[${this.data.join(", ")}]`}constructor(){this.data=new Float32Array(16);this.data[0]=this.data[5]=this.data[10]=this.data[15]=1;}}_Mat=Mat4;Mat4.IDENTITY=Object.freeze(new _Mat);Mat4.ZERO=Object.freeze(new _Mat().set([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]));var _Quat;class Quat{clone(){const cstr=this.constructor;return new cstr(this.x,this.y,this.z,this.w)}conjugate(src=this){this.x=src.x*-1;this.y=src.y*-1;this.z=src.z*-1;this.w=src.w;return this}copy(rhs){this.x=rhs.x;this.y=rhs.y;this.z=rhs.z;this.w=rhs.w;return this}equals(rhs){return this.x===rhs.x&&this.y===rhs.y&&this.z===rhs.z&&this.w===rhs.w}equalsApprox(rhs,epsilon=1e-6){return Math.abs(this.x-rhs.x)<epsilon&&Math.abs(this.y-rhs.y)<epsilon&&Math.abs(this.z-rhs.z)<epsilon&&Math.abs(this.w-rhs.w)<epsilon}getAxisAngle(axis){let rad=Math.acos(this.w)*2;const s=Math.sin(rad/2);if(s!==0){axis.x=this.x/s;axis.y=this.y/s;axis.z=this.z/s;if(axis.x<0||axis.y<0||axis.z<0){axis.x*=-1;axis.y*=-1;axis.z*=-1;rad*=-1;}}else {axis.x=1;axis.y=0;axis.z=0;}return rad*math.RAD_TO_DEG}getEulerAngles(eulers=new Vec3){let x,y,z;const qx=this.x;const qy=this.y;const qz=this.z;const qw=this.w;const a2=2*(qw*qy-qx*qz);if(a2<=-.99999){x=2*Math.atan2(qx,qw);y=-Math.PI/2;z=0;}else if(a2>=.99999){x=2*Math.atan2(qx,qw);y=Math.PI/2;z=0;}else {x=Math.atan2(2*(qw*qx+qy*qz),1-2*(qx*qx+qy*qy));y=Math.asin(a2);z=Math.atan2(2*(qw*qz+qx*qy),1-2*(qy*qy+qz*qz));}return eulers.set(x,y,z).mulScalar(math.RAD_TO_DEG)}invert(src=this){return this.conjugate(src).normalize()}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}mul(rhs){const q1x=this.x;const q1y=this.y;const q1z=this.z;const q1w=this.w;const q2x=rhs.x;const q2y=rhs.y;const q2z=rhs.z;const q2w=rhs.w;this.x=q1w*q2x+q1x*q2w+q1y*q2z-q1z*q2y;this.y=q1w*q2y+q1y*q2w+q1z*q2x-q1x*q2z;this.z=q1w*q2z+q1z*q2w+q1x*q2y-q1y*q2x;this.w=q1w*q2w-q1x*q2x-q1y*q2y-q1z*q2z;return this}mulScalar(scalar,src=this){this.x=src.x*scalar;this.y=src.y*scalar;this.z=src.z*scalar;this.w=src.w*scalar;return this}mul2(lhs,rhs){const q1x=lhs.x;const q1y=lhs.y;const q1z=lhs.z;const q1w=lhs.w;const q2x=rhs.x;const q2y=rhs.y;const q2z=rhs.z;const q2w=rhs.w;this.x=q1w*q2x+q1x*q2w+q1y*q2z-q1z*q2y;this.y=q1w*q2y+q1y*q2w+q1z*q2x-q1x*q2z;this.z=q1w*q2z+q1z*q2w+q1x*q2y-q1y*q2x;this.w=q1w*q2w-q1x*q2x-q1y*q2y-q1z*q2z;return this}normalize(src=this){let len=src.length();if(len===0){this.x=this.y=this.z=0;this.w=1;}else {len=1/len;this.x=src.x*len;this.y=src.y*len;this.z=src.z*len;this.w=src.w*len;}return this}set(x,y,z,w){this.x=x;this.y=y;this.z=z;this.w=w;return this}setFromAxisAngle(axis,angle){angle*=.5*math.DEG_TO_RAD;const sa=Math.sin(angle);const ca=Math.cos(angle);this.x=sa*axis.x;this.y=sa*axis.y;this.z=sa*axis.z;this.w=ca;return this}setFromEulerAngles(ex,ey,ez){if(ex instanceof Vec3){const vec=ex;ex=vec.x;ey=vec.y;ez=vec.z;}const halfToRad=.5*math.DEG_TO_RAD;ex*=halfToRad;ey*=halfToRad;ez*=halfToRad;const sx=Math.sin(ex);const cx=Math.cos(ex);const sy=Math.sin(ey);const cy=Math.cos(ey);const sz=Math.sin(ez);const cz=Math.cos(ez);this.x=sx*cy*cz-cx*sy*sz;this.y=cx*sy*cz+sx*cy*sz;this.z=cx*cy*sz-sx*sy*cz;this.w=cx*cy*cz+sx*sy*sz;return this}setFromMat4(m){const d=m.data;let m00=d[0];let m01=d[1];let m02=d[2];let m10=d[4];let m11=d[5];let m12=d[6];let m20=d[8];let m21=d[9];let m22=d[10];let l;l=m00*m00+m01*m01+m02*m02;if(l===0)return this.set(0,0,0,1);l=1/Math.sqrt(l);m00*=l;m01*=l;m02*=l;l=m10*m10+m11*m11+m12*m12;if(l===0)return this.set(0,0,0,1);l=1/Math.sqrt(l);m10*=l;m11*=l;m12*=l;l=m20*m20+m21*m21+m22*m22;if(l===0)return this.set(0,0,0,1);l=1/Math.sqrt(l);m20*=l;m21*=l;m22*=l;if(m22<0){if(m00>m11){this.set(1+m00-m11-m22,m01+m10,m20+m02,m12-m21);}else {this.set(m01+m10,1-m00+m11-m22,m12+m21,m20-m02);}}else {if(m00<-m11){this.set(m20+m02,m12+m21,1-m00-m11+m22,m01-m10);}else {this.set(m12-m21,m20-m02,m01-m10,1+m00+m11+m22);}}return this.mulScalar(1/this.length())}setFromDirections(from,to){const dotProduct=1+from.dot(to);if(dotProduct<Number.EPSILON){if(Math.abs(from.x)>Math.abs(from.y)){this.x=-from.z;this.y=0;this.z=from.x;this.w=0;}else {this.x=0;this.y=-from.z;this.z=from.y;this.w=0;}}else {this.x=from.y*to.z-from.z*to.y;this.y=from.z*to.x-from.x*to.z;this.z=from.x*to.y-from.y*to.x;this.w=dotProduct;}return this.normalize()}slerp(lhs,rhs,alpha){const lx=lhs.x;const ly=lhs.y;const lz=lhs.z;const lw=lhs.w;let rx=rhs.x;let ry=rhs.y;let rz=rhs.z;let rw=rhs.w;let cosHalfTheta=lw*rw+lx*rx+ly*ry+lz*rz;if(cosHalfTheta<0){rw=-rw;rx=-rx;ry=-ry;rz=-rz;cosHalfTheta=-cosHalfTheta;}if(Math.abs(cosHalfTheta)>=1){this.w=lw;this.x=lx;this.y=ly;this.z=lz;return this}const halfTheta=Math.acos(cosHalfTheta);const sinHalfTheta=Math.sqrt(1-cosHalfTheta*cosHalfTheta);if(Math.abs(sinHalfTheta)<.001){this.w=lw*.5+rw*.5;this.x=lx*.5+rx*.5;this.y=ly*.5+ry*.5;this.z=lz*.5+rz*.5;return this}const ratioA=Math.sin((1-alpha)*halfTheta)/sinHalfTheta;const ratioB=Math.sin(alpha*halfTheta)/sinHalfTheta;this.w=lw*ratioA+rw*ratioB;this.x=lx*ratioA+rx*ratioB;this.y=ly*ratioA+ry*ratioB;this.z=lz*ratioA+rz*ratioB;return this}transformVector(vec,res=new Vec3){const x=vec.x,y=vec.y,z=vec.z;const qx=this.x,qy=this.y,qz=this.z,qw=this.w;const ix=qw*x+qy*z-qz*y;const iy=qw*y+qz*x-qx*z;const iz=qw*z+qx*y-qy*x;const iw=-qx*x-qy*y-qz*z;res.x=ix*qw+iw*-qx+iy*-qz-iz*-qy;res.y=iy*qw+iw*-qy+iz*-qx-ix*-qz;res.z=iz*qw+iw*-qz+ix*-qy-iy*-qx;return res}toString(){return `[${this.x}, ${this.y}, ${this.z}, ${this.w}]`}constructor(x=0,y=0,z=0,w=1){this.x=void 0;this.y=void 0;this.z=void 0;this.w=void 0;if(x.length===4){this.x=x[0];this.y=x[1];this.z=x[2];this.w=x[3];}else {this.x=x;this.y=y;this.z=z;this.w=w;}}}_Quat=Quat;Quat.IDENTITY=Object.freeze(new _Quat(0,0,0,1));Quat.ZERO=Object.freeze(new _Quat(0,0,0,0));const tmpVecA$1=new Vec3;const tmpVecB$1=new Vec3;const tmpVecC=new Vec3;const tmpVecD=new Vec3;const tmpVecE=new Vec3;class BoundingBox{add(other){const tc=this.center;const tcx=tc.x;const tcy=tc.y;const tcz=tc.z;const th=this.halfExtents;const thx=th.x;const thy=th.y;const thz=th.z;let tminx=tcx-thx;let tmaxx=tcx+thx;let tminy=tcy-thy;let tmaxy=tcy+thy;let tminz=tcz-thz;let tmaxz=tcz+thz;const oc=other.center;const ocx=oc.x;const ocy=oc.y;const ocz=oc.z;const oh=other.halfExtents;const ohx=oh.x;const ohy=oh.y;const ohz=oh.z;const ominx=ocx-ohx;const omaxx=ocx+ohx;const ominy=ocy-ohy;const omaxy=ocy+ohy;const ominz=ocz-ohz;const omaxz=ocz+ohz;if(ominx<tminx)tminx=ominx;if(omaxx>tmaxx)tmaxx=omaxx;if(ominy<tminy)tminy=ominy;if(omaxy>tmaxy)tmaxy=omaxy;if(ominz<tminz)tminz=ominz;if(omaxz>tmaxz)tmaxz=omaxz;tc.x=(tminx+tmaxx)*.5;tc.y=(tminy+tmaxy)*.5;tc.z=(tminz+tmaxz)*.5;th.x=(tmaxx-tminx)*.5;th.y=(tmaxy-tminy)*.5;th.z=(tmaxz-tminz)*.5;}copy(src){this.center.copy(src.center);this.halfExtents.copy(src.halfExtents);}clone(){return new BoundingBox(this.center.clone(),this.halfExtents.clone())}intersects(other){const aMax=this.getMax();const aMin=this.getMin();const bMax=other.getMax();const bMin=other.getMin();return aMin.x<=bMax.x&&aMax.x>=bMin.x&&aMin.y<=bMax.y&&aMax.y>=bMin.y&&aMin.z<=bMax.z&&aMax.z>=bMin.z}_intersectsRay(ray,point){const tMin=tmpVecA$1.copy(this.getMin()).sub(ray.origin);const tMax=tmpVecB$1.copy(this.getMax()).sub(ray.origin);const dir=ray.direction;if(dir.x===0){tMin.x=tMin.x<0?-Number.MAX_VALUE:Number.MAX_VALUE;tMax.x=tMax.x<0?-Number.MAX_VALUE:Number.MAX_VALUE;}else {tMin.x/=dir.x;tMax.x/=dir.x;}if(dir.y===0){tMin.y=tMin.y<0?-Number.MAX_VALUE:Number.MAX_VALUE;tMax.y=tMax.y<0?-Number.MAX_VALUE:Number.MAX_VALUE;}else {tMin.y/=dir.y;tMax.y/=dir.y;}if(dir.z===0){tMin.z=tMin.z<0?-Number.MAX_VALUE:Number.MAX_VALUE;tMax.z=tMax.z<0?-Number.MAX_VALUE:Number.MAX_VALUE;}else {tMin.z/=dir.z;tMax.z/=dir.z;}const realMin=tmpVecC.set(Math.min(tMin.x,tMax.x),Math.min(tMin.y,tMax.y),Math.min(tMin.z,tMax.z));const realMax=tmpVecD.set(Math.max(tMin.x,tMax.x),Math.max(tMin.y,tMax.y),Math.max(tMin.z,tMax.z));const minMax=Math.min(Math.min(realMax.x,realMax.y),realMax.z);const maxMin=Math.max(Math.max(realMin.x,realMin.y),realMin.z);const intersects=minMax>=maxMin&&maxMin>=0;if(intersects){point.copy(ray.direction).mulScalar(maxMin).add(ray.origin);}return intersects}_fastIntersectsRay(ray){const diff=tmpVecA$1;const cross=tmpVecB$1;const prod=tmpVecC;const absDiff=tmpVecD;const absDir=tmpVecE;const rayDir=ray.direction;diff.sub2(ray.origin,this.center);absDiff.set(Math.abs(diff.x),Math.abs(diff.y),Math.abs(diff.z));prod.mul2(diff,rayDir);if(absDiff.x>this.halfExtents.x&&prod.x>=0){return false}if(absDiff.y>this.halfExtents.y&&prod.y>=0){return false}if(absDiff.z>this.halfExtents.z&&prod.z>=0){return false}absDir.set(Math.abs(rayDir.x),Math.abs(rayDir.y),Math.abs(rayDir.z));cross.cross(rayDir,diff);cross.set(Math.abs(cross.x),Math.abs(cross.y),Math.abs(cross.z));if(cross.x>this.halfExtents.y*absDir.z+this.halfExtents.z*absDir.y){return false}if(cross.y>this.halfExtents.x*absDir.z+this.halfExtents.z*absDir.x){return false}if(cross.z>this.halfExtents.x*absDir.y+this.halfExtents.y*absDir.x){return false}return true}intersectsRay(ray,point){if(point){return this._intersectsRay(ray,point)}return this._fastIntersectsRay(ray)}setMinMax(min,max){this.center.add2(max,min).mulScalar(.5);this.halfExtents.sub2(max,min).mulScalar(.5);}getMin(){return this._min.copy(this.center).sub(this.halfExtents)}getMax(){return this._max.copy(this.center).add(this.halfExtents)}containsPoint(point){const min=this.getMin();const max=this.getMax();if(point.x<min.x||point.x>max.x||point.y<min.y||point.y>max.y||point.z<min.z||point.z>max.z){return false}return true}setFromTransformedAabb(aabb,m,ignoreScale=false){const ac=aabb.center;const ar=aabb.halfExtents;const d=m.data;let mx0=d[0];let mx1=d[4];let mx2=d[8];let my0=d[1];let my1=d[5];let my2=d[9];let mz0=d[2];let mz1=d[6];let mz2=d[10];if(ignoreScale){let lengthSq=mx0*mx0+mx1*mx1+mx2*mx2;if(lengthSq>0){const invLength=1/Math.sqrt(lengthSq);mx0*=invLength;mx1*=invLength;mx2*=invLength;}lengthSq=my0*my0+my1*my1+my2*my2;if(lengthSq>0){const invLength=1/Math.sqrt(lengthSq);my0*=invLength;my1*=invLength;my2*=invLength;}lengthSq=mz0*mz0+mz1*mz1+mz2*mz2;if(lengthSq>0){const invLength=1/Math.sqrt(lengthSq);mz0*=invLength;mz1*=invLength;mz2*=invLength;}}this.center.set(d[12]+mx0*ac.x+mx1*ac.y+mx2*ac.z,d[13]+my0*ac.x+my1*ac.y+my2*ac.z,d[14]+mz0*ac.x+mz1*ac.y+mz2*ac.z);this.halfExtents.set(Math.abs(mx0)*ar.x+Math.abs(mx1)*ar.y+Math.abs(mx2)*ar.z,Math.abs(my0)*ar.x+Math.abs(my1)*ar.y+Math.abs(my2)*ar.z,Math.abs(mz0)*ar.x+Math.abs(mz1)*ar.y+Math.abs(mz2)*ar.z);}static computeMinMax(vertices,min,max,numVerts=vertices.length/3){if(numVerts>0){let minx=vertices[0];let miny=vertices[1];let minz=vertices[2];let maxx=minx;let maxy=miny;let maxz=minz;const n=numVerts*3;for(let i=3;i<n;i+=3){const x=vertices[i];const y=vertices[i+1];const z=vertices[i+2];if(x<minx)minx=x;if(y<miny)miny=y;if(z<minz)minz=z;if(x>maxx)maxx=x;if(y>maxy)maxy=y;if(z>maxz)maxz=z;}min.set(minx,miny,minz);max.set(maxx,maxy,maxz);}}compute(vertices,numVerts){BoundingBox.computeMinMax(vertices,tmpVecA$1,tmpVecB$1,numVerts);this.setMinMax(tmpVecA$1,tmpVecB$1);}intersectsBoundingSphere(sphere){const sq=this._distanceToBoundingSphereSq(sphere);if(sq<=sphere.radius*sphere.radius){return true}return false}_distanceToBoundingSphereSq(sphere){const boxMin=this.getMin();const boxMax=this.getMax();let sq=0;const axis=["x","y","z"];for(let i=0;i<3;++i){let out=0;const pn=sphere.center[axis[i]];const bMin=boxMin[axis[i]];const bMax=boxMax[axis[i]];let val=0;if(pn<bMin){val=bMin-pn;out+=val*val;}if(pn>bMax){val=pn-bMax;out+=val*val;}sq+=out;}return sq}_expand(expandMin,expandMax){tmpVecA$1.add2(this.getMin(),expandMin);tmpVecB$1.add2(this.getMax(),expandMax);this.setMinMax(tmpVecA$1,tmpVecB$1);}constructor(center=new Vec3,halfExtents=new Vec3(.5,.5,.5)){this.center=void 0;this.halfExtents=void 0;this._min=new Vec3;this._max=new Vec3;this.center=center;this.halfExtents=halfExtents;}}const tmpVecA=new Vec3;const tmpVecB=new Vec3;class BoundingSphere{containsPoint(point){const lenSq=tmpVecA.sub2(point,this.center).lengthSq();const r=this.radius;return lenSq<r*r}intersectsRay(ray,point){const m=tmpVecA.copy(ray.origin).sub(this.center);const b=m.dot(tmpVecB.copy(ray.direction).normalize());const c=m.dot(m)-this.radius*this.radius;if(c>0&&b>0){return false}const discr=b*b-c;if(discr<0){return false}const t=Math.abs(-b-Math.sqrt(discr));if(point){point.copy(ray.direction).mulScalar(t).add(ray.origin);}return true}intersectsBoundingSphere(sphere){tmpVecA.sub2(sphere.center,this.center);const totalRadius=sphere.radius+this.radius;if(tmpVecA.lengthSq()<=totalRadius*totalRadius){return true}return false}constructor(center=new Vec3,radius=.5){this.center=void 0;this.radius=void 0;this.center=center;this.radius=radius;}}class Frustum{setFromMat4(matrix){const vpm=matrix.data;let plane;const planes=this.planes;plane=planes[0];plane[0]=vpm[3]-vpm[0];plane[1]=vpm[7]-vpm[4];plane[2]=vpm[11]-vpm[8];plane[3]=vpm[15]-vpm[12];let t=Math.sqrt(plane[0]*plane[0]+plane[1]*plane[1]+plane[2]*plane[2]);plane[0]/=t;plane[1]/=t;plane[2]/=t;plane[3]/=t;plane=planes[1];plane[0]=vpm[3]+vpm[0];plane[1]=vpm[7]+vpm[4];plane[2]=vpm[11]+vpm[8];plane[3]=vpm[15]+vpm[12];t=Math.sqrt(plane[0]*plane[0]+plane[1]*plane[1]+plane[2]*plane[2]);plane[0]/=t;plane[1]/=t;plane[2]/=t;plane[3]/=t;plane=planes[2];plane[0]=vpm[3]+vpm[1];plane[1]=vpm[7]+vpm[5];plane[2]=vpm[11]+vpm[9];plane[3]=vpm[15]+vpm[13];t=Math.sqrt(plane[0]*plane[0]+plane[1]*plane[1]+plane[2]*plane[2]);plane[0]/=t;plane[1]/=t;plane[2]/=t;plane[3]/=t;plane=planes[3];plane[0]=vpm[3]-vpm[1];plane[1]=vpm[7]-vpm[5];plane[2]=vpm[11]-vpm[9];plane[3]=vpm[15]-vpm[13];t=Math.sqrt(plane[0]*plane[0]+plane[1]*plane[1]+plane[2]*plane[2]);plane[0]/=t;plane[1]/=t;plane[2]/=t;plane[3]/=t;plane=planes[4];plane[0]=vpm[3]-vpm[2];plane[1]=vpm[7]-vpm[6];plane[2]=vpm[11]-vpm[10];plane[3]=vpm[15]-vpm[14];t=Math.sqrt(plane[0]*plane[0]+plane[1]*plane[1]+plane[2]*plane[2]);plane[0]/=t;plane[1]/=t;plane[2]/=t;plane[3]/=t;plane=planes[5];plane[0]=vpm[3]+vpm[2];plane[1]=vpm[7]+vpm[6];plane[2]=vpm[11]+vpm[10];plane[3]=vpm[15]+vpm[14];t=Math.sqrt(plane[0]*plane[0]+plane[1]*plane[1]+plane[2]*plane[2]);plane[0]/=t;plane[1]/=t;plane[2]/=t;plane[3]/=t;}containsPoint(point){let p,plane;for(p=0;p<6;p++){plane=this.planes[p];if(plane[0]*point.x+plane[1]*point.y+plane[2]*point.z+plane[3]<=0){return false}}return true}containsSphere(sphere){let c=0;let d;let p;const sr=sphere.radius;const sc=sphere.center;const scx=sc.x;const scy=sc.y;const scz=sc.z;const planes=this.planes;let plane;for(p=0;p<6;p++){plane=planes[p];d=plane[0]*scx+plane[1]*scy+plane[2]*scz+plane[3];if(d<=-sr){return 0}if(d>sr){c++;}}return c===6?2:1}constructor(){this.planes=[];for(let i=0;i<6;i++){this.planes[i]=[];}}}class Ray{set(origin,direction){this.origin.copy(origin);this.direction.copy(direction);return this}copy(src){return this.set(src.origin,src.direction)}clone(){return new this.constructor(this.origin,this.direction)}constructor(origin,direction){this.origin=new Vec3;this.direction=Vec3.FORWARD.clone();if(origin){this.origin.copy(origin);}if(direction){this.direction.copy(direction);}}}const tmpRay=new Ray;const tmpVec3$2=new Vec3;const tmpSphere=new BoundingSphere;const tmpMat4$1=new Mat4;class OrientedBox{set worldTransform(value){this._worldTransform.copy(value);this._modelTransform.copy(value).invert();}get worldTransform(){return this._worldTransform}intersectsRay(ray,point){this._modelTransform.transformPoint(ray.origin,tmpRay.origin);this._modelTransform.transformVector(ray.direction,tmpRay.direction);if(point){const result=this._aabb._intersectsRay(tmpRay,point);tmpMat4$1.copy(this._modelTransform).invert().transformPoint(point,point);return result}return this._aabb._fastIntersectsRay(tmpRay)}containsPoint(point){this._modelTransform.transformPoint(point,tmpVec3$2);return this._aabb.containsPoint(tmpVec3$2)}intersectsBoundingSphere(sphere){this._modelTransform.transformPoint(sphere.center,tmpSphere.center);tmpSphere.radius=sphere.radius;if(this._aabb.intersectsBoundingSphere(tmpSphere)){return true}return false}constructor(worldTransform=new Mat4,halfExtents=new Vec3(.5,.5,.5)){this.halfExtents=void 0;this._modelTransform=void 0;this._worldTransform=void 0;this._aabb=void 0;this.halfExtents=halfExtents;this._modelTransform=worldTransform.clone().invert();this._worldTransform=worldTransform.clone();this._aabb=new BoundingBox(new Vec3,this.halfExtents);}}class Plane{setFromPointNormal(point,normal){this.normal.copy(normal);this.distance=-this.normal.dot(point);return this}intersectsLine(start,end,point){const d=this.distance;const d0=this.normal.dot(start)+d;const d1=this.normal.dot(end)+d;const t=d0/(d0-d1);const intersects=t>=0&&t<=1;if(intersects&&point){point.lerp(start,end,t);}return intersects}intersectsRay(ray,point){const denominator=this.normal.dot(ray.direction);if(denominator===0){return false}const t=-(this.normal.dot(ray.origin)+this.distance)/denominator;if(t>=0&&point){point.copy(ray.direction).mulScalar(t).add(ray.origin);}return t>=0}copy(src){this.normal.copy(src.normal);this.distance=src.distance;return this}clone(){const cstr=this.constructor;return new cstr().copy(this)}constructor(normal=Vec3.UP,distance=0){this.normal=new Vec3;this.distance=void 0;this.normal.copy(normal);this.distance=distance;}}const e1=new Vec3;const e2=new Vec3;const h=new Vec3;const s=new Vec3;const q$1=new Vec3;const EPSILON=1e-6;class Tri{set(v0,v1,v2){this.v0.copy(v0);this.v1.copy(v1);this.v2.copy(v2);return this}intersectsRay(ray,point){e1.sub2(this.v1,this.v0);e2.sub2(this.v2,this.v0);h.cross(ray.direction,e2);const a=e1.dot(h);if(a>-EPSILON&&a<EPSILON){return false}const f=1/a;s.sub2(ray.origin,this.v0);const u=f*s.dot(h);if(u<0||u>1){return false}q$1.cross(s,e1);const v=f*ray.direction.dot(q$1);if(v<0||u+v>1){return false}const t=f*e2.dot(q$1);if(t>EPSILON){if(point instanceof Vec3){point.copy(ray.direction).mulScalar(t).add(ray.origin);}return true}return false}toString(){return `[${this.v0.toString()}, ${this.v1.toString()}, ${this.v2.toString()}]`}constructor(v0=Vec3.ZERO,v1=Vec3.ZERO,v2=Vec3.ZERO){this.v0=new Vec3;this.v1=new Vec3;this.v2=new Vec3;this.set(v0,v1,v2);}}const DISTANCE_LINEAR="linear";const DISTANCE_INVERSE="inverse";const DISTANCE_EXPONENTIAL="exponential";const ADDRESS_REPEAT=0;const ADDRESS_CLAMP_TO_EDGE=1;const ADDRESS_MIRRORED_REPEAT=2;const BLENDMODE_ZERO=0;const BLENDMODE_ONE=1;const BLENDMODE_SRC_COLOR=2;const BLENDMODE_ONE_MINUS_SRC_COLOR=3;const BLENDMODE_DST_COLOR=4;const BLENDMODE_ONE_MINUS_DST_COLOR=5;const BLENDMODE_SRC_ALPHA=6;const BLENDMODE_SRC_ALPHA_SATURATE=7;const BLENDMODE_ONE_MINUS_SRC_ALPHA=8;const BLENDMODE_DST_ALPHA=9;const BLENDMODE_ONE_MINUS_DST_ALPHA=10;const BLENDMODE_CONSTANT=11;const BLENDMODE_ONE_MINUS_CONSTANT=12;const BLENDEQUATION_ADD=0;const BLENDEQUATION_SUBTRACT=1;const BLENDEQUATION_REVERSE_SUBTRACT=2;const BLENDEQUATION_MIN=3;const BLENDEQUATION_MAX=4;const BUFFERUSAGE_READ=1;const BUFFERUSAGE_WRITE=2;const BUFFERUSAGE_COPY_SRC=4;const BUFFERUSAGE_COPY_DST=8;const BUFFERUSAGE_INDEX=16;const BUFFERUSAGE_VERTEX=32;const BUFFERUSAGE_UNIFORM=64;const BUFFERUSAGE_STORAGE=128;const BUFFERUSAGE_INDIRECT=256;const BUFFER_STATIC=0;const BUFFER_DYNAMIC=1;const BUFFER_STREAM=2;const BUFFER_GPUDYNAMIC=3;const CLEARFLAG_COLOR=1;const CLEARFLAG_DEPTH=2;const CLEARFLAG_STENCIL=4;const CUBEFACE_POSX=0;const CUBEFACE_NEGX=1;const CUBEFACE_POSY=2;const CUBEFACE_NEGY=3;const CUBEFACE_POSZ=4;const CUBEFACE_NEGZ=5;const CULLFACE_NONE=0;const CULLFACE_BACK=1;const CULLFACE_FRONT=2;const CULLFACE_FRONTANDBACK=3;const FILTER_NEAREST=0;const FILTER_LINEAR=1;const FILTER_NEAREST_MIPMAP_NEAREST=2;const FILTER_NEAREST_MIPMAP_LINEAR=3;const FILTER_LINEAR_MIPMAP_NEAREST=4;const FILTER_LINEAR_MIPMAP_LINEAR=5;const FUNC_NEVER=0;const FUNC_LESS=1;const FUNC_EQUAL=2;const FUNC_LESSEQUAL=3;const FUNC_GREATER=4;const FUNC_NOTEQUAL=5;const FUNC_GREATEREQUAL=6;const FUNC_ALWAYS=7;const INDEXFORMAT_UINT8=0;const INDEXFORMAT_UINT16=1;const INDEXFORMAT_UINT32=2;const PIXELFORMAT_A8=0;const PIXELFORMAT_L8=1;const PIXELFORMAT_LA8=2;const PIXELFORMAT_RGB565=3;const PIXELFORMAT_RGBA5551=4;const PIXELFORMAT_RGBA4=5;const PIXELFORMAT_RGB8=6;const PIXELFORMAT_RGBA8=7;const PIXELFORMAT_DXT1=8;const PIXELFORMAT_DXT3=9;const PIXELFORMAT_DXT5=10;const PIXELFORMAT_RGB16F=11;const PIXELFORMAT_RGBA16F=12;const PIXELFORMAT_RGB32F=13;const PIXELFORMAT_RGBA32F=14;const PIXELFORMAT_R32F=15;const PIXELFORMAT_DEPTH=16;const PIXELFORMAT_DEPTHSTENCIL=17;const PIXELFORMAT_111110F=18;const PIXELFORMAT_SRGB=19;const PIXELFORMAT_SRGBA=20;const PIXELFORMAT_ETC1=21;const PIXELFORMAT_ETC2_RGB=22;const PIXELFORMAT_ETC2_RGBA=23;const PIXELFORMAT_PVRTC_2BPP_RGB_1=24;const PIXELFORMAT_PVRTC_2BPP_RGBA_1=25;const PIXELFORMAT_PVRTC_4BPP_RGB_1=26;const PIXELFORMAT_PVRTC_4BPP_RGBA_1=27;const PIXELFORMAT_ASTC_4x4=28;const PIXELFORMAT_ATC_RGB=29;const PIXELFORMAT_ATC_RGBA=30;const PIXELFORMAT_BGRA8=31;const PIXELFORMAT_R8I=32;const PIXELFORMAT_R8U=33;const PIXELFORMAT_R16I=34;const PIXELFORMAT_R16U=35;const PIXELFORMAT_R32I=36;const PIXELFORMAT_R32U=37;const PIXELFORMAT_RG8I=38;const PIXELFORMAT_RG8U=39;const PIXELFORMAT_RG16I=40;const PIXELFORMAT_RG16U=41;const PIXELFORMAT_RG32I=42;const PIXELFORMAT_RG32U=43;const PIXELFORMAT_RGBA8I=44;const PIXELFORMAT_RGBA8U=45;const PIXELFORMAT_RGBA16I=46;const PIXELFORMAT_RGBA16U=47;const PIXELFORMAT_RGBA32I=48;const PIXELFORMAT_RGBA32U=49;const PIXELFORMAT_R16F=50;const PIXELFORMAT_RG16F=51;const pixelFormatInfo=new Map([[PIXELFORMAT_A8,{name:"A8",size:1}],[PIXELFORMAT_L8,{name:"L8",size:1}],[PIXELFORMAT_LA8,{name:"LA8",size:2}],[PIXELFORMAT_RGB565,{name:"RGB565",size:2}],[PIXELFORMAT_RGBA5551,{name:"RGBA5551",size:2}],[PIXELFORMAT_RGBA4,{name:"RGBA4",size:2}],[PIXELFORMAT_RGB8,{name:"RGB8",size:4}],[PIXELFORMAT_RGBA8,{name:"RGBA8",size:4}],[PIXELFORMAT_R16F,{name:"R16F",size:2}],[PIXELFORMAT_RG16F,{name:"RG16F",size:4}],[PIXELFORMAT_RGB16F,{name:"RGB16F",size:8}],[PIXELFORMAT_RGBA16F,{name:"RGBA16F",size:8}],[PIXELFORMAT_RGB32F,{name:"RGB32F",size:16}],[PIXELFORMAT_RGBA32F,{name:"RGBA32F",size:16}],[PIXELFORMAT_R32F,{name:"R32F",size:4}],[PIXELFORMAT_DEPTH,{name:"DEPTH",size:4}],[PIXELFORMAT_DEPTHSTENCIL,{name:"DEPTHSTENCIL",size:4}],[PIXELFORMAT_111110F,{name:"111110F",size:4}],[PIXELFORMAT_SRGB,{name:"SRGB",size:4}],[PIXELFORMAT_SRGBA,{name:"SRGBA",size:4}],[PIXELFORMAT_BGRA8,{name:"BGRA8",size:4}],[PIXELFORMAT_DXT1,{name:"DXT1",blockSize:8}],[PIXELFORMAT_DXT3,{name:"DXT3",blockSize:16}],[PIXELFORMAT_DXT5,{name:"DXT5",blockSize:16}],[PIXELFORMAT_ETC1,{name:"ETC1",blockSize:8}],[PIXELFORMAT_ETC2_RGB,{name:"ETC2_RGB",blockSize:8}],[PIXELFORMAT_ETC2_RGBA,{name:"ETC2_RGBA",blockSize:16}],[PIXELFORMAT_PVRTC_2BPP_RGB_1,{name:"PVRTC_2BPP_RGB_1",blockSize:8}],[PIXELFORMAT_PVRTC_2BPP_RGBA_1,{name:"PVRTC_2BPP_RGBA_1",blockSize:8}],[PIXELFORMAT_PVRTC_4BPP_RGB_1,{name:"PVRTC_4BPP_RGB_1",blockSize:8}],[PIXELFORMAT_PVRTC_4BPP_RGBA_1,{name:"PVRTC_4BPP_RGBA_1",blockSize:8}],[PIXELFORMAT_ASTC_4x4,{name:"ASTC_4x4",blockSize:16}],[PIXELFORMAT_ATC_RGB,{name:"ATC_RGB",blockSize:8}],[PIXELFORMAT_ATC_RGBA,{name:"ATC_RGBA",blockSize:16}],[PIXELFORMAT_R8I,{name:"R8I",size:1,isInt:true}],[PIXELFORMAT_R8U,{name:"R8U",size:1,isInt:true}],[PIXELFORMAT_R16I,{name:"R16I",size:2,isInt:true}],[PIXELFORMAT_R16U,{name:"R16U",size:2,isInt:true}],[PIXELFORMAT_R32I,{name:"R32I",size:4,isInt:true}],[PIXELFORMAT_R32U,{name:"R32U",size:4,isInt:true}],[PIXELFORMAT_RG8I,{name:"RG8I",size:2,isInt:true}],[PIXELFORMAT_RG8U,{name:"RG8U",size:2,isInt:true}],[PIXELFORMAT_RG16I,{name:"RG16I",size:4,isInt:true}],[PIXELFORMAT_RG16U,{name:"RG16U",size:4,isInt:true}],[PIXELFORMAT_RG32I,{name:"RG32I",size:8,isInt:true}],[PIXELFORMAT_RG32U,{name:"RG32U",size:8,isInt:true}],[PIXELFORMAT_RGBA8I,{name:"RGBA8I",size:4,isInt:true}],[PIXELFORMAT_RGBA8U,{name:"RGBA8U",size:4,isInt:true}],[PIXELFORMAT_RGBA16I,{name:"RGBA16I",size:8,isInt:true}],[PIXELFORMAT_RGBA16U,{name:"RGBA16U",size:8,isInt:true}],[PIXELFORMAT_RGBA32I,{name:"RGBA32I",size:16,isInt:true}],[PIXELFORMAT_RGBA32U,{name:"RGBA32U",size:16,isInt:true}]]);const isCompressedPixelFormat=format=>{var _pixelFormatInfo$get;return ((_pixelFormatInfo$get=pixelFormatInfo.get(format))==null?void 0:_pixelFormatInfo$get.blockSize)!==undefined};const isIntegerPixelFormat=format=>{var _pixelFormatInfo$get2;return ((_pixelFormatInfo$get2=pixelFormatInfo.get(format))==null?void 0:_pixelFormatInfo$get2.isInt)===true};const getPixelFormatArrayType=format=>{switch(format){case PIXELFORMAT_R32F:case PIXELFORMAT_RGB32F:case PIXELFORMAT_RGBA32F:return Float32Array;case PIXELFORMAT_R32I:case PIXELFORMAT_RG32I:case PIXELFORMAT_RGBA32I:return Int32Array;case PIXELFORMAT_R32U:case PIXELFORMAT_RG32U:case PIXELFORMAT_RGBA32U:return Uint32Array;case PIXELFORMAT_R16I:case PIXELFORMAT_RG16I:case PIXELFORMAT_RGBA16I:return Int16Array;case PIXELFORMAT_R16U:case PIXELFORMAT_RG16U:case PIXELFORMAT_RGBA16U:case PIXELFORMAT_RGB565:case PIXELFORMAT_RGBA5551:case PIXELFORMAT_RGBA4:case PIXELFORMAT_R16F:case PIXELFORMAT_RG16F:case PIXELFORMAT_RGB16F:case PIXELFORMAT_RGBA16F:return Uint16Array;case PIXELFORMAT_R8I:case PIXELFORMAT_RG8I:case PIXELFORMAT_RGBA8I:return Int8Array;default:return Uint8Array}};const PRIMITIVE_POINTS=0;const PRIMITIVE_LINES=1;const PRIMITIVE_LINELOOP=2;const PRIMITIVE_LINESTRIP=3;const PRIMITIVE_TRIANGLES=4;const PRIMITIVE_TRISTRIP=5;const PRIMITIVE_TRIFAN=6;const SEMANTIC_POSITION="POSITION";const SEMANTIC_NORMAL="NORMAL";const SEMANTIC_TANGENT="TANGENT";const SEMANTIC_BLENDWEIGHT="BLENDWEIGHT";const SEMANTIC_BLENDINDICES="BLENDINDICES";const SEMANTIC_COLOR="COLOR";const SEMANTIC_TEXCOORD="TEXCOORD";const SEMANTIC_TEXCOORD0="TEXCOORD0";const SEMANTIC_TEXCOORD1="TEXCOORD1";const SEMANTIC_TEXCOORD2="TEXCOORD2";const SEMANTIC_TEXCOORD3="TEXCOORD3";const SEMANTIC_TEXCOORD4="TEXCOORD4";const SEMANTIC_TEXCOORD5="TEXCOORD5";const SEMANTIC_TEXCOORD6="TEXCOORD6";const SEMANTIC_TEXCOORD7="TEXCOORD7";const SEMANTIC_ATTR="ATTR";const SEMANTIC_ATTR0="ATTR0";const SEMANTIC_ATTR1="ATTR1";const SEMANTIC_ATTR2="ATTR2";const SEMANTIC_ATTR3="ATTR3";const SEMANTIC_ATTR4="ATTR4";const SEMANTIC_ATTR5="ATTR5";const SEMANTIC_ATTR6="ATTR6";const SEMANTIC_ATTR7="ATTR7";const SEMANTIC_ATTR8="ATTR8";const SEMANTIC_ATTR9="ATTR9";const SEMANTIC_ATTR10="ATTR10";const SEMANTIC_ATTR11="ATTR11";const SEMANTIC_ATTR12="ATTR12";const SEMANTIC_ATTR13="ATTR13";const SEMANTIC_ATTR14="ATTR14";const SEMANTIC_ATTR15="ATTR15";const SHADERTAG_MATERIAL=1;const STENCILOP_KEEP=0;const STENCILOP_ZERO=1;const STENCILOP_REPLACE=2;const STENCILOP_INCREMENT=3;const STENCILOP_INCREMENTWRAP=4;const STENCILOP_DECREMENT=5;const STENCILOP_DECREMENTWRAP=6;const STENCILOP_INVERT=7;const TEXTURELOCK_NONE=0;const TEXTURELOCK_READ=1;const TEXTURELOCK_WRITE=2;const TEXTURETYPE_DEFAULT="default";const TEXTURETYPE_RGBM="rgbm";const TEXTURETYPE_RGBE="rgbe";const TEXTURETYPE_RGBP="rgbp";const TEXTURETYPE_SWIZZLEGGGR="swizzleGGGR";const TEXHINT_NONE=0;const TEXHINT_SHADOWMAP=1;const TEXHINT_ASSET=2;const TEXHINT_LIGHTMAP=3;const TEXTUREDIMENSION_1D="1d";const TEXTUREDIMENSION_2D="2d";const TEXTUREDIMENSION_2D_ARRAY="2d-array";const TEXTUREDIMENSION_CUBE="cube";const TEXTUREDIMENSION_CUBE_ARRAY="cube-array";const TEXTUREDIMENSION_3D="3d";const SAMPLETYPE_FLOAT=0;const SAMPLETYPE_UNFILTERABLE_FLOAT=1;const SAMPLETYPE_DEPTH=2;const SAMPLETYPE_INT=3;const SAMPLETYPE_UINT=4;const TEXTUREPROJECTION_NONE="none";const TEXTUREPROJECTION_CUBE="cube";const TEXTUREPROJECTION_EQUIRECT="equirect";const TEXTUREPROJECTION_OCTAHEDRAL="octahedral";const SHADERLANGUAGE_GLSL="glsl";const SHADERLANGUAGE_WGSL="wgsl";const TYPE_INT8=0;const TYPE_UINT8=1;const TYPE_INT16=2;const TYPE_UINT16=3;const TYPE_INT32=4;const TYPE_UINT32=5;const TYPE_FLOAT32=6;const TYPE_FLOAT16=7;const UNIFORMTYPE_BOOL=0;const UNIFORMTYPE_INT=1;const UNIFORMTYPE_FLOAT=2;const UNIFORMTYPE_VEC2=3;const UNIFORMTYPE_VEC3=4;const UNIFORMTYPE_VEC4=5;const UNIFORMTYPE_IVEC2=6;const UNIFORMTYPE_IVEC3=7;const UNIFORMTYPE_IVEC4=8;const UNIFORMTYPE_BVEC2=9;const UNIFORMTYPE_BVEC3=10;const UNIFORMTYPE_BVEC4=11;const UNIFORMTYPE_MAT2=12;const UNIFORMTYPE_MAT3=13;const UNIFORMTYPE_MAT4=14;const UNIFORMTYPE_TEXTURE2D=15;const UNIFORMTYPE_TEXTURECUBE=16;const UNIFORMTYPE_FLOATARRAY=17;const UNIFORMTYPE_TEXTURE2D_SHADOW=18;const UNIFORMTYPE_TEXTURECUBE_SHADOW=19;const UNIFORMTYPE_TEXTURE3D=20;const UNIFORMTYPE_VEC2ARRAY=21;const UNIFORMTYPE_VEC3ARRAY=22;const UNIFORMTYPE_VEC4ARRAY=23;const UNIFORMTYPE_MAT4ARRAY=24;const UNIFORMTYPE_TEXTURE2D_ARRAY=25;const UNIFORMTYPE_UINT=26;const UNIFORMTYPE_UVEC2=27;const UNIFORMTYPE_UVEC3=28;const UNIFORMTYPE_UVEC4=29;const UNIFORMTYPE_INTARRAY=30;const UNIFORMTYPE_UINTARRAY=31;const UNIFORMTYPE_BOOLARRAY=32;const UNIFORMTYPE_IVEC2ARRAY=33;const UNIFORMTYPE_UVEC2ARRAY=34;const UNIFORMTYPE_BVEC2ARRAY=35;const UNIFORMTYPE_IVEC3ARRAY=36;const UNIFORMTYPE_UVEC3ARRAY=37;const UNIFORMTYPE_BVEC3ARRAY=38;const UNIFORMTYPE_IVEC4ARRAY=39;const UNIFORMTYPE_UVEC4ARRAY=40;const UNIFORMTYPE_BVEC4ARRAY=41;const UNIFORMTYPE_ITEXTURE2D=42;const UNIFORMTYPE_UTEXTURE2D=43;const UNIFORMTYPE_ITEXTURECUBE=44;const UNIFORMTYPE_UTEXTURECUBE=45;const UNIFORMTYPE_ITEXTURE3D=46;const UNIFORMTYPE_UTEXTURE3D=47;const UNIFORMTYPE_ITEXTURE2D_ARRAY=48;const UNIFORMTYPE_UTEXTURE2D_ARRAY=49;const uniformTypeToName=["bool","int","float","vec2","vec3","vec4","ivec2","ivec3","ivec4","bvec2","bvec3","bvec4","mat2","mat3","mat4","sampler2D","samplerCube","","sampler2DShadow","samplerCubeShadow","sampler3D","","","","","sampler2DArray","uint","uvec2","uvec3","uvec4","","","","","","","","","","","","","isampler2D","usampler2D","isamplerCube","usamplerCube","isampler3D","usampler3D","isampler2DArray","usampler2DArray"];const uniformTypeToStorage=new Uint8Array([TYPE_INT32,TYPE_INT32,TYPE_FLOAT32,TYPE_FLOAT32,TYPE_FLOAT32,TYPE_FLOAT32,TYPE_INT32,TYPE_INT32,TYPE_INT32,TYPE_INT32,TYPE_INT32,TYPE_INT32,TYPE_FLOAT32,TYPE_FLOAT32,TYPE_FLOAT32,TYPE_INT32,TYPE_INT32,TYPE_FLOAT32,TYPE_INT32,TYPE_INT32,TYPE_INT32,TYPE_FLOAT32,TYPE_FLOAT32,TYPE_FLOAT32,TYPE_FLOAT32,TYPE_INT32,TYPE_UINT32,TYPE_UINT32,TYPE_UINT32,TYPE_UINT32,TYPE_INT32,TYPE_UINT32,TYPE_INT32,TYPE_INT32,TYPE_UINT32,TYPE_INT32,TYPE_INT32,TYPE_UINT32,TYPE_INT32,TYPE_INT32,TYPE_UINT32,TYPE_INT32,TYPE_INT32,TYPE_UINT32,TYPE_INT32,TYPE_UINT32,TYPE_INT32,TYPE_UINT32,TYPE_INT32,TYPE_UINT32]);const DEVICETYPE_WEBGL1="webgl1";const DEVICETYPE_WEBGL2="webgl2";const DEVICETYPE_WEBGPU="webgpu";const DEVICETYPE_NULL="null";const SHADERSTAGE_VERTEX=1;const SHADERSTAGE_FRAGMENT=2;const SHADERSTAGE_COMPUTE=4;const BINDGROUP_MESH=0;const BINDGROUP_VIEW=1;const bindGroupNames=["mesh","view"];const UNIFORM_BUFFER_DEFAULT_SLOT_NAME="default";const typedArrayTypes=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Uint16Array];const typedArrayTypesByteSize=[1,1,2,2,4,4,4,2];const vertexTypesNames=["INT8","UINT8","INT16","UINT16","INT32","UINT32","FLOAT32","FLOAT16"];const typedArrayToType={"Int8Array":TYPE_INT8,"Uint8Array":TYPE_UINT8,"Int16Array":TYPE_INT16,"Uint16Array":TYPE_UINT16,"Int32Array":TYPE_INT32,"Uint32Array":TYPE_UINT32,"Float32Array":TYPE_FLOAT32};const typedArrayIndexFormats=[Uint8Array,Uint16Array,Uint32Array];const typedArrayIndexFormatsByteSize=[1,2,4];const semanticToLocation={};semanticToLocation[SEMANTIC_POSITION]=0;semanticToLocation[SEMANTIC_NORMAL]=1;semanticToLocation[SEMANTIC_BLENDWEIGHT]=2;semanticToLocation[SEMANTIC_BLENDINDICES]=3;semanticToLocation[SEMANTIC_COLOR]=4;semanticToLocation[SEMANTIC_TEXCOORD0]=5;semanticToLocation[SEMANTIC_TEXCOORD1]=6;semanticToLocation[SEMANTIC_TEXCOORD2]=7;semanticToLocation[SEMANTIC_TEXCOORD3]=8;semanticToLocation[SEMANTIC_TEXCOORD4]=9;semanticToLocation[SEMANTIC_TEXCOORD5]=10;semanticToLocation[SEMANTIC_TEXCOORD6]=11;semanticToLocation[SEMANTIC_TEXCOORD7]=12;semanticToLocation[SEMANTIC_TANGENT]=13;semanticToLocation[SEMANTIC_ATTR0]=0;semanticToLocation[SEMANTIC_ATTR1]=1;semanticToLocation[SEMANTIC_ATTR2]=2;semanticToLocation[SEMANTIC_ATTR3]=3;semanticToLocation[SEMANTIC_ATTR4]=4;semanticToLocation[SEMANTIC_ATTR5]=5;semanticToLocation[SEMANTIC_ATTR6]=6;semanticToLocation[SEMANTIC_ATTR7]=7;semanticToLocation[SEMANTIC_ATTR8]=8;semanticToLocation[SEMANTIC_ATTR9]=9;semanticToLocation[SEMANTIC_ATTR10]=10;semanticToLocation[SEMANTIC_ATTR11]=11;semanticToLocation[SEMANTIC_ATTR12]=12;semanticToLocation[SEMANTIC_ATTR13]=13;semanticToLocation[SEMANTIC_ATTR14]=14;semanticToLocation[SEMANTIC_ATTR15]=15;const CHUNKAPI_1_51="1.51";const CHUNKAPI_1_55="1.55";const CHUNKAPI_1_56="1.56";const CHUNKAPI_1_57="1.57";const CHUNKAPI_1_58="1.58";const CHUNKAPI_1_60="1.60";const CHUNKAPI_1_62="1.62";const CHUNKAPI_1_65="1.65";const CHUNKAPI_1_70="1.70";function _extends(){return _extends=Object.assign?Object.assign.bind():function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var r in t)({}).hasOwnProperty.call(t,r)&&(n[r]=t[r]);}return n},_extends.apply(null,arguments)}const BitPacking={set(storage,value,shift,mask=1){const data=storage&~(mask<<shift);return data|value<<shift},get(storage,shift,mask=1){return storage>>shift&mask},all(storage,shift,mask=1){const shifted=mask<<shift;return (storage&shifted)===shifted},any(storage,shift,mask=1){return (storage&mask<<shift)!==0}};var _BlendState;const opMask=7;const factorMask=15;const colorOpShift=0;const colorSrcFactorShift=3;const colorDstFactorShift=7;const alphaOpShift=11;const alphaSrcFactorShift=14;const alphaDstFactorShift=18;const redWriteShift=22;const greenWriteShift=23;const blueWriteShift=24;const alphaWriteShift=25;const blendShift=26;const allWriteMasks=15;const allWriteShift=redWriteShift;class BlendState{set blend(value){this.target0=BitPacking.set(this.target0,value?1:0,blendShift);}get blend(){return BitPacking.all(this.target0,blendShift)}setColorBlend(op,srcFactor,dstFactor){this.target0=BitPacking.set(this.target0,op,colorOpShift,opMask);this.target0=BitPacking.set(this.target0,srcFactor,colorSrcFactorShift,factorMask);this.target0=BitPacking.set(this.target0,dstFactor,colorDstFactorShift,factorMask);}setAlphaBlend(op,srcFactor,dstFactor){this.target0=BitPacking.set(this.target0,op,alphaOpShift,opMask);this.target0=BitPacking.set(this.target0,srcFactor,alphaSrcFactorShift,factorMask);this.target0=BitPacking.set(this.target0,dstFactor,alphaDstFactorShift,factorMask);}setColorWrite(redWrite,greenWrite,blueWrite,alphaWrite){this.redWrite=redWrite;this.greenWrite=greenWrite;this.blueWrite=blueWrite;this.alphaWrite=alphaWrite;}get colorOp(){return BitPacking.get(this.target0,colorOpShift,opMask)}get colorSrcFactor(){return BitPacking.get(this.target0,colorSrcFactorShift,factorMask)}get colorDstFactor(){return BitPacking.get(this.target0,colorDstFactorShift,factorMask)}get alphaOp(){return BitPacking.get(this.target0,alphaOpShift,opMask)}get alphaSrcFactor(){return BitPacking.get(this.target0,alphaSrcFactorShift,factorMask)}get alphaDstFactor(){return BitPacking.get(this.target0,alphaDstFactorShift,factorMask)}set redWrite(value){this.target0=BitPacking.set(this.target0,value?1:0,redWriteShift);}get redWrite(){return BitPacking.all(this.target0,redWriteShift)}set greenWrite(value){this.target0=BitPacking.set(this.target0,value?1:0,greenWriteShift);}get greenWrite(){return BitPacking.all(this.target0,greenWriteShift)}set blueWrite(value){this.target0=BitPacking.set(this.target0,value?1:0,blueWriteShift);}get blueWrite(){return BitPacking.all(this.target0,blueWriteShift)}set alphaWrite(value){this.target0=BitPacking.set(this.target0,value?1:0,alphaWriteShift);}get alphaWrite(){return BitPacking.all(this.target0,alphaWriteShift)}get allWrite(){return BitPacking.get(this.target0,allWriteShift,allWriteMasks)}copy(rhs){this.target0=rhs.target0;return this}clone(){const clone=new this.constructor;return clone.copy(this)}get key(){return this.target0}equals(rhs){return this.target0===rhs.target0}constructor(blend=false,colorOp=BLENDEQUATION_ADD,colorSrcFactor=BLENDMODE_ONE,colorDstFactor=BLENDMODE_ZERO,alphaOp,alphaSrcFactor,alphaDstFactor,redWrite=true,greenWrite=true,blueWrite=true,alphaWrite=true){this.target0=0;this.setColorBlend(colorOp,colorSrcFactor,colorDstFactor);this.setAlphaBlend(alphaOp!=null?alphaOp:colorOp,alphaSrcFactor!=null?alphaSrcFactor:colorSrcFactor,alphaDstFactor!=null?alphaDstFactor:colorDstFactor);this.setColorWrite(redWrite,greenWrite,blueWrite,alphaWrite);this.blend=blend;}}_BlendState=BlendState;BlendState.NOBLEND=Object.freeze(new _BlendState);BlendState.NOWRITE=Object.freeze(new _BlendState(undefined,undefined,undefined,undefined,undefined,undefined,undefined,false,false,false,false));BlendState.ALPHABLEND=Object.freeze(new _BlendState(true,BLENDEQUATION_ADD,BLENDMODE_SRC_ALPHA,BLENDMODE_ONE_MINUS_SRC_ALPHA));BlendState.ADDBLEND=Object.freeze(new _BlendState(true,BLENDEQUATION_ADD,BLENDMODE_ONE,BLENDMODE_ONE));class StringIds{get(name){let value=this.map.get(name);if(value===undefined){value=this.id++;this.map.set(name,value);}return value}constructor(){this.map=new Map;this.id=0;}}var _DepthState;const stringIds$4=new StringIds;const funcMask=7;const funcShift=0;const writeShift=3;class DepthState{set test(value){this.func=value?FUNC_LESSEQUAL:FUNC_ALWAYS;this.updateKey();}get test(){return this.func!==FUNC_ALWAYS}set write(value){this.data=BitPacking.set(this.data,value?1:0,writeShift);this.updateKey();}get write(){return BitPacking.all(this.data,writeShift)}set func(value){this.data=BitPacking.set(this.data,value,funcShift,funcMask);this.updateKey();}get func(){return BitPacking.get(this.data,funcShift,funcMask)}set depthBias(value){this._depthBias=value;this.updateKey();}get depthBias(){return this._depthBias}set depthBiasSlope(value){this._depthBiasSlope=value;this.updateKey();}get depthBiasSlope(){return this._depthBiasSlope}copy(rhs){this.data=rhs.data;this._depthBias=rhs._depthBias;this._depthBiasSlope=rhs._depthBiasSlope;this.key=rhs.key;return this}clone(){const clone=new this.constructor;return clone.copy(this)}updateKey(){const{data,_depthBias,_depthBiasSlope}=this;const key=`${data}-${_depthBias}-${_depthBiasSlope}`;this.key=stringIds$4.get(key);}equals(rhs){return this.key===rhs.key}constructor(func=FUNC_LESSEQUAL,write=true){this.data=0;this._depthBias=0;this._depthBiasSlope=0;this.key=0;this.func=func;this.write=write;}}_DepthState=DepthState;DepthState.DEFAULT=Object.freeze(new _DepthState);DepthState.NODEPTH=Object.freeze(new _DepthState(FUNC_ALWAYS,false));DepthState.WRITEDEPTH=Object.freeze(new _DepthState(FUNC_ALWAYS,true));class Version{equals(other){return this.globalId===other.globalId&&this.revision===other.revision}copy(other){this.globalId=other.globalId;this.revision=other.revision;}reset(){this.globalId=0;this.revision=0;}constructor(){this.globalId=0;this.revision=0;}}let idCounter=0;class VersionedObject{increment(){this.version.revision++;}constructor(){idCounter++;this.version=new Version;this.version.globalId=idCounter;}}class ScopeId{toJSON(key){return undefined}setValue(value){this.value=value;this.versionObject.increment();}getValue(){return this.value}constructor(name){this.name=name;this.value=null;this.versionObject=new VersionedObject;}}class ScopeSpace{resolve(name){if(!this.variables.has(name)){this.variables.set(name,new ScopeId(name));}return this.variables.get(name)}removeValue(value){for(const uniformName in this.variables){const uniform=this.variables[uniformName];if(uniform.value===value){uniform.value=null;}}}constructor(name){this.name=name;this.variables=new Map;}}let id$b=0;class VertexBuffer{destroy(){const device=this.device;const idx=device.buffers.indexOf(this);if(idx!==-1){device.buffers.splice(idx,1);}if(this.impl.initialized){this.impl.destroy(device);this.adjustVramSizeTracking(device._vram,-this.storage.byteLength);}}adjustVramSizeTracking(vram,size){vram.vb+=size;}loseContext(){this.impl.loseContext();}getFormat(){return this.format}getUsage(){return this.usage}getNumVertices(){return this.numVertices}lock(){return this.storage}unlock(){this.impl.unlock(this);}setData(data){if(data.byteLength!==this.numBytes){return false}this.storage=data;this.unlock();return true}constructor(graphicsDevice,format,numVertices,options){this.usage=BUFFER_STATIC;let initialData;if(typeof options==="object"){var _options$usage;this.usage=(_options$usage=options.usage)!=null?_options$usage:BUFFER_STATIC;initialData=options.data;}else if(arguments.length>3){var _arguments$;this.usage=(_arguments$=arguments[3])!=null?_arguments$:BUFFER_STATIC;initialData=arguments[4];}this.device=graphicsDevice;this.format=format;this.numVertices=numVertices;this.id=id$b++;this.impl=graphicsDevice.createVertexBufferImpl(this,format,options);this.numBytes=format.verticesByteSize?format.verticesByteSize:format.size*numVertices;this.adjustVramSizeTracking(graphicsDevice._vram,this.numBytes);if(initialData){this.setData(initialData);}else {this.storage=new ArrayBuffer(this.numBytes);}this.device.buffers.push(this);}}function hashCode(str){let hash=0;for(let i=0,len=str.length;i<len;i++){hash=(hash<<5)-hash+str.charCodeAt(i);hash|=0;}return hash}function hash32Fnv1a(array){const prime=16777619;let hash=2166136261;for(let i=0;i<array.length;i++){hash^=array[i];hash*=prime;}return hash>>>0}class DeviceCache{get(device,onCreate){if(!this._cache.has(device)){this._cache.set(device,onCreate());device.on("destroy",()=>{this.remove(device);});device.on("devicelost",()=>{var _this$_cache$get;(_this$_cache$get=this._cache.get(device))==null||_this$_cache$get.loseContext==null||_this$_cache$get.loseContext(device);});}return this._cache.get(device)}remove(device){var _this$_cache$get2;(_this$_cache$get2=this._cache.get(device))==null||_this$_cache$get2.destroy==null||_this$_cache$get2.destroy(device);this._cache.delete(device);}constructor(){this._cache=new Map;}}const stringIds$3=new StringIds;const webgpuValidElementSizes=[2,4,8,12,16];const deviceCache$2=new DeviceCache;class VertexFormat{get elements(){return this._elements}static getDefaultInstancingFormat(graphicsDevice){return deviceCache$2.get(graphicsDevice,()=>{return new VertexFormat(graphicsDevice,[{semantic:SEMANTIC_ATTR12,components:4,type:TYPE_FLOAT32},{semantic:SEMANTIC_ATTR13,components:4,type:TYPE_FLOAT32},{semantic:SEMANTIC_ATTR14,components:4,type:TYPE_FLOAT32},{semantic:SEMANTIC_ATTR15,components:4,type:TYPE_FLOAT32}])})}static isElementValid(graphicsDevice,elementDesc){const elementSize=elementDesc.components*typedArrayTypesByteSize[elementDesc.type];if(graphicsDevice.isWebGPU&&!webgpuValidElementSizes.includes(elementSize)){return false}return true}update(){this._evaluateHash();}_evaluateHash(){const stringElementsBatch=[];const stringElementsRender=[];const len=this._elements.length;for(let i=0;i<len;i++){const{name,dataType,numComponents,normalize,offset,stride,size,asInt}=this._elements[i];const stringElementBatch=name+dataType+numComponents+normalize+asInt;stringElementsBatch.push(stringElementBatch);const stringElementRender=stringElementBatch+offset+stride+size;stringElementsRender.push(stringElementRender);}stringElementsBatch.sort();const batchingString=stringElementsBatch.join();this.batchingHash=hashCode(batchingString);this.shaderProcessingHashString=batchingString;this.renderingHashString=stringElementsRender.join("_");this.renderingHash=stringIds$3.get(this.renderingHashString);}constructor(graphicsDevice,description,vertexCount){this.device=graphicsDevice;this._elements=[];this.hasUv0=false;this.hasUv1=false;this.hasColor=false;this.hasTangents=false;this.verticesByteSize=0;this.vertexCount=vertexCount;this.interleaved=vertexCount===undefined;this.instancing=false;this.size=description.reduce((total,desc)=>{return total+Math.ceil(desc.components*typedArrayTypesByteSize[desc.type]/4)*4},0);let offset=0,elementSize;for(let i=0,len=description.length;i<len;i++){var _elementDesc$asInt,_elementDesc$normaliz;const elementDesc=description[i];elementSize=elementDesc.components*typedArrayTypesByteSize[elementDesc.type];if(vertexCount){offset=math.roundUp(offset,elementSize);}const asInt=(_elementDesc$asInt=elementDesc.asInt)!=null?_elementDesc$asInt:false;const normalize=asInt?false:(_elementDesc$normaliz=elementDesc.normalize)!=null?_elementDesc$normaliz:false;const element={name:elementDesc.semantic,offset:vertexCount?offset:elementDesc.hasOwnProperty("offset")?elementDesc.offset:offset,stride:vertexCount?elementSize:elementDesc.hasOwnProperty("stride")?elementDesc.stride:this.size,dataType:elementDesc.type,numComponents:elementDesc.components,normalize:normalize,size:elementSize,asInt:asInt};this._elements.push(element);if(vertexCount){offset+=elementSize*vertexCount;}else {offset+=Math.ceil(elementSize/4)*4;}if(elementDesc.semantic===SEMANTIC_TEXCOORD0){this.hasUv0=true;}else if(elementDesc.semantic===SEMANTIC_TEXCOORD1){this.hasUv1=true;}else if(elementDesc.semantic===SEMANTIC_COLOR){this.hasColor=true;}else if(elementDesc.semantic===SEMANTIC_TANGENT){this.hasTangents=true;}}if(vertexCount){this.verticesByteSize=offset;}this._evaluateHash();}}var _StencilParameters;const stringIds$2=new StringIds;class StencilParameters{set func(value){this._func=value;this._dirty=true;}get func(){return this._func}set ref(value){this._ref=value;this._dirty=true;}get ref(){return this._ref}set fail(value){this._fail=value;this._dirty=true;}get fail(){return this._fail}set zfail(value){this._zfail=value;this._dirty=true;}get zfail(){return this._zfail}set zpass(value){this._zpass=value;this._dirty=true;}get zpass(){return this._zpass}set readMask(value){this._readMask=value;this._dirty=true;}get readMask(){return this._readMask}set writeMask(value){this._writeMask=value;this._dirty=true;}get writeMask(){return this._writeMask}_evalKey(){const{_func,_ref,_fail,_zfail,_zpass,_readMask,_writeMask}=this;const key=`${_func},${_ref},${_fail},${_zfail},${_zpass},${_readMask},${_writeMask}`;this._key=stringIds$2.get(key);this._dirty=false;}get key(){if(this._dirty){this._evalKey();}return this._key}copy(rhs){this._func=rhs._func;this._ref=rhs._ref;this._readMask=rhs._readMask;this._writeMask=rhs._writeMask;this._fail=rhs._fail;this._zfail=rhs._zfail;this._zpass=rhs._zpass;this._dirty=rhs._dirty;this._key=rhs._key;return this}clone(){const clone=new this.constructor;return clone.copy(this)}constructor(options={}){var _options$func,_options$ref,_options$readMask,_options$writeMask,_options$fail,_options$zfail,_options$zpass;this._func=void 0;this._ref=void 0;this._fail=void 0;this._zfail=void 0;this._zpass=void 0;this._readMask=void 0;this._writeMask=void 0;this._dirty=true;this._key=void 0;this._func=(_options$func=options.func)!=null?_options$func:FUNC_ALWAYS;this._ref=(_options$ref=options.ref)!=null?_options$ref:0;this._readMask=(_options$readMask=options.readMask)!=null?_options$readMask:255;this._writeMask=(_options$writeMask=options.writeMask)!=null?_options$writeMask:255;this._fail=(_options$fail=options.fail)!=null?_options$fail:STENCILOP_KEEP;this._zfail=(_options$zfail=options.zfail)!=null?_options$zfail:STENCILOP_KEEP;this._zpass=(_options$zpass=options.zpass)!=null?_options$zpass:STENCILOP_KEEP;this._evalKey();}}_StencilParameters=StencilParameters;StencilParameters.DEFAULT=Object.freeze(new _StencilParameters);class GraphicsDevice extends EventHandler{postInit(){const vertexFormat=new VertexFormat(this,[{semantic:SEMANTIC_POSITION,components:2,type:TYPE_FLOAT32}]);const positions=new Float32Array([-1,-1,1,-1,-1,1,1,1]);this.quadVertexBuffer=new VertexBuffer(this,vertexFormat,4,{data:positions});}destroy(){var _this$quadVertexBuffe,_this$dynamicBuffers,_this$gpuProfiler;this.fire("destroy");(_this$quadVertexBuffe=this.quadVertexBuffer)==null||_this$quadVertexBuffe.destroy();this.quadVertexBuffer=null;(_this$dynamicBuffers=this.dynamicBuffers)==null||_this$dynamicBuffers.destroy();this.dynamicBuffers=null;(_this$gpuProfiler=this.gpuProfiler)==null||_this$gpuProfiler.destroy();this.gpuProfiler=null;}onDestroyShader(shader){this.fire("destroy:shader",shader);const idx=this.shaders.indexOf(shader);if(idx!==-1){this.shaders.splice(idx,1);}}postDestroy(){this.scope=null;this.canvas=null;}loseContext(){var _this$gpuProfiler2;this.contextLost=true;this.backBufferSize.set(-1,-1);for(const texture of this.textures){texture.loseContext();}for(const buffer of this.buffers){buffer.loseContext();}for(const target of this.targets){target.loseContext();}(_this$gpuProfiler2=this.gpuProfiler)==null||_this$gpuProfiler2.loseContext();}restoreContext(){var _this$gpuProfiler3;this.contextLost=false;this.initializeRenderState();this.initializeContextCaches();for(const buffer of this.buffers){buffer.unlock();}(_this$gpuProfiler3=this.gpuProfiler)==null||_this$gpuProfiler3.restoreContext==null||_this$gpuProfiler3.restoreContext();}toJSON(key){return undefined}initializeContextCaches(){this.indexBuffer=null;this.vertexBuffers=[];this.shader=null;this.shaderValid=undefined;this.shaderAsyncCompile=false;this.renderTarget=null;}initializeRenderState(){this.blendState=new BlendState;this.depthState=new DepthState;this.cullMode=CULLFACE_BACK;this.vx=this.vy=this.vw=this.vh=0;this.sx=this.sy=this.sw=this.sh=0;this.blendColor=new Color(0,0,0,0);}setStencilState(stencilFront,stencilBack){}setBlendState(blendState){}setBlendColor(r,g,b,a){}setDepthState(depthState){}setCullMode(cullMode){}setRenderTarget(renderTarget){this.renderTarget=renderTarget;}setIndexBuffer(indexBuffer){this.indexBuffer=indexBuffer;}setVertexBuffer(vertexBuffer){if(vertexBuffer){this.vertexBuffers.push(vertexBuffer);}}clearVertexBuffer(){this.vertexBuffers.length=0;}getRenderTarget(){return this.renderTarget}initRenderTarget(target){if(target.initialized)return;target.init();this.targets.add(target);}_isBrowserInterface(texture){return this._isImageBrowserInterface(texture)||this._isImageCanvasInterface(texture)||this._isImageVideoInterface(texture)}_isImageBrowserInterface(texture){return typeof ImageBitmap!=="undefined"&&texture instanceof ImageBitmap||typeof HTMLImageElement!=="undefined"&&texture instanceof HTMLImageElement}_isImageCanvasInterface(texture){return typeof HTMLCanvasElement!=="undefined"&&texture instanceof HTMLCanvasElement}_isImageVideoInterface(texture){return typeof HTMLVideoElement!=="undefined"&&texture instanceof HTMLVideoElement}resizeCanvas(width,height){const pixelRatio=Math.min(this._maxPixelRatio,platform.browser?window.devicePixelRatio:1);const w=Math.floor(width*pixelRatio);const h=Math.floor(height*pixelRatio);if(w!==this.canvas.width||h!==this.canvas.height){this.setResolution(w,h);}}setResolution(width,height){this.canvas.width=width;this.canvas.height=height;this.fire(GraphicsDevice.EVENT_RESIZE,width,height);}updateClientRect(){if(platform.worker){this.clientRect.width=this.canvas.width;this.clientRect.height=this.canvas.height;}else {const rect=this.canvas.getBoundingClientRect();this.clientRect.width=rect.width;this.clientRect.height=rect.height;}}get width(){return this.canvas.width}get height(){return this.canvas.height}set fullscreen(fullscreen){}get fullscreen(){return false}set maxPixelRatio(ratio){this._maxPixelRatio=ratio;}get maxPixelRatio(){return this._maxPixelRatio}get deviceType(){return this._deviceType}getBoneLimit(){return this.boneLimit}setBoneLimit(maxBones){this.boneLimit=maxBones;}startRenderPass(renderPass){}endRenderPass(renderPass){}startComputePass(){}endComputePass(){}frameStart(){this.renderPassIndex=0;this.renderVersion++;}frameEnd(){}computeDispatch(computes){}getRenderableHdrFormat(formats=[PIXELFORMAT_111110F,PIXELFORMAT_RGBA16F,PIXELFORMAT_RGBA32F],filterable=true){for(let i=0;i<formats.length;i++){const format=formats[i];switch(format){case PIXELFORMAT_111110F:{if(this.textureRG11B10Renderable){return format}break}case PIXELFORMAT_RGBA16F:if(this.textureHalfFloatRenderable&&(!filterable||this.textureHalfFloatFilterable)){return format}break;case PIXELFORMAT_RGBA32F:if(this.textureFloatRenderable&&(!filterable||this.textureFloatFilterable)){return format}break}}return undefined}constructor(canvas,options){var _this$initOptions,_this$initOptions$dep,_this$initOptions2,_this$initOptions2$st,_this$initOptions3,_this$initOptions3$an,_this$initOptions4,_this$initOptions4$po;super();this.canvas=void 0;this.backBuffer=null;this.backBufferSize=new Vec2;this.backBufferFormat=void 0;this.backBufferAntialias=false;this.isWebGPU=false;this.isWebGL1=false;this.isWebGL2=false;this.scope=void 0;this.boneLimit=void 0;this.maxAnisotropy=void 0;this.maxCubeMapSize=void 0;this.maxTextureSize=void 0;this.maxVolumeSize=void 0;this.maxColorAttachments=1;this.precision=void 0;this.samples=void 0;this.supportsStencil=void 0;this.supportsMrt=false;this.supportsVolumeTextures=false;this.supportsCompute=false;this.supportsStorageTextureRead=false;this.renderTarget=null;this.shaders=[];this.textures=[];this.targets=new Set;this.renderVersion=0;this.renderPassIndex=void 0;this.insideRenderPass=false;this.supportsInstancing=void 0;this.supportsUniformBuffers=false;this.textureFloatRenderable=void 0;this.textureHalfFloatRenderable=void 0;this.textureFloatFilterable=false;this.textureHalfFloatFilterable=false;this.quadVertexBuffer=void 0;this.blendState=new BlendState;this.depthState=new DepthState;this.stencilEnabled=false;this.stencilFront=new StencilParameters;this.stencilBack=new StencilParameters;this.dynamicBuffers=void 0;this.gpuProfiler=void 0;this.defaultClearOptions={color:[0,0,0,1],depth:1,stencil:0,flags:CLEARFLAG_COLOR|CLEARFLAG_DEPTH};this.clientRect={width:0,height:0};this.canvas=canvas;this.initOptions=_extends({},options);(_this$initOptions$dep=(_this$initOptions=this.initOptions).depth)!=null?_this$initOptions$dep:_this$initOptions.depth=true;(_this$initOptions2$st=(_this$initOptions2=this.initOptions).stencil)!=null?_this$initOptions2$st:_this$initOptions2.stencil=true;(_this$initOptions3$an=(_this$initOptions3=this.initOptions).antialias)!=null?_this$initOptions3$an:_this$initOptions3.antialias=true;(_this$initOptions4$po=(_this$initOptions4=this.initOptions).powerPreference)!=null?_this$initOptions4$po:_this$initOptions4.powerPreference="high-performance";this._maxPixelRatio=platform.browser?Math.min(1,window.devicePixelRatio):1;this.buffers=[];this._vram={tex:0,vb:0,ib:0,ub:0,sb:0};this._shaderStats={vsCompiled:0,fsCompiled:0,linked:0,materialShaders:0,compileTime:0};this.initializeContextCaches();this._drawCallsPerFrame=0;this._shaderSwitchesPerFrame=0;this._primsPerFrame=[];for(let i=PRIMITIVE_POINTS;i<=PRIMITIVE_TRIFAN;i++){this._primsPerFrame[i]=0;}this._renderTargetCreationTime=0;this.scope=new ScopeSpace("Device");this.textureBias=this.scope.resolve("textureBias");this.textureBias.setValue(0);}}GraphicsDevice.EVENT_RESIZE="resizecanvas";let id$a=0;class RenderTarget{destroy(){const device=this._device;if(device){device.targets.delete(this);if(device.renderTarget===this){device.setRenderTarget(null);}this.destroyFrameBuffers();}}destroyFrameBuffers(){const device=this._device;if(device){this.impl.destroy(device);}}destroyTextureBuffers(){var _this$_depthBuffer3,_this$_colorBuffers;(_this$_depthBuffer3=this._depthBuffer)==null||_this$_depthBuffer3.destroy();this._depthBuffer=null;(_this$_colorBuffers=this._colorBuffers)==null||_this$_colorBuffers.forEach(colorBuffer=>{colorBuffer.destroy();});this._colorBuffers=null;this._colorBuffer=null;}resize(width,height){if(this.width!==width||this.height!==height){var _this$_depthBuffer4,_this$_colorBuffers2;const device=this._device;this.destroyFrameBuffers();if(device.renderTarget===this){device.setRenderTarget(null);}(_this$_depthBuffer4=this._depthBuffer)==null||_this$_depthBuffer4.resize(width,height);(_this$_colorBuffers2=this._colorBuffers)==null||_this$_colorBuffers2.forEach(colorBuffer=>{colorBuffer.resize(width,height);});this.validateMrt();this.impl=device.createRenderTargetImpl(this);}}validateMrt(){}init(){this.impl.init(this._device,this);}get initialized(){return this.impl.initialized}get device(){return this._device}loseContext(){this.impl.loseContext();}resolve(color=true,depth=!!this._depthBuffer){if(this._device&&this._samples>1){this.impl.resolve(this._device,this,color,depth);}}copy(source,color,depth){if(!this._device){if(source._device){this._device=source._device;}else {return false}}const success=this._device.copyRenderTarget(source,this,color,depth);return success}get samples(){return this._samples}get depth(){return this._depth}get stencil(){return this._stencil}get colorBuffer(){return this._colorBuffer}getColorBuffer(index){var _this$_colorBuffers3;return (_this$_colorBuffers3=this._colorBuffers)==null?void 0:_this$_colorBuffers3[index]}get depthBuffer(){return this._depthBuffer}get face(){return this._face}get width(){var _this$_colorBuffer3,_this$_depthBuffer5;return ((_this$_colorBuffer3=this._colorBuffer)==null?void 0:_this$_colorBuffer3.width)||((_this$_depthBuffer5=this._depthBuffer)==null?void 0:_this$_depthBuffer5.width)||this._device.width}get height(){var _this$_colorBuffer4,_this$_depthBuffer6;return ((_this$_colorBuffer4=this._colorBuffer)==null?void 0:_this$_colorBuffer4.height)||((_this$_depthBuffer6=this._depthBuffer)==null?void 0:_this$_depthBuffer6.height)||this._device.height}constructor(options={}){var _options$face,_this$_colorBuffer,_this$_depthBuffer,_options$samples,_options$autoResolve,_options$flipY;this.name=void 0;this._device=void 0;this._colorBuffer=void 0;this._colorBuffers=void 0;this._depthBuffer=void 0;this._depth=void 0;this._stencil=void 0;this._samples=void 0;this.autoResolve=void 0;this._face=void 0;this.flipY=void 0;this.id=id$a++;const _arg2=arguments[1];const _arg3=arguments[2];if(options instanceof GraphicsDevice){this._colorBuffer=_arg2;options=_arg3;}else {this._colorBuffer=options.colorBuffer;}if(this._colorBuffer){this._colorBuffers=[this._colorBuffer];}this._depthBuffer=options.depthBuffer;this._face=(_options$face=options.face)!=null?_options$face:0;if(this._depthBuffer){const format=this._depthBuffer._format;if(format===PIXELFORMAT_DEPTH){this._depth=true;this._stencil=false;}else if(format===PIXELFORMAT_DEPTHSTENCIL){this._depth=true;this._stencil=true;}else {this._depth=false;this._stencil=false;}}else {var _options$depth,_options$stencil;this._depth=(_options$depth=options.depth)!=null?_options$depth:true;this._stencil=(_options$stencil=options.stencil)!=null?_options$stencil:false;}if(options.colorBuffers){if(!this._colorBuffers){this._colorBuffers=[...options.colorBuffers];this._colorBuffer=options.colorBuffers[0];}}const device=((_this$_colorBuffer=this._colorBuffer)==null?void 0:_this$_colorBuffer.device)||((_this$_depthBuffer=this._depthBuffer)==null?void 0:_this$_depthBuffer.device)||options.graphicsDevice;this._device=device;const{maxSamples}=this._device;this._samples=Math.min((_options$samples=options.samples)!=null?_options$samples:1,maxSamples);if(device.isWebGPU){this._samples=this._samples>1?maxSamples:1;}this.autoResolve=(_options$autoResolve=options.autoResolve)!=null?_options$autoResolve:true;this.name=options.name;if(!this.name){var _this$_colorBuffer2;this.name=(_this$_colorBuffer2=this._colorBuffer)==null?void 0:_this$_colorBuffer2.name;}if(!this.name){var _this$_depthBuffer2;this.name=(_this$_depthBuffer2=this._depthBuffer)==null?void 0:_this$_depthBuffer2.name;}if(!this.name){this.name="Untitled";}this.flipY=(_options$flipY=options.flipY)!=null?_options$flipY:false;this.validateMrt();this.impl=device.createRenderTargetImpl(this);}}class WebgpuBindGroup{update(bindGroup){this.destroy();const device=bindGroup.device;const descr=this.createDescriptor(device,bindGroup);this.bindGroup=device.wgpu.createBindGroup(descr);}destroy(){this.bindGroup=null;}createDescriptor(device,bindGroup){const entries=[];const format=bindGroup.format;const uniformBufferFormats=bindGroup.format.uniformBufferFormats;bindGroup.uniformBuffers.forEach((ub,i)=>{const slot=uniformBufferFormats[i].slot;const buffer=ub.persistent?ub.impl.buffer:ub.allocation.gpuBuffer.buffer;entries.push({binding:slot,resource:{buffer:buffer,offset:0,size:ub.format.byteSize}});});const textureFormats=bindGroup.format.textureFormats;bindGroup.textures.forEach((tex,textureIndex)=>{const wgpuTexture=tex.impl;const textureFormat=format.textureFormats[textureIndex];const slot=textureFormats[textureIndex].slot;const view=wgpuTexture.getView(device);entries.push({binding:slot,resource:view});if(textureFormat.hasSampler){const sampler=wgpuTexture.getSampler(device,textureFormat.sampleType);entries.push({binding:slot+1,resource:sampler});}});const storageTextureFormats=bindGroup.format.storageTextureFormats;bindGroup.storageTextures.forEach((tex,textureIndex)=>{const wgpuTexture=tex.impl;const slot=storageTextureFormats[textureIndex].slot;const view=wgpuTexture.getView(device);entries.push({binding:slot,resource:view});});const storageBufferFormats=bindGroup.format.storageBufferFormats;bindGroup.storageBuffers.forEach((buffer,bufferIndex)=>{const wgpuBuffer=buffer.impl.buffer;const slot=storageBufferFormats[bufferIndex].slot;entries.push({binding:slot,resource:{buffer:wgpuBuffer}});});const descr={layout:bindGroup.format.impl.bindGroupLayout,entries:entries};return descr}constructor(){this.bindGroup=void 0;}}class WebgpuUtils{static shaderStage(stage){let ret=0;if(stage&SHADERSTAGE_VERTEX)ret|=GPUShaderStage.VERTEX;if(stage&SHADERSTAGE_FRAGMENT)ret|=GPUShaderStage.FRAGMENT;if(stage&SHADERSTAGE_COMPUTE)ret|=GPUShaderStage.COMPUTE;return ret}}const gpuTextureFormats=[];gpuTextureFormats[PIXELFORMAT_A8]="";gpuTextureFormats[PIXELFORMAT_L8]="r8unorm";gpuTextureFormats[PIXELFORMAT_LA8]="rg8unorm";gpuTextureFormats[PIXELFORMAT_RGB565]="";gpuTextureFormats[PIXELFORMAT_RGBA5551]="";gpuTextureFormats[PIXELFORMAT_RGBA4]="";gpuTextureFormats[PIXELFORMAT_RGB8]="rgba8unorm";gpuTextureFormats[PIXELFORMAT_RGBA8]="rgba8unorm";gpuTextureFormats[PIXELFORMAT_DXT1]="bc1-rgba-unorm";gpuTextureFormats[PIXELFORMAT_DXT3]="bc2-rgba-unorm";gpuTextureFormats[PIXELFORMAT_DXT5]="bc3-rgba-unorm";gpuTextureFormats[PIXELFORMAT_RGB16F]="";gpuTextureFormats[PIXELFORMAT_RGBA16F]="rgba16float";gpuTextureFormats[PIXELFORMAT_R16F]="r16float";gpuTextureFormats[PIXELFORMAT_RG16F]="rg16float";gpuTextureFormats[PIXELFORMAT_RGB32F]="";gpuTextureFormats[PIXELFORMAT_RGBA32F]="rgba32float";gpuTextureFormats[PIXELFORMAT_R32F]="r32float";gpuTextureFormats[PIXELFORMAT_DEPTH]="depth32float";gpuTextureFormats[PIXELFORMAT_DEPTHSTENCIL]="depth24plus-stencil8";gpuTextureFormats[PIXELFORMAT_111110F]="rg11b10ufloat";gpuTextureFormats[PIXELFORMAT_SRGB]="";gpuTextureFormats[PIXELFORMAT_SRGBA]="";gpuTextureFormats[PIXELFORMAT_ETC1]="";gpuTextureFormats[PIXELFORMAT_ETC2_RGB]="etc2-rgb8unorm";gpuTextureFormats[PIXELFORMAT_ETC2_RGBA]="etc2-rgba8unorm";gpuTextureFormats[PIXELFORMAT_PVRTC_2BPP_RGB_1]="";gpuTextureFormats[PIXELFORMAT_PVRTC_2BPP_RGBA_1]="";gpuTextureFormats[PIXELFORMAT_PVRTC_4BPP_RGB_1]="";gpuTextureFormats[PIXELFORMAT_PVRTC_4BPP_RGBA_1]="";gpuTextureFormats[PIXELFORMAT_ASTC_4x4]="astc-4x4-unorm";gpuTextureFormats[PIXELFORMAT_ATC_RGB]="";gpuTextureFormats[PIXELFORMAT_ATC_RGBA]="";gpuTextureFormats[PIXELFORMAT_BGRA8]="bgra8unorm";gpuTextureFormats[PIXELFORMAT_R8I]="r8sint";gpuTextureFormats[PIXELFORMAT_R8U]="r8uint";gpuTextureFormats[PIXELFORMAT_R16I]="r16sint";gpuTextureFormats[PIXELFORMAT_R16U]="r16uint";gpuTextureFormats[PIXELFORMAT_R32I]="r32sint";gpuTextureFormats[PIXELFORMAT_R32U]="r32uint";gpuTextureFormats[PIXELFORMAT_RG8I]="rg8sint";gpuTextureFormats[PIXELFORMAT_RG8U]="rg8uint";gpuTextureFormats[PIXELFORMAT_RG16I]="rg16sint";gpuTextureFormats[PIXELFORMAT_RG16U]="rg16uint";gpuTextureFormats[PIXELFORMAT_RG32I]="rg32sint";gpuTextureFormats[PIXELFORMAT_RG32U]="rg32uint";gpuTextureFormats[PIXELFORMAT_RGBA8I]="rgba8sint";gpuTextureFormats[PIXELFORMAT_RGBA8U]="rgba8uint";gpuTextureFormats[PIXELFORMAT_RGBA16I]="rgba16sint";gpuTextureFormats[PIXELFORMAT_RGBA16U]="rgba16uint";gpuTextureFormats[PIXELFORMAT_RGBA32I]="rgba32sint";gpuTextureFormats[PIXELFORMAT_RGBA32U]="rgba32uint";const samplerTypes=[];samplerTypes[SAMPLETYPE_FLOAT]="filtering";samplerTypes[SAMPLETYPE_UNFILTERABLE_FLOAT]="non-filtering";samplerTypes[SAMPLETYPE_DEPTH]="comparison";samplerTypes[SAMPLETYPE_INT]="comparison";samplerTypes[SAMPLETYPE_UINT]="comparison";const sampleTypes=[];sampleTypes[SAMPLETYPE_FLOAT]="float";sampleTypes[SAMPLETYPE_UNFILTERABLE_FLOAT]="unfilterable-float";sampleTypes[SAMPLETYPE_DEPTH]="depth";sampleTypes[SAMPLETYPE_INT]="sint";sampleTypes[SAMPLETYPE_UINT]="uint";const stringIds$1=new StringIds;class WebgpuBindGroupFormat{destroy(){this.bindGroupLayout=null;}loseContext(){}createDescriptor(bindGroupFormat){const entries=[];let key="";bindGroupFormat.uniformBufferFormats.forEach(bufferFormat=>{const visibility=WebgpuUtils.shaderStage(bufferFormat.visibility);key+=`#${bufferFormat.slot}U:${visibility}`;entries.push({binding:bufferFormat.slot,visibility:visibility,buffer:{type:"uniform",hasDynamicOffset:true}});});bindGroupFormat.textureFormats.forEach(textureFormat=>{const visibility=WebgpuUtils.shaderStage(textureFormat.visibility);const sampleType=textureFormat.sampleType;const viewDimension=textureFormat.textureDimension;const multisampled=false;const gpuSampleType=sampleTypes[sampleType];key+=`#${textureFormat.slot}T:${visibility}-${gpuSampleType}-${viewDimension}-${multisampled}`;entries.push({binding:textureFormat.slot,visibility:visibility,texture:{sampleType:gpuSampleType,viewDimension:viewDimension,multisampled:multisampled}});if(textureFormat.hasSampler){const gpuSamplerType=samplerTypes[sampleType];key+=`#${textureFormat.slot+1}S:${visibility}-${gpuSamplerType}`;entries.push({binding:textureFormat.slot+1,visibility:visibility,sampler:{type:gpuSamplerType}});}});bindGroupFormat.storageTextureFormats.forEach(textureFormat=>{const{format,textureDimension}=textureFormat;const{read,write}=textureFormat;key+=`#${textureFormat.slot}ST:${format}-${textureDimension}-${read?"r1":"r0"}-${write?"w1":"w0"}`;entries.push({binding:textureFormat.slot,visibility:GPUShaderStage.COMPUTE,storageTexture:{access:read?write?"read-write":"read-only":"write-only",format:gpuTextureFormats[format],viewDimension:textureDimension}});});bindGroupFormat.storageBufferFormats.forEach(bufferFormat=>{const readOnly=bufferFormat.readOnly;const visibility=WebgpuUtils.shaderStage(bufferFormat.visibility);key+=`#${bufferFormat.slot}SB:${visibility}-${readOnly?"ro":"rw"}`;entries.push({binding:bufferFormat.slot,visibility:visibility,buffer:{type:readOnly?"read-only-storage":"storage"}});});const descr={entries:entries};return {key,descr}}constructor(bindGroupFormat){const device=bindGroupFormat.device;const{key,descr}=this.createDescriptor(bindGroupFormat);this.key=stringIds$1.get(key);this.bindGroupLayout=device.wgpu.createBindGroupLayout(descr);}}class WebgpuBuffer{destroy(device){if(this.buffer){this.buffer.destroy();this.buffer=null;}}get initialized(){return !!this.buffer}loseContext(){}allocate(device,size){this.buffer=device.wgpu.createBuffer({size,usage:this.usageFlags});}unlock(device,storage){var _storage$byteOffset,_storage$buffer;const wgpu=device.wgpu;if(!this.buffer){const size=storage.byteLength+3&~3;this.usageFlags|=GPUBufferUsage.COPY_DST;this.allocate(device,size);}const srcOffset=(_storage$byteOffset=storage.byteOffset)!=null?_storage$byteOffset:0;const srcData=new Uint8Array((_storage$buffer=storage.buffer)!=null?_storage$buffer:storage,srcOffset,storage.byteLength);const data=new Uint8Array(this.buffer.size);data.set(srcData);wgpu.queue.writeBuffer(this.buffer,0,data,0,data.length);}read(device,offset,size,data){return device.readStorageBuffer(this,offset,size,data)}write(device,bufferOffset,data,dataOffset,size){device.writeStorageBuffer(this,bufferOffset,data,dataOffset,size);}clear(device,offset,size){device.clearStorageBuffer(this,offset,size);}constructor(usageFlags=0){this.buffer=null;this.usageFlags=0;this.usageFlags=usageFlags;}}class WebgpuIndexBuffer extends WebgpuBuffer{unlock(indexBuffer){const device=indexBuffer.device;super.unlock(device,indexBuffer.storage);}constructor(indexBuffer,options){super(BUFFERUSAGE_INDEX|(options!=null&&options.storage?BUFFERUSAGE_STORAGE:0));this.format=null;this.format=indexBuffer.format===INDEXFORMAT_UINT16?"uint16":"uint32";}}const array={equals(arr1,arr2){if(arr1.length!==arr2.length){return false}for(let i=0;i<arr1.length;i++){if(arr1[i]!==arr2[i]){return false}}return true}};const gpuVertexFormats=[];gpuVertexFormats[TYPE_INT8]="sint8";gpuVertexFormats[TYPE_UINT8]="uint8";gpuVertexFormats[TYPE_INT16]="sint16";gpuVertexFormats[TYPE_UINT16]="uint16";gpuVertexFormats[TYPE_INT32]="sint32";gpuVertexFormats[TYPE_UINT32]="uint32";gpuVertexFormats[TYPE_FLOAT32]="float32";gpuVertexFormats[TYPE_FLOAT16]="float16";const gpuVertexFormatsNormalized=[];gpuVertexFormatsNormalized[TYPE_INT8]="snorm8";gpuVertexFormatsNormalized[TYPE_UINT8]="unorm8";gpuVertexFormatsNormalized[TYPE_INT16]="snorm16";gpuVertexFormatsNormalized[TYPE_UINT16]="unorm16";gpuVertexFormatsNormalized[TYPE_INT32]="sint32";gpuVertexFormatsNormalized[TYPE_UINT32]="uint32";gpuVertexFormatsNormalized[TYPE_FLOAT32]="float32";gpuVertexFormatsNormalized[TYPE_FLOAT16]="float16";class WebgpuVertexBufferLayout{get(vertexFormat0,vertexFormat1=null){const key=this.getKey(vertexFormat0,vertexFormat1);let layout=this.cache.get(key);if(!layout){layout=this.create(vertexFormat0,vertexFormat1);this.cache.set(key,layout);}return layout}getKey(vertexFormat0,vertexFormat1=null){return `${vertexFormat0==null?void 0:vertexFormat0.renderingHashString}-${vertexFormat1==null?void 0:vertexFormat1.renderingHashString}`}create(vertexFormat0,vertexFormat1){const layout=[];const addFormat=format=>{const interleaved=format.interleaved;const stepMode=format.instancing?"instance":"vertex";let attributes=[];const elementCount=format.elements.length;for(let i=0;i<elementCount;i++){const element=format.elements[i];const location=semanticToLocation[element.name];const formatTable=element.normalize?gpuVertexFormatsNormalized:gpuVertexFormats;attributes.push({shaderLocation:location,offset:interleaved?element.offset:0,format:`${formatTable[element.dataType]}${element.numComponents>1?`x${element.numComponents}`:""}`});if(!interleaved||i===elementCount-1){layout.push({attributes:attributes,arrayStride:element.stride,stepMode:stepMode});attributes=[];}}};if(vertexFormat0){addFormat(vertexFormat0);}if(vertexFormat1){addFormat(vertexFormat1);}return layout}constructor(){this.cache=new Map;}}class WebgpuPipeline{getPipelineLayout(bindGroupFormats){const bindGroupLayouts=[];bindGroupFormats.forEach(format=>{bindGroupLayouts.push(format.bindGroupLayout);});const descr={bindGroupLayouts:bindGroupLayouts};const pipelineLayout=this.device.wgpu.createPipelineLayout(descr);return pipelineLayout}constructor(device){this.device=device;}}const _primitiveTopology=["point-list","line-list",undefined,"line-strip","triangle-list","triangle-strip",undefined];const _blendOperation=["add","subtract","reverse-subtract","min","max"];const _blendFactor=["zero","one","src","one-minus-src","dst","one-minus-dst","src-alpha","src-alpha-saturated","one-minus-src-alpha","dst-alpha","one-minus-dst-alpha","constant","one-minus-constant"];const _compareFunction=["never","less","equal","less-equal","greater","not-equal","greater-equal","always"];const _cullModes=["none","back","front"];const _stencilOps=["keep","zero","replace","increment-clamp","increment-wrap","decrement-clamp","decrement-wrap","invert"];class CacheEntry{constructor(){this.pipeline=void 0;this.hashes=void 0;}}class WebgpuRenderPipeline extends WebgpuPipeline{get(primitive,vertexFormat0,vertexFormat1,shader,renderTarget,bindGroupFormats,blendState,depthState,cullMode,stencilEnabled,stencilFront,stencilBack){var _vertexFormat0$render,_vertexFormat1$render,_bindGroupFormats$0$k,_bindGroupFormats$,_bindGroupFormats$1$k,_bindGroupFormats$2,_bindGroupFormats$2$k,_bindGroupFormats$3;const lookupHashes=this.lookupHashes;lookupHashes[0]=primitive.type;lookupHashes[1]=shader.id;lookupHashes[2]=cullMode;lookupHashes[3]=depthState.key;lookupHashes[4]=blendState.key;lookupHashes[5]=(_vertexFormat0$render=vertexFormat0==null?void 0:vertexFormat0.renderingHash)!=null?_vertexFormat0$render:0;lookupHashes[6]=(_vertexFormat1$render=vertexFormat1==null?void 0:vertexFormat1.renderingHash)!=null?_vertexFormat1$render:0;lookupHashes[7]=renderTarget.impl.key;lookupHashes[8]=(_bindGroupFormats$0$k=(_bindGroupFormats$=bindGroupFormats[0])==null?void 0:_bindGroupFormats$.key)!=null?_bindGroupFormats$0$k:0;lookupHashes[9]=(_bindGroupFormats$1$k=(_bindGroupFormats$2=bindGroupFormats[1])==null?void 0:_bindGroupFormats$2.key)!=null?_bindGroupFormats$1$k:0;lookupHashes[10]=(_bindGroupFormats$2$k=(_bindGroupFormats$3=bindGroupFormats[2])==null?void 0:_bindGroupFormats$3.key)!=null?_bindGroupFormats$2$k:0;lookupHashes[11]=stencilEnabled?stencilFront.key:0;lookupHashes[12]=stencilEnabled?stencilBack.key:0;const hash=hash32Fnv1a(lookupHashes);let cacheEntries=this.cache.get(hash);if(cacheEntries){for(let i=0;i<cacheEntries.length;i++){const entry=cacheEntries[i];if(array.equals(entry.hashes,lookupHashes)){return entry.pipeline}}}const primitiveTopology=_primitiveTopology[primitive.type];const pipelineLayout=this.getPipelineLayout(bindGroupFormats);const vertexBufferLayout=this.vertexBufferLayout.get(vertexFormat0,vertexFormat1);const cacheEntry=new CacheEntry;cacheEntry.hashes=new Uint32Array(lookupHashes);cacheEntry.pipeline=this.create(primitiveTopology,shader,renderTarget,pipelineLayout,blendState,depthState,vertexBufferLayout,cullMode,stencilEnabled,stencilFront,stencilBack);if(cacheEntries){cacheEntries.push(cacheEntry);}else {cacheEntries=[cacheEntry];}this.cache.set(hash,cacheEntries);return cacheEntry.pipeline}getBlend(blendState){let blend;if(blendState.blend){blend={color:{operation:_blendOperation[blendState.colorOp],srcFactor:_blendFactor[blendState.colorSrcFactor],dstFactor:_blendFactor[blendState.colorDstFactor]},alpha:{operation:_blendOperation[blendState.alphaOp],srcFactor:_blendFactor[blendState.alphaSrcFactor],dstFactor:_blendFactor[blendState.alphaDstFactor]}};}return blend}getDepthStencil(depthState,renderTarget,stencilEnabled,stencilFront,stencilBack){let depthStencil;const{depth,stencil}=renderTarget;if(depth||stencil){depthStencil={format:renderTarget.impl.depthFormat};if(depth){depthStencil.depthWriteEnabled=depthState.write;depthStencil.depthCompare=_compareFunction[depthState.func];depthStencil.depthBias=depthState.depthBias;depthStencil.depthBiasSlopeScale=depthState.depthBiasSlope;}else {depthStencil.depthWriteEnabled=false;depthStencil.depthCompare="always";}if(stencil&&stencilEnabled){depthStencil.stencilReadMas=stencilFront.readMask;depthStencil.stencilWriteMask=stencilFront.writeMask;depthStencil.stencilFront={compare:_compareFunction[stencilFront.func],failOp:_stencilOps[stencilFront.fail],passOp:_stencilOps[stencilFront.zpass],depthFailOp:_stencilOps[stencilFront.zfail]};depthStencil.stencilBack={compare:_compareFunction[stencilBack.func],failOp:_stencilOps[stencilBack.fail],passOp:_stencilOps[stencilBack.zpass],depthFailOp:_stencilOps[stencilBack.zfail]};}}return depthStencil}create(primitiveTopology,shader,renderTarget,pipelineLayout,blendState,depthState,vertexBufferLayout,cullMode,stencilEnabled,stencilFront,stencilBack){const wgpu=this.device.wgpu;const webgpuShader=shader.impl;const descr={vertex:{module:webgpuShader.getVertexShaderModule(),entryPoint:webgpuShader.vertexEntryPoint,buffers:vertexBufferLayout},primitive:{topology:primitiveTopology,frontFace:"ccw",cullMode:_cullModes[cullMode]},depthStencil:this.getDepthStencil(depthState,renderTarget,stencilEnabled,stencilFront,stencilBack),multisample:{count:renderTarget.samples},layout:pipelineLayout};descr.fragment={module:webgpuShader.getFragmentShaderModule(),entryPoint:webgpuShader.fragmentEntryPoint,targets:[]};const colorAttachments=renderTarget.impl.colorAttachments;if(colorAttachments.length>0){let writeMask=0;if(blendState.redWrite)writeMask|=GPUColorWrite.RED;if(blendState.greenWrite)writeMask|=GPUColorWrite.GREEN;if(blendState.blueWrite)writeMask|=GPUColorWrite.BLUE;if(blendState.alphaWrite)writeMask|=GPUColorWrite.ALPHA;const blend=this.getBlend(blendState);colorAttachments.forEach(attachment=>{descr.fragment.targets.push({format:attachment.format,writeMask:writeMask,blend:blend});});}const pipeline=wgpu.createRenderPipeline(descr);return pipeline}constructor(device){super(device);this.lookupHashes=new Uint32Array(13);this.vertexBufferLayout=new WebgpuVertexBufferLayout;this.cache=new Map;}}class WebgpuComputePipeline extends WebgpuPipeline{get(shader,bindGroupFormat){const pipelineLayout=this.getPipelineLayout([bindGroupFormat.impl]);const pipeline=this.create(shader,pipelineLayout);return pipeline}create(shader,pipelineLayout){const wgpu=this.device.wgpu;const webgpuShader=shader.impl;const descr={compute:{module:webgpuShader.getComputeShaderModule(),entryPoint:webgpuShader.computeEntryPoint},layout:pipelineLayout};const pipeline=wgpu.createComputePipeline(descr);return pipeline}}const stringIds=new StringIds;class ColorAttachment{destroy(){var _this$multisampledBuf;(_this$multisampledBuf=this.multisampledBuffer)==null||_this$multisampledBuf.destroy();this.multisampledBuffer=null;}constructor(){this.format=void 0;this.multisampledBuffer=void 0;}}class WebgpuRenderTarget{destroy(device){this.initialized=false;if(this.depthTextureInternal){var _this$depthTexture;(_this$depthTexture=this.depthTexture)==null||_this$depthTexture.destroy();this.depthTexture=null;}this.assignedColorTexture=null;this.colorAttachments.forEach(colorAttachment=>{colorAttachment.destroy();});this.colorAttachments.length=0;}updateKey(){const rt=this.renderTarget;let key=`${rt.samples}:${rt.depth?this.depthFormat:"nodepth"}`;this.colorAttachments.forEach(colorAttachment=>{key+=`:${colorAttachment.format}`;});this.key=stringIds.get(key);}setDepthFormat(depthFormat){this.depthFormat=depthFormat;this.hasStencil=depthFormat==="depth24plus-stencil8";}assignColorTexture(gpuTexture){this.assignedColorTexture=gpuTexture;const view=gpuTexture.createView();const colorAttachment=this.renderPassDescriptor.colorAttachments[0];const samples=this.renderTarget.samples;if(samples>1){colorAttachment.resolveTarget=view;}else {colorAttachment.view=view;}this.setColorAttachment(0,undefined,gpuTexture.format);this.updateKey();}setColorAttachment(index,multisampledBuffer,format){if(!this.colorAttachments[index]){this.colorAttachments[index]=new ColorAttachment;}if(multisampledBuffer){this.colorAttachments[index].multisampledBuffer=multisampledBuffer;}if(format){this.colorAttachments[index].format=format;}}init(device,renderTarget){var _renderTarget$_colorB,_renderTarget$_colorB2;const wgpu=device.wgpu;this.initDepthStencil(wgpu,renderTarget);this.renderPassDescriptor.colorAttachments=[];const count=(_renderTarget$_colorB=(_renderTarget$_colorB2=renderTarget._colorBuffers)==null?void 0:_renderTarget$_colorB2.length)!=null?_renderTarget$_colorB:1;for(let i=0;i<count;++i){var _this$colorAttachment;const colorAttachment=this.initColor(wgpu,renderTarget,i);const isDefaultFramebuffer=i===0&&((_this$colorAttachment=this.colorAttachments[0])==null?void 0:_this$colorAttachment.format);if(colorAttachment.view||isDefaultFramebuffer){this.renderPassDescriptor.colorAttachments.push(colorAttachment);}}this.initialized=true;}initDepthStencil(wgpu,renderTarget){const{samples,width,height,depth,depthBuffer}=renderTarget;if(depth||depthBuffer){if(!depthBuffer){this.setDepthFormat("depth24plus-stencil8");const depthTextureDesc={size:[width,height,1],dimension:"2d",sampleCount:samples,format:this.depthFormat,usage:GPUTextureUsage.RENDER_ATTACHMENT};if(samples>1){depthTextureDesc.usage|=GPUTextureUsage.TEXTURE_BINDING;}else {depthTextureDesc.usage|=GPUTextureUsage.COPY_SRC;}this.depthTexture=wgpu.createTexture(depthTextureDesc);this.depthTextureInternal=true;}else {this.depthTexture=depthBuffer.impl.gpuTexture;this.setDepthFormat(depthBuffer.impl.format);}this.renderPassDescriptor.depthStencilAttachment={view:this.depthTexture.createView()};}}initColor(wgpu,renderTarget,index){const colorAttachment={};const{samples,width,height}=renderTarget;const colorBuffer=renderTarget.getColorBuffer(index);let colorView=null;if(colorBuffer){const mipLevelCount=1;if(colorBuffer.cubemap){colorView=colorBuffer.impl.createView({dimension:"2d",baseArrayLayer:renderTarget.face,arrayLayerCount:1,mipLevelCount});}else {colorView=colorBuffer.impl.createView({mipLevelCount});}}if(samples>1){var _this$colorAttachment2,_this$colorAttachment3;const multisampledTextureDesc={size:[width,height,1],dimension:"2d",sampleCount:samples,format:(_this$colorAttachment2=(_this$colorAttachment3=this.colorAttachments[index])==null?void 0:_this$colorAttachment3.format)!=null?_this$colorAttachment2:colorBuffer.impl.format,usage:GPUTextureUsage.RENDER_ATTACHMENT};const multisampledColorBuffer=wgpu.createTexture(multisampledTextureDesc);this.setColorAttachment(index,multisampledColorBuffer,multisampledTextureDesc.format);colorAttachment.view=multisampledColorBuffer.createView();colorAttachment.resolveTarget=colorView;}else {colorAttachment.view=colorView;}return colorAttachment}setupForRenderPass(renderPass){var _this$renderPassDescr,_this$renderPassDescr2;const count=(_this$renderPassDescr=(_this$renderPassDescr2=this.renderPassDescriptor.colorAttachments)==null?void 0:_this$renderPassDescr2.length)!=null?_this$renderPassDescr:0;for(let i=0;i<count;++i){const colorAttachment=this.renderPassDescriptor.colorAttachments[i];const colorOps=renderPass.colorArrayOps[i];colorAttachment.clearValue=colorOps.clearValue;colorAttachment.loadOp=colorOps.clear?"clear":"load";colorAttachment.storeOp=colorOps.store?"store":"discard";}const depthAttachment=this.renderPassDescriptor.depthStencilAttachment;if(depthAttachment){depthAttachment.depthClearValue=renderPass.depthStencilOps.clearDepthValue;depthAttachment.depthLoadOp=renderPass.depthStencilOps.clearDepth?"clear":"load";depthAttachment.depthStoreOp=renderPass.depthStencilOps.storeDepth?"store":"discard";depthAttachment.depthReadOnly=false;if(this.hasStencil){depthAttachment.stencilClearValue=renderPass.depthStencilOps.clearStencilValue;depthAttachment.stencilLoadOp=renderPass.depthStencilOps.clearStencil?"clear":"load";depthAttachment.stencilStoreOp=renderPass.depthStencilOps.storeStencil?"store":"discard";depthAttachment.stencilReadOnly=false;}}}loseContext(){this.initialized=false;}resolve(device,target,color,depth){}constructor(renderTarget){this.initialized=false;this.key=void 0;this.colorAttachments=[];this.depthFormat=void 0;this.hasStencil=void 0;this.depthTexture=null;this.depthTextureInternal=false;this.assignedColorTexture=null;this.renderPassDescriptor={};this.renderTarget=renderTarget;if(renderTarget._colorBuffers){renderTarget._colorBuffers.forEach((colorBuffer,index)=>{this.setColorAttachment(index,undefined,colorBuffer.impl.format);});}this.updateKey();}}const uniformTypeToNumComponents=[];uniformTypeToNumComponents[UNIFORMTYPE_FLOAT]=1;uniformTypeToNumComponents[UNIFORMTYPE_VEC2]=2;uniformTypeToNumComponents[UNIFORMTYPE_VEC3]=3;uniformTypeToNumComponents[UNIFORMTYPE_VEC4]=4;uniformTypeToNumComponents[UNIFORMTYPE_INT]=1;uniformTypeToNumComponents[UNIFORMTYPE_IVEC2]=2;uniformTypeToNumComponents[UNIFORMTYPE_IVEC3]=3;uniformTypeToNumComponents[UNIFORMTYPE_IVEC4]=4;uniformTypeToNumComponents[UNIFORMTYPE_BOOL]=1;uniformTypeToNumComponents[UNIFORMTYPE_BVEC2]=2;uniformTypeToNumComponents[UNIFORMTYPE_BVEC3]=3;uniformTypeToNumComponents[UNIFORMTYPE_BVEC4]=4;uniformTypeToNumComponents[UNIFORMTYPE_MAT2]=8;uniformTypeToNumComponents[UNIFORMTYPE_MAT3]=12;uniformTypeToNumComponents[UNIFORMTYPE_MAT4]=16;uniformTypeToNumComponents[UNIFORMTYPE_UINT]=1;uniformTypeToNumComponents[UNIFORMTYPE_UVEC2]=2;uniformTypeToNumComponents[UNIFORMTYPE_UVEC3]=3;uniformTypeToNumComponents[UNIFORMTYPE_UVEC4]=4;class UniformFormat{get isArrayType(){return this.count>0}calculateOffset(offset){let alignment=this.byteSize<=8?this.byteSize:16;if(this.count){alignment=16;}offset=math.roundUp(offset,alignment);this.offset=offset/4;}constructor(name,type,count=0){this.name=void 0;this.type=void 0;this.byteSize=void 0;this.offset=void 0;this.scopeId=void 0;this.count=void 0;this.numComponents=void 0;this.shortName=name;this.name=count?`${name}[0]`:name;this.type=type;this.numComponents=uniformTypeToNumComponents[type];this.updateType=type;if(count>0){switch(type){case UNIFORMTYPE_FLOAT:this.updateType=UNIFORMTYPE_FLOATARRAY;break;case UNIFORMTYPE_INT:this.updateType=UNIFORMTYPE_INTARRAY;break;case UNIFORMTYPE_UINT:this.updateType=UNIFORMTYPE_UINTARRAY;break;case UNIFORMTYPE_BOOL:this.updateType=UNIFORMTYPE_BOOLARRAY;break;case UNIFORMTYPE_VEC2:this.updateType=UNIFORMTYPE_VEC2ARRAY;break;case UNIFORMTYPE_IVEC2:this.updateType=UNIFORMTYPE_IVEC2ARRAY;break;case UNIFORMTYPE_UVEC2:this.updateType=UNIFORMTYPE_UVEC2ARRAY;break;case UNIFORMTYPE_BVEC2:this.updateType=UNIFORMTYPE_BVEC2ARRAY;break;case UNIFORMTYPE_VEC3:this.updateType=UNIFORMTYPE_VEC3ARRAY;break;case UNIFORMTYPE_IVEC3:this.updateType=UNIFORMTYPE_IVEC3ARRAY;break;case UNIFORMTYPE_UVEC3:this.updateType=UNIFORMTYPE_UVEC3ARRAY;break;case UNIFORMTYPE_BVEC3:this.updateType=UNIFORMTYPE_BVEC3ARRAY;break;case UNIFORMTYPE_VEC4:this.updateType=UNIFORMTYPE_VEC4ARRAY;break;case UNIFORMTYPE_IVEC4:this.updateType=UNIFORMTYPE_IVEC4ARRAY;break;case UNIFORMTYPE_UVEC4:this.updateType=UNIFORMTYPE_UVEC4ARRAY;break;case UNIFORMTYPE_BVEC4:this.updateType=UNIFORMTYPE_BVEC4ARRAY;break;case UNIFORMTYPE_MAT4:this.updateType=UNIFORMTYPE_MAT4ARRAY;break}}this.count=count;let componentSize=this.numComponents;if(count){componentSize=math.roundUp(componentSize,4);}this.byteSize=componentSize*4;if(count){this.byteSize*=count;}}}class UniformBufferFormat{get(name){return this.map.get(name)}getShaderDeclaration(bindGroup,bindIndex){const name=bindGroupNames[bindGroup];let code=`layout(set = ${bindGroup}, binding = ${bindIndex}, std140) uniform ub_${name} {
`;this.uniforms.forEach(uniform=>{const typeString=uniformTypeToName[uniform.type];code+=`    ${typeString} ${uniform.shortName}${uniform.count?`[${uniform.count}]`:""};
`;});return `${code}};
`}constructor(graphicsDevice,uniforms){this.byteSize=0;this.map=new Map;this.scope=graphicsDevice.scope;this.uniforms=uniforms;let offset=0;for(let i=0;i<uniforms.length;i++){const uniform=uniforms[i];uniform.calculateOffset(offset);offset=uniform.offset*4+uniform.byteSize;uniform.scopeId=this.scope.resolve(uniform.name);this.map.set(uniform.name,uniform);}this.byteSize=math.roundUp(offset,16);}}let id$9=0;const textureDimensionInfo={[TEXTUREDIMENSION_2D]:"texture2D",[TEXTUREDIMENSION_CUBE]:"textureCube",[TEXTUREDIMENSION_3D]:"texture3D",[TEXTUREDIMENSION_2D_ARRAY]:"texture2DArray"};class BindBaseFormat{constructor(name,visibility){this.slot=-1;this.scopeId=null;this.name=name;this.visibility=visibility;}}class BindUniformBufferFormat extends BindBaseFormat{}class BindStorageBufferFormat extends BindBaseFormat{constructor(name,visibility,readOnly=false){super(name,visibility);this.readOnly=readOnly;}}class BindTextureFormat extends BindBaseFormat{constructor(name,visibility,textureDimension=TEXTUREDIMENSION_2D,sampleType=SAMPLETYPE_FLOAT,hasSampler=true){super(name,visibility);this.textureDimension=textureDimension;this.sampleType=sampleType;this.hasSampler=hasSampler;}}class BindStorageTextureFormat extends BindBaseFormat{constructor(name,format=PIXELFORMAT_RGBA8,textureDimension=TEXTUREDIMENSION_2D,write=true,read=false){super(name,SHADERSTAGE_COMPUTE);this.format=format;this.textureDimension=textureDimension;this.write=write;this.read=read;}}class BindGroupFormat{destroy(){this.impl.destroy();}getTexture(name){const index=this.textureFormatsMap.get(name);if(index!==undefined){return this.textureFormats[index]}return null}getStorageTexture(name){const index=this.storageTextureFormatsMap.get(name);if(index!==undefined){return this.storageTextureFormats[index]}return null}getShaderDeclarationTextures(bindGroup){let code="";this.textureFormats.forEach(format=>{let textureType=textureDimensionInfo[format.textureDimension];const isArray=textureType==="texture2DArray";const sampleTypePrefix=format.sampleType===SAMPLETYPE_UINT?"u":format.sampleType===SAMPLETYPE_INT?"i":"";textureType=`${sampleTypePrefix}${textureType}`;let namePostfix="";let extraCode="";if(isArray){namePostfix="_texture";extraCode=`#define ${format.name} ${sampleTypePrefix}sampler2DArray(${format.name}${namePostfix}, ${format.name}_sampler)
`;}code+=`layout(set = ${bindGroup}, binding = ${format.slot}) uniform ${textureType} ${format.name}${namePostfix};
`;if(format.hasSampler){code+=`layout(set = ${bindGroup}, binding = ${format.slot+1}) uniform sampler ${format.name}_sampler;
`;}code+=extraCode;});return code}loseContext(){}constructor(graphicsDevice,formats){this.uniformBufferFormats=[];this.textureFormats=[];this.storageTextureFormats=[];this.storageBufferFormats=[];this.id=id$9++;let slot=0;formats.forEach(format=>{format.slot=slot++;if(format instanceof BindTextureFormat&&format.hasSampler){slot++;}if(format instanceof BindUniformBufferFormat){this.uniformBufferFormats.push(format);}else if(format instanceof BindTextureFormat){this.textureFormats.push(format);}else if(format instanceof BindStorageTextureFormat){this.storageTextureFormats.push(format);}else if(format instanceof BindStorageBufferFormat){this.storageBufferFormats.push(format);}else;});this.device=graphicsDevice;const scope=graphicsDevice.scope;this.bufferFormatsMap=new Map;this.uniformBufferFormats.forEach((bf,i)=>this.bufferFormatsMap.set(bf.name,i));this.textureFormatsMap=new Map;this.textureFormats.forEach((tf,i)=>{this.textureFormatsMap.set(tf.name,i);tf.scopeId=scope.resolve(tf.name);});this.storageTextureFormatsMap=new Map;this.storageTextureFormats.forEach((tf,i)=>{this.storageTextureFormatsMap.set(tf.name,i);tf.scopeId=scope.resolve(tf.name);});this.storageBufferFormatsMap=new Map;this.storageBufferFormats.forEach((bf,i)=>{this.storageBufferFormatsMap.set(bf.name,i);bf.scopeId=scope.resolve(bf.name);});this.impl=graphicsDevice.createBindGroupFormatImpl(this);}}const KEYWORD$1=/[ \t]*(\battribute\b|\bvarying\b|\buniform\b)/g;const KEYWORD_LINE=/(\battribute\b|\bvarying\b|\bout\b|\buniform\b)[ \t]*([^;]+)(;+)/g;const MARKER="@@@";const ARRAY_IDENTIFIER=/([\w-]+)\[(.*?)\]/;const precisionQualifiers=new Set(["highp","mediump","lowp"]);const shadowSamplers=new Set(["sampler2DShadow","samplerCubeShadow","sampler2DArrayShadow"]);const textureDimensions={sampler2D:TEXTUREDIMENSION_2D,sampler3D:TEXTUREDIMENSION_3D,samplerCube:TEXTUREDIMENSION_CUBE,samplerCubeShadow:TEXTUREDIMENSION_CUBE,sampler2DShadow:TEXTUREDIMENSION_2D,sampler2DArray:TEXTUREDIMENSION_2D_ARRAY,sampler2DArrayShadow:TEXTUREDIMENSION_2D_ARRAY,isampler2D:TEXTUREDIMENSION_2D,usampler2D:TEXTUREDIMENSION_2D,isampler3D:TEXTUREDIMENSION_3D,usampler3D:TEXTUREDIMENSION_3D,isamplerCube:TEXTUREDIMENSION_CUBE,usamplerCube:TEXTUREDIMENSION_CUBE,isampler2DArray:TEXTUREDIMENSION_2D_ARRAY,usampler2DArray:TEXTUREDIMENSION_2D_ARRAY};class UniformLine{constructor(line,shader){this.line=line;const words=line.trim().split(/\s+/);if(precisionQualifiers.has(words[0])){this.precision=words.shift();}this.type=words.shift();if(line.includes(","));if(line.includes("[")){const rest=words.join(" ");const match=ARRAY_IDENTIFIER.exec(rest);this.name=match[1];this.arraySize=Number(match[2]);if(isNaN(this.arraySize)){shader.failed=true;}}else {this.name=words.shift();this.arraySize=0;}this.isSampler=this.type.indexOf("sampler")!==-1;this.isSignedInt=this.type.indexOf("isampler")!==-1;this.isUnsignedInt=this.type.indexOf("usampler")!==-1;}}class ShaderProcessor{static run(device,shaderDefinition,shader){const varyingMap=new Map;const vertexExtracted=ShaderProcessor.extract(shaderDefinition.vshader);const fragmentExtracted=ShaderProcessor.extract(shaderDefinition.fshader);const attributesBlock=ShaderProcessor.processAttributes(vertexExtracted.attributes,shaderDefinition.attributes,shaderDefinition.processingOptions);const vertexVaryingsBlock=ShaderProcessor.processVaryings(vertexExtracted.varyings,varyingMap,true);const fragmentVaryingsBlock=ShaderProcessor.processVaryings(fragmentExtracted.varyings,varyingMap,false);const outBlock=ShaderProcessor.processOuts(fragmentExtracted.outs);const concatUniforms=vertexExtracted.uniforms.concat(fragmentExtracted.uniforms);const uniforms=Array.from(new Set(concatUniforms));const parsedUniforms=uniforms.map(line=>new UniformLine(line,shader));const uniformsData=ShaderProcessor.processUniforms(device,parsedUniforms,shaderDefinition.processingOptions,shader);const vBlock=`${attributesBlock}
${vertexVaryingsBlock}
${uniformsData.code}`;const vshader=vertexExtracted.src.replace(MARKER,vBlock);const fBlock=`${fragmentVaryingsBlock}
${outBlock}
${uniformsData.code}`;const fshader=fragmentExtracted.src.replace(MARKER,fBlock);return {vshader:vshader,fshader:fshader,meshUniformBufferFormat:uniformsData.meshUniformBufferFormat,meshBindGroupFormat:uniformsData.meshBindGroupFormat}}static extract(src){const attributes=[];const varyings=[];const outs=[];const uniforms=[];let replacement=`${MARKER}
`;let match;while((match=KEYWORD$1.exec(src))!==null){const keyword=match[1];switch(keyword){case"attribute":case"varying":case"uniform":case"out":{KEYWORD_LINE.lastIndex=match.index;const lineMatch=KEYWORD_LINE.exec(src);if(keyword==="attribute"){attributes.push(lineMatch[2]);}else if(keyword==="varying"){varyings.push(lineMatch[2]);}else if(keyword==="out"){outs.push(lineMatch[2]);}else if(keyword==="uniform"){uniforms.push(lineMatch[2]);}src=ShaderProcessor.cutOut(src,match.index,KEYWORD_LINE.lastIndex,replacement);KEYWORD$1.lastIndex=match.index+replacement.length;replacement="";break}}}return {src,attributes,varyings,outs,uniforms}}static processUniforms(device,uniforms,processingOptions,shader){const uniformLinesSamplers=[];const uniformLinesNonSamplers=[];uniforms.forEach(uniform=>{if(uniform.isSampler){uniformLinesSamplers.push(uniform);}else {uniformLinesNonSamplers.push(uniform);}});const meshUniforms=[];uniformLinesNonSamplers.forEach(uniform=>{if(!processingOptions.hasUniform(uniform.name)){const uniformType=uniformTypeToName.indexOf(uniform.type);const uniformFormat=new UniformFormat(uniform.name,uniformType,uniform.arraySize);meshUniforms.push(uniformFormat);}});const meshUniformBufferFormat=meshUniforms.length?new UniformBufferFormat(device,meshUniforms):null;const uniformBufferFormats=[];if(meshUniformBufferFormat){uniformBufferFormats.push(new BindUniformBufferFormat(UNIFORM_BUFFER_DEFAULT_SLOT_NAME,SHADERSTAGE_VERTEX|SHADERSTAGE_FRAGMENT));}const textureFormats=[];uniformLinesSamplers.forEach(uniform=>{if(!processingOptions.hasTexture(uniform.name)){let sampleType=SAMPLETYPE_FLOAT;if(uniform.isSignedInt){sampleType=SAMPLETYPE_INT;}else if(uniform.isUnsignedInt){sampleType=SAMPLETYPE_UINT;}else {if(uniform.precision==="highp"){sampleType=SAMPLETYPE_UNFILTERABLE_FLOAT;}if(shadowSamplers.has(uniform.type)){sampleType=SAMPLETYPE_DEPTH;}}const dimension=textureDimensions[uniform.type];textureFormats.push(new BindTextureFormat(uniform.name,SHADERSTAGE_VERTEX|SHADERSTAGE_FRAGMENT,dimension,sampleType));}});const meshBindGroupFormat=new BindGroupFormat(device,[...uniformBufferFormats,...textureFormats]);let code="";processingOptions.uniformFormats.forEach((format,bindGroupIndex)=>{if(format){code+=format.getShaderDeclaration(bindGroupIndex,0);}});if(meshUniformBufferFormat){code+=meshUniformBufferFormat.getShaderDeclaration(BINDGROUP_MESH,0);}processingOptions.bindGroupFormats.forEach((format,bindGroupIndex)=>{if(format){code+=format.getShaderDeclarationTextures(bindGroupIndex);}});code+=meshBindGroupFormat.getShaderDeclarationTextures(BINDGROUP_MESH);return {code,meshUniformBufferFormat,meshBindGroupFormat}}static processVaryings(varyingLines,varyingMap,isVertex){let block="";const op=isVertex?"out":"in";varyingLines.forEach((line,index)=>{const words=ShaderProcessor.splitToWords(line);const type=words[0];const name=words[1];if(isVertex){varyingMap.set(name,index);}else {index=varyingMap.get(name);}block+=`layout(location = ${index}) ${op} ${type} ${name};
`;});return block}static processOuts(outsLines){let block="";outsLines.forEach((line,index)=>{block+=`layout(location = ${index}) out ${line};
`;});return block}static getTypeCount(type){const lastChar=type.substring(type.length-1);const num=parseInt(lastChar,10);return isNaN(num)?1:num}static processAttributes(attributeLines,shaderDefinitionAttributes,processingOptions){let block="";attributeLines.forEach(line=>{const words=ShaderProcessor.splitToWords(line);let type=words[0];let name=words[1];if(shaderDefinitionAttributes.hasOwnProperty(name)){const semantic=shaderDefinitionAttributes[name];const location=semanticToLocation[semantic];let copyCode;const element=processingOptions.getVertexElement(semantic);if(element){const dataType=element.dataType;if(dataType!==TYPE_FLOAT32&&dataType!==TYPE_FLOAT16&&!element.normalize&&!element.asInt){const attribNumElements=ShaderProcessor.getTypeCount(type);const newName=`_private_${name}`;copyCode=`vec${attribNumElements} ${name} = vec${attribNumElements}(${newName});
`;name=newName;const isSignedType=dataType===TYPE_INT8||dataType===TYPE_INT16||dataType===TYPE_INT32;if(attribNumElements===1){type=isSignedType?"int":"uint";}else {type=isSignedType?`ivec${attribNumElements}`:`uvec${attribNumElements}`;}}}block+=`layout(location = ${location}) in ${type} ${name};
`;if(copyCode){block+=copyCode;}}});return block}static splitToWords(line){line=line.replace(/\s+/g," ").trim();return line.split(" ")}static cutOut(src,start,end,replacement){return src.substring(0,start)+replacement+src.substring(end)}}class WebgpuShader{destroy(shader){this._vertexCode=null;this._fragmentCode=null;}createShaderModule(code,shaderType){const device=this.shader.device;const wgpu=device.wgpu;const shaderModule=wgpu.createShaderModule({code:code});return shaderModule}getVertexShaderModule(){return this.createShaderModule(this._vertexCode,"Vertex")}getFragmentShaderModule(){return this.createShaderModule(this._fragmentCode,"Fragment")}getComputeShaderModule(){return this.createShaderModule(this._computeCode,"Compute")}process(){const shader=this.shader;const processed=ShaderProcessor.run(shader.device,shader.definition,shader);this._vertexCode=this.transpile(processed.vshader,"vertex",shader.definition.vshader);this._fragmentCode=this.transpile(processed.fshader,"fragment",shader.definition.fshader);if(!(this._vertexCode&&this._fragmentCode)){shader.failed=true;}else {shader.ready=true;}shader.meshUniformBufferFormat=processed.meshUniformBufferFormat;shader.meshBindGroupFormat=processed.meshBindGroupFormat;}transpile(src,shaderType,originalSrc){try{const spirv=this.shader.device.glslang.compileGLSL(src,shaderType);return this.shader.device.twgsl.convertSpirV2WGSL(spirv)}catch(err){console.error(`Failed to transpile webgl ${shaderType} shader [${this.shader.label}] to WebGPU: [${err.message}] while rendering ${void 0}`,{processed:src,original:originalSrc,shader:this.shader});}}get vertexCode(){return this._vertexCode}get fragmentCode(){return this._fragmentCode}loseContext(){}restoreContext(device,shader){}constructor(shader){this._vertexCode=null;this._fragmentCode=null;this._computeCode=null;this.vertexEntryPoint="main";this.fragmentEntryPoint="main";this.computeEntryPoint="main";this.shader=shader;const definition=shader.definition;if(definition.shaderLanguage===SHADERLANGUAGE_WGSL){var _definition$vshader,_definition$fshader,_definition$cshader;this._vertexCode=(_definition$vshader=definition.vshader)!=null?_definition$vshader:null;this._fragmentCode=(_definition$fshader=definition.fshader)!=null?_definition$fshader:null;this._computeCode=(_definition$cshader=definition.cshader)!=null?_definition$cshader:null;this.meshUniformBufferFormat=definition.meshUniformBufferFormat;this.meshBindGroupFormat=definition.meshBindGroupFormat;this.computeUniformBufferFormats=definition.computeUniformBufferFormats;this.computeBindGroupFormat=definition.computeBindGroupFormat;this.vertexEntryPoint="vertexMain";this.fragmentEntryPoint="fragmentMain";shader.ready=true;}else {if(definition.processingOptions){this.process();}}}}class TextureUtils{static calcLevelDimension(dimension,mipLevel){return Math.max(dimension>>mipLevel,1)}static calcMipLevelsCount(width,height,depth=1){return 1+Math.floor(Math.log2(Math.max(width,height,depth)))}static calcLevelGpuSize(width,height,depth,format){var _pixelFormatInfo$get$,_pixelFormatInfo$get,_formatInfo$blockSize;const formatInfo=pixelFormatInfo.get(format);const pixelSize=(_pixelFormatInfo$get$=(_pixelFormatInfo$get=pixelFormatInfo.get(format))==null?void 0:_pixelFormatInfo$get.size)!=null?_pixelFormatInfo$get$:0;if(pixelSize>0){return width*height*depth*pixelSize}const blockSize=(_formatInfo$blockSize=formatInfo.blockSize)!=null?_formatInfo$blockSize:0;let blockWidth=Math.floor((width+3)/4);const blockHeight=Math.floor((height+3)/4);const blockDepth=Math.floor((depth+3)/4);if(format===PIXELFORMAT_PVRTC_2BPP_RGB_1||format===PIXELFORMAT_PVRTC_2BPP_RGBA_1){blockWidth=Math.max(Math.floor(blockWidth/2),1);}return blockWidth*blockHeight*blockDepth*blockSize}static calcGpuSize(width,height,depth,format,mipmaps,cubemap){let result=0;while(1){result+=TextureUtils.calcLevelGpuSize(width,height,depth,format);if(!mipmaps||width===1&&height===1&&depth===1){break}width=Math.max(width>>1,1);height=Math.max(height>>1,1);depth=Math.max(depth>>1,1);}return result*(cubemap?6:1)}}const gpuAddressModes=[];gpuAddressModes[ADDRESS_REPEAT]="repeat";gpuAddressModes[ADDRESS_CLAMP_TO_EDGE]="clamp-to-edge";gpuAddressModes[ADDRESS_MIRRORED_REPEAT]="mirror-repeat";const gpuFilterModes=[];gpuFilterModes[FILTER_NEAREST]={level:"nearest",mip:"nearest"};gpuFilterModes[FILTER_LINEAR]={level:"linear",mip:"nearest"};gpuFilterModes[FILTER_NEAREST_MIPMAP_NEAREST]={level:"nearest",mip:"nearest"};gpuFilterModes[FILTER_NEAREST_MIPMAP_LINEAR]={level:"nearest",mip:"linear"};gpuFilterModes[FILTER_LINEAR_MIPMAP_NEAREST]={level:"linear",mip:"nearest"};gpuFilterModes[FILTER_LINEAR_MIPMAP_LINEAR]={level:"linear",mip:"linear"};const dummyUse=thingOne=>{};class WebgpuTexture{create(device){const texture=this.texture;const wgpu=device.wgpu;const mipLevelCount=texture.requiredMipLevels;this.descr={size:{width:texture.width,height:texture.height,depthOrArrayLayers:texture.cubemap?6:texture.array?texture.arrayLength:1},format:this.format,mipLevelCount:mipLevelCount,sampleCount:1,dimension:texture.volume?"3d":"2d",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|(isCompressedPixelFormat(texture.format)?0:GPUTextureUsage.RENDER_ATTACHMENT)|(texture.storage?GPUTextureUsage.STORAGE_BINDING:0)};this.gpuTexture=wgpu.createTexture(this.descr);let viewDescr;if(this.texture.format===PIXELFORMAT_DEPTHSTENCIL){viewDescr={format:"depth24plus",aspect:"depth-only"};}this.view=this.createView(viewDescr);}destroy(device){}propertyChanged(flag){this.samplers.length=0;}getView(device){this.uploadImmediate(device,this.texture);return this.view}createView(viewDescr){var _options$format,_options$dimension,_options$aspect,_options$baseMipLevel,_options$mipLevelCoun,_options$baseArrayLay,_options$arrayLayerCo;const options=viewDescr!=null?viewDescr:{};const textureDescr=this.descr;const texture=this.texture;const defaultViewDimension=()=>{if(texture.cubemap)return "cube";if(texture.volume)return "3d";if(texture.array)return "2d-array";return "2d"};const descr={format:(_options$format=options.format)!=null?_options$format:textureDescr.format,dimension:(_options$dimension=options.dimension)!=null?_options$dimension:defaultViewDimension(),aspect:(_options$aspect=options.aspect)!=null?_options$aspect:"all",baseMipLevel:(_options$baseMipLevel=options.baseMipLevel)!=null?_options$baseMipLevel:0,mipLevelCount:(_options$mipLevelCoun=options.mipLevelCount)!=null?_options$mipLevelCoun:textureDescr.mipLevelCount,baseArrayLayer:(_options$baseArrayLay=options.baseArrayLayer)!=null?_options$baseArrayLay:0,arrayLayerCount:(_options$arrayLayerCo=options.arrayLayerCount)!=null?_options$arrayLayerCo:textureDescr.depthOrArrayLayers};const view=this.gpuTexture.createView(descr);return view}getSampler(device,sampleType){let sampler=this.samplers[sampleType];if(!sampler){const texture=this.texture;const descr={addressModeU:gpuAddressModes[texture.addressU],addressModeV:gpuAddressModes[texture.addressV],addressModeW:gpuAddressModes[texture.addressW]};if(!sampleType&&texture.compareOnRead){sampleType=SAMPLETYPE_DEPTH;}if(sampleType===SAMPLETYPE_DEPTH||sampleType===SAMPLETYPE_INT||sampleType===SAMPLETYPE_UINT){descr.compare="less";descr.magFilter="linear";descr.minFilter="linear";}else if(sampleType===SAMPLETYPE_UNFILTERABLE_FLOAT){descr.magFilter="nearest";descr.minFilter="nearest";descr.mipmapFilter="nearest";}else {const forceNearest=!device.textureFloatFilterable&&(texture.format===PIXELFORMAT_RGBA32F||texture.format===PIXELFORMAT_RGBA16F);if(forceNearest||this.texture.format===PIXELFORMAT_DEPTHSTENCIL||isIntegerPixelFormat(this.texture.format)){descr.magFilter="nearest";descr.minFilter="nearest";descr.mipmapFilter="nearest";}else {descr.magFilter=gpuFilterModes[texture.magFilter].level;descr.minFilter=gpuFilterModes[texture.minFilter].level;descr.mipmapFilter=gpuFilterModes[texture.minFilter].mip;}}const allLinear=descr.minFilter==="linear"&&descr.magFilter==="linear"&&descr.mipmapFilter==="linear";descr.maxAnisotropy=allLinear?math.clamp(Math.round(texture._anisotropy),1,device.maxTextureAnisotropy):1;sampler=device.wgpu.createSampler(descr);this.samplers[sampleType]=sampler;}return sampler}loseContext(){}uploadImmediate(device,texture){if(texture._needsUpload||texture._needsMipmapsUpload){this.uploadData(device);texture._needsUpload=false;texture._needsMipmapsUpload=false;}}uploadData(device){const texture=this.texture;if(texture._levels){let anyUploads=false;let anyLevelMissing=false;const requiredMipLevels=texture.requiredMipLevels;for(let mipLevel=0;mipLevel<requiredMipLevels;mipLevel++){const mipObject=texture._levels[mipLevel];if(mipObject){if(texture.cubemap){for(let face=0;face<6;face++){const faceSource=mipObject[face];if(faceSource){if(this.isExternalImage(faceSource)){this.uploadExternalImage(device,faceSource,mipLevel,face);anyUploads=true;}else if(ArrayBuffer.isView(faceSource)){this.uploadTypedArrayData(device,faceSource,mipLevel,face);anyUploads=true;}else;}else {anyLevelMissing=true;}}}else if(texture._volume);else if(texture.array){if(texture.arrayLength===mipObject.length){for(let index=0;index<texture._arrayLength;index++){const arraySource=mipObject[index];if(this.isExternalImage(arraySource)){this.uploadExternalImage(device,arraySource,mipLevel,index);anyUploads=true;}else if(ArrayBuffer.isView(arraySource)){this.uploadTypedArrayData(device,arraySource,mipLevel,index);anyUploads=true;}else;}}else {anyLevelMissing=true;}}else {if(this.isExternalImage(mipObject)){this.uploadExternalImage(device,mipObject,mipLevel,0);anyUploads=true;}else if(ArrayBuffer.isView(mipObject)){this.uploadTypedArrayData(device,mipObject,mipLevel,0);anyUploads=true;}else;}}else {anyLevelMissing=true;}}if(anyUploads&&anyLevelMissing&&texture.mipmaps&&!isCompressedPixelFormat(texture.format)){device.mipmapRenderer.generate(this);}if(texture._gpuSize){texture.adjustVramSizeTracking(device._vram,-texture._gpuSize);}texture._gpuSize=texture.gpuSize;texture.adjustVramSizeTracking(device._vram,texture._gpuSize);}}isExternalImage(image){return image instanceof ImageBitmap||image instanceof HTMLVideoElement||image instanceof HTMLCanvasElement||image instanceof OffscreenCanvas}uploadExternalImage(device,image,mipLevel,index){const src={source:image,origin:[0,0],flipY:false};const dst={texture:this.gpuTexture,mipLevel:mipLevel,origin:[0,0,index],aspect:"all"};const copySize={width:this.descr.size.width,height:this.descr.size.height,depthOrArrayLayers:1};device.submit();dummyUse(image instanceof HTMLCanvasElement&&image.getContext("2d"));device.wgpu.queue.copyExternalImageToTexture(src,dst,copySize);}uploadTypedArrayData(device,data,mipLevel,index){const texture=this.texture;const wgpu=device.wgpu;const dest={texture:this.gpuTexture,origin:[0,0,index],mipLevel:mipLevel};const width=TextureUtils.calcLevelDimension(texture.width,mipLevel);const height=TextureUtils.calcLevelDimension(texture.height,mipLevel);TextureUtils.calcLevelGpuSize(width,height,1,texture.format);const formatInfo=pixelFormatInfo.get(texture.format);let dataLayout;let size;if(formatInfo.size){dataLayout={offset:0,bytesPerRow:formatInfo.size*width,rowsPerImage:height};size={width:width,height:height};}else if(formatInfo.blockSize){const blockDim=size=>{return Math.floor((size+3)/4)};dataLayout={offset:0,bytesPerRow:formatInfo.blockSize*blockDim(width),rowsPerImage:blockDim(height)};size={width:Math.max(4,width),height:Math.max(4,height)};}else;device.submit();wgpu.queue.writeTexture(dest,data,dataLayout,size);}constructor(texture){this.gpuTexture=void 0;this.view=void 0;this.samplers=[];this.descr=void 0;this.format=void 0;this.texture=texture;this.format=gpuTextureFormats[texture.format];this.create(texture.device);}}class WebgpuUniformBuffer extends WebgpuBuffer{unlock(uniformBuffer){const device=uniformBuffer.device;super.unlock(device,uniformBuffer.storageInt32.buffer);}constructor(uniformBuffer){super(BUFFERUSAGE_UNIFORM);}}class WebgpuVertexBuffer extends WebgpuBuffer{unlock(vertexBuffer){const device=vertexBuffer.device;super.unlock(device,vertexBuffer.storage);}constructor(vertexBuffer,format,options){super(BUFFERUSAGE_VERTEX|(options!=null&&options.storage?BUFFERUSAGE_STORAGE:0));}}const KEYWORD=/[ \t]*#(ifn?def|if|endif|else|elif|define|undef|extension|include)/g;const DEFINE=/define[ \t]+([^\n]+)\r?(?:\n|$)/g;const EXTENSION=/extension[ \t]+([\w-]+)[ \t]*:[ \t]*(enable|require)/g;const UNDEF=/undef[ \t]+([^\n]+)\r?(?:\n|$)/g;const IF=/(ifdef|ifndef|if)[ \t]*([^\r\n]+)\r?\n/g;const ENDIF=/(endif|else|elif)([ \t][^\r\n]+)?\r?(?:\n|$)/g;const IDENTIFIER$1=/([\w-]+)/;const DEFINED=/(!|\s)?defined\(([\w-]+)\)/;const INVALID=/[><=|&+-]/g;const INCLUDE=/include[ \t]+"([\w-]+)"\r?(?:\n|$)/g;class Preprocessor{static run(source,includes=new Map,stripUnusedColorAttachments=false){source=source.replace(/\/\*[\s\S]*?\*\/|([^\\:]|^)\/\/.*$/gm,"$1");source=source.split(/\r?\n/).map(line=>line.trimEnd()).join("\n");const defines=new Map;if(stripUnusedColorAttachments){const counts=new Map;const regex=/(pcFragColor[1-8])\b/g;const matches=source.match(regex);matches==null||matches.forEach(match=>{var _counts$get;const index=parseInt(match.charAt(match.length-1),10);counts.set(index,((_counts$get=counts.get(index))!=null?_counts$get:0)+1);});counts.forEach((count,index)=>{if(count===1){defines.set(`REMOVE_COLOR_ATTACHMENT_${index}`,"");}});}source=this._preprocess(source,defines,includes);const intDefines=new Map;defines.forEach((value,key)=>{if(Number.isInteger(parseFloat(value))&&!value.includes(".")){intDefines.set(key,value);}});source=this.RemoveEmptyLines(source);source=this.processArraySize(source,intDefines);return source}static processArraySize(source,intDefines){if(source!==null){intDefines.forEach((value,key)=>{source=source.replace(new RegExp(`\\[${key}\\]`,"g"),`[${value}]`);});}return source}static RemoveEmptyLines(source){if(source!==null){source=source.split(/\r?\n/).map(line=>line.trim()===""?"":line).join("\n");source=source.replace(/(\n\n){3,}/g,"\n\n");}return source}static _preprocess(source,defines=new Map,includes){const originalSource=source;const stack=[];let error=false;let match;while((match=KEYWORD.exec(source))!==null){const keyword=match[1];switch(keyword){case"define":{DEFINE.lastIndex=match.index;const define=DEFINE.exec(source);error||(error=define===null);const expression=define[1];IDENTIFIER$1.lastIndex=define.index;const identifierValue=IDENTIFIER$1.exec(expression);const identifier=identifierValue[1];let value=expression.substring(identifier.length).trim();if(value==="")value="true";const keep=Preprocessor._keep(stack);if(keep){defines.set(identifier,value);}KEYWORD.lastIndex=define.index+define[0].length;break}case"undef":{UNDEF.lastIndex=match.index;const undef=UNDEF.exec(source);const identifier=undef[1].trim();const keep=Preprocessor._keep(stack);if(keep){defines.delete(identifier);}KEYWORD.lastIndex=undef.index+undef[0].length;break}case"extension":{EXTENSION.lastIndex=match.index;const extension=EXTENSION.exec(source);error||(error=extension===null);if(extension){const identifier=extension[1];const keep=Preprocessor._keep(stack);if(keep){defines.set(identifier,"true");}}KEYWORD.lastIndex=extension.index+extension[0].length;break}case"ifdef":case"ifndef":case"if":{IF.lastIndex=match.index;const iff=IF.exec(source);const expression=iff[2];const evaluated=Preprocessor.evaluate(expression,defines);error||(error=evaluated.error);let result=evaluated.result;if(keyword==="ifndef"){result=!result;}stack.push({anyKeep:result,keep:result,start:match.index,end:IF.lastIndex});KEYWORD.lastIndex=iff.index+iff[0].length;break}case"endif":case"else":case"elif":{ENDIF.lastIndex=match.index;const endif=ENDIF.exec(source);const blockInfo=stack.pop();const blockCode=blockInfo.keep?source.substring(blockInfo.end,match.index):"";source=source.substring(0,blockInfo.start)+blockCode+source.substring(ENDIF.lastIndex);KEYWORD.lastIndex=blockInfo.start+blockCode.length;const endifCommand=endif[1];if(endifCommand==="else"||endifCommand==="elif"){let result=false;if(!blockInfo.anyKeep){if(endifCommand==="else"){result=!blockInfo.keep;}else {const evaluated=Preprocessor.evaluate(endif[2],defines);result=evaluated.result;error||(error=evaluated.error);}}stack.push({anyKeep:blockInfo.anyKeep||result,keep:result,start:KEYWORD.lastIndex,end:KEYWORD.lastIndex});}break}case"include":{INCLUDE.lastIndex=match.index;const include=INCLUDE.exec(source);error||(error=include===null);const identifier=include[1].trim();const keep=Preprocessor._keep(stack);if(keep){const includeSource=includes==null?void 0:includes.get(identifier);if(includeSource){source=source.substring(0,include.index-1)+includeSource+source.substring(INCLUDE.lastIndex);KEYWORD.lastIndex=include.index;}else {console.error(`Include not found: ${identifier}`);error=true;}}break}}}if(error){console.warn("Failed to preprocess shader: ",{source:originalSource});return originalSource}return source}static _keep(stack){for(let i=0;i<stack.length;i++){if(!stack[i].keep){return false}}return true}static evaluate(expression,defines){const correct=INVALID.exec(expression)===null;let invert=false;const defined=DEFINED.exec(expression);if(defined){invert=defined[1]==="!";expression=defined[2];}expression=expression.trim();let exists=defines.has(expression);if(invert){exists=!exists;}return {result:exists,error:!correct}}}let id$8=0;class Shader{init(){this.ready=false;this.failed=false;}get label(){return `Shader Id ${this.id} ${this.name}`}destroy(){this.device.onDestroyShader(this);this.impl.destroy(this);}loseContext(){this.init();this.impl.loseContext();}restoreContext(){this.impl.restoreContext(this.device,this);}constructor(graphicsDevice,definition){this.meshUniformBufferFormat=void 0;this.meshBindGroupFormat=void 0;this.id=id$8++;this.device=graphicsDevice;this.definition=definition;this.name=definition.name||"Untitled";this.init();if(definition.cshader);else {definition.vshader=Preprocessor.run(definition.vshader,definition.vincludes);const stripUnusedColorAttachments=graphicsDevice.isWebGL2&&(platform.name==="osx"||platform.name==="ios");definition.fshader=Preprocessor.run(definition.fshader,definition.fincludes,stripUnusedColorAttachments);}this.impl=graphicsDevice.createShaderImpl(this);}}let id$7=0;class BindGroup{destroy(){this.impl.destroy();this.impl=null;this.format=null;this.defaultUniformBuffer=null;}setUniformBuffer(name,uniformBuffer){const index=this.format.bufferFormatsMap.get(name);if(this.uniformBuffers[index]!==uniformBuffer){this.uniformBuffers[index]=uniformBuffer;this.dirty=true;}}setStorageBuffer(name,storageBuffer){const index=this.format.storageBufferFormatsMap.get(name);if(this.storageBuffers[index]!==storageBuffer){this.storageBuffers[index]=storageBuffer;this.dirty=true;}}setTexture(name,texture){const index=this.format.textureFormatsMap.get(name);if(this.textures[index]!==texture){this.textures[index]=texture;this.dirty=true;}else if(this.renderVersionUpdated<texture.renderVersionDirty){this.dirty=true;}}setStorageTexture(name,texture){const index=this.format.storageTextureFormatsMap.get(name);if(this.storageTextures[index]!==texture){this.storageTextures[index]=texture;this.dirty=true;}else if(this.renderVersionUpdated<texture.renderVersionDirty){this.dirty=true;}}updateUniformBuffers(){for(let i=0;i<this.uniformBuffers.length;i++){this.uniformBuffers[i].update();}}update(){const{textureFormats,storageTextureFormats,storageBufferFormats}=this.format;for(let i=0;i<textureFormats.length;i++){const textureFormat=textureFormats[i];const value=textureFormat.scopeId.value;this.setTexture(textureFormat.name,value);}for(let i=0;i<storageTextureFormats.length;i++){const storageTextureFormat=storageTextureFormats[i];const value=storageTextureFormat.scopeId.value;this.setStorageTexture(storageTextureFormat.name,value);}for(let i=0;i<storageBufferFormats.length;i++){const storageBufferFormat=storageBufferFormats[i];const value=storageBufferFormat.scopeId.value;this.setStorageBuffer(storageBufferFormat.name,value);}this.uniformBufferOffsets.length=this.uniformBuffers.length;for(let i=0;i<this.uniformBuffers.length;i++){const uniformBuffer=this.uniformBuffers[i];this.uniformBufferOffsets[i]=uniformBuffer.offset;if(this.renderVersionUpdated<uniformBuffer.renderVersionDirty){this.dirty=true;}}if(this.dirty){this.dirty=false;this.renderVersionUpdated=this.device.renderVersion;this.impl.update(this);}}constructor(graphicsDevice,format,defaultUniformBuffer){this.renderVersionUpdated=-1;this.uniformBuffers=void 0;this.uniformBufferOffsets=[];this.id=id$7++;this.device=graphicsDevice;this.format=format;this.dirty=true;this.impl=graphicsDevice.createBindGroupImpl(this);this.textures=[];this.storageTextures=[];this.storageBuffers=[];this.uniformBuffers=[];this.defaultUniformBuffer=defaultUniformBuffer;if(defaultUniformBuffer){this.setUniformBuffer(UNIFORM_BUFFER_DEFAULT_SLOT_NAME,defaultUniformBuffer);}}}class DynamicBuffer{constructor(device){this.device=void 0;this.device=device;}}class UsedBuffer{constructor(){this.gpuBuffer=void 0;this.stagingBuffer=void 0;this.offset=void 0;this.size=void 0;}}class DynamicBufferAllocation{constructor(){this.storage=void 0;this.gpuBuffer=void 0;this.offset=void 0;}}class DynamicBuffers{destroy(){this.gpuBuffers.forEach(gpuBuffer=>{gpuBuffer.destroy(this.device);});this.gpuBuffers=null;this.stagingBuffers.forEach(stagingBuffer=>{stagingBuffer.destroy(this.device);});this.stagingBuffers=null;this.usedBuffers=null;this.activeBuffer=null;}alloc(allocation,size){if(this.activeBuffer){const _alignedStart=math.roundUp(this.activeBuffer.size,this.bufferAlignment);const space=this.bufferSize-_alignedStart;if(space<size){this.scheduleSubmit();}}if(!this.activeBuffer){let gpuBuffer=this.gpuBuffers.pop();if(!gpuBuffer){gpuBuffer=this.createBuffer(this.device,this.bufferSize,false);}let stagingBuffer=this.stagingBuffers.pop();if(!stagingBuffer){stagingBuffer=this.createBuffer(this.device,this.bufferSize,true);}this.activeBuffer=new UsedBuffer;this.activeBuffer.stagingBuffer=stagingBuffer;this.activeBuffer.gpuBuffer=gpuBuffer;this.activeBuffer.offset=0;this.activeBuffer.size=0;}const activeBuffer=this.activeBuffer;const alignedStart=math.roundUp(activeBuffer.size,this.bufferAlignment);allocation.gpuBuffer=activeBuffer.gpuBuffer;allocation.offset=alignedStart;allocation.storage=activeBuffer.stagingBuffer.alloc(alignedStart,size);activeBuffer.size=alignedStart+size;}scheduleSubmit(){if(this.activeBuffer){this.usedBuffers.push(this.activeBuffer);this.activeBuffer=null;}}submit(){this.scheduleSubmit();}constructor(device,bufferSize,bufferAlignment){this.bufferSize=void 0;this.gpuBuffers=[];this.stagingBuffers=[];this.usedBuffers=[];this.activeBuffer=null;this.device=device;this.bufferSize=bufferSize;this.bufferAlignment=bufferAlignment;}}const _updateFunctions=[];_updateFunctions[UNIFORMTYPE_FLOAT]=function(uniformBuffer,value,offset){const dst=uniformBuffer.storageFloat32;dst[offset]=value;};_updateFunctions[UNIFORMTYPE_VEC2]=(uniformBuffer,value,offset)=>{const dst=uniformBuffer.storageFloat32;dst[offset]=value[0];dst[offset+1]=value[1];};_updateFunctions[UNIFORMTYPE_VEC3]=(uniformBuffer,value,offset)=>{const dst=uniformBuffer.storageFloat32;dst[offset]=value[0];dst[offset+1]=value[1];dst[offset+2]=value[2];};_updateFunctions[UNIFORMTYPE_VEC4]=(uniformBuffer,value,offset)=>{const dst=uniformBuffer.storageFloat32;dst[offset]=value[0];dst[offset+1]=value[1];dst[offset+2]=value[2];dst[offset+3]=value[3];};_updateFunctions[UNIFORMTYPE_INT]=function(uniformBuffer,value,offset){const dst=uniformBuffer.storageInt32;dst[offset]=value;};_updateFunctions[UNIFORMTYPE_IVEC2]=function(uniformBuffer,value,offset){const dst=uniformBuffer.storageInt32;dst[offset]=value[0];dst[offset+1]=value[1];};_updateFunctions[UNIFORMTYPE_IVEC3]=function(uniformBuffer,value,offset){const dst=uniformBuffer.storageInt32;dst[offset]=value[0];dst[offset+1]=value[1];dst[offset+2]=value[2];};_updateFunctions[UNIFORMTYPE_IVEC4]=function(uniformBuffer,value,offset){const dst=uniformBuffer.storageInt32;dst[offset]=value[0];dst[offset+1]=value[1];dst[offset+2]=value[2];dst[offset+3]=value[3];};_updateFunctions[UNIFORMTYPE_MAT2]=(uniformBuffer,value,offset)=>{const dst=uniformBuffer.storageFloat32;dst[offset]=value[0];dst[offset+1]=value[1];dst[offset+4]=value[2];dst[offset+5]=value[3];dst[offset+8]=value[4];dst[offset+9]=value[5];};_updateFunctions[UNIFORMTYPE_MAT3]=(uniformBuffer,value,offset)=>{const dst=uniformBuffer.storageFloat32;dst[offset]=value[0];dst[offset+1]=value[1];dst[offset+2]=value[2];dst[offset+4]=value[3];dst[offset+5]=value[4];dst[offset+6]=value[5];dst[offset+8]=value[6];dst[offset+9]=value[7];dst[offset+10]=value[8];};_updateFunctions[UNIFORMTYPE_FLOATARRAY]=function(uniformBuffer,value,offset,count){const dst=uniformBuffer.storageFloat32;for(let i=0;i<count;i++){dst[offset+i*4]=value[i];}};_updateFunctions[UNIFORMTYPE_VEC2ARRAY]=(uniformBuffer,value,offset,count)=>{const dst=uniformBuffer.storageFloat32;for(let i=0;i<count;i++){dst[offset+i*4]=value[i*2];dst[offset+i*4+1]=value[i*2+1];}};_updateFunctions[UNIFORMTYPE_VEC3ARRAY]=(uniformBuffer,value,offset,count)=>{const dst=uniformBuffer.storageFloat32;for(let i=0;i<count;i++){dst[offset+i*4]=value[i*3];dst[offset+i*4+1]=value[i*3+1];dst[offset+i*4+2]=value[i*3+2];}};_updateFunctions[UNIFORMTYPE_UINT]=(uniformBuffer,value,offset,count)=>{const dst=uniformBuffer.storageUint32;dst[offset]=value;};_updateFunctions[UNIFORMTYPE_UVEC2]=(uniformBuffer,value,offset,count)=>{const dst=uniformBuffer.storageUint32;dst[offset]=value[0];dst[offset+1]=value[1];};_updateFunctions[UNIFORMTYPE_UVEC3]=(uniformBuffer,value,offset,count)=>{const dst=uniformBuffer.storageUint32;dst[offset]=value[0];dst[offset+1]=value[1];dst[offset+2]=value[2];};_updateFunctions[UNIFORMTYPE_UVEC4]=(uniformBuffer,value,offset,count)=>{const dst=uniformBuffer.storageUint32;dst[offset]=value[0];dst[offset+1]=value[1];dst[offset+2]=value[2];dst[offset+3]=value[3];};_updateFunctions[UNIFORMTYPE_INTARRAY]=function(uniformBuffer,value,offset,count){const dst=uniformBuffer.storageInt32;for(let i=0;i<count;i++){dst[offset+i*4]=value[i];}};_updateFunctions[UNIFORMTYPE_BOOLARRAY]=_updateFunctions[UNIFORMTYPE_INTARRAY];_updateFunctions[UNIFORMTYPE_UINTARRAY]=function(uniformBuffer,value,offset,count){const dst=uniformBuffer.storageUint32;for(let i=0;i<count;i++){dst[offset+i*4]=value[i];}};_updateFunctions[UNIFORMTYPE_IVEC2ARRAY]=(uniformBuffer,value,offset,count)=>{const dst=uniformBuffer.storageInt32;for(let i=0;i<count;i++){dst[offset+i*4]=value[i*2];dst[offset+i*4+1]=value[i*2+1];}};_updateFunctions[UNIFORMTYPE_BVEC2ARRAY]=_updateFunctions[UNIFORMTYPE_IVEC2ARRAY];_updateFunctions[UNIFORMTYPE_UVEC2ARRAY]=(uniformBuffer,value,offset,count)=>{const dst=uniformBuffer.storageUint32;for(let i=0;i<count;i++){dst[offset+i*4]=value[i*2];dst[offset+i*4+1]=value[i*2+1];}};_updateFunctions[UNIFORMTYPE_IVEC3ARRAY]=(uniformBuffer,value,offset,count)=>{const dst=uniformBuffer.storageInt32;for(let i=0;i<count;i++){dst[offset+i*4]=value[i*3];dst[offset+i*4+1]=value[i*3+1];dst[offset+i*4+2]=value[i*3+2];}};_updateFunctions[UNIFORMTYPE_BVEC3ARRAY]=_updateFunctions[UNIFORMTYPE_IVEC3ARRAY];_updateFunctions[UNIFORMTYPE_UVEC3ARRAY]=(uniformBuffer,value,offset,count)=>{const dst=uniformBuffer.storageUint32;for(let i=0;i<count;i++){dst[offset+i*4]=value[i*3];dst[offset+i*4+1]=value[i*3+1];dst[offset+i*4+2]=value[i*3+2];}};class UniformBuffer{destroy(){if(this.persistent){const device=this.device;this.impl.destroy(device);device._vram.ub-=this.format.byteSize;}}get offset(){return this.persistent?0:this.allocation.offset}assignStorage(storage){this.storageInt32=storage;this.storageUint32=new Uint32Array(storage.buffer,storage.byteOffset,storage.byteLength/4);this.storageFloat32=new Float32Array(storage.buffer,storage.byteOffset,storage.byteLength/4);}loseContext(){var _this$impl;(_this$impl=this.impl)==null||_this$impl.loseContext();}setUniform(uniformFormat){const offset=uniformFormat.offset;const value=uniformFormat.scopeId.value;if(value!==null&&value!==undefined){const updateFunction=_updateFunctions[uniformFormat.updateType];if(updateFunction){updateFunction(this,value,offset,uniformFormat.count);}else {this.storageFloat32.set(value,offset);}}}set(name){const uniformFormat=this.format.map.get(name);if(uniformFormat){this.setUniform(uniformFormat);}}update(){const persistent=this.persistent;if(!persistent){const allocation=this.allocation;const oldGpuBuffer=allocation.gpuBuffer;this.device.dynamicBuffers.alloc(allocation,this.format.byteSize);this.assignStorage(allocation.storage);if(oldGpuBuffer!==allocation.gpuBuffer){this.renderVersionDirty=this.device.renderVersion;}}const uniforms=this.format.uniforms;for(let i=0;i<uniforms.length;i++){this.setUniform(uniforms[i]);}if(persistent){this.impl.unlock(this);}else {this.storageFloat32=null;this.storageInt32=null;}}constructor(graphicsDevice,format,persistent=true){this.device=void 0;this.persistent=void 0;this.allocation=void 0;this.storageFloat32=void 0;this.storageInt32=void 0;this.storageUint32=void 0;this.renderVersionDirty=0;this.device=graphicsDevice;this.format=format;this.persistent=persistent;if(persistent){this.impl=graphicsDevice.createUniformBufferImpl(this);const storage=new ArrayBuffer(format.byteSize);this.assignStorage(new Int32Array(storage));graphicsDevice._vram.ub+=this.format.byteSize;}else {this.allocation=new DynamicBufferAllocation;}}}const primitive={type:PRIMITIVE_TRISTRIP,base:0,count:4,indexed:false};class WebgpuClearRenderer{destroy(){this.shader.destroy();this.shader=null;this.uniformBuffer.destroy();this.uniformBuffer=null;this.bindGroup.destroy();this.bindGroup=null;}clear(device,renderTarget,options,defaultOptions){var _options$flags;options=options||defaultOptions;const flags=(_options$flags=options.flags)!=null?_options$flags:defaultOptions.flags;if(flags!==0){if(flags&CLEARFLAG_COLOR&&(renderTarget.colorBuffer||renderTarget.impl.assignedColorTexture)){var _options$color;const color=(_options$color=options.color)!=null?_options$color:defaultOptions.color;this.colorData.set(color);device.setBlendState(BlendState.NOBLEND);}else {device.setBlendState(BlendState.NOWRITE);}this.colorId.setValue(this.colorData);if(flags&CLEARFLAG_DEPTH&&renderTarget.depth){var _options$depth;const depth=(_options$depth=options.depth)!=null?_options$depth:defaultOptions.depth;this.depthId.setValue(depth);device.setDepthState(DepthState.WRITEDEPTH);}else {this.depthId.setValue(1);device.setDepthState(DepthState.NODEPTH);}if(flags&CLEARFLAG_STENCIL&&renderTarget.stencil);device.setCullMode(CULLFACE_NONE);device.setShader(this.shader);const bindGroup=this.bindGroup;bindGroup.defaultUniformBuffer.update();bindGroup.update();device.setBindGroup(BINDGROUP_MESH,bindGroup);device.draw(primitive);}}constructor(device){const code=`

						struct ub_mesh {
								color : vec4f,
								depth: f32
						}

						@group(0) @binding(0) var<uniform> ubMesh : ub_mesh;

						var<private> pos : array<vec2f, 4> = array<vec2f, 4>(
								vec2(-1.0, 1.0), vec2(1.0, 1.0),
								vec2(-1.0, -1.0), vec2(1.0, -1.0)
						);

						struct VertexOutput {
								@builtin(position) position : vec4f
						}

						@vertex
						fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
								var output : VertexOutput;
								output.position = vec4(pos[vertexIndex], ubMesh.depth, 1.0);
								return output;
						}

						@fragment
						fn fragmentMain() -> @location(0) vec4f {
								return ubMesh.color;
						}
				`;this.shader=new Shader(device,{name:"WebGPUClearRendererShader",shaderLanguage:SHADERLANGUAGE_WGSL,vshader:code,fshader:code});this.uniformBuffer=new UniformBuffer(device,new UniformBufferFormat(device,[new UniformFormat("color",UNIFORMTYPE_VEC4),new UniformFormat("depth",UNIFORMTYPE_FLOAT)]),false);const bindGroupFormat=new BindGroupFormat(device,[new BindUniformBufferFormat(UNIFORM_BUFFER_DEFAULT_SLOT_NAME,SHADERSTAGE_VERTEX|SHADERSTAGE_FRAGMENT)]);this.bindGroup=new BindGroup(device,bindGroupFormat,this.uniformBuffer);this.colorData=new Float32Array(4);this.colorId=device.scope.resolve("color");this.depthId=device.scope.resolve("depth");}}class WebgpuMipmapRenderer{destroy(){this.shader.destroy();this.shader=null;}generate(webgpuTexture){var _device$commandEncode;const textureDescr=webgpuTexture.descr;if(textureDescr.mipLevelCount<=1){return}if(webgpuTexture.texture.volume){return}const device=this.device;const wgpu=device.wgpu;const webgpuShader=this.shader.impl;const pipeline=wgpu.createRenderPipeline({layout:"auto",vertex:{module:webgpuShader.getVertexShaderModule(),entryPoint:webgpuShader.vertexEntryPoint},fragment:{module:webgpuShader.getFragmentShaderModule(),entryPoint:webgpuShader.fragmentEntryPoint,targets:[{format:textureDescr.format}]},primitive:{topology:"triangle-strip"}});const texture=webgpuTexture.texture;const numFaces=texture.cubemap?6:texture.array?texture.arrayLength:1;const srcViews=[];for(let face=0;face<numFaces;face++){srcViews.push(webgpuTexture.createView({dimension:"2d",baseMipLevel:0,mipLevelCount:1,baseArrayLayer:face}));}const commandEncoder=(_device$commandEncode=device.commandEncoder)!=null?_device$commandEncode:wgpu.createCommandEncoder();for(let i=1;i<textureDescr.mipLevelCount;i++){for(let face=0;face<numFaces;face++){const dstView=webgpuTexture.createView({dimension:"2d",baseMipLevel:i,mipLevelCount:1,baseArrayLayer:face});const passEncoder=commandEncoder.beginRenderPass({colorAttachments:[{view:dstView,loadOp:"clear",storeOp:"store"}]});const bindGroup=wgpu.createBindGroup({layout:pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:this.minSampler},{binding:1,resource:srcViews[face]}]});passEncoder.setPipeline(pipeline);passEncoder.setBindGroup(0,bindGroup);passEncoder.draw(4);passEncoder.end();srcViews[face]=dstView;}}if(!device.commandEncoder){const cb=commandEncoder.finish();device.addCommandBuffer(cb);}device.pipeline=null;}constructor(device){this.device=void 0;this.device=device;const code=`
 
						var<private> pos : array<vec2f, 4> = array<vec2f, 4>(
								vec2(-1.0, 1.0), vec2(1.0, 1.0),
								vec2(-1.0, -1.0), vec2(1.0, -1.0)
						);

						struct VertexOutput {
								@builtin(position) position : vec4f,
								@location(0) texCoord : vec2f
						};

						@vertex
						fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
							var output : VertexOutput;
							output.texCoord = pos[vertexIndex] * vec2f(0.5, -0.5) + vec2f(0.5);
							output.position = vec4f(pos[vertexIndex], 0, 1);
							return output;
						}

						@group(0) @binding(0) var imgSampler : sampler;
						@group(0) @binding(1) var img : texture_2d<f32>;

						@fragment
						fn fragmentMain(@location(0) texCoord : vec2f) -> @location(0) vec4f {
							return textureSample(img, imgSampler, texCoord);
						}
				`;this.shader=new Shader(device,{name:"WebGPUMipmapRendererShader",shaderLanguage:SHADERLANGUAGE_WGSL,vshader:code,fshader:code});this.minSampler=device.wgpu.createSampler({minFilter:"linear"});}}class WebgpuDynamicBuffer extends DynamicBuffer{destroy(device){device._vram.ub-=this.buffer.size;this.buffer.destroy();this.buffer=null;}onAvailable(){this.mappedRange=this.buffer.getMappedRange();}alloc(offset,size){return new Int32Array(this.mappedRange,offset,size/4)}constructor(device,size,isStaging){super(device);this.buffer=null;this.mappedRange=null;this.buffer=device.wgpu.createBuffer({size:size,usage:isStaging?GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,mappedAtCreation:isStaging});if(isStaging){this.onAvailable();}device._vram.ub+=size;}}class WebgpuDynamicBuffers extends DynamicBuffers{createBuffer(device,size,isStaging){return new WebgpuDynamicBuffer(device,size,isStaging)}submit(){super.submit();const count=this.usedBuffers.length;if(count){const device=this.device;const gpuBuffers=this.gpuBuffers;const commandEncoder=device.wgpu.createCommandEncoder();for(let i=count-1;i>=0;i--){const usedBuffer=this.usedBuffers[i];const{stagingBuffer,gpuBuffer,offset,size}=usedBuffer;const src=stagingBuffer.buffer;src.unmap();commandEncoder.copyBufferToBuffer(src,offset,gpuBuffer.buffer,offset,size);gpuBuffers.push(gpuBuffer);}const cb=commandEncoder.finish();device.addCommandBuffer(cb,true);for(let i=0;i<count;i++){const stagingBuffer=this.usedBuffers[i].stagingBuffer;this.pendingStagingBuffers.push(stagingBuffer);}this.usedBuffers.length=0;}}onCommandBuffersSubmitted(){const count=this.pendingStagingBuffers.length;if(count){for(let i=0;i<count;i++){const stagingBuffer=this.pendingStagingBuffers[i];stagingBuffer.buffer.mapAsync(GPUMapMode.WRITE).then(()=>{if(this.stagingBuffers){stagingBuffer.onAvailable();this.stagingBuffers.push(stagingBuffer);}});}this.pendingStagingBuffers.length=0;}}constructor(...args){super(...args);this.pendingStagingBuffers=[];}}class GpuProfiler{loseContext(){this.pastFrameAllocations.clear();}set enabled(value){this._enableRequest=value;}get enabled(){return this._enableRequest}processEnableRequest(){if(this._enableRequest!==this._enabled){this._enabled=this._enableRequest;if(!this._enabled){this._frameTime=0;}}}request(renderVersion){this.pastFrameAllocations.set(renderVersion,this.frameAllocations);this.frameAllocations=[];}report(renderVersion,timings){if(timings){const allocations=this.pastFrameAllocations.get(renderVersion);if(timings.length>0){this._frameTime=timings[0];}if(Tracing.get(TRACEID_GPU_TIMINGS)){for(let i=0;i<allocations.length;++i){allocations[i];}}}this.pastFrameAllocations.delete(renderVersion);}getSlot(name){const slot=this.frameAllocations.length;this.frameAllocations.push(name);return slot}get slotCount(){return this.frameAllocations.length}constructor(){this.frameAllocations=[];this.pastFrameAllocations=new Map;this._enabled=false;this._enableRequest=false;this._frameTime=0;}}class WebgpuQuerySet{destroy(){var _this$querySet,_this$queryBuffer;(_this$querySet=this.querySet)==null||_this$querySet.destroy();this.querySet=null;(_this$queryBuffer=this.queryBuffer)==null||_this$queryBuffer.destroy();this.queryBuffer=null;this.activeStagingBuffer=null;this.stagingBuffers.forEach(stagingBuffer=>{stagingBuffer.destroy();});this.stagingBuffers=null;}getStagingBuffer(){let stagingBuffer=this.stagingBuffers.pop();if(!stagingBuffer){stagingBuffer=this.device.wgpu.createBuffer({size:this.queryBuffer.size,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});}return stagingBuffer}resolve(count){const device=this.device;const commandEncoder=device.wgpu.createCommandEncoder();commandEncoder.resolveQuerySet(this.querySet,0,count,this.queryBuffer,0);const activeStagingBuffer=this.getStagingBuffer();this.activeStagingBuffer=activeStagingBuffer;commandEncoder.copyBufferToBuffer(this.queryBuffer,0,activeStagingBuffer,0,this.bytesPerSlot*count);const cb=commandEncoder.finish();device.addCommandBuffer(cb);}request(count,renderVersion){const stagingBuffer=this.activeStagingBuffer;this.activeStagingBuffer=null;return stagingBuffer.mapAsync(GPUMapMode.READ).then(()=>{var _this$stagingBuffers;const srcTimings=new BigInt64Array(stagingBuffer.getMappedRange());const timings=[];for(let i=0;i<count;i++){timings.push(Number(srcTimings[i*2+1]-srcTimings[i*2])*1e-6);}stagingBuffer.unmap();(_this$stagingBuffers=this.stagingBuffers)==null||_this$stagingBuffers.push(stagingBuffer);return {renderVersion,timings}})}constructor(device,isTimestamp,capacity){this.querySet=void 0;this.stagingBuffers=[];this.activeStagingBuffer=null;this.bytesPerSlot=void 0;this.device=device;this.capacity=capacity;this.bytesPerSlot=isTimestamp?8:4;const wgpu=device.wgpu;this.querySet=wgpu.createQuerySet({type:isTimestamp?"timestamp":"occlusion",count:capacity});this.queryBuffer=wgpu.createBuffer({size:this.bytesPerSlot*capacity,usage:GPUBufferUsage.QUERY_RESOLVE|GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST});}}class WebgpuGpuProfiler extends GpuProfiler{destroy(){var _this$timestampQuerie;(_this$timestampQuerie=this.timestampQueriesSet)==null||_this$timestampQuerie.destroy();this.timestampQueriesSet=null;}frameStart(){this.processEnableRequest();}frameEnd(){if(this._enabled){var _this$timestampQuerie2;(_this$timestampQuerie2=this.timestampQueriesSet)==null||_this$timestampQuerie2.resolve(this.slotCount*2);}}request(){if(this._enabled){var _this$timestampQuerie3;const renderVersion=this.device.renderVersion;(_this$timestampQuerie3=this.timestampQueriesSet)==null||_this$timestampQuerie3.request(this.slotCount,renderVersion).then(results=>{this.report(results.renderVersion,results.timings);});super.request(renderVersion);}}constructor(device){super();this.device=void 0;this.frameGPUMarkerSlot=void 0;this.device=device;this.timestampQueriesSet=device.supportsTimestampQuery?new WebgpuQuerySet(device,true,512):null;}}class WebgpuResolver{destroy(){this.shader.destroy();this.shader=null;this.pipelineCache=null;}getPipeline(format){let pipeline=this.pipelineCache.get(format);if(!pipeline){pipeline=this.createPipeline(format);this.pipelineCache.set(format,pipeline);}return pipeline}createPipeline(format){const webgpuShader=this.shader.impl;const pipeline=this.device.wgpu.createRenderPipeline({layout:"auto",vertex:{module:webgpuShader.getVertexShaderModule(),entryPoint:webgpuShader.vertexEntryPoint},fragment:{module:webgpuShader.getFragmentShaderModule(),entryPoint:webgpuShader.fragmentEntryPoint,targets:[{format:format}]},primitive:{topology:"triangle-strip"}});return pipeline}resolveDepth(commandEncoder,sourceTexture,destinationTexture){const device=this.device;const wgpu=device.wgpu;const pipeline=this.getPipeline(destinationTexture.format);const numFaces=sourceTexture.depthOrArrayLayers;for(let face=0;face<numFaces;face++){const srcView=sourceTexture.createView({dimension:"2d",aspect:"depth-only",baseMipLevel:0,mipLevelCount:1,baseArrayLayer:face});const dstView=destinationTexture.createView({dimension:"2d",baseMipLevel:0,mipLevelCount:1,baseArrayLayer:face});const passEncoder=commandEncoder.beginRenderPass({colorAttachments:[{view:dstView,loadOp:"clear",storeOp:"store"}]});const bindGroup=wgpu.createBindGroup({layout:pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:srcView}]});passEncoder.setPipeline(pipeline);passEncoder.setBindGroup(0,bindGroup);passEncoder.draw(4);passEncoder.end();}device.pipeline=null;}constructor(device){this.device=void 0;this.pipelineCache=new Map;this.device=device;const code=`
 
						var<private> pos : array<vec2f, 4> = array<vec2f, 4>(
								vec2(-1.0, 1.0), vec2(1.0, 1.0), vec2(-1.0, -1.0), vec2(1.0, -1.0)
						);

						struct VertexOutput {
								@builtin(position) position : vec4f,
						};

						@vertex
						fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
							var output : VertexOutput;
							output.position = vec4f(pos[vertexIndex], 0, 1);
							return output;
						}

						@group(0) @binding(0) var img : texture_depth_multisampled_2d;

						@fragment
						fn fragmentMain(@builtin(position) fragColor: vec4f) -> @location(0) vec4f {
								// load th depth value from sample index 0
								var depth = textureLoad(img, vec2i(fragColor.xy), 0u);
								return vec4<f32>(depth, 0.0, 0.0, 0.0);
						}
				`;this.shader=new Shader(device,{name:"WebGPUResolverDepthShader",shaderLanguage:SHADERLANGUAGE_WGSL,vshader:code,fshader:code});}}class WebgpuCompute{destroy(){this.uniformBuffers.forEach(ub=>ub.destroy());this.uniformBuffers.length=0;this.bindGroup.destroy();this.bindGroup=null;}updateBindGroup(){const{bindGroup}=this;bindGroup.updateUniformBuffers();bindGroup.update();}dispatch(x,y,z){const device=this.compute.device;device.setBindGroup(0,this.bindGroup);const passEncoder=device.passEncoder;passEncoder.setPipeline(this.pipeline);passEncoder.dispatchWorkgroups(x,y,z);}constructor(compute){this.uniformBuffers=[];this.bindGroup=null;this.compute=compute;const{device,shader}=compute;const{computeBindGroupFormat,computeUniformBufferFormats}=shader.impl;this.bindGroup=new BindGroup(device,computeBindGroupFormat);if(computeUniformBufferFormats){for(const name in computeUniformBufferFormats){if(computeUniformBufferFormats.hasOwnProperty(name)){const ub=new UniformBuffer(device,computeUniformBufferFormats[name],true);this.uniformBuffers.push(ub);this.bindGroup.setUniformBuffer(name,ub);}}}this.pipeline=device.computePipeline.get(shader,computeBindGroupFormat);}}const _uniqueLocations=new Map;class WebgpuGraphicsDevice extends GraphicsDevice{destroy(){this.clearRenderer.destroy();this.clearRenderer=null;this.mipmapRenderer.destroy();this.mipmapRenderer=null;this.resolver.destroy();this.resolver=null;super.destroy();}initDeviceCaps(){var _this$wgpu;const limits=(_this$wgpu=this.wgpu)==null?void 0:_this$wgpu.limits;this.limits=limits;this.precision="highp";this.maxPrecision="highp";this.maxSamples=4;this.maxTextures=16;this.maxTextureSize=limits.maxTextureDimension2D;this.maxCubeMapSize=limits.maxTextureDimension2D;this.maxVolumeSize=limits.maxTextureDimension3D;this.maxColorAttachments=limits.maxColorAttachments;this.maxPixelRatio=1;this.maxAnisotropy=16;this.fragmentUniformsCount=limits.maxUniformBufferBindingSize/16;this.vertexUniformsCount=limits.maxUniformBufferBindingSize/16;this.supportsInstancing=true;this.supportsUniformBuffers=true;this.supportsVolumeTextures=true;this.supportsBoneTextures=true;this.supportsMorphTargetTexturesCore=true;this.supportsAreaLights=true;this.supportsDepthShadow=true;this.supportsGpuParticles=true;this.supportsMrt=true;this.supportsCompute=true;this.extUintElement=true;this.extTextureFloat=true;this.textureFloatRenderable=true;this.textureHalfFloatFilterable=true;this.extTextureHalfFloat=true;this.textureHalfFloatRenderable=true;this.textureHalfFloatUpdatable=true;this.boneLimit=1024;this.supportsImageBitmap=true;this.extStandardDerivatives=true;this.extBlendMinmax=true;this.areaLightLutFormat=this.textureFloatFilterable?PIXELFORMAT_RGBA32F:PIXELFORMAT_RGBA8;this.supportsTextureFetch=true;this.samples=this.backBufferAntialias?4:1;const wgslFeatures=navigator.gpu.wgslLanguageFeatures;this.supportsStorageTextureRead=wgslFeatures==null?void 0:wgslFeatures.has("readonly_and_readwrite_storage_textures");}async initWebGpu(glslangUrl,twgslUrl){var _this$gpuAdapter,_this$wgpu$lost;if(!window.navigator.gpu){throw new Error("Unable to retrieve GPU. Ensure you are using a browser that supports WebGPU rendering.")}const buildUrl=srcPath=>{return new URL(srcPath,window.location.href).toString()};const results=await Promise.all([import(/* @vite-ignore */`${buildUrl(twgslUrl)}`).then(module=>twgsl(twgslUrl.replace(".js",".wasm"))),import(/* @vite-ignore */`${buildUrl(glslangUrl)}`).then(module=>module.default())]);this.twgsl=results[0];this.glslang=results[1];const adapterOptions={powerPreference:this.initOptions.powerPreference!=="default"?this.initOptions.powerPreference:undefined};this.gpuAdapter=await window.navigator.gpu.requestAdapter(adapterOptions);const requiredFeatures=[];const requireFeature=feature=>{const supported=this.gpuAdapter.features.has(feature);if(supported){requiredFeatures.push(feature);}return supported};this.textureFloatFilterable=requireFeature("float32-filterable");this.extCompressedTextureS3TC=requireFeature("texture-compression-bc");this.extCompressedTextureETC=requireFeature("texture-compression-etc2");this.extCompressedTextureASTC=requireFeature("texture-compression-astc");this.supportsTimestampQuery=requireFeature("timestamp-query");this.supportsDepthClip=requireFeature("depth-clip-control");this.supportsDepth32Stencil=requireFeature("depth32float-stencil8");this.supportsIndirectFirstInstance=requireFeature("indirect-first-instance");this.supportsShaderF16=requireFeature("shader-f16");this.supportsStorageRGBA8=requireFeature("bgra8unorm-storage");this.textureRG11B10Renderable=requireFeature("rg11b10ufloat-renderable");const adapterLimits=(_this$gpuAdapter=this.gpuAdapter)==null?void 0:_this$gpuAdapter.limits;const requiredLimits={};if(adapterLimits){for(const limitName in adapterLimits){if(limitName==="minSubgroupSize"||limitName==="maxSubgroupSize"){continue}requiredLimits[limitName]=adapterLimits[limitName];}}const deviceDescr={requiredFeatures,requiredLimits,defaultQueue:{label:"Default Queue"}};this.wgpu=await this.gpuAdapter.requestDevice(deviceDescr);(_this$wgpu$lost=this.wgpu.lost)==null||_this$wgpu$lost.then(info=>{if(info.reason!=="destroyed");});this.initDeviceCaps();this.gpuContext=this.canvas.getContext("webgpu");const preferredCanvasFormat=navigator.gpu.getPreferredCanvasFormat();this.backBufferFormat=preferredCanvasFormat==="rgba8unorm"?PIXELFORMAT_RGBA8:PIXELFORMAT_BGRA8;this.canvasConfig={device:this.wgpu,colorSpace:"srgb",alphaMode:this.initOptions.alpha?"premultiplied":"opaque",format:preferredCanvasFormat,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST,viewFormats:[]};this.gpuContext.configure(this.canvasConfig);this.createBackbuffer();this.clearRenderer=new WebgpuClearRenderer(this);this.mipmapRenderer=new WebgpuMipmapRenderer(this);this.resolver=new WebgpuResolver(this);this.postInit();return this}postInit(){super.postInit();this.initializeRenderState();this.setupPassEncoderDefaults();this.gpuProfiler=new WebgpuGpuProfiler(this);this.dynamicBuffers=new WebgpuDynamicBuffers(this,1024*1024,this.limits.minUniformBufferOffsetAlignment);}createBackbuffer(){this.supportsStencil=this.initOptions.stencil;this.backBuffer=new RenderTarget({name:"WebgpuFramebuffer",graphicsDevice:this,depth:this.initOptions.depth,stencil:this.supportsStencil,samples:this.samples});}frameStart(){super.frameStart();this.gpuProfiler.frameStart();this.submit();const outColorBuffer=this.gpuContext.getCurrentTexture();if(this.backBufferSize.x!==outColorBuffer.width||this.backBufferSize.y!==outColorBuffer.height){this.backBufferSize.set(outColorBuffer.width,outColorBuffer.height);this.backBuffer.destroy();this.backBuffer=null;this.createBackbuffer();}const rt=this.backBuffer;const wrt=rt.impl;wrt.setColorAttachment(0,undefined,outColorBuffer.format);this.initRenderTarget(rt);wrt.assignColorTexture(outColorBuffer);}frameEnd(){super.frameEnd();this.gpuProfiler.frameEnd();this.submit();if(!this.contextLost){this.gpuProfiler.request();}}createBufferImpl(usageFlags){return new WebgpuBuffer(usageFlags)}createUniformBufferImpl(uniformBuffer){return new WebgpuUniformBuffer(uniformBuffer)}createVertexBufferImpl(vertexBuffer,format,options){return new WebgpuVertexBuffer(vertexBuffer,format,options)}createIndexBufferImpl(indexBuffer,options){return new WebgpuIndexBuffer(indexBuffer,options)}createShaderImpl(shader){return new WebgpuShader(shader)}createTextureImpl(texture){return new WebgpuTexture(texture)}createRenderTargetImpl(renderTarget){return new WebgpuRenderTarget(renderTarget)}createBindGroupFormatImpl(bindGroupFormat){return new WebgpuBindGroupFormat(bindGroupFormat)}createBindGroupImpl(bindGroup){return new WebgpuBindGroup}createComputeImpl(compute){return new WebgpuCompute(compute)}setBindGroup(index,bindGroup){if(this.passEncoder){this.passEncoder.setBindGroup(index,bindGroup.impl.bindGroup,bindGroup.uniformBufferOffsets);this.bindGroupFormats[index]=bindGroup.format.impl;}}submitVertexBuffer(vertexBuffer,slot){const format=vertexBuffer.format;const{interleaved,elements}=format;const elementCount=elements.length;const vbBuffer=vertexBuffer.impl.buffer;if(interleaved){this.passEncoder.setVertexBuffer(slot,vbBuffer);return 1}for(let i=0;i<elementCount;i++){this.passEncoder.setVertexBuffer(slot+i,vbBuffer,elements[i].offset);}return elementCount}validateVBLocations(vb0,vb1){const validateVB=vb=>{const{elements}=vb.format;for(let i=0;i<elements.length;i++){const name=elements[i].name;const location=semanticToLocation[name];if(_uniqueLocations.has(location));_uniqueLocations.set(location,name);}};validateVB(vb0);validateVB(vb1);_uniqueLocations.clear();}draw(primitive,numInstances=1,keepBuffers){if(this.shader.ready&&!this.shader.failed){const passEncoder=this.passEncoder;const vb0=this.vertexBuffers[0];const vb1=this.vertexBuffers[1];this.vertexBuffers.length=0;if(vb0){const vbSlot=this.submitVertexBuffer(vb0,0);if(vb1){this.submitVertexBuffer(vb1,vbSlot);}}const pipeline=this.renderPipeline.get(primitive,vb0==null?void 0:vb0.format,vb1==null?void 0:vb1.format,this.shader,this.renderTarget,this.bindGroupFormats,this.blendState,this.depthState,this.cullMode,this.stencilEnabled,this.stencilFront,this.stencilBack);if(this.pipeline!==pipeline){this.pipeline=pipeline;passEncoder.setPipeline(pipeline);}const ib=this.indexBuffer;if(ib){this.indexBuffer=null;passEncoder.setIndexBuffer(ib.impl.buffer,ib.impl.format);passEncoder.drawIndexed(primitive.count,numInstances,primitive.base,0,0);}else {passEncoder.draw(primitive.count,numInstances,primitive.base,0);}}}setShader(shader,asyncCompile=false){if(shader!==this.shader){this.shader=shader;}}setBlendState(blendState){this.blendState.copy(blendState);}setDepthState(depthState){this.depthState.copy(depthState);}setStencilState(stencilFront,stencilBack){if(stencilFront||stencilBack){this.stencilEnabled=true;this.stencilFront.copy(stencilFront!=null?stencilFront:StencilParameters.DEFAULT);this.stencilBack.copy(stencilBack!=null?stencilBack:StencilParameters.DEFAULT);const ref=this.stencilFront.ref;if(this.stencilRef!==ref){this.stencilRef=ref;this.passEncoder.setStencilReference(ref);}}else {this.stencilEnabled=false;}}setBlendColor(r,g,b,a){const c=this.blendColor;if(r!==c.r||g!==c.g||b!==c.b||a!==c.a){c.set(r,g,b,a);this.passEncoder.setBlendConstant(c);}}setCullMode(cullMode){this.cullMode=cullMode;}setAlphaToCoverage(state){}initializeContextCaches(){super.initializeContextCaches();}setupPassEncoderDefaults(){this.pipeline=null;this.stencilRef=0;this.blendColor.set(0,0,0,0);}_uploadDirtyTextures(){this.textures.forEach(texture=>{if(texture._needsUpload||texture._needsMipmaps){texture.upload();}});}startRenderPass(renderPass){this._uploadDirtyTextures();const rt=renderPass.renderTarget||this.backBuffer;this.renderTarget=rt;const wrt=rt.impl;this.commandEncoder=this.wgpu.createCommandEncoder();if(rt!==this.backBuffer){this.initRenderTarget(rt);}wrt.setupForRenderPass(renderPass);const renderPassDesc=wrt.renderPassDescriptor;if(this.gpuProfiler._enabled){if(this.gpuProfiler.timestampQueriesSet){const slot=this.gpuProfiler.getSlot(renderPass.name);renderPassDesc.timestampWrites={querySet:this.gpuProfiler.timestampQueriesSet.querySet,beginningOfPassWriteIndex:slot*2,endOfPassWriteIndex:slot*2+1};}}this.passEncoder=this.commandEncoder.beginRenderPass(renderPassDesc);this.setupPassEncoderDefaults();const{width,height}=rt;this.setViewport(0,0,width,height);this.setScissor(0,0,width,height);this.insideRenderPass=true;}endRenderPass(renderPass){this.passEncoder.end();this.passEncoder=null;this.insideRenderPass=false;this.bindGroupFormats.length=0;for(let i=0;i<renderPass.colorArrayOps.length;i++){const colorOps=renderPass.colorArrayOps[i];if(colorOps.mipmaps){this.mipmapRenderer.generate(renderPass.renderTarget._colorBuffers[i].impl);}}const cb=this.commandEncoder.finish();this.addCommandBuffer(cb);this.commandEncoder=null;}startComputePass(){this.commandEncoder=this.wgpu.createCommandEncoder();this.pipeline=null;this.passEncoder=this.commandEncoder.beginComputePass();this.insideRenderPass=true;}endComputePass(){this.passEncoder.end();this.passEncoder=null;this.insideRenderPass=false;this.bindGroupFormats.length=0;const cb=this.commandEncoder.finish();this.addCommandBuffer(cb);this.commandEncoder=null;}computeDispatch(computes){this.startComputePass();for(let i=0;i<computes.length;i++){const compute=computes[i];compute.applyParameters();compute.impl.updateBindGroup();}for(let i=0;i<computes.length;i++){const compute=computes[i];compute.impl.dispatch(compute.countX,compute.countY,compute.countZ);}this.endComputePass();}addCommandBuffer(commandBuffer,front=false){if(front){this.commandBuffers.unshift(commandBuffer);}else {this.commandBuffers.push(commandBuffer);}}submit(){if(this.commandBuffers.length>0){this.dynamicBuffers.submit();this.wgpu.queue.submit(this.commandBuffers);this.commandBuffers.length=0;this.dynamicBuffers.onCommandBuffersSubmitted();}}clear(options){if(options.flags){this.clearRenderer.clear(this,this.renderTarget,options,this.defaultClearOptions);}}setViewport(x,y,w,h){if(this.passEncoder){if(!this.renderTarget.flipY){y=this.renderTarget.height-y-h;}this.vx=x;this.vy=y;this.vw=w;this.vh=h;this.passEncoder.setViewport(x,y,w,h,0,1);}}setScissor(x,y,w,h){if(this.passEncoder){if(!this.renderTarget.flipY){y=this.renderTarget.height-y-h;}this.sx=x;this.sy=y;this.sw=w;this.sh=h;this.passEncoder.setScissorRect(x,y,w,h);}}clearStorageBuffer(storageBuffer,offset=0,size=storageBuffer.byteSize){var _this$commandEncoder;const commandEncoder=(_this$commandEncoder=this.commandEncoder)!=null?_this$commandEncoder:this.wgpu.createCommandEncoder();commandEncoder.clearBuffer(storageBuffer.buffer,offset,size);if(!this.commandEncoder){const cb=commandEncoder.finish();this.addCommandBuffer(cb);}}readStorageBuffer(storageBuffer,offset=0,size=storageBuffer.byteSize-offset,data=null,immediate=false){var _this$commandEncoder2;const stagingBuffer=this.createBufferImpl(BUFFERUSAGE_READ|BUFFERUSAGE_COPY_DST);stagingBuffer.allocate(this,size);const destBuffer=stagingBuffer.buffer;const commandEncoder=(_this$commandEncoder2=this.commandEncoder)!=null?_this$commandEncoder2:this.wgpu.createCommandEncoder();commandEncoder.copyBufferToBuffer(storageBuffer.buffer,offset,destBuffer,0,size);if(!this.commandEncoder){const cb=commandEncoder.finish();this.addCommandBuffer(cb);}return new Promise((resolve,reject)=>{const read=()=>{destBuffer==null||destBuffer.mapAsync(GPUMapMode.READ).then(()=>{var _data;(_data=data)!=null?_data:data=new Uint8Array(size);const copySrc=destBuffer.getMappedRange(0,size);const srcType=data.constructor;data.set(new srcType(copySrc));destBuffer.unmap();stagingBuffer.destroy(this);resolve(data);});};if(immediate){this.submit();read();}else {setTimeout(()=>{read();});}})}writeStorageBuffer(storageBuffer,bufferOffset=0,data,dataOffset=0,size){this.wgpu.queue.writeBuffer(storageBuffer.buffer,bufferOffset,data,dataOffset,size);}copyRenderTarget(source,dest,color,depth){var _this$commandEncoder3;const copySize={width:source?source.width:dest.width,height:source?source.height:dest.height,depthOrArrayLayers:1};const commandEncoder=(_this$commandEncoder3=this.commandEncoder)!=null?_this$commandEncoder3:this.wgpu.createCommandEncoder();if(color){const copySrc={texture:source?source.colorBuffer.impl.gpuTexture:this.renderTarget.impl.assignedColorTexture,mipLevel:0};const copyDst={texture:dest?dest.colorBuffer.impl.gpuTexture:this.renderTarget.impl.assignedColorTexture,mipLevel:0};commandEncoder.copyTextureToTexture(copySrc,copyDst,copySize);}if(depth){const sourceRT=source?source:this.renderTarget;const sourceTexture=sourceRT.impl.depthTexture;if(source.samples>1){const destTexture=dest.colorBuffer.impl.gpuTexture;this.resolver.resolveDepth(commandEncoder,sourceTexture,destTexture);}else {const destTexture=dest?dest.depthBuffer.impl.gpuTexture:this.renderTarget.impl.depthTexture;const copySrc={texture:sourceTexture,mipLevel:0};const copyDst={texture:destTexture,mipLevel:0};commandEncoder.copyTextureToTexture(copySrc,copyDst,copySize);}}if(!this.commandEncoder){const cb=commandEncoder.finish();this.addCommandBuffer(cb);}return true}constructor(canvas,options={}){var _options$alpha,_options$antialias;super(canvas,options);this.renderPipeline=new WebgpuRenderPipeline(this);this.computePipeline=new WebgpuComputePipeline(this);this.clearRenderer=void 0;this.mipmapRenderer=void 0;this.pipeline=void 0;this.bindGroupFormats=[];this.commandEncoder=null;this.commandBuffers=[];this.limits=void 0;options=this.initOptions;options.alpha=(_options$alpha=options.alpha)!=null?_options$alpha:true;this.backBufferAntialias=(_options$antialias=options.antialias)!=null?_options$antialias:false;this.isWebGPU=true;this._deviceType=DEVICETYPE_WEBGPU;}}let id$6=0;class Texture{destroy(){const device=this.device;if(device){const idx=device.textures.indexOf(this);if(idx!==-1){device.textures.splice(idx,1);}device.scope.removeValue(this);this.impl.destroy(device);this.adjustVramSizeTracking(device._vram,-this._gpuSize);this._levels=null;this.device=null;}}resize(width,height,depth=1){const device=this.device;this.adjustVramSizeTracking(device._vram,-this._gpuSize);this.impl.destroy(device);this._width=Math.floor(width);this._height=Math.floor(height);this._depth=Math.floor(depth);this.impl=device.createTextureImpl(this);this.dirtyAll();}loseContext(){this.impl.loseContext();this.dirtyAll();}adjustVramSizeTracking(vram,size){vram.tex+=size;}propertyChanged(flag){this.impl.propertyChanged(flag);this.renderVersionDirty=this.device.renderVersion;}get requiredMipLevels(){return this.mipmaps?TextureUtils.calcMipLevelsCount(this.width,this.height):1}get lockedMode(){return this._lockedMode}set minFilter(v){if(this._minFilter!==v){if(isIntegerPixelFormat(this._format));else {this._minFilter=v;this.propertyChanged(1);}}}get minFilter(){return this._minFilter}set magFilter(v){if(this._magFilter!==v){if(isIntegerPixelFormat(this._format));else {this._magFilter=v;this.propertyChanged(2);}}}get magFilter(){return this._magFilter}set addressU(v){if(this._addressU!==v){this._addressU=v;this.propertyChanged(4);}}get addressU(){return this._addressU}set addressV(v){if(this._addressV!==v){this._addressV=v;this.propertyChanged(8);}}get addressV(){return this._addressV}set addressW(addressW){if(!this.device.supportsVolumeTextures)return;if(!this._volume){return}if(addressW!==this._addressW){this._addressW=addressW;this.propertyChanged(16);}}get addressW(){return this._addressW}set compareOnRead(v){if(this._compareOnRead!==v){this._compareOnRead=v;this.propertyChanged(32);}}get compareOnRead(){return this._compareOnRead}set compareFunc(v){if(this._compareFunc!==v){this._compareFunc=v;this.propertyChanged(64);}}get compareFunc(){return this._compareFunc}set anisotropy(v){if(this._anisotropy!==v){this._anisotropy=v;this.propertyChanged(128);}}get anisotropy(){return this._anisotropy}set mipmaps(v){if(this._mipmaps!==v){if(this.device.isWebGPU);else if(isIntegerPixelFormat(this._format));else {this._mipmaps=v;}if(v)this._needsMipmapsUpload=true;}}get mipmaps(){return this._mipmaps}get storage(){return this._storage}get width(){return this._width}get height(){return this._height}get depth(){return this._depth}get format(){return this._format}get cubemap(){return this._cubemap}get gpuSize(){const mips=this.pot&&this._mipmaps&&!(this._compressed&&this._levels.length===1);return TextureUtils.calcGpuSize(this._width,this._height,this._depth,this._format,mips,this._cubemap)}get array(){return this._arrayLength>0}get arrayLength(){return this._arrayLength}get volume(){return this._volume}set flipY(flipY){if(this._flipY!==flipY){this._flipY=flipY;this._needsUpload=true;}}get flipY(){return this._flipY}set premultiplyAlpha(premultiplyAlpha){if(this._premultiplyAlpha!==premultiplyAlpha){this._premultiplyAlpha=premultiplyAlpha;this._needsUpload=true;}}get premultiplyAlpha(){return this._premultiplyAlpha}get pot(){return math.powerOfTwo(this._width)&&math.powerOfTwo(this._height)}get encoding(){switch(this.type){case TEXTURETYPE_RGBM:return "rgbm";case TEXTURETYPE_RGBE:return "rgbe";case TEXTURETYPE_RGBP:return "rgbp";default:return this.format===PIXELFORMAT_RGB16F||this.format===PIXELFORMAT_RGB32F||this.format===PIXELFORMAT_RGBA16F||this.format===PIXELFORMAT_RGBA32F||isIntegerPixelFormat(this.format)?"linear":"srgb"}}dirtyAll(){this._levelsUpdated=this._cubemap?[[true,true,true,true,true,true]]:[true];this._needsUpload=true;this._needsMipmapsUpload=this._mipmaps;this._mipmapsUploaded=false;this.propertyChanged(255);}lock(options={}){var _options$level,_options$face,_options$mode;(_options$level=options.level)!=null?_options$level:options.level=0;(_options$face=options.face)!=null?_options$face:options.face=0;(_options$mode=options.mode)!=null?_options$mode:options.mode=TEXTURELOCK_WRITE;this._lockedMode=options.mode;this._lockedLevel=options.level;const levels=this.cubemap?this._levels[options.face]:this._levels;if(levels[options.level]===null){const width=Math.max(1,this._width>>options.level);const height=Math.max(1,this._height>>options.level);const depth=Math.max(1,this._depth>>options.level);const data=new ArrayBuffer(TextureUtils.calcLevelGpuSize(width,height,depth,this._format));levels[options.level]=new(getPixelFormatArrayType(this._format))(data);}return levels[options.level]}setSource(source,mipLevel=0){let invalid=false;let width,height;if(this._cubemap){if(source[0]){width=source[0].width||0;height=source[0].height||0;for(let i=0;i<6;i++){const face=source[i];if(!face||face.width!==width||face.height!==height||!this.device._isBrowserInterface(face)){invalid=true;break}}}else {invalid=true;}if(!invalid){for(let i=0;i<6;i++){if(this._levels[mipLevel][i]!==source[i]){this._levelsUpdated[mipLevel][i]=true;}}}}else {if(!this.device._isBrowserInterface(source)){invalid=true;}if(!invalid){if(source!==this._levels[mipLevel]){this._levelsUpdated[mipLevel]=true;}width=source.width;height=source.height;}}if(invalid){this._width=4;this._height=4;if(this._cubemap){for(let i=0;i<6;i++){this._levels[mipLevel][i]=null;this._levelsUpdated[mipLevel][i]=true;}}else {this._levels[mipLevel]=null;this._levelsUpdated[mipLevel]=true;}}else {if(mipLevel===0){this._width=width;this._height=height;}this._levels[mipLevel]=source;}if(this._invalid!==invalid||!invalid){this._invalid=invalid;this.upload();}}getSource(mipLevel=0){return this._levels[mipLevel]}unlock(){if(this._lockedMode===TEXTURELOCK_NONE);if(this._lockedMode===TEXTURELOCK_WRITE){this.upload();}this._lockedLevel=-1;this._lockedMode=TEXTURELOCK_NONE;}upload(){var _this$impl$uploadImme,_this$impl;this._needsUpload=true;this._needsMipmapsUpload=this._mipmaps;(_this$impl$uploadImme=(_this$impl=this.impl).uploadImmediate)==null||_this$impl$uploadImme.call(_this$impl,this.device,this);}async downloadAsync(){const promises=[];for(let i=0;i<(this.cubemap?6:1);i++){var _this$device$readPixe,_this$device;const renderTarget=new RenderTarget({colorBuffer:this,depth:false,face:i});this.device.setRenderTarget(renderTarget);this.device.initRenderTarget(renderTarget);const levels=this.cubemap?this._levels[i]:this._levels;let level=levels[0];if(levels[0]&&this.device._isBrowserInterface(levels[0])){levels[0]=null;}level=this.lock({face:i});const promise=(_this$device$readPixe=(_this$device=this.device).readPixelsAsync)==null?void 0:_this$device$readPixe.call(_this$device,0,0,this.width,this.height,level).then(()=>renderTarget.destroy());promises.push(promise);}await Promise.all(promises);}constructor(graphicsDevice,options={}){var _options$name,_options$width,_options$height,_options$format,_options$storage,_options$cubemap,_options$fixCubemapSe,_options$flipY,_options$premultiplyA,_ref,_options$mipmaps,_options$minFilter,_options$magFilter,_options$anisotropy,_options$addressU,_options$addressV,_options$addressW,_options$compareOnRea,_options$compareFunc;this.name=void 0;this._gpuSize=0;this.id=id$6++;this._invalid=false;this._lockedLevel=-1;this._lockedMode=TEXTURELOCK_NONE;this.renderVersionDirty=0;this._storage=false;this.device=graphicsDevice;this.name=(_options$name=options.name)!=null?_options$name:"";this._width=Math.floor((_options$width=options.width)!=null?_options$width:4);this._height=Math.floor((_options$height=options.height)!=null?_options$height:4);this._format=(_options$format=options.format)!=null?_options$format:PIXELFORMAT_RGBA8;this._compressed=isCompressedPixelFormat(this._format);this._integerFormat=isIntegerPixelFormat(this._format);if(this._integerFormat){options.mipmaps=false;options.minFilter=FILTER_NEAREST;options.magFilter=FILTER_NEAREST;}if(graphicsDevice.supportsVolumeTextures){var _options$volume,_options$depth,_options$arrayLength;this._volume=(_options$volume=options.volume)!=null?_options$volume:false;this._depth=Math.floor((_options$depth=options.depth)!=null?_options$depth:1);this._arrayLength=Math.floor((_options$arrayLength=options.arrayLength)!=null?_options$arrayLength:0);}else {this._volume=false;this._depth=1;this._arrayLength=0;}this._storage=(_options$storage=options.storage)!=null?_options$storage:false;this._cubemap=(_options$cubemap=options.cubemap)!=null?_options$cubemap:false;this.fixCubemapSeams=(_options$fixCubemapSe=options.fixCubemapSeams)!=null?_options$fixCubemapSe:false;this._flipY=(_options$flipY=options.flipY)!=null?_options$flipY:false;this._premultiplyAlpha=(_options$premultiplyA=options.premultiplyAlpha)!=null?_options$premultiplyA:false;this._mipmaps=(_ref=(_options$mipmaps=options.mipmaps)!=null?_options$mipmaps:options.autoMipmap)!=null?_ref:true;this._minFilter=(_options$minFilter=options.minFilter)!=null?_options$minFilter:FILTER_LINEAR_MIPMAP_LINEAR;this._magFilter=(_options$magFilter=options.magFilter)!=null?_options$magFilter:FILTER_LINEAR;this._anisotropy=(_options$anisotropy=options.anisotropy)!=null?_options$anisotropy:1;this._addressU=(_options$addressU=options.addressU)!=null?_options$addressU:ADDRESS_REPEAT;this._addressV=(_options$addressV=options.addressV)!=null?_options$addressV:ADDRESS_REPEAT;this._addressW=(_options$addressW=options.addressW)!=null?_options$addressW:ADDRESS_REPEAT;this._compareOnRead=(_options$compareOnRea=options.compareOnRead)!=null?_options$compareOnRea:false;this._compareFunc=(_options$compareFunc=options.compareFunc)!=null?_options$compareFunc:FUNC_LESS;this.type=TEXTURETYPE_DEFAULT;if(options.hasOwnProperty("type")){this.type=options.type;}else if(options.hasOwnProperty("rgbm")){this.type=options.rgbm?TEXTURETYPE_RGBM:TEXTURETYPE_DEFAULT;}else if(options.hasOwnProperty("swizzleGGGR")){this.type=options.swizzleGGGR?TEXTURETYPE_SWIZZLEGGGR:TEXTURETYPE_DEFAULT;}this.projection=TEXTUREPROJECTION_NONE;if(this._cubemap){this.projection=TEXTUREPROJECTION_CUBE;}else if(options.projection&&options.projection!==TEXTUREPROJECTION_CUBE){this.projection=options.projection;}this.impl=graphicsDevice.createTextureImpl(this);this.dirtyAll();this._levels=options.levels;if(this._levels){this.upload();}else {this._levels=this._cubemap?[[null,null,null,null,null,null]]:[null];}graphicsDevice.textures.push(this);}}class WebglBuffer{destroy(device){if(this.bufferId){device.gl.deleteBuffer(this.bufferId);this.bufferId=null;}}get initialized(){return !!this.bufferId}loseContext(){this.bufferId=null;}unlock(device,usage,target,storage){const gl=device.gl;if(!this.bufferId){let glUsage;switch(usage){case BUFFER_STATIC:glUsage=gl.STATIC_DRAW;break;case BUFFER_DYNAMIC:glUsage=gl.DYNAMIC_DRAW;break;case BUFFER_STREAM:glUsage=gl.STREAM_DRAW;break;case BUFFER_GPUDYNAMIC:glUsage=device.isWebGL2?gl.DYNAMIC_COPY:gl.STATIC_DRAW;break}this.bufferId=gl.createBuffer();gl.bindBuffer(target,this.bufferId);gl.bufferData(target,storage,glUsage);}else {gl.bindBuffer(target,this.bufferId);gl.bufferSubData(target,0,storage);}}constructor(){this.bufferId=null;}}class WebglVertexBuffer extends WebglBuffer{destroy(device){super.destroy(device);device.unbindVertexArray();}loseContext(){super.loseContext();this.vao=null;}unlock(vertexBuffer){const device=vertexBuffer.device;super.unlock(device,vertexBuffer.usage,device.gl.ARRAY_BUFFER,vertexBuffer.storage);}constructor(...args){super(...args);this.vao=null;}}class WebglIndexBuffer extends WebglBuffer{unlock(indexBuffer){const device=indexBuffer.device;super.unlock(device,indexBuffer.usage,device.gl.ELEMENT_ARRAY_BUFFER,indexBuffer.storage);}constructor(indexBuffer){super();const gl=indexBuffer.device.gl;const format=indexBuffer.format;if(format===INDEXFORMAT_UINT8){this.glFormat=gl.UNSIGNED_BYTE;}else if(format===INDEXFORMAT_UINT16){this.glFormat=gl.UNSIGNED_SHORT;}else if(format===INDEXFORMAT_UINT32){this.glFormat=gl.UNSIGNED_INT;}}}class WebglShaderInput{constructor(graphicsDevice,name,type,locationId){this.locationId=locationId;this.scopeId=graphicsDevice.scope.resolve(name);this.version=new Version;if(name.substring(name.length-3)==="[0]"){switch(type){case UNIFORMTYPE_FLOAT:type=UNIFORMTYPE_FLOATARRAY;break;case UNIFORMTYPE_INT:type=UNIFORMTYPE_INTARRAY;break;case UNIFORMTYPE_UINT:type=UNIFORMTYPE_UINTARRAY;break;case UNIFORMTYPE_BOOL:type=UNIFORMTYPE_BOOLARRAY;break;case UNIFORMTYPE_VEC2:type=UNIFORMTYPE_VEC2ARRAY;break;case UNIFORMTYPE_IVEC2:type=UNIFORMTYPE_IVEC2ARRAY;break;case UNIFORMTYPE_UVEC2:type=UNIFORMTYPE_UVEC2ARRAY;break;case UNIFORMTYPE_BVEC2:type=UNIFORMTYPE_BVEC2ARRAY;break;case UNIFORMTYPE_VEC3:type=UNIFORMTYPE_VEC3ARRAY;break;case UNIFORMTYPE_IVEC3:type=UNIFORMTYPE_IVEC3ARRAY;break;case UNIFORMTYPE_UVEC3:type=UNIFORMTYPE_UVEC3ARRAY;break;case UNIFORMTYPE_BVEC3:type=UNIFORMTYPE_BVEC3ARRAY;break;case UNIFORMTYPE_VEC4:type=UNIFORMTYPE_VEC4ARRAY;break;case UNIFORMTYPE_IVEC4:type=UNIFORMTYPE_IVEC4ARRAY;break;case UNIFORMTYPE_UVEC4:type=UNIFORMTYPE_UVEC4ARRAY;break;case UNIFORMTYPE_BVEC4:type=UNIFORMTYPE_BVEC4ARRAY;break}}this.dataType=type;this.value=[null,null,null,null];this.array=[];}}const _vertexShaderBuiltins=new Set(["gl_VertexID","gl_InstanceID","gl_DrawID","gl_BaseVertex","gl_BaseInstance"]);class CompiledShaderCache{destroy(device){this.map.forEach(shader=>{device.gl.deleteShader(shader);});}loseContext(device){this.map.clear();}constructor(){this.map=new Map;}}const _vertexShaderCache=new DeviceCache;const _fragmentShaderCache=new DeviceCache;class WebglShader{destroy(shader){if(this.glProgram){shader.device.gl.deleteProgram(this.glProgram);this.glProgram=null;}}init(){this.uniforms=[];this.samplers=[];this.attributes=[];this.glProgram=null;this.glVertexShader=null;this.glFragmentShader=null;}loseContext(){this.init();}restoreContext(device,shader){this.compile(device,shader);this.link(device,shader);}compile(device,shader){const definition=shader.definition;this.glVertexShader=this._compileShaderSource(device,definition.vshader,true);this.glFragmentShader=this._compileShaderSource(device,definition.fshader,false);}link(device,shader){if(this.glProgram){return}const gl=device.gl;if(gl.isContextLost()){return}const glProgram=gl.createProgram();this.glProgram=glProgram;gl.attachShader(glProgram,this.glVertexShader);gl.attachShader(glProgram,this.glFragmentShader);const definition=shader.definition;const attrs=definition.attributes;if(device.isWebGL2&&definition.useTransformFeedback){const outNames=[];for(const attr in attrs){if(attrs.hasOwnProperty(attr)){outNames.push(`out_${attr}`);}}gl.transformFeedbackVaryings(glProgram,outNames,gl.INTERLEAVED_ATTRIBS);}for(const attr in attrs){if(attrs.hasOwnProperty(attr)){const semantic=attrs[attr];const loc=semanticToLocation[semantic];gl.bindAttribLocation(glProgram,loc,attr);}}gl.linkProgram(glProgram);}_compileShaderSource(device,src,isVertexShader){const gl=device.gl;if(gl.isContextLost()){return null}const shaderDeviceCache=isVertexShader?_vertexShaderCache:_fragmentShaderCache;const shaderCache=shaderDeviceCache.get(device,()=>{return new CompiledShaderCache});let glShader=shaderCache.map.get(src);if(!glShader){glShader=gl.createShader(isVertexShader?gl.VERTEX_SHADER:gl.FRAGMENT_SHADER);gl.shaderSource(glShader,src);gl.compileShader(glShader);shaderCache.map.set(src,glShader);}return glShader}finalize(device,shader){const gl=device.gl;if(gl.isContextLost()){return true}const glProgram=this.glProgram;const definition=shader.definition;const linkStatus=gl.getProgramParameter(glProgram,gl.LINK_STATUS);if(!linkStatus){if(!this._isCompiled(device,shader,this.glVertexShader,definition.vshader,"vertex")){return false}if(!this._isCompiled(device,shader,this.glFragmentShader,definition.fshader,"fragment")){return false}const message=`Failed to link shader program. Error: ${gl.getProgramInfoLog(glProgram)}`;console.error(message);return false}const numAttributes=gl.getProgramParameter(glProgram,gl.ACTIVE_ATTRIBUTES);for(let i=0;i<numAttributes;i++){const info=gl.getActiveAttrib(glProgram,i);const location=gl.getAttribLocation(glProgram,info.name);if(_vertexShaderBuiltins.has(info.name)){continue}if(definition.attributes[info.name]===undefined){console.error(`Vertex shader attribute "${info.name}" is not mapped to a semantic in shader definition, shader [${shader.label}]`,shader);shader.failed=true;}else {const shaderInput=new WebglShaderInput(device,definition.attributes[info.name],device.pcUniformType[info.type],location);this.attributes.push(shaderInput);}}const samplerTypes=device._samplerTypes;const numUniforms=gl.getProgramParameter(glProgram,gl.ACTIVE_UNIFORMS);for(let i=0;i<numUniforms;i++){const info=gl.getActiveUniform(glProgram,i);const location=gl.getUniformLocation(glProgram,info.name);const shaderInput=new WebglShaderInput(device,info.name,device.pcUniformType[info.type],location);if(samplerTypes.has(info.type)){this.samplers.push(shaderInput);}else {this.uniforms.push(shaderInput);}}shader.ready=true;return true}_isCompiled(device,shader,glShader,source,shaderType){const gl=device.gl;if(!gl.getShaderParameter(glShader,gl.COMPILE_STATUS)){const infoLog=gl.getShaderInfoLog(glShader);const[code,error]=this._processError(source,infoLog);const message=`Failed to compile ${shaderType} shader:

${infoLog}
${code} while rendering ${void 0}`;console.error(message);return false}return true}isLinked(device){const{extParallelShaderCompile}=device;if(extParallelShaderCompile){return device.gl.getProgramParameter(this.glProgram,extParallelShaderCompile.COMPLETION_STATUS_KHR)}return true}_processError(src,infoLog){const error={};let code="";if(src){const lines=src.split("\n");let from=0;let to=lines.length;if(infoLog&&infoLog.startsWith("ERROR:")){const match=infoLog.match(/^ERROR:\s(\d+):(\d+):\s*(.+)/);if(match){error.message=match[3];error.line=parseInt(match[2],10);from=Math.max(0,error.line-6);to=Math.min(lines.length,error.line+5);}}for(let i=from;i<to;i++){code+=`${i+1}:	${lines[i]}
`;}error.source=src;}return [code,error]}constructor(shader){this.compileDuration=0;this.init();this.compile(shader.device,shader);this.link(shader.device,shader);shader.device.shaders.push(shader);}}function downsampleImage(image,size){const srcW=image.width;const srcH=image.height;if(srcW>size||srcH>size){const scale=size/Math.max(srcW,srcH);const dstW=Math.floor(srcW*scale);const dstH=Math.floor(srcH*scale);const canvas=document.createElement("canvas");canvas.width=dstW;canvas.height=dstH;const context=canvas.getContext("2d");context.drawImage(image,0,0,srcW,srcH,0,0,dstW,dstH);return canvas}return image}class WebglTexture{destroy(device){if(this._glTexture){for(let i=0;i<device.textureUnits.length;i++){const textureUnit=device.textureUnits[i];for(let j=0;j<textureUnit.length;j++){if(textureUnit[j]===this._glTexture){textureUnit[j]=null;}}}device.gl.deleteTexture(this._glTexture);this._glTexture=null;}}loseContext(){this._glTexture=null;}propertyChanged(flag){this.dirtyParameterFlags|=flag;}initialize(device,texture){const gl=device.gl;this._glTexture=gl.createTexture();this._glTarget=texture._cubemap?gl.TEXTURE_CUBE_MAP:texture._volume?gl.TEXTURE_3D:texture.array?gl.TEXTURE_2D_ARRAY:gl.TEXTURE_2D;switch(texture._format){case PIXELFORMAT_A8:this._glFormat=gl.ALPHA;this._glInternalFormat=gl.ALPHA;this._glPixelType=gl.UNSIGNED_BYTE;break;case PIXELFORMAT_L8:this._glFormat=gl.LUMINANCE;this._glInternalFormat=gl.LUMINANCE;this._glPixelType=gl.UNSIGNED_BYTE;break;case PIXELFORMAT_LA8:this._glFormat=gl.LUMINANCE_ALPHA;this._glInternalFormat=gl.LUMINANCE_ALPHA;this._glPixelType=gl.UNSIGNED_BYTE;break;case PIXELFORMAT_RGB565:this._glFormat=gl.RGB;this._glInternalFormat=gl.RGB;this._glPixelType=gl.UNSIGNED_SHORT_5_6_5;break;case PIXELFORMAT_RGBA5551:this._glFormat=gl.RGBA;this._glInternalFormat=gl.RGBA;this._glPixelType=gl.UNSIGNED_SHORT_5_5_5_1;break;case PIXELFORMAT_RGBA4:this._glFormat=gl.RGBA;this._glInternalFormat=gl.RGBA;this._glPixelType=gl.UNSIGNED_SHORT_4_4_4_4;break;case PIXELFORMAT_RGB8:this._glFormat=gl.RGB;this._glInternalFormat=device.isWebGL2?gl.RGB8:gl.RGB;this._glPixelType=gl.UNSIGNED_BYTE;break;case PIXELFORMAT_RGBA8:this._glFormat=gl.RGBA;this._glInternalFormat=device.isWebGL2?gl.RGBA8:gl.RGBA;this._glPixelType=gl.UNSIGNED_BYTE;break;case PIXELFORMAT_DXT1:this._glFormat=gl.RGB;this._glInternalFormat=device.extCompressedTextureS3TC.COMPRESSED_RGB_S3TC_DXT1_EXT;break;case PIXELFORMAT_DXT3:this._glFormat=gl.RGBA;this._glInternalFormat=device.extCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT3_EXT;break;case PIXELFORMAT_DXT5:this._glFormat=gl.RGBA;this._glInternalFormat=device.extCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT5_EXT;break;case PIXELFORMAT_ETC1:this._glFormat=gl.RGB;this._glInternalFormat=device.extCompressedTextureETC1.COMPRESSED_RGB_ETC1_WEBGL;break;case PIXELFORMAT_PVRTC_2BPP_RGB_1:this._glFormat=gl.RGB;this._glInternalFormat=device.extCompressedTexturePVRTC.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;break;case PIXELFORMAT_PVRTC_2BPP_RGBA_1:this._glFormat=gl.RGBA;this._glInternalFormat=device.extCompressedTexturePVRTC.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;break;case PIXELFORMAT_PVRTC_4BPP_RGB_1:this._glFormat=gl.RGB;this._glInternalFormat=device.extCompressedTexturePVRTC.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;break;case PIXELFORMAT_PVRTC_4BPP_RGBA_1:this._glFormat=gl.RGBA;this._glInternalFormat=device.extCompressedTexturePVRTC.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;break;case PIXELFORMAT_ETC2_RGB:this._glFormat=gl.RGB;this._glInternalFormat=device.extCompressedTextureETC.COMPRESSED_RGB8_ETC2;break;case PIXELFORMAT_ETC2_RGBA:this._glFormat=gl.RGBA;this._glInternalFormat=device.extCompressedTextureETC.COMPRESSED_RGBA8_ETC2_EAC;break;case PIXELFORMAT_ASTC_4x4:this._glFormat=gl.RGBA;this._glInternalFormat=device.extCompressedTextureASTC.COMPRESSED_RGBA_ASTC_4x4_KHR;break;case PIXELFORMAT_ATC_RGB:this._glFormat=gl.RGB;this._glInternalFormat=device.extCompressedTextureATC.COMPRESSED_RGB_ATC_WEBGL;break;case PIXELFORMAT_ATC_RGBA:this._glFormat=gl.RGBA;this._glInternalFormat=device.extCompressedTextureATC.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL;break;case PIXELFORMAT_R16F:if(device.isWebGL2){this._glFormat=gl.RED;this._glInternalFormat=gl.R16F;this._glPixelType=gl.HALF_FLOAT;}else {this._glFormat=gl.LUMINANCE;this._glInternalFormat=gl.LUMINANCE;this._glPixelType=device.extTextureHalfFloat.HALF_FLOAT_OES;}break;case PIXELFORMAT_RG16F:if(device.isWebGL2){this._glFormat=gl.RG;this._glInternalFormat=gl.RG16F;this._glPixelType=gl.HALF_FLOAT;}else {this._glFormat=gl.RG;this._glInternalFormat=gl.RG;this._glPixelType=device.extTextureHalfFloat.HALF_FLOAT_OES;}break;case PIXELFORMAT_RGB16F:this._glFormat=gl.RGB;if(device.isWebGL2){this._glInternalFormat=gl.RGB16F;this._glPixelType=gl.HALF_FLOAT;}else {this._glInternalFormat=gl.RGB;this._glPixelType=device.extTextureHalfFloat.HALF_FLOAT_OES;}break;case PIXELFORMAT_RGBA16F:this._glFormat=gl.RGBA;if(device.isWebGL2){this._glInternalFormat=gl.RGBA16F;this._glPixelType=gl.HALF_FLOAT;}else {this._glInternalFormat=gl.RGBA;this._glPixelType=device.extTextureHalfFloat.HALF_FLOAT_OES;}break;case PIXELFORMAT_RGB32F:this._glFormat=gl.RGB;if(device.isWebGL2){this._glInternalFormat=gl.RGB32F;}else {this._glInternalFormat=gl.RGB;}this._glPixelType=gl.FLOAT;break;case PIXELFORMAT_RGBA32F:this._glFormat=gl.RGBA;if(device.isWebGL2){this._glInternalFormat=gl.RGBA32F;}else {this._glInternalFormat=gl.RGBA;}this._glPixelType=gl.FLOAT;break;case PIXELFORMAT_R32F:this._glFormat=gl.RED;this._glInternalFormat=gl.R32F;this._glPixelType=gl.FLOAT;break;case PIXELFORMAT_DEPTH:if(device.isWebGL2){this._glFormat=gl.DEPTH_COMPONENT;this._glInternalFormat=gl.DEPTH_COMPONENT32F;this._glPixelType=gl.FLOAT;}else {this._glFormat=gl.DEPTH_COMPONENT;this._glInternalFormat=gl.DEPTH_COMPONENT;this._glPixelType=gl.UNSIGNED_SHORT;}break;case PIXELFORMAT_DEPTHSTENCIL:this._glFormat=gl.DEPTH_STENCIL;if(device.isWebGL2){this._glInternalFormat=gl.DEPTH24_STENCIL8;this._glPixelType=gl.UNSIGNED_INT_24_8;}else {this._glInternalFormat=gl.DEPTH_STENCIL;this._glPixelType=device.extDepthTexture.UNSIGNED_INT_24_8_WEBGL;}break;case PIXELFORMAT_111110F:this._glFormat=gl.RGB;this._glInternalFormat=gl.R11F_G11F_B10F;this._glPixelType=gl.UNSIGNED_INT_10F_11F_11F_REV;break;case PIXELFORMAT_SRGB:this._glFormat=gl.RGB;this._glInternalFormat=gl.SRGB8;this._glPixelType=gl.UNSIGNED_BYTE;break;case PIXELFORMAT_SRGBA:this._glFormat=gl.RGBA;this._glInternalFormat=gl.SRGB8_ALPHA8;this._glPixelType=gl.UNSIGNED_BYTE;break;case PIXELFORMAT_R8I:this._glFormat=gl.RED_INTEGER;this._glInternalFormat=gl.R8I;this._glPixelType=gl.BYTE;break;case PIXELFORMAT_R8U:this._glFormat=gl.RED_INTEGER;this._glInternalFormat=gl.R8UI;this._glPixelType=gl.UNSIGNED_BYTE;break;case PIXELFORMAT_R16I:this._glFormat=gl.RED_INTEGER;this._glInternalFormat=gl.R16I;this._glPixelType=gl.SHORT;break;case PIXELFORMAT_R16U:this._glFormat=gl.RED_INTEGER;this._glInternalFormat=gl.R16UI;this._glPixelType=gl.UNSIGNED_SHORT;break;case PIXELFORMAT_R32I:this._glFormat=gl.RED_INTEGER;this._glInternalFormat=gl.R32I;this._glPixelType=gl.INT;break;case PIXELFORMAT_R32U:this._glFormat=gl.RED_INTEGER;this._glInternalFormat=gl.R32UI;this._glPixelType=gl.UNSIGNED_INT;break;case PIXELFORMAT_RG8I:this._glFormat=gl.RG_INTEGER;this._glInternalFormat=gl.RG8I;this._glPixelType=gl.BYTE;break;case PIXELFORMAT_RG8U:this._glFormat=gl.RG_INTEGER;this._glInternalFormat=gl.RG8UI;this._glPixelType=gl.UNSIGNED_BYTE;break;case PIXELFORMAT_RG16I:this._glFormat=gl.RG_INTEGER;this._glInternalFormat=gl.RG16I;this._glPixelType=gl.SHORT;break;case PIXELFORMAT_RG16U:this._glFormat=gl.RG_INTEGER;this._glInternalFormat=gl.RG16UI;this._glPixelType=gl.UNSIGNED_SHORT;break;case PIXELFORMAT_RG32I:this._glFormat=gl.RG_INTEGER;this._glInternalFormat=gl.RG32I;this._glPixelType=gl.INT;break;case PIXELFORMAT_RG32U:this._glFormat=gl.RG_INTEGER;this._glInternalFormat=gl.RG32UI;this._glPixelType=gl.UNSIGNED_INT;break;case PIXELFORMAT_RGBA8I:this._glFormat=gl.RGBA_INTEGER;this._glInternalFormat=gl.RGBA8I;this._glPixelType=gl.BYTE;break;case PIXELFORMAT_RGBA8U:this._glFormat=gl.RGBA_INTEGER;this._glInternalFormat=gl.RGBA8UI;this._glPixelType=gl.UNSIGNED_BYTE;break;case PIXELFORMAT_RGBA16I:this._glFormat=gl.RGBA_INTEGER;this._glInternalFormat=gl.RGBA16I;this._glPixelType=gl.SHORT;break;case PIXELFORMAT_RGBA16U:this._glFormat=gl.RGBA_INTEGER;this._glInternalFormat=gl.RGBA16UI;this._glPixelType=gl.UNSIGNED_SHORT;break;case PIXELFORMAT_RGBA32I:this._glFormat=gl.RGBA_INTEGER;this._glInternalFormat=gl.RGBA32I;this._glPixelType=gl.INT;break;case PIXELFORMAT_RGBA32U:this._glFormat=gl.RGBA_INTEGER;this._glInternalFormat=gl.RGBA32UI;this._glPixelType=gl.UNSIGNED_INT;break}this._glCreated=false;}upload(device,texture){const gl=device.gl;if(!texture._needsUpload&&(texture._needsMipmapsUpload&&texture._mipmapsUploaded||!texture.pot)){return}let mipLevel=0;let mipObject;let resMult;const requiredMipLevels=texture.requiredMipLevels;if(texture.array){gl.texStorage3D(gl.TEXTURE_2D_ARRAY,requiredMipLevels,this._glInternalFormat,texture._width,texture._height,texture._arrayLength);}while(texture._levels[mipLevel]||mipLevel===0){if(!texture._needsUpload&&mipLevel===0){mipLevel++;continue}else if(mipLevel&&(!texture._needsMipmapsUpload||!texture._mipmaps)){break}mipObject=texture._levels[mipLevel];resMult=1/Math.pow(2,mipLevel);if(mipLevel===1&&!texture._compressed&&!texture._integerFormat&&texture._levels.length<requiredMipLevels){gl.generateMipmap(this._glTarget);texture._mipmapsUploaded=true;}if(texture._cubemap){let face;if(device._isBrowserInterface(mipObject[0])){for(face=0;face<6;face++){if(!texture._levelsUpdated[0][face]){continue}let src=mipObject[face];if(device._isImageBrowserInterface(src)){if(src.width>device.maxCubeMapSize||src.height>device.maxCubeMapSize){src=downsampleImage(src,device.maxCubeMapSize);if(mipLevel===0){texture._width=src.width;texture._height=src.height;}}}device.setUnpackFlipY(false);device.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);if(this._glCreated){gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X+face,mipLevel,0,0,this._glFormat,this._glPixelType,src);}else {gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X+face,mipLevel,this._glInternalFormat,this._glFormat,this._glPixelType,src);}}}else {resMult=1/Math.pow(2,mipLevel);for(face=0;face<6;face++){if(!texture._levelsUpdated[0][face]){continue}const texData=mipObject[face];if(texture._compressed){if(this._glCreated&&texData){gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X+face,mipLevel,0,0,Math.max(texture._width*resMult,1),Math.max(texture._height*resMult,1),this._glInternalFormat,texData);}else {gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X+face,mipLevel,this._glInternalFormat,Math.max(texture._width*resMult,1),Math.max(texture._height*resMult,1),0,texData);}}else {device.setUnpackFlipY(false);device.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);if(this._glCreated&&texData){gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X+face,mipLevel,0,0,Math.max(texture._width*resMult,1),Math.max(texture._height*resMult,1),this._glFormat,this._glPixelType,texData);}else {gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X+face,mipLevel,this._glInternalFormat,Math.max(texture._width*resMult,1),Math.max(texture._height*resMult,1),0,this._glFormat,this._glPixelType,texData);}}}}}else if(texture._volume){if(texture._compressed){gl.compressedTexImage3D(gl.TEXTURE_3D,mipLevel,this._glInternalFormat,Math.max(texture._width*resMult,1),Math.max(texture._height*resMult,1),Math.max(texture._depth*resMult,1),0,mipObject);}else {device.setUnpackFlipY(false);device.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);gl.texImage3D(gl.TEXTURE_3D,mipLevel,this._glInternalFormat,Math.max(texture._width*resMult,1),Math.max(texture._height*resMult,1),Math.max(texture._depth*resMult,1),0,this._glFormat,this._glPixelType,mipObject);}}else if(texture.array&&typeof mipObject==="object"){if(texture._arrayLength===mipObject.length){if(texture._compressed){for(let index=0;index<texture._arrayLength;index++){gl.compressedTexSubImage3D(gl.TEXTURE_2D_ARRAY,mipLevel,0,0,index,Math.max(Math.floor(texture._width*resMult),1),Math.max(Math.floor(texture._height*resMult),1),1,this._glInternalFormat,mipObject[index]);}}else {for(let index=0;index<texture._arrayLength;index++){gl.texSubImage3D(gl.TEXTURE_2D_ARRAY,mipLevel,0,0,index,Math.max(Math.floor(texture._width*resMult),1),Math.max(Math.floor(texture._height*resMult),1),1,this._glFormat,this._glPixelType,mipObject[index]);}}}}else {if(device._isBrowserInterface(mipObject)){if(device._isImageBrowserInterface(mipObject)){if(mipObject.width>device.maxTextureSize||mipObject.height>device.maxTextureSize){mipObject=downsampleImage(mipObject,device.maxTextureSize);if(mipLevel===0){texture._width=mipObject.width;texture._height=mipObject.height;}}}const w=mipObject.width||mipObject.videoWidth;const h=mipObject.height||mipObject.videoHeight;device.setUnpackFlipY(texture._flipY);device.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);if(this._glCreated&&texture._width===w&&texture._height===h&&!device._isImageVideoInterface(mipObject)){gl.texSubImage2D(gl.TEXTURE_2D,mipLevel,0,0,this._glFormat,this._glPixelType,mipObject);}else {gl.texImage2D(gl.TEXTURE_2D,mipLevel,this._glInternalFormat,this._glFormat,this._glPixelType,mipObject);if(mipLevel===0){texture._width=w;texture._height=h;}}}else {resMult=1/Math.pow(2,mipLevel);if(texture._compressed){if(this._glCreated&&mipObject){gl.compressedTexSubImage2D(gl.TEXTURE_2D,mipLevel,0,0,Math.max(Math.floor(texture._width*resMult),1),Math.max(Math.floor(texture._height*resMult),1),this._glInternalFormat,mipObject);}else {gl.compressedTexImage2D(gl.TEXTURE_2D,mipLevel,this._glInternalFormat,Math.max(Math.floor(texture._width*resMult),1),Math.max(Math.floor(texture._height*resMult),1),0,mipObject);}}else {device.setUnpackFlipY(false);device.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);if(this._glCreated&&mipObject){gl.texSubImage2D(gl.TEXTURE_2D,mipLevel,0,0,Math.max(texture._width*resMult,1),Math.max(texture._height*resMult,1),this._glFormat,this._glPixelType,mipObject);}else {gl.texImage2D(gl.TEXTURE_2D,mipLevel,this._glInternalFormat,Math.max(texture._width*resMult,1),Math.max(texture._height*resMult,1),0,this._glFormat,this._glPixelType,mipObject);}}}if(mipLevel===0){texture._mipmapsUploaded=false;}else {texture._mipmapsUploaded=true;}}mipLevel++;}if(texture._needsUpload){if(texture._cubemap){for(let i=0;i<6;i++){texture._levelsUpdated[0][i]=false;}}else {texture._levelsUpdated[0]=false;}}if(!texture._compressed&&!texture._integerFormat&&texture._mipmaps&&texture._needsMipmapsUpload&&(texture.pot||device.isWebGL2)&&texture._levels.length===1){gl.generateMipmap(this._glTarget);texture._mipmapsUploaded=true;}if(texture._gpuSize){texture.adjustVramSizeTracking(device._vram,-texture._gpuSize);}texture._gpuSize=texture.gpuSize;texture.adjustVramSizeTracking(device._vram,texture._gpuSize);this._glCreated=true;}constructor(){this._glTexture=null;this._glTarget=void 0;this._glFormat=void 0;this._glInternalFormat=void 0;this._glPixelType=void 0;this._glCreated=void 0;this.dirtyParameterFlags=0;}}class FramebufferPair{destroy(gl){if(this.msaaFB){gl.deleteRenderbuffer(this.msaaFB);this.msaaFB=null;}if(this.resolveFB){gl.deleteRenderbuffer(this.resolveFB);this.resolveFB=null;}}constructor(msaaFB,resolveFB){this.msaaFB=void 0;this.resolveFB=void 0;this.msaaFB=msaaFB;this.resolveFB=resolveFB;}}class WebglRenderTarget{destroy(device){var _this$colorMrtFramebu;const gl=device.gl;this._isInitialized=false;if(this._glFrameBuffer){if(this._glFrameBuffer!==this.suppliedColorFramebuffer){gl.deleteFramebuffer(this._glFrameBuffer);}this._glFrameBuffer=null;}if(this._glDepthBuffer){gl.deleteRenderbuffer(this._glDepthBuffer);this._glDepthBuffer=null;}if(this._glResolveFrameBuffer){if(this._glResolveFrameBuffer!==this.suppliedColorFramebuffer){gl.deleteFramebuffer(this._glResolveFrameBuffer);}this._glResolveFrameBuffer=null;}this._glMsaaColorBuffers.forEach(buffer=>{gl.deleteRenderbuffer(buffer);});this._glMsaaColorBuffers.length=0;(_this$colorMrtFramebu=this.colorMrtFramebuffers)==null||_this$colorMrtFramebu.forEach(framebuffer=>{framebuffer.destroy(gl);});this.colorMrtFramebuffers=null;if(this._glMsaaDepthBuffer){gl.deleteRenderbuffer(this._glMsaaDepthBuffer);this._glMsaaDepthBuffer=null;}this.suppliedColorFramebuffer=undefined;}get initialized(){return this._isInitialized}init(device,target){const gl=device.gl;this._isInitialized=true;const buffers=[];if(this.suppliedColorFramebuffer!==undefined){this._glFrameBuffer=this.suppliedColorFramebuffer;}else {var _target$_colorBuffers,_target$_colorBuffers2,_device$extDrawBuffer,_device$extDrawBuffer2;this._glFrameBuffer=gl.createFramebuffer();device.setFramebuffer(this._glFrameBuffer);const colorBufferCount=(_target$_colorBuffers=(_target$_colorBuffers2=target._colorBuffers)==null?void 0:_target$_colorBuffers2.length)!=null?_target$_colorBuffers:0;const attachmentBaseConstant=device.isWebGL2?gl.COLOR_ATTACHMENT0:(_device$extDrawBuffer=(_device$extDrawBuffer2=device.extDrawBuffers)==null?void 0:_device$extDrawBuffer2.COLOR_ATTACHMENT0_WEBGL)!=null?_device$extDrawBuffer:gl.COLOR_ATTACHMENT0;for(let i=0;i<colorBufferCount;++i){const colorBuffer=target.getColorBuffer(i);if(colorBuffer){if(!colorBuffer.impl._glTexture){colorBuffer._width=Math.min(colorBuffer.width,device.maxRenderBufferSize);colorBuffer._height=Math.min(colorBuffer.height,device.maxRenderBufferSize);device.setTexture(colorBuffer,0);}gl.framebufferTexture2D(gl.FRAMEBUFFER,attachmentBaseConstant+i,colorBuffer._cubemap?gl.TEXTURE_CUBE_MAP_POSITIVE_X+target._face:gl.TEXTURE_2D,colorBuffer.impl._glTexture,0);buffers.push(attachmentBaseConstant+i);}}if(device.drawBuffers){device.drawBuffers(buffers);}const depthBuffer=target._depthBuffer;if(depthBuffer){if(!depthBuffer.impl._glTexture){depthBuffer._width=Math.min(depthBuffer.width,device.maxRenderBufferSize);depthBuffer._height=Math.min(depthBuffer.height,device.maxRenderBufferSize);device.setTexture(depthBuffer,0);}if(target._stencil){gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.DEPTH_STENCIL_ATTACHMENT,depthBuffer._cubemap?gl.TEXTURE_CUBE_MAP_POSITIVE_X+target._face:gl.TEXTURE_2D,target._depthBuffer.impl._glTexture,0);}else {gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.DEPTH_ATTACHMENT,depthBuffer._cubemap?gl.TEXTURE_CUBE_MAP_POSITIVE_X+target._face:gl.TEXTURE_2D,target._depthBuffer.impl._glTexture,0);}}else if(target._depth){const willRenderMsaa=target._samples>1&&device.isWebGL2;if(!willRenderMsaa){if(!this._glDepthBuffer){this._glDepthBuffer=gl.createRenderbuffer();}gl.bindRenderbuffer(gl.RENDERBUFFER,this._glDepthBuffer);if(target._stencil){gl.renderbufferStorage(gl.RENDERBUFFER,gl.DEPTH_STENCIL,target.width,target.height);gl.framebufferRenderbuffer(gl.FRAMEBUFFER,gl.DEPTH_STENCIL_ATTACHMENT,gl.RENDERBUFFER,this._glDepthBuffer);}else {const depthFormat=device.isWebGL2?gl.DEPTH_COMPONENT32F:gl.DEPTH_COMPONENT16;gl.renderbufferStorage(gl.RENDERBUFFER,depthFormat,target.width,target.height);gl.framebufferRenderbuffer(gl.FRAMEBUFFER,gl.DEPTH_ATTACHMENT,gl.RENDERBUFFER,this._glDepthBuffer);}gl.bindRenderbuffer(gl.RENDERBUFFER,null);}}}if(device.isWebGL2&&target._samples>1){var _target$_colorBuffers3,_target$_colorBuffers4;this._glResolveFrameBuffer=this._glFrameBuffer;this._glFrameBuffer=gl.createFramebuffer();device.setFramebuffer(this._glFrameBuffer);const colorBufferCount=(_target$_colorBuffers3=(_target$_colorBuffers4=target._colorBuffers)==null?void 0:_target$_colorBuffers4.length)!=null?_target$_colorBuffers3:0;if(this.suppliedColorFramebuffer!==undefined){const buffer=gl.createRenderbuffer();this._glMsaaColorBuffers.push(buffer);const internalFormat=device.backBufferFormat===PIXELFORMAT_RGBA8?gl.RGBA8:gl.RGB8;gl.bindRenderbuffer(gl.RENDERBUFFER,buffer);gl.renderbufferStorageMultisample(gl.RENDERBUFFER,target._samples,internalFormat,target.width,target.height);gl.framebufferRenderbuffer(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0,gl.RENDERBUFFER,buffer);}else {for(let i=0;i<colorBufferCount;++i){const colorBuffer=target.getColorBuffer(i);if(colorBuffer){const buffer=gl.createRenderbuffer();this._glMsaaColorBuffers.push(buffer);gl.bindRenderbuffer(gl.RENDERBUFFER,buffer);gl.renderbufferStorageMultisample(gl.RENDERBUFFER,target._samples,colorBuffer.impl._glInternalFormat,target.width,target.height);gl.framebufferRenderbuffer(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0+i,gl.RENDERBUFFER,buffer);}}}if(target._depth){if(!this._glMsaaDepthBuffer){this._glMsaaDepthBuffer=gl.createRenderbuffer();}gl.bindRenderbuffer(gl.RENDERBUFFER,this._glMsaaDepthBuffer);if(target._stencil){gl.renderbufferStorageMultisample(gl.RENDERBUFFER,target._samples,gl.DEPTH24_STENCIL8,target.width,target.height);gl.framebufferRenderbuffer(gl.FRAMEBUFFER,gl.DEPTH_STENCIL_ATTACHMENT,gl.RENDERBUFFER,this._glMsaaDepthBuffer);}else {gl.renderbufferStorageMultisample(gl.RENDERBUFFER,target._samples,gl.DEPTH_COMPONENT32F,target.width,target.height);gl.framebufferRenderbuffer(gl.FRAMEBUFFER,gl.DEPTH_ATTACHMENT,gl.RENDERBUFFER,this._glMsaaDepthBuffer);}}if(colorBufferCount>1){this._createMsaaMrtFramebuffers(device,target,colorBufferCount);device.setFramebuffer(this._glFrameBuffer);device.drawBuffers(buffers);}}}_createMsaaMrtFramebuffers(device,target,colorBufferCount){const gl=device.gl;this.colorMrtFramebuffers=[];for(let i=0;i<colorBufferCount;++i){const colorBuffer=target.getColorBuffer(i);const srcFramebuffer=gl.createFramebuffer();device.setFramebuffer(srcFramebuffer);const buffer=this._glMsaaColorBuffers[i];gl.bindRenderbuffer(gl.RENDERBUFFER,buffer);gl.renderbufferStorageMultisample(gl.RENDERBUFFER,target._samples,colorBuffer.impl._glInternalFormat,target.width,target.height);gl.framebufferRenderbuffer(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0,gl.RENDERBUFFER,buffer);device.drawBuffers([gl.COLOR_ATTACHMENT0]);const dstFramebuffer=gl.createFramebuffer();device.setFramebuffer(dstFramebuffer);gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0,colorBuffer._cubemap?gl.TEXTURE_CUBE_MAP_POSITIVE_X+target._face:gl.TEXTURE_2D,colorBuffer.impl._glTexture,0);this.colorMrtFramebuffers[i]=new FramebufferPair(srcFramebuffer,dstFramebuffer);}}_checkFbo(device,target,type=""){const gl=device.gl;const status=gl.checkFramebufferStatus(gl.FRAMEBUFFER);switch(status){case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:break;case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:break;case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:break;case gl.FRAMEBUFFER_UNSUPPORTED:break}}loseContext(){this._glFrameBuffer=null;this._glDepthBuffer=null;this._glResolveFrameBuffer=null;this._glMsaaColorBuffers.length=0;this._glMsaaDepthBuffer=null;this.colorMrtFramebuffers=null;this.suppliedColorFramebuffer=undefined;this._isInitialized=false;}internalResolve(device,src,dst,target,mask){device.setScissor(0,0,target.width,target.height);const gl=device.gl;gl.bindFramebuffer(gl.READ_FRAMEBUFFER,src);gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER,dst);gl.blitFramebuffer(0,0,target.width,target.height,0,0,target.width,target.height,mask,gl.NEAREST);}resolve(device,target,color,depth){if(device.isWebGL2){const gl=device.gl;if(this.colorMrtFramebuffers){if(color){for(let i=0;i<this.colorMrtFramebuffers.length;i++){const fbPair=this.colorMrtFramebuffers[i];this.internalResolve(device,fbPair.msaaFB,fbPair.resolveFB,target,gl.COLOR_BUFFER_BIT);}}if(depth){this.internalResolve(device,this._glFrameBuffer,this._glResolveFrameBuffer,target,gl.DEPTH_BUFFER_BIT);}}else {this.internalResolve(device,this._glFrameBuffer,this._glResolveFrameBuffer,target,(color?gl.COLOR_BUFFER_BIT:0)|(depth?gl.DEPTH_BUFFER_BIT:0));}gl.bindFramebuffer(gl.FRAMEBUFFER,this._glFrameBuffer);}}constructor(){this._glFrameBuffer=null;this._glDepthBuffer=null;this._glResolveFrameBuffer=null;this.colorMrtFramebuffers=null;this._glMsaaColorBuffers=[];this._glMsaaDepthBuffer=null;this.suppliedColorFramebuffer=void 0;this._isInitialized=false;}}var gles2PS=`
#define pcFragColor0 gl_FragData[0]
#if COLOR_ATTACHMENT_1
#define pcFragColor1 gl_FragData[1]
#endif
#if COLOR_ATTACHMENT_2
#define pcFragColor2 gl_FragData[2]
#endif
#if COLOR_ATTACHMENT_3
#define pcFragColor3 gl_FragData[3]
#endif
#if COLOR_ATTACHMENT_4
#define pcFragColor4 gl_FragData[4]
#endif
#if COLOR_ATTACHMENT_5
#define pcFragColor5 gl_FragData[5]
#endif
#if COLOR_ATTACHMENT_6
#define pcFragColor6 gl_FragData[6]
#endif
#if COLOR_ATTACHMENT_7
#define pcFragColor7 gl_FragData[7]
#endif
#define texture2DBias texture2D
#define itexture2D texture2D
#define utexture2D texture2D
#define SHADOWMAP_PASS(name) name
#define SHADOWMAP_ACCEPT(name) sampler2D name
#define TEXTURE_PASS(name) name
#define TEXTURE_ACCEPT(name) sampler2D name
#define TEXTURE_ACCEPT_HIGHP(name) highp sampler2D name
#ifndef SUPPORTS_TEXLOD
	#define texture2DLodEXT texture2D
	#define texture2DProjLodEXT textureProj
	#define textureCubeLodEXT textureCube
	#define textureShadow texture2D
#else
	#define textureShadow(res, uv) texture2DGradEXT(res, uv, vec2(1, 1), vec2(1, 1))
#endif
#ifdef SUPPORTS_MRT
	#define gl_FragColor pcFragColor0
#endif
`;var gles2VS=`
#define TEXTURE_PASS(name) name
#define TEXTURE_ACCEPT(name) sampler2D name
#define TEXTURE_ACCEPT_HIGHP(name) highp sampler2D name
`;var gles3PS=`
#ifndef outType_0
#define outType_0 vec4
#endif
layout(location = 0) out highp outType_0 pc_fragColor;
#ifndef REMOVE_COLOR_ATTACHMENT_1
#if COLOR_ATTACHMENT_1
layout(location = 1) out highp outType_1 pc_fragColor1;
#endif
#endif
#ifndef REMOVE_COLOR_ATTACHMENT_2
#if COLOR_ATTACHMENT_2
layout(location = 2) out highp outType_2 pc_fragColor2;
#endif
#endif
#ifndef REMOVE_COLOR_ATTACHMENT_3
#if COLOR_ATTACHMENT_3
layout(location = 3) out highp outType_3 pc_fragColor3;
#endif
#endif
#ifndef REMOVE_COLOR_ATTACHMENT_4
#if COLOR_ATTACHMENT_4
layout(location = 4) out highp outType_4 pc_fragColor4;
#endif
#endif
#ifndef REMOVE_COLOR_ATTACHMENT_5
#if COLOR_ATTACHMENT_5
layout(location = 5) out highp outType_5 pc_fragColor5;
#endif
#endif
#ifndef REMOVE_COLOR_ATTACHMENT_6
#if COLOR_ATTACHMENT_6
layout(location = 6) out highp outType_6 pc_fragColor6;
#endif
#endif
#ifndef REMOVE_COLOR_ATTACHMENT_7
#if COLOR_ATTACHMENT_7
layout(location = 7) out highp outType_7 pc_fragColor7;
#endif
#endif
#define gl_FragColor pc_fragColor
#define pcFragColor0 pc_fragColor
#define pcFragColor1 pc_fragColor1
#define pcFragColor2 pc_fragColor2
#define pcFragColor3 pc_fragColor3
#define pcFragColor4 pc_fragColor4
#define pcFragColor5 pc_fragColor5
#define pcFragColor6 pc_fragColor6
#define pcFragColor7 pc_fragColor7
#define varying in
#define texture2D texture
#define texture2DBias texture
#define textureCube texture
#define texture2DProj textureProj
#define texture2DLodEXT textureLod
#define texture2DProjLodEXT textureProjLod
#define textureCubeLodEXT textureLod
#define texture2DGradEXT textureGrad
#define texture2DProjGradEXT textureProjGrad
#define textureCubeGradEXT textureGrad
#define utexture2D texture
#define itexture2D texture
#define textureShadow(res, uv) textureGrad(res, uv, vec2(1, 1), vec2(1, 1))
#define SHADOWMAP_PASS(name) name
#define SHADOWMAP_ACCEPT(name) sampler2DShadow name
#define TEXTURE_PASS(name) name
#define TEXTURE_ACCEPT(name) sampler2D name
#define TEXTURE_ACCEPT_HIGHP(name) highp sampler2D name
#define GL2
#define SUPPORTS_TEXLOD
#define SUPPORTS_MRT
`;var gles3VS=`
#define attribute in
#define varying out
#define texture2D texture
#define utexture2D texture
#define itexture2D texture
#define GL2
#define VERTEXSHADER
#define TEXTURE_PASS(name) name
#define TEXTURE_ACCEPT(name) sampler2D name
#define TEXTURE_ACCEPT_HIGHP(name) highp sampler2D name
`;var webgpuPS=`
#extension GL_EXT_samplerless_texture_functions : require
#ifndef outType_0
#define outType_0 vec4
#endif
#ifndef outType_1
#define outType_1 vec4
#endif
#ifndef outType_2
#define outType_2 vec4
#endif
#ifndef outType_3
#define outType_3 vec4
#endif
#ifndef outType_4
#define outType_4 vec4
#endif
#ifndef outType_5
#define outType_5 vec4
#endif
#ifndef outType_6
#define outType_6 vec4
#endif
#ifndef outType_7
#define outType_7 vec4
#endif
layout(location = 0) out highp outType_0 pc_fragColor;
layout(location = 1) out highp outType_1 pc_fragColor1;
layout(location = 2) out highp outType_2 pc_fragColor2;
layout(location = 3) out highp outType_3 pc_fragColor3;
layout(location = 4) out highp outType_4 pc_fragColor4;
layout(location = 5) out highp outType_5 pc_fragColor5;
layout(location = 6) out highp outType_6 pc_fragColor6;
layout(location = 7) out highp outType_7 pc_fragColor7;
#define gl_FragColor pc_fragColor
#define pcFragColor0 pc_fragColor
#define pcFragColor1 pc_fragColor1
#define pcFragColor2 pc_fragColor2
#define pcFragColor3 pc_fragColor3
#define pcFragColor4 pc_fragColor4
#define pcFragColor5 pc_fragColor5
#define pcFragColor6 pc_fragColor6
#define pcFragColor7 pc_fragColor7
#define texture2D(res, uv) texture(sampler2D(res, res ## _sampler), uv)
#define texture2DBias(res, uv, bias) texture(sampler2D(res, res ## _sampler), uv, bias)
#define texture2DLodEXT(res, uv, lod) textureLod(sampler2D(res, res ## _sampler), uv, lod)
#define textureCube(res, uv) texture(samplerCube(res, res ## _sampler), uv)
#define textureCubeLodEXT(res, uv, lod) textureLod(samplerCube(res, res ## _sampler), uv, lod)
#define textureShadow(res, uv) textureLod(sampler2DShadow(res, res ## _sampler), uv, 0.0)
#define itexture2D(res, uv) texture(isampler2D(res, res ## _sampler), uv)
#define utexture2D(res, uv) texture(usampler2D(res, res ## _sampler), uv)
#define SHADOWMAP_PASS(name) name, name ## _sampler
#define SHADOWMAP_ACCEPT(name) texture2D name, sampler name ## _sampler
#define TEXTURE_PASS(name) name, name ## _sampler
#define TEXTURE_ACCEPT(name) texture2D name, sampler name ## _sampler
#define TEXTURE_ACCEPT_HIGHP TEXTURE_ACCEPT
#define GL2
#define WEBGPU
#define SUPPORTS_TEXLOD
#define SUPPORTS_MRT
`;var webgpuVS=`
#extension GL_EXT_samplerless_texture_functions : require
#define texture2D(res, uv) texture(sampler2D(res, res ## _sampler), uv)
#define itexture2D(res, uv) texture(isampler2D(res, res ## _sampler), uv)
#define utexture2D(res, uv) texture(usampler2D(res, res ## _sampler), uv)
#define TEXTURE_PASS(name) name, name ## _sampler
#define TEXTURE_ACCEPT(name) texture2D name, sampler name ## _sampler
#define TEXTURE_ACCEPT_HIGHP TEXTURE_ACCEPT
#define GL2
#define WEBGPU
#define VERTEXSHADER
#define gl_VertexID gl_VertexIndex
`;var sharedFS=`
vec2 getGrabScreenPos(vec4 clipPos) {
	vec2 uv = (clipPos.xy / clipPos.w) * 0.5 + 0.5;
	#ifdef WEBGPU
		uv.y = 1.0 - uv.y;
	#endif
	return uv;
}
vec2 getImageEffectUV(vec2 uv) {
	#ifdef WEBGPU
		uv.y = 1.0 - uv.y;
	#endif
	return uv;
}
`;const _attrib2Semantic={vertex_position:SEMANTIC_POSITION,vertex_normal:SEMANTIC_NORMAL,vertex_tangent:SEMANTIC_TANGENT,vertex_texCoord0:SEMANTIC_TEXCOORD0,vertex_texCoord1:SEMANTIC_TEXCOORD1,vertex_texCoord2:SEMANTIC_TEXCOORD2,vertex_texCoord3:SEMANTIC_TEXCOORD3,vertex_texCoord4:SEMANTIC_TEXCOORD4,vertex_texCoord5:SEMANTIC_TEXCOORD5,vertex_texCoord6:SEMANTIC_TEXCOORD6,vertex_texCoord7:SEMANTIC_TEXCOORD7,vertex_color:SEMANTIC_COLOR,vertex_boneIndices:SEMANTIC_BLENDINDICES,vertex_boneWeights:SEMANTIC_BLENDWEIGHT};class ShaderUtils{static createDefinition(device,options){var _options$name,_options$attributes;const getDefines=(gpu,gl2,gl1,isVertex,options)=>{const deviceIntro=device.isWebGPU?gpu:device.isWebGL2?gl2:ShaderUtils.gl1Extensions(device,options)+gl1;let attachmentsDefine="";if(!isVertex){var _options$fragmentOutp;let fragmentOutputTypes=(_options$fragmentOutp=options.fragmentOutputTypes)!=null?_options$fragmentOutp:"vec4";if(!Array.isArray(fragmentOutputTypes)){fragmentOutputTypes=[fragmentOutputTypes];}for(let i=0;i<device.maxColorAttachments;i++){var _fragmentOutputTypes$;attachmentsDefine+=`#define COLOR_ATTACHMENT_${i}
`;const outType=(_fragmentOutputTypes$=fragmentOutputTypes[i])!=null?_fragmentOutputTypes$:"vec4";attachmentsDefine+=`#define outType_${i} ${outType}
`;}}return attachmentsDefine+deviceIntro};const name=(_options$name=options.name)!=null?_options$name:"Untitled";const vertCode=ShaderUtils.versionCode(device)+getDefines(webgpuVS,gles3VS,gles2VS,true,options)+ShaderUtils.getDefinesCode(options.vertexDefines)+sharedFS+ShaderUtils.getShaderNameCode(name)+options.vertexCode;const fragCode=`${(options.fragmentPreamble||"")+ShaderUtils.versionCode(device)+getDefines(webgpuPS,gles3PS,gles2PS,false,options)+ShaderUtils.getDefinesCode(options.fragmentDefines)+ShaderUtils.precisionCode(device)}
${sharedFS}${ShaderUtils.getShaderNameCode(name)}${options.fragmentCode||ShaderUtils.dummyFragmentCode()}`;const attribs=(_options$attributes=options.attributes)!=null?_options$attributes:ShaderUtils.collectAttributes(options.vertexCode);return {name:name,attributes:attribs,vshader:vertCode,vincludes:options.vertexIncludes,fincludes:options.fragmentIncludes,fshader:fragCode,useTransformFeedback:options.useTransformFeedback}}static getDefinesCode(defines){let code="";defines==null||defines.forEach((value,key)=>{code+=`#define ${key} ${value}
`;});return code}static getShaderNameCode(name){return `#define SHADER_NAME ${name}
`}static gl1Extensions(device,options,isVertex){let code;if(isVertex){code=options.vertexExtensions?`${options.vertexExtensions}
`:"";}else {code=options.fragmentExtensions?`${options.fragmentExtensions}
`:"";if(device.extStandardDerivatives){code+="#extension GL_OES_standard_derivatives : enable\n";}if(device.extTextureLod){code+="#extension GL_EXT_shader_texture_lod : enable\n";code+="#define SUPPORTS_TEXLOD\n";}if(device.extDrawBuffers){code+="#extension GL_EXT_draw_buffers : require\n";code+="#define SUPPORTS_MRT\n";}}return code}static dummyFragmentCode(){return "void main(void) {gl_FragColor = vec4(0.0);}"}static versionCode(device){if(device.isWebGPU){return "#version 450\n"}return device.isWebGL2?"#version 300 es\n":""}static precisionCode(device,forcePrecision){let code="";if(forcePrecision&&forcePrecision!=="highp"&&forcePrecision!=="mediump"&&forcePrecision!=="lowp"){forcePrecision=null;}if(forcePrecision){if(forcePrecision==="highp"&&device.maxPrecision!=="highp"){forcePrecision="mediump";}if(forcePrecision==="mediump"&&device.maxPrecision==="lowp"){forcePrecision="lowp";}}const precision=forcePrecision?forcePrecision:device.precision;if(!device.isWebGPU){code=`precision ${precision} float;
precision ${precision} int;`;if(device.isWebGL2){code+=`precision ${precision} sampler2DShadow;
`;}}else {code=`precision ${precision} float;
precision ${precision} int;
`;}return code}static collectAttributes(vsCode){const attribs={};let attrs=0;let found=vsCode.indexOf("attribute");while(found>=0){if(found>0&&vsCode[found-1]==="/")break;const endOfLine=vsCode.indexOf(";",found);const startOfAttribName=vsCode.lastIndexOf(" ",endOfLine);const attribName=vsCode.substring(startOfAttribName+1,endOfLine);if(attribs[attribName]);else {const semantic=_attrib2Semantic[attribName];if(semantic!==undefined){attribs[attribName]=semantic;}else {attribs[attribName]=`ATTR${attrs}`;attrs++;}}found=vsCode.indexOf("attribute",found+1);}return attribs}}class FrameQueriesInfo{destroy(gl){this.queries.forEach(query=>gl.deleteQuery(query));this.queries=null;}constructor(){this.renderVersion=void 0;this.queries=[];}}class WebglGpuProfiler extends GpuProfiler{destroy(){this.freeQueries.forEach(query=>this.device.gl.deleteQuery(query));this.frameQueries.forEach(query=>this.device.gl.deleteQuery(query));this.previousFrameQueries.forEach(frameQueriesInfo=>frameQueriesInfo.destroy(this.device.gl));this.freeQueries=null;this.frameQueries=null;this.previousFrameQueries=null;}loseContext(){super.loseContext();this.freeQueries=[];this.frameQueries=[];this.previousFrameQueries=[];}restoreContext(){this.ext=this.device.extDisjointTimerQuery;}getQuery(){var _this$freeQueries$pop;return (_this$freeQueries$pop=this.freeQueries.pop())!=null?_this$freeQueries$pop:this.device.gl.createQuery()}start(name){if(this.ext){const slot=this.getSlot(name);const query=this.getQuery();this.frameQueries[slot]=query;this.device.gl.beginQuery(this.ext.TIME_ELAPSED_EXT,query);return slot}return undefined}end(slot){if(slot!==undefined){this.device.gl.endQuery(this.ext.TIME_ELAPSED_EXT);}}frameStart(){this.processEnableRequest();if(this._enabled){this.frameGPUMarkerSlot=this.start("GpuFrame");}}frameEnd(){if(this._enabled){this.end(this.frameGPUMarkerSlot);}}request(){if(this._enabled){const ext=this.ext;const gl=this.device.gl;const renderVersion=this.device.renderVersion;const frameQueries=this.frameQueries;if(frameQueries.length>0){this.frameQueries=[];const frameQueriesInfo=new FrameQueriesInfo;frameQueriesInfo.queries=frameQueries;frameQueriesInfo.renderVersion=renderVersion;this.previousFrameQueries.push(frameQueriesInfo);}if(this.previousFrameQueries.length>0){const previousQueriesInfo=this.previousFrameQueries[0];const previousQueries=previousQueriesInfo.queries;const lastQuery=previousQueries[previousQueries.length-1];const available=gl.getQueryParameter(lastQuery,gl.QUERY_RESULT_AVAILABLE);const disjoint=gl.getParameter(ext.GPU_DISJOINT_EXT);if(available&&!disjoint){this.previousFrameQueries.shift();const timings=this.timings;timings.length=0;for(let i=0;i<previousQueries.length;i++){const query=previousQueries[i];const duration=gl.getQueryParameter(query,gl.QUERY_RESULT);timings[i]=duration*1e-6;this.freeQueries.push(query);}this.report(previousQueriesInfo.renderVersion,timings);}if(disjoint){this.previousFrameQueries.forEach(frameQueriesInfo=>{this.report(frameQueriesInfo.renderVersion,null);frameQueriesInfo.destroy(gl);});this.previousFrameQueries.length=0;}}super.request(renderVersion);}}constructor(device){super();this.device=void 0;this.freeQueries=[];this.frameQueries=[];this.previousFrameQueries=[];this.timings=[];this.device=device;this.ext=device.extDisjointTimerQuery;}}const invalidateAttachments=[];const _fullScreenQuadVS=`
attribute vec2 vertex_position;
varying vec2 vUv0;
void main(void)
{
	gl_Position = vec4(vertex_position, 0.5, 1.0);
	vUv0 = vertex_position.xy*0.5+0.5;
}
`;const _precisionTest1PS=`
void main(void) { 
	gl_FragColor = vec4(2147483648.0);
}
`;const _precisionTest2PS=`
uniform sampler2D source;
vec4 packFloat(float depth) {
	const vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);
	const vec4 bit_mask  = vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);
	vec4 res = mod(depth * bit_shift * vec4(255), vec4(256) ) / vec4(255);
	res -= res.xxyz * bit_mask;
	return res;
}
void main(void) {
	float c = texture2D(source, vec2(0.0)).r;
	float diff = abs(c - 2147483648.0) / 2147483648.0;
	gl_FragColor = packFloat(diff);
}
`;const _outputTexture2D=`
varying vec2 vUv0;
uniform sampler2D source;
void main(void) {
	gl_FragColor = texture2D(source, vUv0);
}
`;function quadWithShader(device,target,shader){const oldRt=device.renderTarget;device.setRenderTarget(target);device.updateBegin();device.setCullMode(CULLFACE_NONE);device.setBlendState(BlendState.NOBLEND);device.setDepthState(DepthState.NODEPTH);device.setStencilState(null,null);device.setVertexBuffer(device.quadVertexBuffer,0);device.setShader(shader);device.draw({type:PRIMITIVE_TRISTRIP,base:0,count:4,indexed:false});device.updateEnd();device.setRenderTarget(oldRt);device.updateBegin();}function testRenderable(gl,pixelFormat){let result=true;const texture=gl.createTexture();gl.bindTexture(gl.TEXTURE_2D,texture);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.NEAREST);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.NEAREST);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,2,2,0,gl.RGBA,pixelFormat,null);const framebuffer=gl.createFramebuffer();gl.bindFramebuffer(gl.FRAMEBUFFER,framebuffer);gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0,gl.TEXTURE_2D,texture,0);if(gl.checkFramebufferStatus(gl.FRAMEBUFFER)!==gl.FRAMEBUFFER_COMPLETE){result=false;}gl.bindTexture(gl.TEXTURE_2D,null);gl.deleteTexture(texture);gl.bindFramebuffer(gl.FRAMEBUFFER,null);gl.deleteFramebuffer(framebuffer);return result}function testTextureHalfFloatUpdatable(gl,pixelFormat){let result=true;const texture=gl.createTexture();gl.bindTexture(gl.TEXTURE_2D,texture);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.NEAREST);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.NEAREST);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);const data=new Uint16Array(4*2*2);gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,2,2,0,gl.RGBA,pixelFormat,data);if(gl.getError()!==gl.NO_ERROR){result=false;console.log("Above error related to HALF_FLOAT_OES can be ignored, it was triggered by testing half float texture support");}gl.bindTexture(gl.TEXTURE_2D,null);gl.deleteTexture(texture);return result}function testTextureFloatHighPrecision(device){if(!device.textureFloatRenderable){return false}const shader1=new Shader(device,ShaderUtils.createDefinition(device,{name:"ptest1",vertexCode:_fullScreenQuadVS,fragmentCode:_precisionTest1PS}));const shader2=new Shader(device,ShaderUtils.createDefinition(device,{name:"ptest2",vertexCode:_fullScreenQuadVS,fragmentCode:_precisionTest2PS}));const textureOptions={format:PIXELFORMAT_RGBA32F,width:1,height:1,mipmaps:false,minFilter:FILTER_NEAREST,magFilter:FILTER_NEAREST,name:"testFHP"};const tex1=new Texture(device,textureOptions);const targ1=new RenderTarget({colorBuffer:tex1,depth:false});quadWithShader(device,targ1,shader1);textureOptions.format=PIXELFORMAT_RGBA8;const tex2=new Texture(device,textureOptions);const targ2=new RenderTarget({colorBuffer:tex2,depth:false});device.constantTexSource.setValue(tex1);quadWithShader(device,targ2,shader2);const prevFramebuffer=device.activeFramebuffer;device.setFramebuffer(targ2.impl._glFrameBuffer);const pixels=new Uint8Array(4);device.readPixels(0,0,1,1,pixels);device.setFramebuffer(prevFramebuffer);const x=pixels[0]/255;const y=pixels[1]/255;const z=pixels[2]/255;const w=pixels[3]/255;const f=x/(256*256*256)+y/(256*256)+z/256+w;tex1.destroy();targ1.destroy();tex2.destroy();targ2.destroy();shader1.destroy();shader2.destroy();return f===0}class WebglGraphicsDevice extends GraphicsDevice{postInit(){super.postInit();this.gpuProfiler=new WebglGpuProfiler(this);}destroy(){super.destroy();const gl=this.gl;if(this.isWebGL2&&this.feedback){gl.deleteTransformFeedback(this.feedback);}this.clearVertexArrayObjectCache();this.canvas.removeEventListener("webglcontextlost",this._contextLostHandler,false);this.canvas.removeEventListener("webglcontextrestored",this._contextRestoredHandler,false);this._contextLostHandler=null;this._contextRestoredHandler=null;this.gl=null;super.postDestroy();}createBackbuffer(frameBuffer){this.supportsStencil=this.initOptions.stencil;this.backBuffer=new RenderTarget({name:"WebglFramebuffer",graphicsDevice:this,depth:this.initOptions.depth,stencil:this.supportsStencil,samples:this.samples});this.backBuffer.impl.suppliedColorFramebuffer=frameBuffer;}updateBackbufferFormat(framebuffer){const gl=this.gl;gl.bindFramebuffer(gl.FRAMEBUFFER,framebuffer);const alphaBits=this.gl.getParameter(this.gl.ALPHA_BITS);this.backBufferFormat=alphaBits?PIXELFORMAT_RGBA8:PIXELFORMAT_RGB8;}updateBackbuffer(){const resolutionChanged=this.canvas.width!==this.backBufferSize.x||this.canvas.height!==this.backBufferSize.y;if(this._defaultFramebufferChanged||resolutionChanged){if(this._defaultFramebufferChanged){this.updateBackbufferFormat(this._defaultFramebuffer);}this._defaultFramebufferChanged=false;this.backBufferSize.set(this.canvas.width,this.canvas.height);this.backBuffer.destroy();this.createBackbuffer(this._defaultFramebuffer);}}createVertexBufferImpl(vertexBuffer,format){return new WebglVertexBuffer}createIndexBufferImpl(indexBuffer){return new WebglIndexBuffer(indexBuffer)}createShaderImpl(shader){return new WebglShader(shader)}createTextureImpl(texture){return new WebglTexture}createRenderTargetImpl(renderTarget){return new WebglRenderTarget}getPrecision(){const gl=this.gl;let precision="highp";if(gl.getShaderPrecisionFormat){const vertexShaderPrecisionHighpFloat=gl.getShaderPrecisionFormat(gl.VERTEX_SHADER,gl.HIGH_FLOAT);const vertexShaderPrecisionMediumpFloat=gl.getShaderPrecisionFormat(gl.VERTEX_SHADER,gl.MEDIUM_FLOAT);const fragmentShaderPrecisionHighpFloat=gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER,gl.HIGH_FLOAT);const fragmentShaderPrecisionMediumpFloat=gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER,gl.MEDIUM_FLOAT);if(vertexShaderPrecisionHighpFloat&&vertexShaderPrecisionMediumpFloat&&fragmentShaderPrecisionHighpFloat&&fragmentShaderPrecisionMediumpFloat){const highpAvailable=vertexShaderPrecisionHighpFloat.precision>0&&fragmentShaderPrecisionHighpFloat.precision>0;const mediumpAvailable=vertexShaderPrecisionMediumpFloat.precision>0&&fragmentShaderPrecisionMediumpFloat.precision>0;if(!highpAvailable){if(mediumpAvailable){precision="mediump";}else {precision="lowp";}}}}return precision}getExtension(){for(let i=0;i<arguments.length;i++){if(this.supportedExtensions.indexOf(arguments[i])!==-1){return this.gl.getExtension(arguments[i])}}return null}get extDisjointTimerQuery(){if(!this._extDisjointTimerQuery){if(this.isWebGL2){this._extDisjointTimerQuery=this.getExtension("EXT_disjoint_timer_query_webgl2","EXT_disjoint_timer_query");}}return this._extDisjointTimerQuery}initializeExtensions(){var _gl$getSupportedExten;const gl=this.gl;this.supportedExtensions=(_gl$getSupportedExten=gl.getSupportedExtensions())!=null?_gl$getSupportedExten:[];this._extDisjointTimerQuery=null;if(this.isWebGL2){this.extBlendMinmax=true;this.extDrawBuffers=true;this.drawBuffers=gl.drawBuffers.bind(gl);this.extInstancing=true;this.extStandardDerivatives=true;this.extTextureFloat=true;this.extTextureHalfFloat=true;this.textureHalfFloatFilterable=true;this.extTextureLod=true;this.extUintElement=true;this.extVertexArrayObject=true;this.extColorBufferFloat=this.getExtension("EXT_color_buffer_float");this.extDepthTexture=true;this.textureRG11B10Renderable=true;}else {var _this$extDrawBuffers;this.extBlendMinmax=this.getExtension("EXT_blend_minmax");this.extDrawBuffers=this.getExtension("WEBGL_draw_buffers");this.extInstancing=this.getExtension("ANGLE_instanced_arrays");this.drawBuffers=(_this$extDrawBuffers=this.extDrawBuffers)==null?void 0:_this$extDrawBuffers.drawBuffersWEBGL.bind(this.extDrawBuffers);if(this.extInstancing){const ext=this.extInstancing;gl.drawArraysInstanced=ext.drawArraysInstancedANGLE.bind(ext);gl.drawElementsInstanced=ext.drawElementsInstancedANGLE.bind(ext);gl.vertexAttribDivisor=ext.vertexAttribDivisorANGLE.bind(ext);}this.extStandardDerivatives=this.getExtension("OES_standard_derivatives");this.extTextureFloat=this.getExtension("OES_texture_float");this.extTextureLod=this.getExtension("EXT_shader_texture_lod");this.extUintElement=this.getExtension("OES_element_index_uint");this.extVertexArrayObject=this.getExtension("OES_vertex_array_object");if(this.extVertexArrayObject){const ext=this.extVertexArrayObject;gl.createVertexArray=ext.createVertexArrayOES.bind(ext);gl.deleteVertexArray=ext.deleteVertexArrayOES.bind(ext);gl.isVertexArray=ext.isVertexArrayOES.bind(ext);gl.bindVertexArray=ext.bindVertexArrayOES.bind(ext);}this.extColorBufferFloat=null;this.extDepthTexture=gl.getExtension("WEBGL_depth_texture");this.extTextureHalfFloat=this.getExtension("OES_texture_half_float");this.extTextureHalfFloatLinear=this.getExtension("OES_texture_half_float_linear");this.textureHalfFloatFilterable=!!this.extTextureHalfFloatLinear;}this.extDebugRendererInfo=this.getExtension("WEBGL_debug_renderer_info");this.extTextureFloatLinear=this.getExtension("OES_texture_float_linear");this.textureFloatFilterable=!!this.extTextureFloatLinear;this.extFloatBlend=this.getExtension("EXT_float_blend");this.extTextureFilterAnisotropic=this.getExtension("EXT_texture_filter_anisotropic","WEBKIT_EXT_texture_filter_anisotropic");this.extCompressedTextureETC1=this.getExtension("WEBGL_compressed_texture_etc1");this.extCompressedTextureETC=this.getExtension("WEBGL_compressed_texture_etc");this.extCompressedTexturePVRTC=this.getExtension("WEBGL_compressed_texture_pvrtc","WEBKIT_WEBGL_compressed_texture_pvrtc");this.extCompressedTextureS3TC=this.getExtension("WEBGL_compressed_texture_s3tc","WEBKIT_WEBGL_compressed_texture_s3tc");this.extCompressedTextureATC=this.getExtension("WEBGL_compressed_texture_atc");this.extCompressedTextureASTC=this.getExtension("WEBGL_compressed_texture_astc");this.extParallelShaderCompile=this.getExtension("KHR_parallel_shader_compile");this.extColorBufferHalfFloat=this.getExtension("EXT_color_buffer_half_float");}initializeCapabilities(){var _contextAttribs$antia,_contextAttribs$stenc;const gl=this.gl;let ext;const userAgent=typeof navigator!=="undefined"?navigator.userAgent:"";this.maxPrecision=this.precision=this.getPrecision();const contextAttribs=gl.getContextAttributes();this.supportsMsaa=(_contextAttribs$antia=contextAttribs==null?void 0:contextAttribs.antialias)!=null?_contextAttribs$antia:false;this.supportsStencil=(_contextAttribs$stenc=contextAttribs==null?void 0:contextAttribs.stencil)!=null?_contextAttribs$stenc:false;this.supportsInstancing=!!this.extInstancing;this.maxTextureSize=gl.getParameter(gl.MAX_TEXTURE_SIZE);this.maxCubeMapSize=gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);this.maxRenderBufferSize=gl.getParameter(gl.MAX_RENDERBUFFER_SIZE);this.maxTextures=gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);this.maxCombinedTextures=gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);this.maxVertexTextures=gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);this.vertexUniformsCount=gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);this.fragmentUniformsCount=gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);if(this.isWebGL2){this.maxDrawBuffers=gl.getParameter(gl.MAX_DRAW_BUFFERS);this.maxColorAttachments=gl.getParameter(gl.MAX_COLOR_ATTACHMENTS);this.maxVolumeSize=gl.getParameter(gl.MAX_3D_TEXTURE_SIZE);this.supportsMrt=true;this.supportsVolumeTextures=true;}else {ext=this.extDrawBuffers;this.supportsMrt=!!ext;this.maxDrawBuffers=ext?gl.getParameter(ext.MAX_DRAW_BUFFERS_WEBGL):1;this.maxColorAttachments=ext?gl.getParameter(ext.MAX_COLOR_ATTACHMENTS_WEBGL):1;this.maxVolumeSize=1;}ext=this.extDebugRendererInfo;this.unmaskedRenderer=ext?gl.getParameter(ext.UNMASKED_RENDERER_WEBGL):"";this.unmaskedVendor=ext?gl.getParameter(ext.UNMASKED_VENDOR_WEBGL):"";const maliRendererRegex=/\bMali-G52+/;const samsungModelRegex=/SM-[a-zA-Z0-9]+/;this.supportsGpuParticles=!(this.unmaskedVendor==="ARM"&&userAgent.match(samsungModelRegex))&&!this.unmaskedRenderer.match(maliRendererRegex);ext=this.extTextureFilterAnisotropic;this.maxAnisotropy=ext?gl.getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT):1;const antialiasSupported=this.isWebGL2&&!this.forceDisableMultisampling;this.maxSamples=antialiasSupported?gl.getParameter(gl.MAX_SAMPLES):1;this.maxSamples=Math.min(this.maxSamples,4);this.samples=antialiasSupported&&this.backBufferAntialias?this.maxSamples:1;this.supportsAreaLights=this.isWebGL2||!platform.android;this.supportsTextureFetch=this.isWebGL2;if(this.maxTextures<=8){this.supportsAreaLights=false;}}initializeRenderState(){super.initializeRenderState();const gl=this.gl;gl.disable(gl.BLEND);gl.blendFunc(gl.ONE,gl.ZERO);gl.blendEquation(gl.FUNC_ADD);gl.colorMask(true,true,true,true);gl.blendColor(0,0,0,0);gl.enable(gl.CULL_FACE);this.cullFace=gl.BACK;gl.cullFace(gl.BACK);gl.enable(gl.DEPTH_TEST);gl.depthFunc(gl.LEQUAL);gl.depthMask(true);this.stencil=false;gl.disable(gl.STENCIL_TEST);this.stencilFuncFront=this.stencilFuncBack=FUNC_ALWAYS;this.stencilRefFront=this.stencilRefBack=0;this.stencilMaskFront=this.stencilMaskBack=255;gl.stencilFunc(gl.ALWAYS,0,255);this.stencilFailFront=this.stencilFailBack=STENCILOP_KEEP;this.stencilZfailFront=this.stencilZfailBack=STENCILOP_KEEP;this.stencilZpassFront=this.stencilZpassBack=STENCILOP_KEEP;this.stencilWriteMaskFront=255;this.stencilWriteMaskBack=255;gl.stencilOp(gl.KEEP,gl.KEEP,gl.KEEP);gl.stencilMask(255);this.alphaToCoverage=false;this.raster=true;if(this.isWebGL2){gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);gl.disable(gl.RASTERIZER_DISCARD);}this.depthBiasEnabled=false;gl.disable(gl.POLYGON_OFFSET_FILL);this.clearDepth=1;gl.clearDepth(1);this.clearColor=new Color(0,0,0,0);gl.clearColor(0,0,0,0);this.clearStencil=0;gl.clearStencil(0);if(this.isWebGL2){gl.hint(gl.FRAGMENT_SHADER_DERIVATIVE_HINT,gl.NICEST);}else {if(this.extStandardDerivatives){gl.hint(this.extStandardDerivatives.FRAGMENT_SHADER_DERIVATIVE_HINT_OES,gl.NICEST);}}gl.enable(gl.SCISSOR_TEST);gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL,gl.NONE);this.unpackFlipY=false;gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL,false);this.unpackPremultiplyAlpha=false;gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,false);gl.pixelStorei(gl.UNPACK_ALIGNMENT,1);}initTextureUnits(count=16){this.textureUnits=[];for(let i=0;i<count;i++){this.textureUnits.push([null,null,null]);}}initializeContextCaches(){super.initializeContextCaches();this._vaoMap=new Map;this.boundVao=null;this.activeFramebuffer=null;this.feedback=null;this.transformFeedbackBuffer=null;this.textureUnit=0;this.initTextureUnits(this.maxCombinedTextures);}loseContext(){super.loseContext();for(const shader of this.shaders){shader.loseContext();}}restoreContext(){this.initializeExtensions();this.initializeCapabilities();super.restoreContext();for(const shader of this.shaders){shader.restoreContext();}}setViewport(x,y,w,h){if(this.vx!==x||this.vy!==y||this.vw!==w||this.vh!==h){this.gl.viewport(x,y,w,h);this.vx=x;this.vy=y;this.vw=w;this.vh=h;}}setScissor(x,y,w,h){if(this.sx!==x||this.sy!==y||this.sw!==w||this.sh!==h){this.gl.scissor(x,y,w,h);this.sx=x;this.sy=y;this.sw=w;this.sh=h;}}setFramebuffer(fb){if(this.activeFramebuffer!==fb){const gl=this.gl;gl.bindFramebuffer(gl.FRAMEBUFFER,fb);this.activeFramebuffer=fb;}}copyRenderTarget(source,dest,color,depth){const gl=this.gl;if(source===this.backBuffer){source=null;}if(!this.isWebGL2&&depth){return false}if(color){if(!dest){if(!source._colorBuffer){return false}}else if(source){if(!source._colorBuffer||!dest._colorBuffer){return false}if(source._colorBuffer._format!==dest._colorBuffer._format){return false}}}if(depth&&source){if(!source._depth){if(!source._depthBuffer||!dest._depthBuffer){return false}if(source._depthBuffer._format!==dest._depthBuffer._format){return false}}}if(this.isWebGL2){var _this$backBuffer,_this$backBuffer2;const prevRt=this.renderTarget;this.renderTarget=dest;this.updateBegin();const src=source?source.impl._glFrameBuffer:(_this$backBuffer=this.backBuffer)==null?void 0:_this$backBuffer.impl._glFrameBuffer;const dst=dest?dest.impl._glFrameBuffer:(_this$backBuffer2=this.backBuffer)==null?void 0:_this$backBuffer2.impl._glFrameBuffer;gl.bindFramebuffer(gl.READ_FRAMEBUFFER,src);gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER,dst);const w=source?source.width:dest?dest.width:this.width;const h=source?source.height:dest?dest.height:this.height;gl.blitFramebuffer(0,0,w,h,0,0,w,h,(color?gl.COLOR_BUFFER_BIT:0)|(depth?gl.DEPTH_BUFFER_BIT:0),gl.NEAREST);this.renderTarget=prevRt;gl.bindFramebuffer(gl.FRAMEBUFFER,prevRt?prevRt.impl._glFrameBuffer:null);}else {const shader=this.getCopyShader();this.constantTexSource.setValue(source._colorBuffer);quadWithShader(this,dest,shader);}return true}getCopyShader(){if(!this._copyShader){this._copyShader=new Shader(this,ShaderUtils.createDefinition(this,{name:"outputTex2D",vertexCode:_fullScreenQuadVS,fragmentCode:_outputTexture2D}));}return this._copyShader}frameStart(){super.frameStart();this.updateBackbuffer();this.gpuProfiler.frameStart();}frameEnd(){super.frameEnd();this.gpuProfiler.frameEnd();this.gpuProfiler.request();}startRenderPass(renderPass){var _renderPass$renderTar;const rt=(_renderPass$renderTar=renderPass.renderTarget)!=null?_renderPass$renderTar:this.backBuffer;this.renderTarget=rt;this.updateBegin();const{width,height}=rt;this.setViewport(0,0,width,height);this.setScissor(0,0,width,height);const colorOps=renderPass.colorOps;const depthStencilOps=renderPass.depthStencilOps;if(colorOps!=null&&colorOps.clear||depthStencilOps.clearDepth||depthStencilOps.clearStencil){let clearFlags=0;const clearOptions={};if(colorOps!=null&&colorOps.clear){clearFlags|=CLEARFLAG_COLOR;clearOptions.color=[colorOps.clearValue.r,colorOps.clearValue.g,colorOps.clearValue.b,colorOps.clearValue.a];}if(depthStencilOps.clearDepth){clearFlags|=CLEARFLAG_DEPTH;clearOptions.depth=depthStencilOps.clearDepthValue;}if(depthStencilOps.clearStencil){clearFlags|=CLEARFLAG_STENCIL;clearOptions.stencil=depthStencilOps.clearStencilValue;}clearOptions.flags=clearFlags;this.clear(clearOptions);}this.insideRenderPass=true;}endRenderPass(renderPass){this.unbindVertexArray();const target=this.renderTarget;const colorBufferCount=renderPass.colorArrayOps.length;if(target){var _renderPass$colorOps;if(this.isWebGL2){invalidateAttachments.length=0;const gl=this.gl;for(let i=0;i<colorBufferCount;i++){const colorOps=renderPass.colorArrayOps[i];if(!(colorOps.store||colorOps.resolve)){invalidateAttachments.push(gl.COLOR_ATTACHMENT0+i);}}if(target!==this.backBuffer){if(!renderPass.depthStencilOps.storeDepth){invalidateAttachments.push(gl.DEPTH_ATTACHMENT);}if(!renderPass.depthStencilOps.storeStencil){invalidateAttachments.push(gl.STENCIL_ATTACHMENT);}}if(invalidateAttachments.length>0){if(renderPass.fullSizeClearRect){gl.invalidateFramebuffer(gl.DRAW_FRAMEBUFFER,invalidateAttachments);}}}if((_renderPass$colorOps=renderPass.colorOps)!=null&&_renderPass$colorOps.resolve){if(this.isWebGL2&&renderPass.samples>1&&target.autoResolve){target.resolve(true,false);}}for(let i=0;i<colorBufferCount;i++){const colorOps=renderPass.colorArrayOps[i];if(colorOps.mipmaps){const colorBuffer=target._colorBuffers[i];if(colorBuffer&&colorBuffer.impl._glTexture&&colorBuffer.mipmaps&&(colorBuffer.pot||this.isWebGL2)){this.activeTexture(this.maxCombinedTextures-1);this.bindTexture(colorBuffer);this.gl.generateMipmap(colorBuffer.impl._glTarget);}}}}this.insideRenderPass=false;}set defaultFramebuffer(value){if(this._defaultFramebuffer!==value){this._defaultFramebuffer=value;this._defaultFramebufferChanged=true;}}get defaultFramebuffer(){return this._defaultFramebuffer}updateBegin(){var _this$renderTarget;this.boundVao=null;if(this._tempEnableSafariTextureUnitWorkaround){for(let unit=0;unit<this.textureUnits.length;++unit){for(let slot=0;slot<3;++slot){this.textureUnits[unit][slot]=null;}}}const target=(_this$renderTarget=this.renderTarget)!=null?_this$renderTarget:this.backBuffer;const targetImpl=target.impl;if(!targetImpl.initialized){this.initRenderTarget(target);}this.setFramebuffer(targetImpl._glFrameBuffer);}updateEnd(){this.unbindVertexArray();const target=this.renderTarget;if(target&&target!==this.backBuffer){if(this.isWebGL2&&target._samples>1&&target.autoResolve){target.resolve();}const colorBuffer=target._colorBuffer;if(colorBuffer&&colorBuffer.impl._glTexture&&colorBuffer.mipmaps&&(colorBuffer.pot||this.isWebGL2)){this.activeTexture(this.maxCombinedTextures-1);this.bindTexture(colorBuffer);this.gl.generateMipmap(colorBuffer.impl._glTarget);}}}setUnpackFlipY(flipY){if(this.unpackFlipY!==flipY){this.unpackFlipY=flipY;const gl=this.gl;gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL,flipY);}}setUnpackPremultiplyAlpha(premultiplyAlpha){if(this.unpackPremultiplyAlpha!==premultiplyAlpha){this.unpackPremultiplyAlpha=premultiplyAlpha;const gl=this.gl;gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,premultiplyAlpha);}}activeTexture(textureUnit){if(this.textureUnit!==textureUnit){this.gl.activeTexture(this.gl.TEXTURE0+textureUnit);this.textureUnit=textureUnit;}}bindTexture(texture){const impl=texture.impl;const textureTarget=impl._glTarget;const textureObject=impl._glTexture;const textureUnit=this.textureUnit;const slot=this.targetToSlot[textureTarget];if(this.textureUnits[textureUnit][slot]!==textureObject){this.gl.bindTexture(textureTarget,textureObject);this.textureUnits[textureUnit][slot]=textureObject;}}bindTextureOnUnit(texture,textureUnit){const impl=texture.impl;const textureTarget=impl._glTarget;const textureObject=impl._glTexture;const slot=this.targetToSlot[textureTarget];if(this.textureUnits[textureUnit][slot]!==textureObject){this.activeTexture(textureUnit);this.gl.bindTexture(textureTarget,textureObject);this.textureUnits[textureUnit][slot]=textureObject;}}setTextureParameters(texture){const gl=this.gl;const flags=texture.impl.dirtyParameterFlags;const target=texture.impl._glTarget;if(flags&1){let filter=texture._minFilter;if(!texture.pot&&!this.isWebGL2||!texture._mipmaps||texture._compressed&&texture._levels.length===1){if(filter===FILTER_NEAREST_MIPMAP_NEAREST||filter===FILTER_NEAREST_MIPMAP_LINEAR){filter=FILTER_NEAREST;}else if(filter===FILTER_LINEAR_MIPMAP_NEAREST||filter===FILTER_LINEAR_MIPMAP_LINEAR){filter=FILTER_LINEAR;}}gl.texParameteri(target,gl.TEXTURE_MIN_FILTER,this.glFilter[filter]);}if(flags&2){gl.texParameteri(target,gl.TEXTURE_MAG_FILTER,this.glFilter[texture._magFilter]);}if(flags&4){if(this.isWebGL2){gl.texParameteri(target,gl.TEXTURE_WRAP_S,this.glAddress[texture._addressU]);}else {gl.texParameteri(target,gl.TEXTURE_WRAP_S,this.glAddress[texture.pot?texture._addressU:ADDRESS_CLAMP_TO_EDGE]);}}if(flags&8){if(this.isWebGL2){gl.texParameteri(target,gl.TEXTURE_WRAP_T,this.glAddress[texture._addressV]);}else {gl.texParameteri(target,gl.TEXTURE_WRAP_T,this.glAddress[texture.pot?texture._addressV:ADDRESS_CLAMP_TO_EDGE]);}}if(flags&16){if(this.isWebGL2){gl.texParameteri(target,gl.TEXTURE_WRAP_R,this.glAddress[texture._addressW]);}}if(flags&32){if(this.isWebGL2){gl.texParameteri(target,gl.TEXTURE_COMPARE_MODE,texture._compareOnRead?gl.COMPARE_REF_TO_TEXTURE:gl.NONE);}}if(flags&64){if(this.isWebGL2){gl.texParameteri(target,gl.TEXTURE_COMPARE_FUNC,this.glComparison[texture._compareFunc]);}}if(flags&128){const ext=this.extTextureFilterAnisotropic;if(ext){gl.texParameterf(target,ext.TEXTURE_MAX_ANISOTROPY_EXT,math.clamp(Math.round(texture._anisotropy),1,this.maxAnisotropy));}}}setTexture(texture,textureUnit){const impl=texture.impl;if(!impl._glTexture){impl.initialize(this,texture);}if(impl.dirtyParameterFlags>0||texture._needsUpload||texture._needsMipmapsUpload){this.activeTexture(textureUnit);this.bindTexture(texture);if(impl.dirtyParameterFlags){this.setTextureParameters(texture);impl.dirtyParameterFlags=0;}if(texture._needsUpload||texture._needsMipmapsUpload){impl.upload(this,texture);texture._needsUpload=false;texture._needsMipmapsUpload=false;}}else {this.bindTextureOnUnit(texture,textureUnit);}}createVertexArray(vertexBuffers){let key,vao;const useCache=vertexBuffers.length>1;if(useCache){key="";for(let i=0;i<vertexBuffers.length;i++){const vertexBuffer=vertexBuffers[i];key+=vertexBuffer.id+vertexBuffer.format.renderingHash;}vao=this._vaoMap.get(key);}if(!vao){const gl=this.gl;vao=gl.createVertexArray();gl.bindVertexArray(vao);gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,null);for(let i=0;i<vertexBuffers.length;i++){const vertexBuffer=vertexBuffers[i];gl.bindBuffer(gl.ARRAY_BUFFER,vertexBuffer.impl.bufferId);const elements=vertexBuffer.format.elements;for(let j=0;j<elements.length;j++){const e=elements[j];const loc=semanticToLocation[e.name];if(e.asInt){gl.vertexAttribIPointer(loc,e.numComponents,this.glType[e.dataType],e.stride,e.offset);}else {gl.vertexAttribPointer(loc,e.numComponents,this.glType[e.dataType],e.normalize,e.stride,e.offset);}gl.enableVertexAttribArray(loc);if(vertexBuffer.format.instancing){gl.vertexAttribDivisor(loc,1);}}}gl.bindVertexArray(null);gl.bindBuffer(gl.ARRAY_BUFFER,null);if(useCache){this._vaoMap.set(key,vao);}}return vao}unbindVertexArray(){if(this.boundVao){this.boundVao=null;this.gl.bindVertexArray(null);}}setBuffers(){const gl=this.gl;let vao;if(this.vertexBuffers.length===1){const vertexBuffer=this.vertexBuffers[0];if(!vertexBuffer.impl.vao){vertexBuffer.impl.vao=this.createVertexArray(this.vertexBuffers);}vao=vertexBuffer.impl.vao;}else {vao=this.createVertexArray(this.vertexBuffers);}if(this.boundVao!==vao){this.boundVao=vao;gl.bindVertexArray(vao);}this.clearVertexBuffer();const bufferId=this.indexBuffer?this.indexBuffer.impl.bufferId:null;gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,bufferId);}draw(primitive,numInstances,keepBuffers){const gl=this.gl;this.activateShader(this);if(!this.shaderValid){return}let sampler,samplerValue,texture,numTextures;let uniform,scopeId,uniformVersion,programVersion;const shader=this.shader;if(!shader){return}const samplers=shader.impl.samplers;const uniforms=shader.impl.uniforms;if(!keepBuffers){this.setBuffers();}let textureUnit=0;for(let i=0,len=samplers.length;i<len;i++){sampler=samplers[i];samplerValue=sampler.scopeId.value;if(!samplerValue){return}if(samplerValue instanceof Texture){texture=samplerValue;this.setTexture(texture,textureUnit);if(sampler.slot!==textureUnit){gl.uniform1i(sampler.locationId,textureUnit);sampler.slot=textureUnit;}textureUnit++;}else {sampler.array.length=0;numTextures=samplerValue.length;for(let j=0;j<numTextures;j++){texture=samplerValue[j];this.setTexture(texture,textureUnit);sampler.array[j]=textureUnit;textureUnit++;}gl.uniform1iv(sampler.locationId,sampler.array);}}for(let i=0,len=uniforms.length;i<len;i++){uniform=uniforms[i];scopeId=uniform.scopeId;uniformVersion=uniform.version;programVersion=scopeId.versionObject.version;if(uniformVersion.globalId!==programVersion.globalId||uniformVersion.revision!==programVersion.revision){uniformVersion.globalId=programVersion.globalId;uniformVersion.revision=programVersion.revision;if(scopeId.value!==null){this.commitFunction[uniform.dataType](uniform,scopeId.value);}}}if(this.isWebGL2&&this.transformFeedbackBuffer){gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER,0,this.transformFeedbackBuffer.impl.bufferId);gl.beginTransformFeedback(gl.POINTS);}const mode=this.glPrimitive[primitive.type];const count=primitive.count;if(primitive.indexed){const indexBuffer=this.indexBuffer;const format=indexBuffer.impl.glFormat;const offset=primitive.base*indexBuffer.bytesPerIndex;if(numInstances>0){gl.drawElementsInstanced(mode,count,format,offset,numInstances);}else {gl.drawElements(mode,count,format,offset);}}else {const first=primitive.base;if(numInstances>0){gl.drawArraysInstanced(mode,first,count,numInstances);}else {gl.drawArrays(mode,first,count);}}if(this.isWebGL2&&this.transformFeedbackBuffer){gl.endTransformFeedback();gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER,0,null);}this._drawCallsPerFrame++;}clear(options){var _options$flags;const defaultOptions=this.defaultClearOptions;options=options||defaultOptions;const flags=(_options$flags=options.flags)!=null?_options$flags:defaultOptions.flags;if(flags!==0){const gl=this.gl;if(flags&CLEARFLAG_COLOR){var _options$color;const color=(_options$color=options.color)!=null?_options$color:defaultOptions.color;const r=color[0];const g=color[1];const b=color[2];const a=color[3];const c=this.clearColor;if(r!==c.r||g!==c.g||b!==c.b||a!==c.a){this.gl.clearColor(r,g,b,a);this.clearColor.set(r,g,b,a);}this.setBlendState(BlendState.NOBLEND);}if(flags&CLEARFLAG_DEPTH){var _options$depth;const depth=(_options$depth=options.depth)!=null?_options$depth:defaultOptions.depth;if(depth!==this.clearDepth){this.gl.clearDepth(depth);this.clearDepth=depth;}this.setDepthState(DepthState.WRITEDEPTH);}if(flags&CLEARFLAG_STENCIL){var _options$stencil;const stencil=(_options$stencil=options.stencil)!=null?_options$stencil:defaultOptions.stencil;if(stencil!==this.clearStencil){this.gl.clearStencil(stencil);this.clearStencil=stencil;}gl.stencilMask(255);this.stencilWriteMaskFront=255;this.stencilWriteMaskBack=255;}gl.clear(this.glClearFlag[flags]);}}submit(){this.gl.flush();}readPixels(x,y,w,h,pixels){const gl=this.gl;gl.readPixels(x,y,w,h,gl.RGBA,gl.UNSIGNED_BYTE,pixels);}async readPixelsAsync(x,y,w,h,pixels){var _this$renderTarget$co,_impl$_glFormat,_impl$_glPixelType;const gl=this.gl;if(!this.isWebGL2){this.readPixels(x,y,w,h,pixels);return}const clientWaitAsync=(flags,interval_ms)=>{const sync=gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE,0);this.submit();return new Promise((resolve,reject)=>{function test(){const res=gl.clientWaitSync(sync,flags,0);if(res===gl.WAIT_FAILED){gl.deleteSync(sync);reject(new Error("webgl clientWaitSync sync failed"));}else if(res===gl.TIMEOUT_EXPIRED){setTimeout(test,interval_ms);}else {gl.deleteSync(sync);resolve();}}test();})};const impl=(_this$renderTarget$co=this.renderTarget.colorBuffer)==null?void 0:_this$renderTarget$co.impl;const format=(_impl$_glFormat=impl==null?void 0:impl._glFormat)!=null?_impl$_glFormat:gl.RGBA;const pixelType=(_impl$_glPixelType=impl==null?void 0:impl._glPixelType)!=null?_impl$_glPixelType:gl.UNSIGNED_BYTE;const buf=gl.createBuffer();gl.bindBuffer(gl.PIXEL_PACK_BUFFER,buf);gl.bufferData(gl.PIXEL_PACK_BUFFER,pixels.byteLength,gl.STREAM_READ);gl.readPixels(x,y,w,h,format,pixelType,0);gl.bindBuffer(gl.PIXEL_PACK_BUFFER,null);await clientWaitAsync(0,20);gl.bindBuffer(gl.PIXEL_PACK_BUFFER,buf);gl.getBufferSubData(gl.PIXEL_PACK_BUFFER,0,pixels);gl.bindBuffer(gl.PIXEL_PACK_BUFFER,null);gl.deleteBuffer(buf);}setAlphaToCoverage(state){if(this.isWebGL1)return;if(this.alphaToCoverage===state)return;this.alphaToCoverage=state;if(state){this.gl.enable(this.gl.SAMPLE_ALPHA_TO_COVERAGE);}else {this.gl.disable(this.gl.SAMPLE_ALPHA_TO_COVERAGE);}}setTransformFeedbackBuffer(tf){if(this.transformFeedbackBuffer===tf){return}this.transformFeedbackBuffer=tf;if(this.isWebGL2){const gl=this.gl;if(tf){if(!this.feedback){this.feedback=gl.createTransformFeedback();}gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK,this.feedback);}else {gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK,null);}}}setRaster(on){if(this.raster===on)return;this.raster=on;if(this.isWebGL2){if(on){this.gl.disable(this.gl.RASTERIZER_DISCARD);}else {this.gl.enable(this.gl.RASTERIZER_DISCARD);}}}setStencilTest(enable){if(this.stencil!==enable){const gl=this.gl;if(enable){gl.enable(gl.STENCIL_TEST);}else {gl.disable(gl.STENCIL_TEST);}this.stencil=enable;}}setStencilFunc(func,ref,mask){if(this.stencilFuncFront!==func||this.stencilRefFront!==ref||this.stencilMaskFront!==mask||this.stencilFuncBack!==func||this.stencilRefBack!==ref||this.stencilMaskBack!==mask){this.gl.stencilFunc(this.glComparison[func],ref,mask);this.stencilFuncFront=this.stencilFuncBack=func;this.stencilRefFront=this.stencilRefBack=ref;this.stencilMaskFront=this.stencilMaskBack=mask;}}setStencilFuncFront(func,ref,mask){if(this.stencilFuncFront!==func||this.stencilRefFront!==ref||this.stencilMaskFront!==mask){const gl=this.gl;gl.stencilFuncSeparate(gl.FRONT,this.glComparison[func],ref,mask);this.stencilFuncFront=func;this.stencilRefFront=ref;this.stencilMaskFront=mask;}}setStencilFuncBack(func,ref,mask){if(this.stencilFuncBack!==func||this.stencilRefBack!==ref||this.stencilMaskBack!==mask){const gl=this.gl;gl.stencilFuncSeparate(gl.BACK,this.glComparison[func],ref,mask);this.stencilFuncBack=func;this.stencilRefBack=ref;this.stencilMaskBack=mask;}}setStencilOperation(fail,zfail,zpass,writeMask){if(this.stencilFailFront!==fail||this.stencilZfailFront!==zfail||this.stencilZpassFront!==zpass||this.stencilFailBack!==fail||this.stencilZfailBack!==zfail||this.stencilZpassBack!==zpass){this.gl.stencilOp(this.glStencilOp[fail],this.glStencilOp[zfail],this.glStencilOp[zpass]);this.stencilFailFront=this.stencilFailBack=fail;this.stencilZfailFront=this.stencilZfailBack=zfail;this.stencilZpassFront=this.stencilZpassBack=zpass;}if(this.stencilWriteMaskFront!==writeMask||this.stencilWriteMaskBack!==writeMask){this.gl.stencilMask(writeMask);this.stencilWriteMaskFront=writeMask;this.stencilWriteMaskBack=writeMask;}}setStencilOperationFront(fail,zfail,zpass,writeMask){if(this.stencilFailFront!==fail||this.stencilZfailFront!==zfail||this.stencilZpassFront!==zpass){this.gl.stencilOpSeparate(this.gl.FRONT,this.glStencilOp[fail],this.glStencilOp[zfail],this.glStencilOp[zpass]);this.stencilFailFront=fail;this.stencilZfailFront=zfail;this.stencilZpassFront=zpass;}if(this.stencilWriteMaskFront!==writeMask){this.gl.stencilMaskSeparate(this.gl.FRONT,writeMask);this.stencilWriteMaskFront=writeMask;}}setStencilOperationBack(fail,zfail,zpass,writeMask){if(this.stencilFailBack!==fail||this.stencilZfailBack!==zfail||this.stencilZpassBack!==zpass){this.gl.stencilOpSeparate(this.gl.BACK,this.glStencilOp[fail],this.glStencilOp[zfail],this.glStencilOp[zpass]);this.stencilFailBack=fail;this.stencilZfailBack=zfail;this.stencilZpassBack=zpass;}if(this.stencilWriteMaskBack!==writeMask){this.gl.stencilMaskSeparate(this.gl.BACK,writeMask);this.stencilWriteMaskBack=writeMask;}}setBlendState(blendState){const currentBlendState=this.blendState;if(!currentBlendState.equals(blendState)){const gl=this.gl;const{blend,colorOp,alphaOp,colorSrcFactor,colorDstFactor,alphaSrcFactor,alphaDstFactor}=blendState;if(currentBlendState.blend!==blend){if(blend){gl.enable(gl.BLEND);}else {gl.disable(gl.BLEND);}}if(currentBlendState.colorOp!==colorOp||currentBlendState.alphaOp!==alphaOp){const glBlendEquation=this.glBlendEquation;gl.blendEquationSeparate(glBlendEquation[colorOp],glBlendEquation[alphaOp]);}if(currentBlendState.colorSrcFactor!==colorSrcFactor||currentBlendState.colorDstFactor!==colorDstFactor||currentBlendState.alphaSrcFactor!==alphaSrcFactor||currentBlendState.alphaDstFactor!==alphaDstFactor){gl.blendFuncSeparate(this.glBlendFunctionColor[colorSrcFactor],this.glBlendFunctionColor[colorDstFactor],this.glBlendFunctionAlpha[alphaSrcFactor],this.glBlendFunctionAlpha[alphaDstFactor]);}if(currentBlendState.allWrite!==blendState.allWrite){this.gl.colorMask(blendState.redWrite,blendState.greenWrite,blendState.blueWrite,blendState.alphaWrite);}currentBlendState.copy(blendState);}}setBlendColor(r,g,b,a){const c=this.blendColor;if(r!==c.r||g!==c.g||b!==c.b||a!==c.a){this.gl.blendColor(r,g,b,a);c.set(r,g,b,a);}}setStencilState(stencilFront,stencilBack){if(stencilFront||stencilBack){this.setStencilTest(true);if(stencilFront===stencilBack){this.setStencilFunc(stencilFront.func,stencilFront.ref,stencilFront.readMask);this.setStencilOperation(stencilFront.fail,stencilFront.zfail,stencilFront.zpass,stencilFront.writeMask);}else {var _stencilFront,_stencilBack;(_stencilFront=stencilFront)!=null?_stencilFront:stencilFront=StencilParameters.DEFAULT;this.setStencilFuncFront(stencilFront.func,stencilFront.ref,stencilFront.readMask);this.setStencilOperationFront(stencilFront.fail,stencilFront.zfail,stencilFront.zpass,stencilFront.writeMask);(_stencilBack=stencilBack)!=null?_stencilBack:stencilBack=StencilParameters.DEFAULT;this.setStencilFuncBack(stencilBack.func,stencilBack.ref,stencilBack.readMask);this.setStencilOperationBack(stencilBack.fail,stencilBack.zfail,stencilBack.zpass,stencilBack.writeMask);}}else {this.setStencilTest(false);}}setDepthState(depthState){const currentDepthState=this.depthState;if(!currentDepthState.equals(depthState)){const gl=this.gl;const write=depthState.write;if(currentDepthState.write!==write){gl.depthMask(write);}let{func,test}=depthState;if(!test&&write){test=true;func=FUNC_ALWAYS;}if(currentDepthState.func!==func){gl.depthFunc(this.glComparison[func]);}if(currentDepthState.test!==test){if(test){gl.enable(gl.DEPTH_TEST);}else {gl.disable(gl.DEPTH_TEST);}}const{depthBias,depthBiasSlope}=depthState;if(depthBias||depthBiasSlope){if(!this.depthBiasEnabled){this.depthBiasEnabled=true;this.gl.enable(this.gl.POLYGON_OFFSET_FILL);}gl.polygonOffset(depthBiasSlope,depthBias);}else {if(this.depthBiasEnabled){this.depthBiasEnabled=false;this.gl.disable(this.gl.POLYGON_OFFSET_FILL);}}currentDepthState.copy(depthState);}}setCullMode(cullMode){if(this.cullMode!==cullMode){if(cullMode===CULLFACE_NONE){this.gl.disable(this.gl.CULL_FACE);}else {if(this.cullMode===CULLFACE_NONE){this.gl.enable(this.gl.CULL_FACE);}const mode=this.glCull[cullMode];if(this.cullFace!==mode){this.gl.cullFace(mode);this.cullFace=mode;}}this.cullMode=cullMode;}}setShader(shader,asyncCompile=false){if(shader!==this.shader){this.shader=shader;this.shaderAsyncCompile=asyncCompile;this.shaderValid=undefined;}}activateShader(device){const{shader}=this;const{impl}=shader;if(this.shaderValid===undefined){if(shader.failed){this.shaderValid=false;}else if(!shader.ready){if(this.shaderAsyncCompile){if(impl.isLinked(device)){if(!impl.finalize(this,shader)){shader.failed=true;this.shaderValid=false;}}else {this.shaderValid=false;}}else {if(!impl.finalize(this,shader)){shader.failed=true;this.shaderValid=false;}}}}if(this.shaderValid===undefined){this.gl.useProgram(impl.glProgram);this.shaderValid=true;}}clearVertexArrayObjectCache(){const gl=this.gl;this._vaoMap.forEach((item,key,mapObj)=>{gl.deleteVertexArray(item);});this._vaoMap.clear();}set fullscreen(fullscreen){if(fullscreen){const canvas=this.gl.canvas;canvas.requestFullscreen();}else {document.exitFullscreen();}}get fullscreen(){return !!document.fullscreenElement}get textureFloatHighPrecision(){if(this._textureFloatHighPrecision===undefined){this._textureFloatHighPrecision=testTextureFloatHighPrecision(this);}return this._textureFloatHighPrecision}get textureHalfFloatUpdatable(){if(this._textureHalfFloatUpdatable===undefined){if(this.isWebGL2){this._textureHalfFloatUpdatable=true;}else {this._textureHalfFloatUpdatable=testTextureHalfFloatUpdatable(this.gl,this.extTextureHalfFloat.HALF_FLOAT_OES);}}return this._textureHalfFloatUpdatable}constructor(canvas,options={}){var _options$antialias;super(canvas,options);this.gl=void 0;this._defaultFramebuffer=null;this._defaultFramebufferChanged=false;options=this.initOptions;this.updateClientRect();this.initTextureUnits();this.contextLost=false;this._contextLostHandler=event=>{event.preventDefault();this.loseContext();this.fire("devicelost");};this._contextRestoredHandler=()=>{this.restoreContext();this.fire("devicerestored");};const ua=typeof navigator!=="undefined"&&navigator.userAgent;this.forceDisableMultisampling=ua&&ua.includes("AppleWebKit")&&(ua.includes("15.4")||ua.includes("15_4"));if(this.forceDisableMultisampling){options.antialias=false;}if(platform.browserName==="firefox"){const _ua=typeof navigator!=="undefined"?navigator.userAgent:"";const match=_ua.match(/Firefox\/(\d+(\.\d+)*)/);const firefoxVersion=match?match[1]:null;if(firefoxVersion){const version=parseFloat(firefoxVersion);const disableAntialias=platform.name==="windows"&&(version>=120||version===115)||platform.name==="android"&&version>=132;if(disableAntialias){options.antialias=false;}}}let gl=null;this.backBufferAntialias=(_options$antialias=options.antialias)!=null?_options$antialias:false;options.antialias=false;if(options.gl){gl=options.gl;}else {const preferWebGl2=options.preferWebGl2!==undefined?options.preferWebGl2:true;const names=preferWebGl2?["webgl2","webgl","experimental-webgl"]:["webgl","experimental-webgl"];for(let i=0;i<names.length;i++){gl=canvas.getContext(names[i],options);if(gl){break}}}if(!gl){throw new Error("WebGL not supported")}this.gl=gl;this.isWebGL2=typeof WebGL2RenderingContext!=="undefined"&&gl instanceof WebGL2RenderingContext;this.isWebGL1=!this.isWebGL2;this._deviceType=this.isWebGL2?DEVICETYPE_WEBGL2:DEVICETYPE_WEBGL1;this.updateBackbufferFormat(null);const isChrome=platform.browserName==="chrome";const isSafari=platform.browserName==="safari";const isMac=platform.browser&&navigator.appVersion.indexOf("Mac")!==-1;this._tempEnableSafariTextureUnitWorkaround=isSafari;this._tempMacChromeBlitFramebufferWorkaround=isMac&&isChrome&&!options.alpha;canvas.addEventListener("webglcontextlost",this._contextLostHandler,false);canvas.addEventListener("webglcontextrestored",this._contextRestoredHandler,false);this.initializeExtensions();this.initializeCapabilities();this.initializeRenderState();this.initializeContextCaches();this.createBackbuffer(null);this.supportsImageBitmap=!isSafari&&typeof ImageBitmap!=="undefined";this._samplerTypes=new Set([...[gl.SAMPLER_2D,gl.SAMPLER_CUBE],...this.isWebGL2?[gl.UNSIGNED_INT_SAMPLER_2D,gl.INT_SAMPLER_2D,gl.SAMPLER_2D_SHADOW,gl.SAMPLER_CUBE_SHADOW,gl.SAMPLER_3D,gl.INT_SAMPLER_3D,gl.UNSIGNED_INT_SAMPLER_3D,gl.SAMPLER_2D_ARRAY,gl.INT_SAMPLER_2D_ARRAY,gl.UNSIGNED_INT_SAMPLER_2D_ARRAY]:[]]);this.glAddress=[gl.REPEAT,gl.CLAMP_TO_EDGE,gl.MIRRORED_REPEAT];this.glBlendEquation=[gl.FUNC_ADD,gl.FUNC_SUBTRACT,gl.FUNC_REVERSE_SUBTRACT,this.isWebGL2?gl.MIN:this.extBlendMinmax?this.extBlendMinmax.MIN_EXT:gl.FUNC_ADD,this.isWebGL2?gl.MAX:this.extBlendMinmax?this.extBlendMinmax.MAX_EXT:gl.FUNC_ADD];this.glBlendFunctionColor=[gl.ZERO,gl.ONE,gl.SRC_COLOR,gl.ONE_MINUS_SRC_COLOR,gl.DST_COLOR,gl.ONE_MINUS_DST_COLOR,gl.SRC_ALPHA,gl.SRC_ALPHA_SATURATE,gl.ONE_MINUS_SRC_ALPHA,gl.DST_ALPHA,gl.ONE_MINUS_DST_ALPHA,gl.CONSTANT_COLOR,gl.ONE_MINUS_CONSTANT_COLOR];this.glBlendFunctionAlpha=[gl.ZERO,gl.ONE,gl.SRC_COLOR,gl.ONE_MINUS_SRC_COLOR,gl.DST_COLOR,gl.ONE_MINUS_DST_COLOR,gl.SRC_ALPHA,gl.SRC_ALPHA_SATURATE,gl.ONE_MINUS_SRC_ALPHA,gl.DST_ALPHA,gl.ONE_MINUS_DST_ALPHA,gl.CONSTANT_ALPHA,gl.ONE_MINUS_CONSTANT_ALPHA];this.glComparison=[gl.NEVER,gl.LESS,gl.EQUAL,gl.LEQUAL,gl.GREATER,gl.NOTEQUAL,gl.GEQUAL,gl.ALWAYS];this.glStencilOp=[gl.KEEP,gl.ZERO,gl.REPLACE,gl.INCR,gl.INCR_WRAP,gl.DECR,gl.DECR_WRAP,gl.INVERT];this.glClearFlag=[0,gl.COLOR_BUFFER_BIT,gl.DEPTH_BUFFER_BIT,gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT,gl.STENCIL_BUFFER_BIT,gl.STENCIL_BUFFER_BIT|gl.COLOR_BUFFER_BIT,gl.STENCIL_BUFFER_BIT|gl.DEPTH_BUFFER_BIT,gl.STENCIL_BUFFER_BIT|gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT];this.glCull=[0,gl.BACK,gl.FRONT,gl.FRONT_AND_BACK];this.glFilter=[gl.NEAREST,gl.LINEAR,gl.NEAREST_MIPMAP_NEAREST,gl.NEAREST_MIPMAP_LINEAR,gl.LINEAR_MIPMAP_NEAREST,gl.LINEAR_MIPMAP_LINEAR];this.glPrimitive=[gl.POINTS,gl.LINES,gl.LINE_LOOP,gl.LINE_STRIP,gl.TRIANGLES,gl.TRIANGLE_STRIP,gl.TRIANGLE_FAN];this.glType=[gl.BYTE,gl.UNSIGNED_BYTE,gl.SHORT,gl.UNSIGNED_SHORT,gl.INT,gl.UNSIGNED_INT,gl.FLOAT,gl.HALF_FLOAT];this.pcUniformType={};this.pcUniformType[gl.BOOL]=UNIFORMTYPE_BOOL;this.pcUniformType[gl.INT]=UNIFORMTYPE_INT;this.pcUniformType[gl.FLOAT]=UNIFORMTYPE_FLOAT;this.pcUniformType[gl.FLOAT_VEC2]=UNIFORMTYPE_VEC2;this.pcUniformType[gl.FLOAT_VEC3]=UNIFORMTYPE_VEC3;this.pcUniformType[gl.FLOAT_VEC4]=UNIFORMTYPE_VEC4;this.pcUniformType[gl.INT_VEC2]=UNIFORMTYPE_IVEC2;this.pcUniformType[gl.INT_VEC3]=UNIFORMTYPE_IVEC3;this.pcUniformType[gl.INT_VEC4]=UNIFORMTYPE_IVEC4;this.pcUniformType[gl.BOOL_VEC2]=UNIFORMTYPE_BVEC2;this.pcUniformType[gl.BOOL_VEC3]=UNIFORMTYPE_BVEC3;this.pcUniformType[gl.BOOL_VEC4]=UNIFORMTYPE_BVEC4;this.pcUniformType[gl.FLOAT_MAT2]=UNIFORMTYPE_MAT2;this.pcUniformType[gl.FLOAT_MAT3]=UNIFORMTYPE_MAT3;this.pcUniformType[gl.FLOAT_MAT4]=UNIFORMTYPE_MAT4;this.pcUniformType[gl.SAMPLER_2D]=UNIFORMTYPE_TEXTURE2D;this.pcUniformType[gl.SAMPLER_CUBE]=UNIFORMTYPE_TEXTURECUBE;this.pcUniformType[gl.UNSIGNED_INT]=UNIFORMTYPE_UINT;this.pcUniformType[gl.UNSIGNED_INT_VEC2]=UNIFORMTYPE_UVEC2;this.pcUniformType[gl.UNSIGNED_INT_VEC3]=UNIFORMTYPE_UVEC3;this.pcUniformType[gl.UNSIGNED_INT_VEC4]=UNIFORMTYPE_UVEC4;if(this.isWebGL2){this.pcUniformType[gl.SAMPLER_2D_SHADOW]=UNIFORMTYPE_TEXTURE2D_SHADOW;this.pcUniformType[gl.SAMPLER_CUBE_SHADOW]=UNIFORMTYPE_TEXTURECUBE_SHADOW;this.pcUniformType[gl.SAMPLER_2D_ARRAY]=UNIFORMTYPE_TEXTURE2D_ARRAY;this.pcUniformType[gl.SAMPLER_3D]=UNIFORMTYPE_TEXTURE3D;this.pcUniformType[gl.INT_SAMPLER_2D]=UNIFORMTYPE_ITEXTURE2D;this.pcUniformType[gl.UNSIGNED_INT_SAMPLER_2D]=UNIFORMTYPE_UTEXTURE2D;this.pcUniformType[gl.INT_SAMPLER_CUBE]=UNIFORMTYPE_ITEXTURECUBE;this.pcUniformType[gl.UNSIGNED_INT_SAMPLER_2D]=UNIFORMTYPE_UTEXTURECUBE;this.pcUniformType[gl.INT_SAMPLER_3D]=UNIFORMTYPE_ITEXTURE3D;this.pcUniformType[gl.UNSIGNED_INT_SAMPLER_3D]=UNIFORMTYPE_UTEXTURE3D;this.pcUniformType[gl.INT_SAMPLER_2D_ARRAY]=UNIFORMTYPE_ITEXTURE2D_ARRAY;this.pcUniformType[gl.UNSIGNED_INT_SAMPLER_2D_ARRAY]=UNIFORMTYPE_UTEXTURE2D_ARRAY;}this.targetToSlot={};this.targetToSlot[gl.TEXTURE_2D]=0;this.targetToSlot[gl.TEXTURE_CUBE_MAP]=1;this.targetToSlot[gl.TEXTURE_3D]=2;let scopeX,scopeY,scopeZ,scopeW;let uniformValue;this.commitFunction=[];this.commitFunction[UNIFORMTYPE_BOOL]=function(uniform,value){if(uniform.value!==value){gl.uniform1i(uniform.locationId,value);uniform.value=value;}};this.commitFunction[UNIFORMTYPE_INT]=this.commitFunction[UNIFORMTYPE_BOOL];this.commitFunction[UNIFORMTYPE_FLOAT]=function(uniform,value){if(uniform.value!==value){gl.uniform1f(uniform.locationId,value);uniform.value=value;}};this.commitFunction[UNIFORMTYPE_VEC2]=function(uniform,value){uniformValue=uniform.value;scopeX=value[0];scopeY=value[1];if(uniformValue[0]!==scopeX||uniformValue[1]!==scopeY){gl.uniform2fv(uniform.locationId,value);uniformValue[0]=scopeX;uniformValue[1]=scopeY;}};this.commitFunction[UNIFORMTYPE_VEC3]=function(uniform,value){uniformValue=uniform.value;scopeX=value[0];scopeY=value[1];scopeZ=value[2];if(uniformValue[0]!==scopeX||uniformValue[1]!==scopeY||uniformValue[2]!==scopeZ){gl.uniform3fv(uniform.locationId,value);uniformValue[0]=scopeX;uniformValue[1]=scopeY;uniformValue[2]=scopeZ;}};this.commitFunction[UNIFORMTYPE_VEC4]=function(uniform,value){uniformValue=uniform.value;scopeX=value[0];scopeY=value[1];scopeZ=value[2];scopeW=value[3];if(uniformValue[0]!==scopeX||uniformValue[1]!==scopeY||uniformValue[2]!==scopeZ||uniformValue[3]!==scopeW){gl.uniform4fv(uniform.locationId,value);uniformValue[0]=scopeX;uniformValue[1]=scopeY;uniformValue[2]=scopeZ;uniformValue[3]=scopeW;}};this.commitFunction[UNIFORMTYPE_IVEC2]=function(uniform,value){uniformValue=uniform.value;scopeX=value[0];scopeY=value[1];if(uniformValue[0]!==scopeX||uniformValue[1]!==scopeY){gl.uniform2iv(uniform.locationId,value);uniformValue[0]=scopeX;uniformValue[1]=scopeY;}};this.commitFunction[UNIFORMTYPE_BVEC2]=this.commitFunction[UNIFORMTYPE_IVEC2];this.commitFunction[UNIFORMTYPE_IVEC3]=function(uniform,value){uniformValue=uniform.value;scopeX=value[0];scopeY=value[1];scopeZ=value[2];if(uniformValue[0]!==scopeX||uniformValue[1]!==scopeY||uniformValue[2]!==scopeZ){gl.uniform3iv(uniform.locationId,value);uniformValue[0]=scopeX;uniformValue[1]=scopeY;uniformValue[2]=scopeZ;}};this.commitFunction[UNIFORMTYPE_BVEC3]=this.commitFunction[UNIFORMTYPE_IVEC3];this.commitFunction[UNIFORMTYPE_IVEC4]=function(uniform,value){uniformValue=uniform.value;scopeX=value[0];scopeY=value[1];scopeZ=value[2];scopeW=value[3];if(uniformValue[0]!==scopeX||uniformValue[1]!==scopeY||uniformValue[2]!==scopeZ||uniformValue[3]!==scopeW){gl.uniform4iv(uniform.locationId,value);uniformValue[0]=scopeX;uniformValue[1]=scopeY;uniformValue[2]=scopeZ;uniformValue[3]=scopeW;}};this.commitFunction[UNIFORMTYPE_BVEC4]=this.commitFunction[UNIFORMTYPE_IVEC4];this.commitFunction[UNIFORMTYPE_MAT2]=function(uniform,value){gl.uniformMatrix2fv(uniform.locationId,false,value);};this.commitFunction[UNIFORMTYPE_MAT3]=function(uniform,value){gl.uniformMatrix3fv(uniform.locationId,false,value);};this.commitFunction[UNIFORMTYPE_MAT4]=function(uniform,value){gl.uniformMatrix4fv(uniform.locationId,false,value);};this.commitFunction[UNIFORMTYPE_FLOATARRAY]=function(uniform,value){gl.uniform1fv(uniform.locationId,value);};this.commitFunction[UNIFORMTYPE_VEC2ARRAY]=function(uniform,value){gl.uniform2fv(uniform.locationId,value);};this.commitFunction[UNIFORMTYPE_VEC3ARRAY]=function(uniform,value){gl.uniform3fv(uniform.locationId,value);};this.commitFunction[UNIFORMTYPE_VEC4ARRAY]=function(uniform,value){gl.uniform4fv(uniform.locationId,value);};this.commitFunction[UNIFORMTYPE_UINT]=function(uniform,value){if(uniform.value!==value){gl.uniform1ui(uniform.locationId,value);uniform.value=value;}};this.commitFunction[UNIFORMTYPE_UVEC2]=function(uniform,value){uniformValue=uniform.value;scopeX=value[0];scopeY=value[1];if(uniformValue[0]!==scopeX||uniformValue[1]!==scopeY){gl.uniform2uiv(uniform.locationId,value);uniformValue[0]=scopeX;uniformValue[1]=scopeY;}};this.commitFunction[UNIFORMTYPE_UVEC3]=function(uniform,value){uniformValue=uniform.value;scopeX=value[0];scopeY=value[1];scopeZ=value[2];if(uniformValue[0]!==scopeX||uniformValue[1]!==scopeY||uniformValue[2]!==scopeZ){gl.uniform3uiv(uniform.locationId,value);uniformValue[0]=scopeX;uniformValue[1]=scopeY;uniformValue[2]=scopeZ;}};this.commitFunction[UNIFORMTYPE_UVEC4]=function(uniform,value){uniformValue=uniform.value;scopeX=value[0];scopeY=value[1];scopeZ=value[2];scopeW=value[3];if(uniformValue[0]!==scopeX||uniformValue[1]!==scopeY||uniformValue[2]!==scopeZ||uniformValue[3]!==scopeW){gl.uniform4uiv(uniform.locationId,value);uniformValue[0]=scopeX;uniformValue[1]=scopeY;uniformValue[2]=scopeZ;uniformValue[3]=scopeW;}};this.commitFunction[UNIFORMTYPE_INTARRAY]=function(uniform,value){gl.uniform1iv(uniform.locationId,value);};this.commitFunction[UNIFORMTYPE_UINTARRAY]=function(uniform,value){gl.uniform1uiv(uniform.locationId,value);};this.commitFunction[UNIFORMTYPE_BOOLARRAY]=this.commitFunction[UNIFORMTYPE_INTARRAY];this.commitFunction[UNIFORMTYPE_IVEC2ARRAY]=function(uniform,value){gl.uniform2iv(uniform.locationId,value);};this.commitFunction[UNIFORMTYPE_UVEC2ARRAY]=function(uniform,value){gl.uniform2uiv(uniform.locationId,value);};this.commitFunction[UNIFORMTYPE_BVEC2ARRAY]=this.commitFunction[UNIFORMTYPE_IVEC2ARRAY];this.commitFunction[UNIFORMTYPE_IVEC3ARRAY]=function(uniform,value){gl.uniform3iv(uniform.locationId,value);};this.commitFunction[UNIFORMTYPE_UVEC3ARRAY]=function(uniform,value){gl.uniform3uiv(uniform.locationId,value);};this.commitFunction[UNIFORMTYPE_BVEC3ARRAY]=this.commitFunction[UNIFORMTYPE_IVEC3ARRAY];this.commitFunction[UNIFORMTYPE_IVEC4ARRAY]=function(uniform,value){gl.uniform4iv(uniform.locationId,value);};this.commitFunction[UNIFORMTYPE_UVEC4ARRAY]=function(uniform,value){gl.uniform4uiv(uniform.locationId,value);};this.commitFunction[UNIFORMTYPE_BVEC4ARRAY]=this.commitFunction[UNIFORMTYPE_IVEC4ARRAY];this.commitFunction[UNIFORMTYPE_MAT4ARRAY]=function(uniform,value){gl.uniformMatrix4fv(uniform.locationId,false,value);};this.supportsBoneTextures=this.extTextureFloat&&this.maxVertexTextures>0;let numUniforms=this.vertexUniformsCount;numUniforms-=4*4;numUniforms-=8;numUniforms-=1;numUniforms-=4*4;this.boneLimit=Math.floor(numUniforms/3);this.boneLimit=Math.min(this.boneLimit,128);this.constantTexSource=this.scope.resolve("source");if(this.extTextureFloat){if(this.isWebGL2){this.textureFloatRenderable=!!this.extColorBufferFloat;}else {this.textureFloatRenderable=testRenderable(gl,gl.FLOAT);}}else {this.textureFloatRenderable=false;}if(this.extColorBufferHalfFloat){this.textureHalfFloatRenderable=!!this.extColorBufferHalfFloat;}else if(this.extTextureHalfFloat){if(this.isWebGL2){this.textureHalfFloatRenderable=!!this.extColorBufferFloat;}else {this.textureHalfFloatRenderable=testRenderable(gl,this.extTextureHalfFloat.HALF_FLOAT_OES);}}else {this.textureHalfFloatRenderable=false;}this.supportsMorphTargetTexturesCore=this.maxPrecision==="highp"&&this.maxVertexTextures>=2;this.supportsDepthShadow=this.isWebGL2;this._textureFloatHighPrecision=undefined;this._textureHalfFloatUpdatable=undefined;this.areaLightLutFormat=PIXELFORMAT_RGBA8;if(this.extTextureHalfFloat&&this.textureHalfFloatUpdatable&&this.extTextureHalfFloatLinear){this.areaLightLutFormat=PIXELFORMAT_RGBA16F;}else if(this.extTextureFloat&&this.extTextureFloatLinear){this.areaLightLutFormat=PIXELFORMAT_RGBA32F;}this.postInit();}}class NullIndexBuffer{unlock(indexBuffer){}}class NullRenderTarget{destroy(device){}init(device,renderTarget){}loseContext(){}resolve(device,target,color,depth){}}class NullShader{destroy(shader){}loseContext(){}restoreContext(device,shader){}}class NullTexture{destroy(device){}propertyChanged(flag){}loseContext(){}}class NullVertexBuffer{destroy(device){}unlock(vertexBuffer){}}class NullGraphicsDevice extends GraphicsDevice{destroy(){super.destroy();}initDeviceCaps(){this.disableParticleSystem=true;this.precision="highp";this.maxPrecision="highp";this.maxSamples=4;this.maxTextures=16;this.maxTextureSize=4096;this.maxCubeMapSize=4096;this.maxVolumeSize=4096;this.maxColorAttachments=8;this.maxPixelRatio=1;this.maxAnisotropy=16;this.supportsInstancing=true;this.supportsUniformBuffers=false;this.supportsVolumeTextures=true;this.supportsBoneTextures=true;this.supportsMorphTargetTexturesCore=true;this.supportsAreaLights=true;this.supportsDepthShadow=true;this.supportsGpuParticles=false;this.supportsMrt=true;this.extUintElement=true;this.extTextureFloat=true;this.textureFloatRenderable=true;this.extTextureHalfFloat=true;this.textureHalfFloatRenderable=true;this.textureHalfFloatUpdatable=true;this.boneLimit=1024;this.supportsImageBitmap=true;this.extStandardDerivatives=true;this.extBlendMinmax=true;this.areaLightLutFormat=PIXELFORMAT_RGBA8;this.supportsTextureFetch=true;}postInit(){super.postInit();}frameStart(){super.frameStart();}frameEnd(){super.frameEnd();}updateBegin(){}updateEnd(){}readPixels(x,y,w,h,pixels){}createVertexBufferImpl(vertexBuffer,format){return new NullVertexBuffer(vertexBuffer,format)}createIndexBufferImpl(indexBuffer){return new NullIndexBuffer(indexBuffer)}createShaderImpl(shader){return new NullShader(shader)}createTextureImpl(texture){return new NullTexture(texture)}createRenderTargetImpl(renderTarget){return new NullRenderTarget(renderTarget)}draw(primitive,numInstances=1,keepBuffers){}setShader(shader,asyncCompile=false){}setBlendState(blendState){}setDepthState(depthState){}setStencilState(stencilFront,stencilBack){}setBlendColor(r,g,b,a){}setCullMode(cullMode){}setAlphaToCoverage(state){}initializeContextCaches(){super.initializeContextCaches();}clear(options){}setViewport(x,y,w,h){}setScissor(x,y,w,h){}copyRenderTarget(source,dest,color,depth){return true}constructor(canvas,options={}){super(canvas,options);options=this.initOptions;this.isNull=true;this._deviceType=DEVICETYPE_NULL;this.samples=1;}}function createGraphicsDevice(canvas,options={}){var _options$deviceTypes;const deviceTypes=(_options$deviceTypes=options.deviceTypes)!=null?_options$deviceTypes:[];if(!deviceTypes.includes(DEVICETYPE_WEBGL2)){deviceTypes.push(DEVICETYPE_WEBGL2);}if(!deviceTypes.includes(DEVICETYPE_WEBGL1)){deviceTypes.push(DEVICETYPE_WEBGL1);}if(!deviceTypes.includes(DEVICETYPE_NULL)){deviceTypes.push(DEVICETYPE_NULL);}if(platform.browser&&!!navigator.xr){var _options$xrCompatible;(_options$xrCompatible=options.xrCompatible)!=null?_options$xrCompatible:options.xrCompatible=true;}const deviceCreateFuncs=[];for(let i=0;i<deviceTypes.length;i++){var _window;const deviceType=deviceTypes[i];if(deviceType===DEVICETYPE_WEBGPU&&(_window=window)!=null&&(_window=_window.navigator)!=null&&_window.gpu){deviceCreateFuncs.push(()=>{const device=new WebgpuGraphicsDevice(canvas,options);return device.initWebGpu(options.glslangUrl,options.twgslUrl)});}if(deviceType===DEVICETYPE_WEBGL1||deviceType===DEVICETYPE_WEBGL2){deviceCreateFuncs.push(()=>{options.preferWebGl2=deviceType===DEVICETYPE_WEBGL2;return new WebglGraphicsDevice(canvas,options)});}if(deviceType===DEVICETYPE_NULL){deviceCreateFuncs.push(()=>{return new NullGraphicsDevice(canvas,options)});}}return new Promise((resolve,reject)=>{let attempt=0;const next=()=>{if(attempt>=deviceCreateFuncs.length){reject(new Error("Failed to create a graphics device"));}else {Promise.resolve(deviceCreateFuncs[attempt++]()).then(device=>{if(device){resolve(device);}else {next();}}).catch(err=>{console.log(err);next();});}};next();})}class ComputeParameter{constructor(){this.value=void 0;this.scopeId=null;}}class Compute{setParameter(name,value){let param=this.parameters.get(name);if(!param){param=new ComputeParameter;param.scopeId=this.device.scope.resolve(name);this.parameters.set(name,param);}param.value=value;}getParameter(name){var _this$parameters$get;return (_this$parameters$get=this.parameters.get(name))==null?void 0:_this$parameters$get.value}deleteParameter(name){this.parameters.delete(name);}applyParameters(){for(const[,param]of this.parameters){param.scopeId.setValue(param.value);}}setupDispatch(x,y,z){this.countX=x;this.countY=y;this.countZ=z;}constructor(graphicsDevice,shader,name="Unnamed"){this.shader=null;this.name=void 0;this.parameters=new Map;this.countX=1;this.countY=void 0;this.countZ=void 0;this.device=graphicsDevice;this.shader=shader;this.name=name;if(graphicsDevice.supportsCompute){this.impl=graphicsDevice.createComputeImpl(this);}}}let id$5=0;class IndexBuffer{destroy(){const device=this.device;const idx=device.buffers.indexOf(this);if(idx!==-1){device.buffers.splice(idx,1);}if(this.device.indexBuffer===this){this.device.indexBuffer=null;}if(this.impl.initialized){this.impl.destroy(device);this.adjustVramSizeTracking(device._vram,-this.storage.byteLength);}}adjustVramSizeTracking(vram,size){vram.ib+=size;}loseContext(){this.impl.loseContext();}getFormat(){return this.format}getNumIndices(){return this.numIndices}lock(){return this.storage}unlock(){this.impl.unlock(this);}setData(data){if(data.byteLength!==this.numBytes){return false}this.storage=data;this.unlock();return true}_lockTypedArray(){const lock=this.lock();const indices=this.format===INDEXFORMAT_UINT32?new Uint32Array(lock):this.format===INDEXFORMAT_UINT16?new Uint16Array(lock):new Uint8Array(lock);return indices}writeData(data,count){const indices=this._lockTypedArray();if(data.length>count){if(ArrayBuffer.isView(data)){data=data.subarray(0,count);indices.set(data);}else {for(let i=0;i<count;i++){indices[i]=data[i];}}}else {indices.set(data);}this.unlock();}readData(data){const indices=this._lockTypedArray();const count=this.numIndices;if(ArrayBuffer.isView(data)){data.set(indices);}else {data.length=0;for(let i=0;i<count;i++){data[i]=indices[i];}}return count}constructor(graphicsDevice,format,numIndices,usage=BUFFER_STATIC,initialData,options){this.device=graphicsDevice;this.format=format;this.numIndices=numIndices;this.usage=usage;this.id=id$5++;this.impl=graphicsDevice.createIndexBufferImpl(this,options);const bytesPerIndex=typedArrayIndexFormatsByteSize[format];this.bytesPerIndex=bytesPerIndex;this.numBytes=this.numIndices*bytesPerIndex;if(initialData){this.setData(initialData);}else {this.storage=new ArrayBuffer(this.numBytes);}this.adjustVramSizeTracking(graphicsDevice._vram,this.numBytes);this.device.buffers.push(this);}}class ColorAttachmentOps{constructor(){this.clearValue=new Color(0,0,0,1);this.clear=false;this.store=false;this.resolve=true;this.mipmaps=false;}}class DepthStencilAttachmentOps{constructor(){this.clearDepthValue=1;this.clearStencilValue=0;this.clearDepth=false;this.clearStencil=false;this.storeDepth=false;this.storeStencil=false;}}class RenderPass{get colorOps(){return this.colorArrayOps[0]}set name(value){this._name=value;}get name(){if(!this._name){this._name=this.constructor.name;}return this._name}set options(value){this._options=value;if(value){var _this$_options$scaleX,_this$_options$scaleY;this._options.scaleX=(_this$_options$scaleX=this._options.scaleX)!=null?_this$_options$scaleX:1;this._options.scaleY=(_this$_options$scaleY=this._options.scaleY)!=null?_this$_options$scaleY:1;}}get options(){return this._options}init(renderTarget=null,options=null){var _renderTarget$_colorB;this.options=options;this.renderTarget=renderTarget;this.samples=Math.max(this.renderTarget?this.renderTarget.samples:this.device.samples,1);this.depthStencilOps=new DepthStencilAttachmentOps;const numColorOps=renderTarget?(_renderTarget$_colorB=renderTarget._colorBuffers)==null?void 0:_renderTarget$_colorB.length:1;this.colorArrayOps.length=0;for(let i=0;i<numColorOps;i++){var _this$renderTarget;const colorOps=new ColorAttachmentOps;this.colorArrayOps[i]=colorOps;if(this.samples===1){colorOps.store=true;colorOps.resolve=false;}if((_this$renderTarget=this.renderTarget)!=null&&(_this$renderTarget=_this$renderTarget._colorBuffers)!=null&&_this$renderTarget[i].mipmaps){colorOps.mipmaps=true;}}this.postInit();}destroy(){}postInit(){}frameUpdate(){if(this._options&&this.renderTarget){var _this$_options$resize;const resizeSource=(_this$_options$resize=this._options.resizeSource)!=null?_this$_options$resize:this.device.backBuffer;const width=Math.floor(resizeSource.width*this._options.scaleX);const height=Math.floor(resizeSource.height*this._options.scaleY);this.renderTarget.resize(width,height);}}before(){}execute(){}after(){}onEnable(){}onDisable(){}set enabled(value){if(this._enabled!==value){this._enabled=value;if(value){this.onEnable();}else {this.onDisable();}}}get enabled(){return this._enabled}setClearColor(color){const count=this.colorArrayOps.length;for(let i=0;i<count;i++){const colorOps=this.colorArrayOps[i];if(color){colorOps.clearValue.copy(color);}colorOps.clear=!!color;}}setClearDepth(depthValue){if(depthValue){this.depthStencilOps.clearDepthValue=depthValue;}this.depthStencilOps.clearDepth=depthValue!==undefined;}setClearStencil(stencilValue){if(stencilValue){this.depthStencilOps.clearStencilValue=stencilValue;}this.depthStencilOps.clearStencil=stencilValue!==undefined;}render(){if(this.enabled){const device=this.device;const realPass=this.renderTarget!==undefined;this.before();if(this.executeEnabled){if(realPass){device.startRenderPass(this);}this.execute();if(realPass){device.endRenderPass(this);}}this.after();device.renderPassIndex++;}}constructor(graphicsDevice){this._name=void 0;this.device=void 0;this._enabled=true;this.executeEnabled=true;this.renderTarget=void 0;this._options=void 0;this.samples=0;this.colorArrayOps=[];this.depthStencilOps=void 0;this.requiresCubemaps=true;this.fullSizeClearRect=true;this.beforePasses=[];this.afterPasses=[];this.device=graphicsDevice;}}class ShaderProcessorOptions{hasUniform(name){for(let i=0;i<this.uniformFormats.length;i++){const uniformFormat=this.uniformFormats[i];if(uniformFormat!=null&&uniformFormat.get(name)){return true}}return false}hasTexture(name){for(let i=0;i<this.bindGroupFormats.length;i++){const groupFormat=this.bindGroupFormats[i];if(groupFormat!=null&&groupFormat.getTexture(name)){return true}}return false}getVertexElement(semantic){var _this$vertexFormat;return (_this$vertexFormat=this.vertexFormat)==null?void 0:_this$vertexFormat.elements.find(element=>element.name===semantic)}generateKey(device){let key=JSON.stringify(this.uniformFormats)+JSON.stringify(this.bindGroupFormats);if(device.isWebGPU){var _this$vertexFormat2;key+=(_this$vertexFormat2=this.vertexFormat)==null?void 0:_this$vertexFormat2.shaderProcessingHashString;}return key}constructor(viewUniformFormat,viewBindGroupFormat,vertexFormat){this.uniformFormats=[];this.bindGroupFormats=[];this.vertexFormat=void 0;this.uniformFormats[BINDGROUP_VIEW]=viewUniformFormat;this.bindGroupFormats[BINDGROUP_VIEW]=viewBindGroupFormat;this.vertexFormat=vertexFormat;}}let id$4=0;class StorageBuffer{destroy(){const device=this.device;const idx=device.buffers.indexOf(this);if(idx!==-1){device.buffers.splice(idx,1);}this.adjustVramSizeTracking(device._vram,-this.byteSize);this.impl.destroy(device);}adjustVramSizeTracking(vram,size){vram.sb+=size;}read(offset=0,size=this.byteSize,data=null){return this.impl.read(this.device,offset,size,data)}write(bufferOffset=0,data,dataOffset=0,size){this.impl.write(this.device,bufferOffset,data,dataOffset,size);}clear(offset=0,size=this.byteSize){this.impl.clear(this.device,offset,size);}constructor(graphicsDevice,byteSize,bufferUsage=0){this.id=id$4++;this.device=graphicsDevice;this.byteSize=byteSize;this.bufferUsage=bufferUsage;this.impl=graphicsDevice.createBufferImpl(BUFFERUSAGE_STORAGE|bufferUsage);this.impl.allocate(graphicsDevice,byteSize);this.device.buffers.push(this);this.adjustVramSizeTracking(graphicsDevice._vram,this.byteSize);}}class TransformFeedback{static createShader(graphicsDevice,vertexCode,name){return new Shader(graphicsDevice,ShaderUtils.createDefinition(graphicsDevice,{name,vertexCode,useTransformFeedback:true}))}destroy(){this._outputBuffer.destroy();}process(shader,swap=true){const device=this.device;const oldRt=device.getRenderTarget();device.setRenderTarget(null);device.updateBegin();device.setVertexBuffer(this._inputBuffer,0);device.setRaster(false);device.setTransformFeedbackBuffer(this._outputBuffer);device.setShader(shader);device.draw({type:PRIMITIVE_POINTS,base:0,count:this._inputBuffer.numVertices,indexed:false});device.setTransformFeedbackBuffer(null);device.setRaster(true);device.updateEnd();device.setRenderTarget(oldRt);if(swap){let tmp=this._inputBuffer.impl.bufferId;this._inputBuffer.impl.bufferId=this._outputBuffer.impl.bufferId;this._outputBuffer.impl.bufferId=tmp;tmp=this._inputBuffer.impl.vao;this._inputBuffer.impl.vao=this._outputBuffer.impl.vao;this._outputBuffer.impl.vao=tmp;}}get inputBuffer(){return this._inputBuffer}get outputBuffer(){return this._outputBuffer}constructor(inputBuffer,usage=BUFFER_GPUDYNAMIC){this.device=inputBuffer.device;const gl=this.device.gl;this._inputBuffer=inputBuffer;if(usage===BUFFER_GPUDYNAMIC&&inputBuffer.usage!==usage){gl.bindBuffer(gl.ARRAY_BUFFER,inputBuffer.impl.bufferId);gl.bufferData(gl.ARRAY_BUFFER,inputBuffer.storage,gl.DYNAMIC_COPY);}this._outputBuffer=new VertexBuffer(inputBuffer.device,inputBuffer.format,inputBuffer.numVertices,{usage:usage,data:inputBuffer.storage});}}function set1(a){this.array[this.index]=a;}function set2(a,b){this.array[this.index]=a;this.array[this.index+1]=b;}function set3(a,b,c){this.array[this.index]=a;this.array[this.index+1]=b;this.array[this.index+2]=c;}function set4(a,b,c,d){this.array[this.index]=a;this.array[this.index+1]=b;this.array[this.index+2]=c;this.array[this.index+3]=d;}function arraySet1(index,inputArray,inputIndex){this.array[index]=inputArray[inputIndex];}function arraySet2(index,inputArray,inputIndex){this.array[index]=inputArray[inputIndex];this.array[index+1]=inputArray[inputIndex+1];}function arraySet3(index,inputArray,inputIndex){this.array[index]=inputArray[inputIndex];this.array[index+1]=inputArray[inputIndex+1];this.array[index+2]=inputArray[inputIndex+2];}function arraySet4(index,inputArray,inputIndex){this.array[index]=inputArray[inputIndex];this.array[index+1]=inputArray[inputIndex+1];this.array[index+2]=inputArray[inputIndex+2];this.array[index+3]=inputArray[inputIndex+3];}function arrayGet1(offset,outputArray,outputIndex){outputArray[outputIndex]=this.array[offset];}function arrayGet2(offset,outputArray,outputIndex){outputArray[outputIndex]=this.array[offset];outputArray[outputIndex+1]=this.array[offset+1];}function arrayGet3(offset,outputArray,outputIndex){outputArray[outputIndex]=this.array[offset];outputArray[outputIndex+1]=this.array[offset+1];outputArray[outputIndex+2]=this.array[offset+2];}function arrayGet4(offset,outputArray,outputIndex){outputArray[outputIndex]=this.array[offset];outputArray[outputIndex+1]=this.array[offset+1];outputArray[outputIndex+2]=this.array[offset+2];outputArray[outputIndex+3]=this.array[offset+3];}class VertexIteratorAccessor{get(offset){return this.array[this.index+offset]}set(a,b,c,d){}getToArray(offset,outputArray,outputIndex){}setFromArray(index,inputArray,inputIndex){}constructor(buffer,vertexElement,vertexFormat){this.index=0;this.numComponents=vertexElement.numComponents;if(vertexFormat.interleaved){this.array=new typedArrayTypes[vertexElement.dataType](buffer,vertexElement.offset);}else {this.array=new typedArrayTypes[vertexElement.dataType](buffer,vertexElement.offset,vertexFormat.vertexCount*vertexElement.numComponents);}this.stride=vertexElement.stride/this.array.constructor.BYTES_PER_ELEMENT;switch(vertexElement.numComponents){case 1:this.set=set1;this.getToArray=arrayGet1;this.setFromArray=arraySet1;break;case 2:this.set=set2;this.getToArray=arrayGet2;this.setFromArray=arraySet2;break;case 3:this.set=set3;this.getToArray=arrayGet3;this.setFromArray=arraySet3;break;case 4:this.set=set4;this.getToArray=arrayGet4;this.setFromArray=arraySet4;break}}}class VertexIterator{next(count=1){let i=0;const accessors=this.accessors;const numAccessors=this.accessors.length;while(i<numAccessors){const accessor=accessors[i++];accessor.index+=count*accessor.stride;}}end(){this.vertexBuffer.unlock();}writeData(semantic,data,numVertices){const element=this.element[semantic];if(element){if(numVertices>this.vertexBuffer.numVertices){numVertices=this.vertexBuffer.numVertices;}const numComponents=element.numComponents;if(this.vertexBuffer.getFormat().interleaved){let index=0;for(let i=0;i<numVertices;i++){element.setFromArray(index,data,i*numComponents);index+=element.stride;}}else {if(data.length>numVertices*numComponents){const copyCount=numVertices*numComponents;if(ArrayBuffer.isView(data)){data=data.subarray(0,copyCount);element.array.set(data);}else {for(let i=0;i<copyCount;i++){element.array[i]=data[i];}}}else {element.array.set(data);}}}}readData(semantic,data){const element=this.element[semantic];let count=0;if(element){count=this.vertexBuffer.numVertices;let i;const numComponents=element.numComponents;if(this.vertexBuffer.getFormat().interleaved){if(Array.isArray(data)){data.length=0;}element.index=0;let offset=0;for(i=0;i<count;i++){element.getToArray(offset,data,i*numComponents);offset+=element.stride;}}else {if(ArrayBuffer.isView(data)){data.set(element.array);}else {data.length=0;const copyCount=count*numComponents;for(i=0;i<copyCount;i++){data[i]=element.array[i];}}}}return count}constructor(vertexBuffer){this.vertexBuffer=vertexBuffer;this.vertexFormatSize=vertexBuffer.getFormat().size;this.buffer=this.vertexBuffer.lock();this.accessors=[];this.element={};const vertexFormat=this.vertexBuffer.getFormat();for(let i=0;i<vertexFormat.elements.length;i++){const vertexElement=vertexFormat.elements[i];this.accessors[i]=new VertexIteratorAccessor(this.buffer,vertexElement,vertexFormat);this.element[vertexElement.name]=this.accessors[i];}}}const ACTION_MOUSE="mouse";const ACTION_KEYBOARD="keyboard";const ACTION_GAMEPAD="gamepad";const AXIS_MOUSE_X="mousex";const AXIS_MOUSE_Y="mousey";const AXIS_PAD_L_X="padlx";const AXIS_PAD_L_Y="padly";const AXIS_PAD_R_X="padrx";const AXIS_PAD_R_Y="padry";const AXIS_KEY="key";const EVENT_KEYDOWN="keydown";const EVENT_KEYUP="keyup";const EVENT_MOUSEDOWN="mousedown";const EVENT_MOUSEMOVE="mousemove";const EVENT_MOUSEUP="mouseup";const EVENT_MOUSEWHEEL="mousewheel";const EVENT_TOUCHSTART="touchstart";const EVENT_TOUCHEND="touchend";const EVENT_TOUCHMOVE="touchmove";const EVENT_TOUCHCANCEL="touchcancel";const EVENT_SELECT="select";const EVENT_SELECTSTART="selectstart";const EVENT_SELECTEND="selectend";const KEY_BACKSPACE=8;const KEY_TAB=9;const KEY_RETURN=13;const KEY_ENTER=13;const KEY_SHIFT=16;const KEY_CONTROL=17;const KEY_ALT=18;const KEY_PAUSE=19;const KEY_CAPS_LOCK=20;const KEY_ESCAPE=27;const KEY_SPACE=32;const KEY_PAGE_UP=33;const KEY_PAGE_DOWN=34;const KEY_END=35;const KEY_HOME=36;const KEY_LEFT=37;const KEY_UP=38;const KEY_RIGHT=39;const KEY_DOWN=40;const KEY_PRINT_SCREEN=44;const KEY_INSERT=45;const KEY_DELETE=46;const KEY_0=48;const KEY_1=49;const KEY_2=50;const KEY_3=51;const KEY_4=52;const KEY_5=53;const KEY_6=54;const KEY_7=55;const KEY_8=56;const KEY_9=57;const KEY_SEMICOLON=59;const KEY_EQUAL=61;const KEY_A=65;const KEY_B=66;const KEY_C=67;const KEY_D=68;const KEY_E=69;const KEY_F=70;const KEY_G=71;const KEY_H=72;const KEY_I=73;const KEY_J=74;const KEY_K=75;const KEY_L=76;const KEY_M=77;const KEY_N=78;const KEY_O=79;const KEY_P=80;const KEY_Q=81;const KEY_R=82;const KEY_S=83;const KEY_T=84;const KEY_U=85;const KEY_V=86;const KEY_W=87;const KEY_X=88;const KEY_Y=89;const KEY_Z=90;const KEY_WINDOWS=91;const KEY_CONTEXT_MENU=93;const KEY_NUMPAD_0=96;const KEY_NUMPAD_1=97;const KEY_NUMPAD_2=98;const KEY_NUMPAD_3=99;const KEY_NUMPAD_4=100;const KEY_NUMPAD_5=101;const KEY_NUMPAD_6=102;const KEY_NUMPAD_7=103;const KEY_NUMPAD_8=104;const KEY_NUMPAD_9=105;const KEY_MULTIPLY=106;const KEY_ADD=107;const KEY_SEPARATOR=108;const KEY_SUBTRACT=109;const KEY_DECIMAL=110;const KEY_DIVIDE=111;const KEY_F1=112;const KEY_F2=113;const KEY_F3=114;const KEY_F4=115;const KEY_F5=116;const KEY_F6=117;const KEY_F7=118;const KEY_F8=119;const KEY_F9=120;const KEY_F10=121;const KEY_F11=122;const KEY_F12=123;const KEY_COMMA=188;const KEY_PERIOD=190;const KEY_SLASH=191;const KEY_OPEN_BRACKET=219;const KEY_BACK_SLASH=220;const KEY_CLOSE_BRACKET=221;const KEY_META=224;const MOUSEBUTTON_NONE=-1;const MOUSEBUTTON_LEFT=0;const MOUSEBUTTON_MIDDLE=1;const MOUSEBUTTON_RIGHT=2;const PAD_1=0;const PAD_2=1;const PAD_3=2;const PAD_4=3;const PAD_FACE_1=0;const PAD_FACE_2=1;const PAD_FACE_3=2;const PAD_FACE_4=3;const PAD_L_SHOULDER_1=4;const PAD_R_SHOULDER_1=5;const PAD_L_SHOULDER_2=6;const PAD_R_SHOULDER_2=7;const PAD_SELECT=8;const PAD_START=9;const PAD_L_STICK_BUTTON=10;const PAD_R_STICK_BUTTON=11;const PAD_UP=12;const PAD_DOWN=13;const PAD_LEFT=14;const PAD_RIGHT=15;const PAD_VENDOR=16;const PAD_L_STICK_X=0;const PAD_L_STICK_Y=1;const PAD_R_STICK_X=2;const PAD_R_STICK_Y=3;const EVENT_GAMEPADCONNECTED="gamepadconnected";const EVENT_GAMEPADDISCONNECTED="gamepaddisconnected";const XRPAD_TOUCHPAD_X=0;const XRPAD_TOUCHPAD_Y=1;const XRPAD_STICK_X=2;const XRPAD_STICK_Y=3;const XRPAD_TOUCHPAD_BUTTON=2;const XRPAD_TRIGGER=0;const XRPAD_SQUEEZE=1;const XRPAD_STICK_BUTTON=3;const XRPAD_A=4;const XRPAD_B=5;class KeyboardEvent{constructor(keyboard,event){this.key=null;this.element=null;this.event=null;if(event){this.key=event.keyCode;this.element=event.target;this.event=event;}}}const _keyboardEvent=new KeyboardEvent;function makeKeyboardEvent(event){_keyboardEvent.key=event.keyCode;_keyboardEvent.element=event.target;_keyboardEvent.event=event;return _keyboardEvent}function toKeyCode(s){if(typeof s==="string"){return s.toUpperCase().charCodeAt(0)}return s}const _keyCodeToKeyIdentifier={"9":"Tab","13":"Enter","16":"Shift","17":"Control","18":"Alt","27":"Escape","37":"Left","38":"Up","39":"Right","40":"Down","46":"Delete","91":"Win"};class Keyboard extends EventHandler{attach(element){if(this._element){this.detach();}this._element=element;this._element.addEventListener("keydown",this._keyDownHandler,false);this._element.addEventListener("keypress",this._keyPressHandler,false);this._element.addEventListener("keyup",this._keyUpHandler,false);document.addEventListener("visibilitychange",this._visibilityChangeHandler,false);window.addEventListener("blur",this._windowBlurHandler,false);}detach(){if(!this._element){return}this._element.removeEventListener("keydown",this._keyDownHandler);this._element.removeEventListener("keypress",this._keyPressHandler);this._element.removeEventListener("keyup",this._keyUpHandler);this._element=null;document.removeEventListener("visibilitychange",this._visibilityChangeHandler,false);window.removeEventListener("blur",this._windowBlurHandler,false);}toKeyIdentifier(keyCode){keyCode=toKeyCode(keyCode);const id=_keyCodeToKeyIdentifier[keyCode.toString()];if(id){return id}let hex=keyCode.toString(16).toUpperCase();const length=hex.length;for(let count=0;count<4-length;count++){hex=`0${hex}`;}return `U+${hex}`}_handleKeyDown(event){const code=event.keyCode||event.charCode;if(code===undefined)return;const id=this.toKeyIdentifier(code);this._keymap[id]=true;this.fire("keydown",makeKeyboardEvent(event));if(this.preventDefault){event.preventDefault();}if(this.stopPropagation){event.stopPropagation();}}_handleKeyUp(event){const code=event.keyCode||event.charCode;if(code===undefined)return;const id=this.toKeyIdentifier(code);delete this._keymap[id];this.fire("keyup",makeKeyboardEvent(event));if(this.preventDefault){event.preventDefault();}if(this.stopPropagation){event.stopPropagation();}}_handleKeyPress(event){this.fire("keypress",makeKeyboardEvent(event));if(this.preventDefault){event.preventDefault();}if(this.stopPropagation){event.stopPropagation();}}_handleVisibilityChange(){if(document.visibilityState==="hidden"){this._handleWindowBlur();}}_handleWindowBlur(){this._keymap={};this._lastmap={};}update(){for(const prop in this._lastmap){delete this._lastmap[prop];}for(const prop in this._keymap){if(this._keymap.hasOwnProperty(prop)){this._lastmap[prop]=this._keymap[prop];}}}isPressed(key){const keyCode=toKeyCode(key);const id=this.toKeyIdentifier(keyCode);return !!this._keymap[id]}wasPressed(key){const keyCode=toKeyCode(key);const id=this.toKeyIdentifier(keyCode);return !!this._keymap[id]&&!!!this._lastmap[id]}wasReleased(key){const keyCode=toKeyCode(key);const id=this.toKeyIdentifier(keyCode);return !!!this._keymap[id]&&!!this._lastmap[id]}constructor(element,options={}){super();this._element=null;this._keymap={};this._lastmap={};this._keyDownHandler=this._handleKeyDown.bind(this);this._keyUpHandler=this._handleKeyUp.bind(this);this._keyPressHandler=this._handleKeyPress.bind(this);this._visibilityChangeHandler=this._handleVisibilityChange.bind(this);this._windowBlurHandler=this._handleWindowBlur.bind(this);if(element){this.attach(element);}this.preventDefault=options.preventDefault||false;this.stopPropagation=options.stopPropagation||false;}}Keyboard.EVENT_KEYDOWN="keydown";Keyboard.EVENT_KEYUP="keyup";function isMousePointerLocked(){return !!(document.pointerLockElement||document.mozPointerLockElement||document.webkitPointerLockElement)}class MouseEvent{constructor(mouse,event){var _event$ctrlKey,_event$altKey,_event$shiftKey,_event$metaKey;this.x=0;this.y=0;this.dx=0;this.dy=0;this.button=MOUSEBUTTON_NONE;this.wheelDelta=0;this.element=void 0;this.ctrlKey=false;this.altKey=false;this.shiftKey=false;this.metaKey=false;this.event=void 0;let coords={x:0,y:0};if(event){if(event instanceof MouseEvent){throw Error("Expected MouseEvent")}coords=mouse._getTargetCoords(event);}else {event={};}if(coords){this.x=coords.x;this.y=coords.y;}else if(isMousePointerLocked()){this.x=0;this.y=0;}else {return}if(event.type==="wheel"){if(event.deltaY>0){this.wheelDelta=1;}else if(event.deltaY<0){this.wheelDelta=-1;}}if(isMousePointerLocked()){this.dx=event.movementX||event.webkitMovementX||event.mozMovementX||0;this.dy=event.movementY||event.webkitMovementY||event.mozMovementY||0;}else {this.dx=this.x-mouse._lastX;this.dy=this.y-mouse._lastY;}if(event.type==="mousedown"||event.type==="mouseup"){this.button=event.button;}this.buttons=mouse._buttons.slice(0);this.element=event.target;this.ctrlKey=(_event$ctrlKey=event.ctrlKey)!=null?_event$ctrlKey:false;this.altKey=(_event$altKey=event.altKey)!=null?_event$altKey:false;this.shiftKey=(_event$shiftKey=event.shiftKey)!=null?_event$shiftKey:false;this.metaKey=(_event$metaKey=event.metaKey)!=null?_event$metaKey:false;this.event=event;}}class Mouse extends EventHandler{static isPointerLocked(){return isMousePointerLocked()}attach(element){this._target=element;if(this._attached)return;this._attached=true;const passiveOptions={passive:false};const options=platform.passiveEvents?passiveOptions:false;window.addEventListener("mouseup",this._upHandler,options);window.addEventListener("mousedown",this._downHandler,options);window.addEventListener("mousemove",this._moveHandler,options);window.addEventListener("wheel",this._wheelHandler,options);}detach(){if(!this._attached)return;this._attached=false;this._target=null;const passiveOptions={passive:false};const options=platform.passiveEvents?passiveOptions:false;window.removeEventListener("mouseup",this._upHandler,options);window.removeEventListener("mousedown",this._downHandler,options);window.removeEventListener("mousemove",this._moveHandler,options);window.removeEventListener("wheel",this._wheelHandler,options);}disableContextMenu(){if(!this._target)return;this._target.addEventListener("contextmenu",this._contextMenuHandler);}enableContextMenu(){if(!this._target)return;this._target.removeEventListener("contextmenu",this._contextMenuHandler);}enablePointerLock(success,error){if(!document.body.requestPointerLock){if(error){error();}return}const s=()=>{success();document.removeEventListener("pointerlockchange",s);};const e=()=>{error();document.removeEventListener("pointerlockerror",e);};if(success){document.addEventListener("pointerlockchange",s,false);}if(error){document.addEventListener("pointerlockerror",e,false);}document.body.requestPointerLock();}disablePointerLock(success){if(!document.exitPointerLock){return}const s=()=>{success();document.removeEventListener("pointerlockchange",s);};if(success){document.addEventListener("pointerlockchange",s,false);}document.exitPointerLock();}update(){this._lastbuttons[0]=this._buttons[0];this._lastbuttons[1]=this._buttons[1];this._lastbuttons[2]=this._buttons[2];}isPressed(button){return this._buttons[button]}wasPressed(button){return this._buttons[button]&&!this._lastbuttons[button]}wasReleased(button){return !this._buttons[button]&&this._lastbuttons[button]}_handleUp(event){this._buttons[event.button]=false;const e=new MouseEvent(this,event);if(!e.event)return;this.fire(EVENT_MOUSEUP,e);}_handleDown(event){this._buttons[event.button]=true;const e=new MouseEvent(this,event);if(!e.event)return;this.fire(EVENT_MOUSEDOWN,e);}_handleMove(event){const e=new MouseEvent(this,event);if(!e.event)return;this.fire(EVENT_MOUSEMOVE,e);this._lastX=e.x;this._lastY=e.y;}_handleWheel(event){const e=new MouseEvent(this,event);if(!e.event)return;this.fire(EVENT_MOUSEWHEEL,e);}_getTargetCoords(event){const rect=this._target.getBoundingClientRect();const left=Math.floor(rect.left);const top=Math.floor(rect.top);if(event.clientX<left||event.clientX>=left+this._target.clientWidth||event.clientY<top||event.clientY>=top+this._target.clientHeight){return null}return {x:event.clientX-left,y:event.clientY-top}}constructor(element){super();this._lastX=0;this._lastY=0;this._buttons=[false,false,false];this._lastbuttons=[false,false,false];this._target=null;this._attached=false;this._upHandler=this._handleUp.bind(this);this._downHandler=this._handleDown.bind(this);this._moveHandler=this._handleMove.bind(this);this._wheelHandler=this._handleWheel.bind(this);this._contextMenuHandler=event=>{event.preventDefault();};this.attach(element);}}Mouse.EVENT_MOUSEMOVE=EVENT_MOUSEMOVE;Mouse.EVENT_MOUSEDOWN=EVENT_MOUSEDOWN;Mouse.EVENT_MOUSEUP=EVENT_MOUSEUP;Mouse.EVENT_MOUSEWHEEL=EVENT_MOUSEWHEEL;class Controller{attach(element){this._element=element;if(this._keyboard){this._keyboard.attach(element);}if(this._mouse){this._mouse.attach(element);}}detach(){if(this._keyboard){this._keyboard.detach();}if(this._mouse){this._mouse.detach();}this._element=null;}disableContextMenu(){if(!this._mouse){this._enableMouse();}this._mouse.disableContextMenu();}enableContextMenu(){if(!this._mouse){this._enableMouse();}this._mouse.enableContextMenu();}update(dt){if(this._keyboard){this._keyboard.update();}if(this._mouse){this._mouse.update();}if(this._gamepads){this._gamepads.update();}this._axesValues={};for(const key in this._axes){this._axesValues[key]=[];}}appendAction(action_name,action){this._actions[action_name]=this._actions[action_name]||[];this._actions[action_name].push(action);}registerKeys(action,keys){if(!this._keyboard){this._enableKeyboard();}if(this._actions[action]){throw new Error(`Action: ${action} already registered`)}if(keys===undefined){throw new Error("Invalid button")}if(!keys.length){keys=[keys];}this.appendAction(action,{type:ACTION_KEYBOARD,keys});}registerMouse(action,button){if(!this._mouse){this._enableMouse();}if(button===undefined){throw new Error("Invalid button")}this.appendAction(action,{type:ACTION_MOUSE,button});}registerPadButton(action,pad,button){if(button===undefined){throw new Error("Invalid button")}this.appendAction(action,{type:ACTION_GAMEPAD,button,pad});}registerAxis(options){const name=options.name;if(!this._axes[name]){this._axes[name]=[];}const i=this._axes[name].push(name);options=options||{};options.pad=options.pad||PAD_1;const bind=function bind(controller,source,value,key){switch(source){case"mousex":controller._mouse.on(EVENT_MOUSEMOVE,e=>{controller._axesValues[name][i]=e.dx/10;});break;case"mousey":controller._mouse.on(EVENT_MOUSEMOVE,e=>{controller._axesValues[name][i]=e.dy/10;});break;case"key":controller._axes[name].push(()=>{return controller._keyboard.isPressed(key)?value:0});break;case"padrx":controller._axes[name].push(()=>{return controller._gamepads.getAxis(options.pad,PAD_R_STICK_X)});break;case"padry":controller._axes[name].push(()=>{return controller._gamepads.getAxis(options.pad,PAD_R_STICK_Y)});break;case"padlx":controller._axes[name].push(()=>{return controller._gamepads.getAxis(options.pad,PAD_L_STICK_X)});break;case"padly":controller._axes[name].push(()=>{return controller._gamepads.getAxis(options.pad,PAD_L_STICK_Y)});break;default:throw new Error("Unknown axis")}};bind(this,options.positive,1,options.positiveKey);if(options.negativeKey||options.negative!==options.positive){bind(this,options.negative,-1,options.negativeKey);}}isPressed(actionName){if(!this._actions[actionName]){return false}const length=this._actions[actionName].length;for(let index=0;index<length;++index){const action=this._actions[actionName][index];switch(action.type){case ACTION_KEYBOARD:if(this._keyboard){const len=action.keys.length;for(let i=0;i<len;i++){if(this._keyboard.isPressed(action.keys[i])){return true}}}break;case ACTION_MOUSE:if(this._mouse&&this._mouse.isPressed(action.button)){return true}break;case ACTION_GAMEPAD:if(this._gamepads&&this._gamepads.isPressed(action.pad,action.button)){return true}break}}return false}wasPressed(actionName){if(!this._actions[actionName]){return false}const length=this._actions[actionName].length;for(let index=0;index<length;++index){const action=this._actions[actionName][index];switch(action.type){case ACTION_KEYBOARD:if(this._keyboard){const len=action.keys.length;for(let i=0;i<len;i++){if(this._keyboard.wasPressed(action.keys[i])){return true}}}break;case ACTION_MOUSE:if(this._mouse&&this._mouse.wasPressed(action.button)){return true}break;case ACTION_GAMEPAD:if(this._gamepads&&this._gamepads.wasPressed(action.pad,action.button)){return true}break}}return false}getAxis(name){let value=0;if(this._axes[name]){const len=this._axes[name].length;for(let i=0;i<len;i++){if(type(this._axes[name][i])==="function"){const v=this._axes[name][i]();if(Math.abs(v)>Math.abs(value)){value=v;}}else if(this._axesValues[name]){if(Math.abs(this._axesValues[name][i])>Math.abs(value)){value=this._axesValues[name][i];}}}}return value}_enableMouse(){this._mouse=new Mouse;if(!this._element){throw new Error("Controller must be attached to an Element")}this._mouse.attach(this._element);}_enableKeyboard(){this._keyboard=new Keyboard;if(!this._element){throw new Error("Controller must be attached to an Element")}this._keyboard.attach(this._element);}constructor(element,options={}){this._keyboard=void 0;this._mouse=void 0;this._gamepads=void 0;this._element=null;this._actions={};this._axes={};this._axesValues={};this._keyboard=options.keyboard||null;this._mouse=options.mouse||null;this._gamepads=options.gamepads||null;if(element){this.attach(element);}}}const dummyArray=Object.freeze([]);let _getGamepads=function getGamepads(){return dummyArray};if(typeof navigator!=="undefined"){_getGamepads=(navigator.getGamepads||navigator.webkitGetGamepads||_getGamepads).bind(navigator);}const MAPS_INDEXES={buttons:{PAD_FACE_1,PAD_FACE_2,PAD_FACE_3,PAD_FACE_4,PAD_L_SHOULDER_1,PAD_R_SHOULDER_1,PAD_L_SHOULDER_2,PAD_R_SHOULDER_2,PAD_SELECT,PAD_START,PAD_L_STICK_BUTTON,PAD_R_STICK_BUTTON,PAD_UP,PAD_DOWN,PAD_LEFT,PAD_RIGHT,PAD_VENDOR,XRPAD_TRIGGER,XRPAD_SQUEEZE,XRPAD_TOUCHPAD_BUTTON,XRPAD_STICK_BUTTON,XRPAD_A,XRPAD_B},axes:{PAD_L_STICK_X,PAD_L_STICK_Y,PAD_R_STICK_X,PAD_R_STICK_Y,XRPAD_TOUCHPAD_X,XRPAD_TOUCHPAD_Y,XRPAD_STICK_X,XRPAD_STICK_Y}};const MAPS={DEFAULT:{buttons:["PAD_FACE_1","PAD_FACE_2","PAD_FACE_3","PAD_FACE_4","PAD_L_SHOULDER_1","PAD_R_SHOULDER_1","PAD_L_SHOULDER_2","PAD_R_SHOULDER_2","PAD_SELECT","PAD_START","PAD_L_STICK_BUTTON","PAD_R_STICK_BUTTON","PAD_UP","PAD_DOWN","PAD_LEFT","PAD_RIGHT","PAD_VENDOR"],axes:["PAD_L_STICK_X","PAD_L_STICK_Y","PAD_R_STICK_X","PAD_R_STICK_Y"]},DEFAULT_DUAL:{buttons:["PAD_FACE_1","PAD_FACE_2","PAD_FACE_3","PAD_FACE_4","PAD_L_SHOULDER_1","PAD_R_SHOULDER_1","PAD_L_SHOULDER_2","PAD_R_SHOULDER_2","PAD_SELECT","PAD_START","PAD_L_STICK_BUTTON","PAD_R_STICK_BUTTON","PAD_VENDOR"],axes:["PAD_L_STICK_X","PAD_L_STICK_Y","PAD_R_STICK_X","PAD_R_STICK_Y"],synthesizedButtons:{PAD_UP:{axis:0,min:0,max:1},PAD_DOWN:{axis:0,min:-1,max:0},PAD_LEFT:{axis:0,min:-1,max:0},PAD_RIGHT:{axis:0,min:0,max:1}}},PS3:{buttons:["PAD_FACE_1","PAD_FACE_2","PAD_FACE_4","PAD_FACE_3","PAD_L_SHOULDER_1","PAD_R_SHOULDER_1","PAD_L_SHOULDER_2","PAD_R_SHOULDER_2","PAD_SELECT","PAD_START","PAD_L_STICK_BUTTON","PAD_R_STICK_BUTTON","PAD_UP","PAD_DOWN","PAD_LEFT","PAD_RIGHT","PAD_VENDOR"],axes:["PAD_L_STICK_X","PAD_L_STICK_Y","PAD_R_STICK_X","PAD_R_STICK_Y"],mapping:"standard"},DEFAULT_XR:{buttons:["XRPAD_TRIGGER","XRPAD_SQUEEZE","XRPAD_TOUCHPAD_BUTTON","XRPAD_STICK_BUTTON","XRPAD_A","XRPAD_B"],axes:["XRPAD_TOUCHPAD_X","XRPAD_TOUCHPAD_Y","XRPAD_STICK_X","XRPAD_STICK_Y"],mapping:"xr-standard"}};const PRODUCT_CODES={"Product: 0268":"PS3"};const custom_maps={};function getMap(pad){const custom=custom_maps[pad.id];if(custom){return custom}for(const code in PRODUCT_CODES){if(pad.id.indexOf(code)!==-1){const product=PRODUCT_CODES[code];if(!pad.mapping){const raw=MAPS[`RAW_${product}`];if(raw){return raw}}return MAPS[product]}}if(pad.mapping==="xr-standard"){return MAPS.DEFAULT_XR}const defaultmap=MAPS.DEFAULT;const map=pad.buttons.length<defaultmap.buttons.length?MAPS.DEFAULT_DUAL:defaultmap;map.mapping=pad.mapping;return map}let deadZone=.25;function sleep(ms){return new Promise(resolve=>{setTimeout(resolve,ms);})}class GamePadButton{update(button){var _button$touched;const{value,pressed}=button;const touched=(_button$touched=button.touched)!=null?_button$touched:value>0;this.wasPressed=!this.pressed&&pressed;this.wasReleased=this.pressed&&!pressed;this.wasTouched=!this.touched&&touched;this.value=value;this.pressed=pressed;this.touched=touched;}constructor(current,previous){this.value=0;this.pressed=false;this.touched=false;this.wasPressed=false;this.wasReleased=false;this.wasTouched=false;if(typeof current==="number"){this.value=current;this.pressed=current===1;this.touched=current>0;}else {var _current$touched;this.value=current.value;this.pressed=current.pressed;this.touched=(_current$touched=current.touched)!=null?_current$touched:current.value>0;}if(previous){if(typeof previous==="number"){this.wasPressed=previous!==1&&this.pressed;this.wasReleased=previous===1&&!this.pressed;this.wasTouched=previous===0&&this.touched;}else {var _previous$touched;this.wasPressed=!previous.pressed&&this.pressed;this.wasReleased=previous.pressed&&!this.pressed;this.wasTouched=!((_previous$touched=previous.touched)!=null?_previous$touched:previous.value>0)&&this.touched;}}}}const dummyButton=Object.freeze(new GamePadButton(0));class GamePad{get connected(){return this.pad.connected}_compileMapping(){const{axes,buttons}=this._compiledMapping;const axesIndexes=MAPS_INDEXES.axes;const buttonsIndexes=MAPS_INDEXES.buttons;axes.length=0;buttons.length=0;const axesMap=this.map.axes;if(axesMap){this.map.axes.forEach((axis,i)=>{axes[axesIndexes[axis]]=()=>this.pad.axes[i]||0;});}for(let i=0,l=axes.length;i<l;i++){if(!axes[i]){axes[i]=()=>0;}}const buttonsMap=this.map.buttons;if(buttonsMap){buttonsMap.forEach((button,i)=>{buttons[buttonsIndexes[button]]=()=>this._buttons[i]||dummyButton;});}const synthesizedButtonsMap=this.map.synthesizedButtons;if(synthesizedButtonsMap){Object.entries(synthesizedButtonsMap).forEach(button=>{const{axis,max,min}=button[1];buttons[buttonsIndexes[button[0]]]=()=>{var _this$_axes$axis,_this$_previousAxes$a;return new GamePadButton(Math.abs(math.clamp((_this$_axes$axis=this._axes[axis])!=null?_this$_axes$axis:0,min,max)),Math.abs(math.clamp((_this$_previousAxes$a=this._previousAxes[axis])!=null?_this$_previousAxes$a:0,min,max)))};});}for(let i=0,l=buttons.length;i<l;i++){if(!buttons[i]){buttons[i]=()=>dummyButton;}}}update(gamepad){this.pad=gamepad;const previousAxes=this._previousAxes;const axes=this._axes;previousAxes.length=0;previousAxes.push(...axes);axes.length=0;axes.push(...gamepad.axes);const buttons=this._buttons;for(let i=0,l=buttons.length;i<l;i++){buttons[i].update(gamepad.buttons[i]);}return this}updateMap(map){map.mapping="custom";custom_maps[this.id]=map;this.map=map;this.mapping="custom";this._compileMapping();}resetMap(){if(custom_maps[this.id]){delete custom_maps[this.id];const map=getMap(this.pad);this.map=map;this.mapping=map.mapping;this._compileMapping();}}get axes(){return this._compiledMapping.axes.map(a=>a())}get buttons(){return this._compiledMapping.buttons.map(b=>b())}async pulse(intensity,duration,options){const actuators=this.pad.vibrationActuator?[this.pad.vibrationActuator]:this.pad.hapticActuators||dummyArray;if(actuators.length){var _options$startDelay,_options$strongMagnit,_options$weakMagnitud;const startDelay=(_options$startDelay=options==null?void 0:options.startDelay)!=null?_options$startDelay:0;const strongMagnitude=(_options$strongMagnit=options==null?void 0:options.strongMagnitude)!=null?_options$strongMagnit:intensity;const weakMagnitude=(_options$weakMagnitud=options==null?void 0:options.weakMagnitude)!=null?_options$weakMagnitud:intensity;const results=await Promise.all(actuators.map(async function(actuator){if(!actuator){return true}if(actuator.playEffect){return actuator.playEffect(actuator.type,{duration,startDelay,strongMagnitude,weakMagnitude})}else if(actuator.pulse){await sleep(startDelay);return actuator.pulse(intensity,duration)}return false}));return results.some(r=>r===true||r==="complete")}return false}getButton(index){const button=this._compiledMapping.buttons[index];return button?button():dummyButton}isPressed(button){return this.getButton(button).pressed}wasPressed(button){return this.getButton(button).wasPressed}wasReleased(button){return this.getButton(button).wasReleased}isTouched(button){return this.getButton(button).touched}wasTouched(button){return this.getButton(button).wasTouched}getValue(button){return this.getButton(button).value}getAxis(axis){const a=this.axes[axis];return a&&Math.abs(a)>deadZone?a:0}constructor(gamepad,map){this._compiledMapping={buttons:[],axes:[]};this.id=gamepad.id;this.index=gamepad.index;this._buttons=gamepad.buttons.map(b=>new GamePadButton(b));this._axes=[...gamepad.axes];this._previousAxes=[...gamepad.axes];this.mapping=map.mapping;this.map=map;this.hand=gamepad.hand||"none";this.pad=gamepad;this._compileMapping();}}class GamePads extends EventHandler{set deadZone(value){deadZone=value;}get deadZone(){return deadZone}get previous(){const current=this.current;for(let i=0,l=current.length;i<l;i++){const buttons=current[i]._buttons;if(!this._previous[i]){this._previous[i]=[];}for(let j=0,m=buttons.length;j<m;j++){const button=buttons[i];this.previous[i][j]=button?!button.wasPressed&&button.pressed||button.wasReleased:false;}}this._previous.length=this.current.length;return this._previous}_ongamepadconnected(event){const pad=new GamePad(event.gamepad,this.getMap(event.gamepad));const current=this.current;let padIndex=current.findIndex(gp=>gp.index===pad.index);while(padIndex!==-1){current.splice(padIndex,1);padIndex=current.findIndex(gp=>gp.index===pad.index);}current.push(pad);this.fire(EVENT_GAMEPADCONNECTED,pad);}_ongamepaddisconnected(event){const current=this.current;const padIndex=current.findIndex(gp=>gp.index===event.gamepad.index);if(padIndex!==-1){this.fire(EVENT_GAMEPADDISCONNECTED,current[padIndex]);current.splice(padIndex,1);}}update(){this.poll();}poll(pads=[]){if(pads.length>0){pads.length=0;}const padDevices=_getGamepads();for(let i=0,len=padDevices.length;i<len;i++){if(padDevices[i]){const pad=this.findByIndex(padDevices[i].index);if(pad){pads.push(pad.update(padDevices[i]));}else {const nPad=new GamePad(padDevices[i],this.getMap(padDevices[i]));this.current.push(nPad);pads.push(nPad);}}}return pads}destroy(){window.removeEventListener("gamepadconnected",this._ongamepadconnectedHandler,false);window.removeEventListener("gamepaddisconnected",this._ongamepaddisconnectedHandler,false);}getMap(pad){return getMap(pad)}isPressed(orderIndex,button){var _this$current$orderIn;return ((_this$current$orderIn=this.current[orderIndex])==null?void 0:_this$current$orderIn.isPressed(button))||false}wasPressed(orderIndex,button){var _this$current$orderIn2;return ((_this$current$orderIn2=this.current[orderIndex])==null?void 0:_this$current$orderIn2.wasPressed(button))||false}wasReleased(orderIndex,button){var _this$current$orderIn3;return ((_this$current$orderIn3=this.current[orderIndex])==null?void 0:_this$current$orderIn3.wasReleased(button))||false}getAxis(orderIndex,axis){var _this$current$orderIn4;return ((_this$current$orderIn4=this.current[orderIndex])==null?void 0:_this$current$orderIn4.getAxis(axis))||0}pulse(orderIndex,intensity,duration,options){const pad=this.current[orderIndex];return pad?pad.pulse(intensity,duration,options):Promise.resolve(false)}pulseAll(intensity,duration,options){return Promise.all(this.current.map(pad=>pad.pulse(intensity,duration,options)))}findById(id){return this.current.find(gp=>gp&&gp.id===id)||null}findByIndex(index){return this.current.find(gp=>gp&&gp.index===index)||null}constructor(){super();this.gamepadsSupported=platform.gamepads;this.current=[];this._previous=[];this._ongamepadconnectedHandler=this._ongamepadconnected.bind(this);this._ongamepaddisconnectedHandler=this._ongamepaddisconnected.bind(this);window.addEventListener("gamepadconnected",this._ongamepadconnectedHandler,false);window.addEventListener("gamepaddisconnected",this._ongamepaddisconnectedHandler,false);this.poll();}}GamePads.EVENT_GAMEPADCONNECTED="gamepadconnected";GamePads.EVENT_GAMEPADDISCONNECTED="gamepaddisconnected";function getTouchTargetCoords(touch){let totalOffsetX=0;let totalOffsetY=0;let target=touch.target;while(!(target instanceof HTMLElement)&&target){target=target.parentNode;}while(target){totalOffsetX+=target.offsetLeft-target.scrollLeft;totalOffsetY+=target.offsetTop-target.scrollTop;target=target.offsetParent;}return {x:touch.pageX-totalOffsetX,y:touch.pageY-totalOffsetY}}class Touch{constructor(touch){this.id=void 0;this.x=void 0;this.y=void 0;this.target=void 0;this.touch=void 0;const coords=getTouchTargetCoords(touch);this.id=touch.identifier;this.x=coords.x;this.y=coords.y;this.target=touch.target;this.touch=touch;}}class TouchEvent{getTouchById(id,list){return list.find(touch=>touch.id===id)||null}constructor(device,event){this.element=void 0;this.event=void 0;this.touches=[];this.changedTouches=[];this.element=event.target;this.event=event;this.touches=Array.from(event.touches).map(touch=>new Touch(touch));this.changedTouches=Array.from(event.changedTouches).map(touch=>new Touch(touch));}}class TouchDevice extends EventHandler{attach(element){if(this._element){this.detach();}this._element=element;this._element.addEventListener("touchstart",this._startHandler,false);this._element.addEventListener("touchend",this._endHandler,false);this._element.addEventListener("touchmove",this._moveHandler,false);this._element.addEventListener("touchcancel",this._cancelHandler,false);}detach(){if(this._element){this._element.removeEventListener("touchstart",this._startHandler,false);this._element.removeEventListener("touchend",this._endHandler,false);this._element.removeEventListener("touchmove",this._moveHandler,false);this._element.removeEventListener("touchcancel",this._cancelHandler,false);}this._element=null;}_handleTouchStart(e){this.fire("touchstart",new TouchEvent(this,e));}_handleTouchEnd(e){this.fire("touchend",new TouchEvent(this,e));}_handleTouchMove(e){e.preventDefault();this.fire("touchmove",new TouchEvent(this,e));}_handleTouchCancel(e){this.fire("touchcancel",new TouchEvent(this,e));}constructor(element){super();this._element=null;this._startHandler=this._handleTouchStart.bind(this);this._endHandler=this._handleTouchEnd.bind(this);this._moveHandler=this._handleTouchMove.bind(this);this._cancelHandler=this._handleTouchCancel.bind(this);this.attach(element);}}class Http{get(url,options,callback){if(typeof options==="function"){callback=options;options={};}return this.request("GET",url,options,callback)}post(url,data,options,callback){if(typeof options==="function"){callback=options;options={};}options.postdata=data;return this.request("POST",url,options,callback)}put(url,data,options,callback){if(typeof options==="function"){callback=options;options={};}options.postdata=data;return this.request("PUT",url,options,callback)}del(url,options,callback){if(typeof options==="function"){callback=options;options={};}return this.request("DELETE",url,options,callback)}request(method,url,options,callback){let uri,query,postdata;let errored=false;if(typeof options==="function"){callback=options;options={};}if(options.retry){options=Object.assign({retries:0,maxRetries:5},options);}options.callback=callback;if(options.async==null){options.async=true;}if(options.headers==null){options.headers={};}if(options.postdata!=null){if(options.postdata instanceof Document){postdata=options.postdata;}else if(options.postdata instanceof FormData){postdata=options.postdata;}else if(options.postdata instanceof Object){let contentType=options.headers["Content-Type"];if(contentType===undefined){options.headers["Content-Type"]=Http.ContentType.FORM_URLENCODED;contentType=options.headers["Content-Type"];}switch(contentType){case Http.ContentType.FORM_URLENCODED:{postdata="";let bFirstItem=true;for(const key in options.postdata){if(options.postdata.hasOwnProperty(key)){if(bFirstItem){bFirstItem=false;}else {postdata+="&";}const encodedKey=encodeURIComponent(key);const encodedValue=encodeURIComponent(options.postdata[key]);postdata+=`${encodedKey}=${encodedValue}`;}}break}default:case Http.ContentType.JSON:if(contentType==null){options.headers["Content-Type"]=Http.ContentType.JSON;}postdata=JSON.stringify(options.postdata);break}}else {postdata=options.postdata;}}if(options.cache===false){const timestamp=now();uri=new URI(url);if(!uri.query){uri.query=`ts=${timestamp}`;}else {uri.query=`${uri.query}&ts=${timestamp}`;}url=uri.toString();}if(options.query){uri=new URI(url);query=extend(uri.getQuery(),options.query);uri.setQuery(query);url=uri.toString();}const xhr=new XMLHttpRequest;xhr.open(method,url,options.async);xhr.withCredentials=options.withCredentials!==undefined?options.withCredentials:false;xhr.responseType=options.responseType||this._guessResponseType(url);for(const header in options.headers){if(options.headers.hasOwnProperty(header)){xhr.setRequestHeader(header,options.headers[header]);}}xhr.onreadystatechange=()=>{this._onReadyStateChange(method,url,options,xhr);};xhr.onerror=()=>{this._onError(method,url,options,xhr);errored=true;};try{xhr.send(postdata);}catch(e){if(!errored){options.error(xhr.status,xhr,e);}}return xhr}_guessResponseType(url){const uri=new URI(url);const ext=path.getExtension(uri.path).toLowerCase();if(Http.binaryExtensions.indexOf(ext)>=0){return Http.ResponseType.ARRAY_BUFFER}else if(ext===".json"){return Http.ResponseType.JSON}else if(ext===".xml"){return Http.ResponseType.DOCUMENT}return Http.ResponseType.TEXT}_isBinaryContentType(contentType){const binTypes=[Http.ContentType.BASIS,Http.ContentType.BIN,Http.ContentType.DDS,Http.ContentType.GLB,Http.ContentType.MP3,Http.ContentType.MP4,Http.ContentType.OGG,Http.ContentType.OPUS,Http.ContentType.WAV];if(binTypes.indexOf(contentType)>=0){return true}return false}_isBinaryResponseType(responseType){return responseType===Http.ResponseType.ARRAY_BUFFER||responseType===Http.ResponseType.BLOB||responseType===Http.ResponseType.JSON}_onReadyStateChange(method,url,options,xhr){if(xhr.readyState===4){switch(xhr.status){case 0:{if(xhr.responseURL&&xhr.responseURL.startsWith("file:///")){this._onSuccess(method,url,options,xhr);}else {this._onError(method,url,options,xhr);}break}case 200:case 201:case 206:case 304:{this._onSuccess(method,url,options,xhr);break}default:{this._onError(method,url,options,xhr);break}}}}_onSuccess(method,url,options,xhr){let response;let contentType;const header=xhr.getResponseHeader("Content-Type");if(header){const parts=header.split(";");contentType=parts[0].trim();}try{if(this._isBinaryContentType(contentType)||this._isBinaryResponseType(xhr.responseType)){response=xhr.response;}else if(contentType===Http.ContentType.JSON||url.split("?")[0].endsWith(".json")){response=JSON.parse(xhr.responseText);}else if(xhr.responseType===Http.ResponseType.DOCUMENT||contentType===Http.ContentType.XML){response=xhr.responseXML;}else {response=xhr.responseText;}options.callback(null,response);}catch(err){options.callback(err);}}_onError(method,url,options,xhr){if(options.retrying){return}if(options.retry&&options.retries<options.maxRetries){options.retries++;options.retrying=true;const retryDelay=math.clamp(Math.pow(2,options.retries)*Http.retryDelay,0,options.maxRetryDelay||5e3);console.log(`${method}: ${url} - Error ${xhr.status}. Retrying in ${retryDelay} ms`);setTimeout(()=>{options.retrying=false;this.request(method,url,options,options.callback);},retryDelay);}else {options.callback(xhr.status===0?"Network error":xhr.status,null);}}}Http.ContentType={AAC:"audio/aac",BASIS:"image/basis",BIN:"application/octet-stream",DDS:"image/dds",FORM_URLENCODED:"application/x-www-form-urlencoded",GIF:"image/gif",GLB:"model/gltf-binary",JPEG:"image/jpeg",JSON:"application/json",MP3:"audio/mpeg",MP4:"audio/mp4",OGG:"audio/ogg",OPUS:'audio/ogg; codecs="opus"',PNG:"image/png",TEXT:"text/plain",WAV:"audio/x-wav",XML:"application/xml"};Http.ResponseType={TEXT:"text",ARRAY_BUFFER:"arraybuffer",BLOB:"blob",DOCUMENT:"document",JSON:"json"};Http.binaryExtensions=[".model",".wav",".ogg",".mp3",".mp4",".m4a",".aac",".dds",".basis",".glb",".opus"];Http.retryDelay=100;const http=new Http;function hasAudioContext(){return !!(typeof AudioContext!=="undefined"||typeof webkitAudioContext!=="undefined")}class Channel{getVolume(){return this.volume}getLoop(){return this.loop}setLoop(loop){this.loop=loop;if(this.source){this.source.loop=loop;}}getPitch(){return this.pitch}onManagerVolumeChange(){this.setVolume(this.getVolume());}onManagerSuspend(){if(this.isPlaying()&&!this.suspended){this.suspended=true;this.pause();}}onManagerResume(){if(this.suspended){this.suspended=false;this.unpause();}}play(){if(this.source){throw new Error("Call stop() before calling play()")}this._createSource();if(!this.source){return}this.startTime=this.manager.context.currentTime;this.source.start(0,this.startOffset%this.source.buffer.duration);this.setVolume(this.volume);this.setLoop(this.loop);this.setPitch(this.pitch);this.manager.on("volumechange",this.onManagerVolumeChange,this);this.manager.on("suspend",this.onManagerSuspend,this);this.manager.on("resume",this.onManagerResume,this);if(this.manager.suspended){this.onManagerSuspend();}}pause(){if(this.source){this.paused=true;this.startOffset+=this.manager.context.currentTime-this.startTime;this.source.stop(0);this.source=null;}}unpause(){if(this.source||!this.paused){console.warn("Call pause() before unpausing.");return}this._createSource();if(!this.source){return}this.startTime=this.manager.context.currentTime;this.source.start(0,this.startOffset%this.source.buffer.duration);this.setVolume(this.volume);this.setLoop(this.loop);this.setPitch(this.pitch);this.paused=false;}stop(){if(this.source){this.source.stop(0);this.source=null;}this.manager.off("volumechange",this.onManagerVolumeChange,this);this.manager.off("suspend",this.onManagerSuspend,this);this.manager.off("resume",this.onManagerResume,this);}setVolume(volume){volume=math.clamp(volume,0,1);this.volume=volume;if(this.gain){this.gain.gain.value=volume*this.manager.volume;}}setPitch(pitch){this.pitch=pitch;if(this.source){this.source.playbackRate.value=pitch;}}isPlaying(){return !this.paused&&this.source.playbackState===this.source.PLAYING_STATE}getDuration(){return this.source?this.source.buffer.duration:0}_createSource(){const context=this.manager.context;if(this.sound.buffer){this.source=context.createBufferSource();this.source.buffer=this.sound.buffer;this.source.connect(this.gain);this.gain.connect(context.destination);if(!this.loop){this.source.onended=this.pause.bind(this);}}}constructor(manager,sound,options={}){var _options$volume,_options$loop,_options$pitch;this.volume=(_options$volume=options.volume)!=null?_options$volume:1;this.loop=(_options$loop=options.loop)!=null?_options$loop:false;this.pitch=(_options$pitch=options.pitch)!=null?_options$pitch:1;this.sound=sound;this.paused=false;this.suspended=false;this.manager=manager;this.source=null;if(hasAudioContext()){this.startTime=0;this.startOffset=0;const context=manager.context;this.gain=context.createGain();}else if(sound.audio){this.source=sound.audio.cloneNode(false);this.source.pause();}}}if(!hasAudioContext()){Object.assign(Channel.prototype,{play:function(){if(this.source){this.paused=false;this.setVolume(this.volume);this.setLoop(this.loop);this.setPitch(this.pitch);this.source.play();}this.manager.on("volumechange",this.onManagerVolumeChange,this);this.manager.on("suspend",this.onManagerSuspend,this);this.manager.on("resume",this.onManagerResume,this);if(this.manager.suspended){this.onManagerSuspend();}},pause:function(){if(this.source){this.paused=true;this.source.pause();}},unpause:function(){if(this.source){this.paused=false;this.source.play();}},stop:function(){if(this.source){this.source.pause();}this.manager.off("volumechange",this.onManagerVolumeChange,this);this.manager.off("suspend",this.onManagerSuspend,this);this.manager.off("resume",this.onManagerResume,this);},setVolume:function(volume){volume=math.clamp(volume,0,1);this.volume=volume;if(this.source){this.source.volume=volume*this.manager.volume;}},setPitch:function(pitch){this.pitch=pitch;if(this.source){this.source.playbackRate=pitch;}},getDuration:function(){return this.source&&!isNaN(this.source.duration)?this.source.duration:0},isPlaying:function(){return !this.source.paused}});}const MAX_DISTANCE$1=1e4;class Channel3d extends Channel{getPosition(){return this.position}setPosition(position){this.position.copy(position);const panner=this.panner;if("positionX"in panner){panner.positionX.value=position.x;panner.positionY.value=position.y;panner.positionZ.value=position.z;}else if(panner.setPosition){panner.setPosition(position.x,position.y,position.z);}}getVelocity(){return this.velocity}setVelocity(velocity){this.velocity.copy(velocity);}getMaxDistance(){return this.panner.maxDistance}setMaxDistance(max){this.panner.maxDistance=max;}getMinDistance(){return this.panner.refDistance}setMinDistance(min){this.panner.refDistance=min;}getRollOffFactor(){return this.panner.rolloffFactor}setRollOffFactor(factor){this.panner.rolloffFactor=factor;}getDistanceModel(){return this.panner.distanceModel}setDistanceModel(distanceModel){this.panner.distanceModel=distanceModel;}_createSource(){const context=this.manager.context;this.source=context.createBufferSource();this.source.buffer=this.sound.buffer;this.source.connect(this.panner);this.panner.connect(this.gain);this.gain.connect(context.destination);if(!this.loop){this.source.onended=this.pause.bind(this);}}constructor(manager,sound,options){super(manager,sound,options);this.position=new Vec3;this.velocity=new Vec3;if(hasAudioContext()){this.panner=manager.context.createPanner();}else {this.maxDistance=MAX_DISTANCE$1;this.minDistance=1;this.rollOffFactor=1;this.distanceModel=DISTANCE_INVERSE;}}}if(!hasAudioContext()){let offset=new Vec3;const fallOff=function fallOff(posOne,posTwo,refDistance,maxDistance,rolloffFactor,distanceModel){offset=offset.sub2(posOne,posTwo);const distance=offset.length();if(distance<refDistance){return 1}else if(distance>maxDistance){return 0}let result=0;if(distanceModel===DISTANCE_LINEAR){result=1-rolloffFactor*(distance-refDistance)/(maxDistance-refDistance);}else if(distanceModel===DISTANCE_INVERSE){result=refDistance/(refDistance+rolloffFactor*(distance-refDistance));}else if(distanceModel===DISTANCE_EXPONENTIAL){result=Math.pow(distance/refDistance,-rolloffFactor);}return math.clamp(result,0,1)};Object.assign(Channel3d.prototype,{setPosition:function(position){this.position.copy(position);if(this.source){const listener=this.manager.listener;const lpos=listener.getPosition();const factor=fallOff(lpos,this.position,this.minDistance,this.maxDistance,this.rollOffFactor,this.distanceModel);const v=this.getVolume();this.source.volume=v*factor;}},getMaxDistance:function(){return this.maxDistance},setMaxDistance:function(max){this.maxDistance=max;},getMinDistance:function(){return this.minDistance},setMinDistance:function(min){this.minDistance=min;},getRollOffFactor:function(){return this.rollOffFactor},setRollOffFactor:function(factor){this.rollOffFactor=factor;},getDistanceModel:function(){return this.distanceModel},setDistanceModel:function(distanceModel){this.distanceModel=distanceModel;}});}class Listener{getPosition(){return this.position}setPosition(position){this.position.copy(position);const listener=this.listener;if(listener){if("positionX"in listener){listener.positionX.value=position.x;listener.positionY.value=position.y;listener.positionZ.value=position.z;}else if(listener.setPosition){listener.setPosition(position.x,position.y,position.z);}}}getVelocity(){return this.velocity}setVelocity(velocity){}setOrientation(orientation){this.orientation.copy(orientation);const listener=this.listener;if(listener){const m=orientation.data;if("forwardX"in listener){listener.forwardX.value=-m[8];listener.forwardY.value=-m[9];listener.forwardZ.value=-m[10];listener.upX.value=m[4];listener.upY.value=m[5];listener.upZ.value=m[6];}else if(listener.setOrientation){listener.setOrientation(-m[8],-m[9],-m[10],m[4],m[5],m[6]);}}}getOrientation(){return this.orientation}get listener(){const context=this._manager.context;return context?context.listener:null}constructor(manager){this._manager=void 0;this.position=new Vec3;this.velocity=new Vec3;this.orientation=new Mat4;this._manager=manager;}}const CONTEXT_STATE_RUNNING="running";const USER_INPUT_EVENTS=["click","touchstart","mousedown"];class SoundManager extends EventHandler{set volume(volume){volume=math.clamp(volume,0,1);this._volume=volume;this.fire("volumechange",volume);}get volume(){return this._volume}get suspended(){return this._userSuspended}get context(){if(!this._context&&this.AudioContext){this._context=new this.AudioContext;if(this._context.state!==CONTEXT_STATE_RUNNING){this._registerUnlockListeners();}}return this._context}suspend(){if(!this._userSuspended){this._userSuspended=true;if(this._context&&this._context.state===CONTEXT_STATE_RUNNING){this._suspend();}}}resume(){if(this._userSuspended){this._userSuspended=false;if(this._context&&this._context.state!==CONTEXT_STATE_RUNNING){this._resume();}}}destroy(){this.fire("destroy");if(this._context){var _this$_context;this._removeUnlockListeners();(_this$_context=this._context)==null||_this$_context.close();this._context=null;}}playSound(sound,options={}){let channel=null;if(Channel){channel=new Channel(this,sound,options);channel.play();}return channel}playSound3d(sound,position,options={}){let channel=null;if(Channel3d){channel=new Channel3d(this,sound,options);channel.setPosition(position);if(options.volume){channel.setVolume(options.volume);}if(options.loop){channel.setLoop(options.loop);}if(options.maxDistance){channel.setMaxDistance(options.maxDistance);}if(options.minDistance){channel.setMinDistance(options.minDistance);}if(options.rollOffFactor){channel.setRollOffFactor(options.rollOffFactor);}if(options.distanceModel){channel.setDistanceModel(options.distanceModel);}channel.play();}return channel}_resume(){this._context.resume().then(()=>{const source=this._context.createBufferSource();source.buffer=this._context.createBuffer(1,1,this._context.sampleRate);source.connect(this._context.destination);source.start(0);source.onended=event=>{source.disconnect(0);this.fire("resume");};},e=>{}).catch(e=>{});}_suspend(){this._context.suspend().then(()=>{this.fire("suspend");},e=>{}).catch(e=>{});}_unlockHandler(){this._removeUnlockListeners();if(!this._userSuspended&&this._context.state!==CONTEXT_STATE_RUNNING){this._resume();}}_registerUnlockListeners(){USER_INPUT_EVENTS.forEach(eventName=>{window.addEventListener(eventName,this._unlockHandlerFunc,false);});}_removeUnlockListeners(){USER_INPUT_EVENTS.forEach(eventName=>{window.removeEventListener(eventName,this._unlockHandlerFunc,false);});}constructor(){super();this._context=null;this.AudioContext=typeof AudioContext!=="undefined"&&AudioContext||typeof webkitAudioContext!=="undefined"&&webkitAudioContext;if(!this.AudioContext);this._unlockHandlerFunc=this._unlockHandler.bind(this);this._userSuspended=false;this.listener=new Listener(this);this._volume=1;}}class Sound{get duration(){let duration=0;if(this.buffer){duration=this.buffer.duration;}else if(this.audio){duration=this.audio.duration;}return duration||0}constructor(resource){this.audio=void 0;this.buffer=void 0;if(resource instanceof Audio){this.audio=resource;}else {this.buffer=resource;}}}const STATE_PLAYING=0;const STATE_PAUSED=1;const STATE_STOPPED=2;function capTime(time,duration){return time%duration||0}class SoundInstance extends EventHandler{set currentTime(value){if(value<0)return;if(this._state===STATE_PLAYING){const suspend=this._suspendInstanceEvents;this._suspendInstanceEvents=true;this.stop();this._startOffset=value;this.play();this._suspendInstanceEvents=suspend;}else {this._startOffset=value;this._currentTime=value;}}get currentTime(){if(this._startOffset!==null){return this._startOffset}if(this._state===STATE_PAUSED){return this._currentTime}if(this._state===STATE_STOPPED||!this.source){return 0}this._updateCurrentTime();return this._currentTime}set duration(value){this._duration=Math.max(0,Number(value)||0);const isPlaying=this._state===STATE_PLAYING;this.stop();if(isPlaying){this.play();}}get duration(){if(!this._sound){return 0}if(this._duration){return capTime(this._duration,this._sound.duration)}return this._sound.duration}get isPaused(){return this._state===STATE_PAUSED}get isPlaying(){return this._state===STATE_PLAYING}get isStopped(){return this._state===STATE_STOPPED}get isSuspended(){return this._suspended}set loop(value){this._loop=!!value;if(this.source){this.source.loop=this._loop;}}get loop(){return this._loop}set pitch(pitch){this._currentOffset=this.currentTime;this._startedAt=this._manager.context.currentTime;this._pitch=Math.max(Number(pitch)||0,.01);if(this.source){this.source.playbackRate.value=this._pitch;}}get pitch(){return this._pitch}set sound(value){this._sound=value;if(this._state!==STATE_STOPPED){this.stop();}else {this._createSource();}}get sound(){return this._sound}set startTime(value){this._startTime=Math.max(0,Number(value)||0);const isPlaying=this._state===STATE_PLAYING;this.stop();if(isPlaying){this.play();}}get startTime(){return this._startTime}set volume(volume){volume=math.clamp(volume,0,1);this._volume=volume;if(this.gain){this.gain.gain.value=volume*this._manager.volume;}}get volume(){return this._volume}_onPlay(){this.fire("play");if(this._onPlayCallback){this._onPlayCallback(this);}}_onPause(){this.fire("pause");if(this._onPauseCallback){this._onPauseCallback(this);}}_onResume(){this.fire("resume");if(this._onResumeCallback){this._onResumeCallback(this);}}_onStop(){this.fire("stop");if(this._onStopCallback){this._onStopCallback(this);}}_onEnded(){if(this._suspendEndEvent>0){this._suspendEndEvent--;return}this.fire("end");if(this._onEndCallback){this._onEndCallback(this);}this.stop();}_onManagerVolumeChange(){this.volume=this._volume;}_onManagerSuspend(){if(this._state===STATE_PLAYING&&!this._suspended){this._suspended=true;this.pause();}}_onManagerResume(){if(this._suspended){this._suspended=false;this.resume();}}_initializeNodes(){this.gain=this._manager.context.createGain();this._inputNode=this.gain;this._connectorNode=this.gain;this._connectorNode.connect(this._manager.context.destination);}play(){if(this._state!==STATE_STOPPED){this.stop();}this._state=STATE_PLAYING;this._playWhenLoaded=false;if(this._waitingContextSuspension){return false}if(this._manager.suspended){this._manager.once("resume",this._playAudioImmediate,this);this._waitingContextSuspension=true;return false}this._playAudioImmediate();return true}_playAudioImmediate(){this._waitingContextSuspension=false;if(this._state!==STATE_PLAYING){return}if(!this.source){this._createSource();}let offset=capTime(this._startOffset,this.duration);offset=capTime(this._startTime+offset,this._sound.duration);this._startOffset=null;if(this._duration){this.source.start(0,offset,this._duration);}else {this.source.start(0,offset);}this._startedAt=this._manager.context.currentTime;this._currentTime=0;this._currentOffset=offset;this.volume=this._volume;this.loop=this._loop;this.pitch=this._pitch;this._manager.on("volumechange",this._onManagerVolumeChange,this);this._manager.on("suspend",this._onManagerSuspend,this);this._manager.on("resume",this._onManagerResume,this);this._manager.on("destroy",this._onManagerDestroy,this);if(!this._suspendInstanceEvents){this._onPlay();}}pause(){this._playWhenLoaded=false;if(this._state!==STATE_PLAYING){return false}this._state=STATE_PAUSED;if(this._waitingContextSuspension){return true}this._updateCurrentTime();this._suspendEndEvent++;this.source.stop(0);this.source=null;this._startOffset=null;if(!this._suspendInstanceEvents){this._onPause();}return true}resume(){if(this._state!==STATE_PAUSED){return false}let offset=this.currentTime;this._state=STATE_PLAYING;if(this._waitingContextSuspension){return true}if(!this.source){this._createSource();}if(this._startOffset!==null){offset=capTime(this._startOffset,this.duration);offset=capTime(this._startTime+offset,this._sound.duration);this._startOffset=null;}if(this._duration){this.source.start(0,offset,this._duration);}else {this.source.start(0,offset);}this._startedAt=this._manager.context.currentTime;this._currentOffset=offset;this.volume=this._volume;this.loop=this._loop;this.pitch=this._pitch;this._playWhenLoaded=false;if(!this._suspendInstanceEvents){this._onResume();}return true}stop(){this._playWhenLoaded=false;if(this._state===STATE_STOPPED){return false}const wasPlaying=this._state===STATE_PLAYING;this._state=STATE_STOPPED;if(this._waitingContextSuspension){return true}this._manager.off("volumechange",this._onManagerVolumeChange,this);this._manager.off("suspend",this._onManagerSuspend,this);this._manager.off("resume",this._onManagerResume,this);this._manager.off("destroy",this._onManagerDestroy,this);this._startedAt=0;this._currentTime=0;this._currentOffset=0;this._startOffset=null;this._suspendEndEvent++;if(wasPlaying&&this.source){this.source.stop(0);}this.source=null;if(!this._suspendInstanceEvents){this._onStop();}return true}setExternalNodes(firstNode,lastNode){if(!firstNode){console.error("The firstNode must be a valid Audio Node");return}if(!lastNode){lastNode=firstNode;}const speakers=this._manager.context.destination;if(this._firstNode!==firstNode){if(this._firstNode){this._connectorNode.disconnect(this._firstNode);}else {this._connectorNode.disconnect(speakers);}this._firstNode=firstNode;this._connectorNode.connect(firstNode);}if(this._lastNode!==lastNode){if(this._lastNode){this._lastNode.disconnect(speakers);}this._lastNode=lastNode;this._lastNode.connect(speakers);}}clearExternalNodes(){const speakers=this._manager.context.destination;if(this._firstNode){this._connectorNode.disconnect(this._firstNode);this._firstNode=null;}if(this._lastNode){this._lastNode.disconnect(speakers);this._lastNode=null;}this._connectorNode.connect(speakers);}getExternalNodes(){return [this._firstNode,this._lastNode]}_createSource(){if(!this._sound){return null}const context=this._manager.context;if(this._sound.buffer){this.source=context.createBufferSource();this.source.buffer=this._sound.buffer;this.source.connect(this._inputNode);this.source.onended=this._endedHandler;this.source.loopStart=capTime(this._startTime,this.source.buffer.duration);if(this._duration){this.source.loopEnd=Math.max(this.source.loopStart,capTime(this._startTime+this._duration,this.source.buffer.duration));}}return this.source}_updateCurrentTime(){this._currentTime=capTime((this._manager.context.currentTime-this._startedAt)*this._pitch+this._currentOffset,this.duration);}_onManagerDestroy(){if(this.source&&this._state===STATE_PLAYING){this.source.stop(0);this.source=null;}}constructor(manager,sound,options){super();this.source=null;this._manager=manager;this._volume=options.volume!==undefined?math.clamp(Number(options.volume)||0,0,1):1;this._pitch=options.pitch!==undefined?Math.max(.01,Number(options.pitch)||0):1;this._loop=!!(options.loop!==undefined?options.loop:false);this._sound=sound;this._state=STATE_STOPPED;this._suspended=false;this._suspendEndEvent=0;this._suspendInstanceEvents=false;this._playWhenLoaded=true;this._startTime=Math.max(0,Number(options.startTime)||0);this._duration=Math.max(0,Number(options.duration)||0);this._startOffset=null;this._onPlayCallback=options.onPlay;this._onPauseCallback=options.onPause;this._onResumeCallback=options.onResume;this._onStopCallback=options.onStop;this._onEndCallback=options.onEnd;if(hasAudioContext()){this._startedAt=0;this._currentTime=0;this._currentOffset=0;this._inputNode=null;this._connectorNode=null;this._firstNode=null;this._lastNode=null;this._waitingContextSuspension=false;this._initializeNodes();this._endedHandler=this._onEnded.bind(this);}else {this._isReady=false;this._loadedMetadataHandler=this._onLoadedMetadata.bind(this);this._timeUpdateHandler=this._onTimeUpdate.bind(this);this._endedHandler=this._onEnded.bind(this);this._createSource();}}}SoundInstance.EVENT_PLAY="play";SoundInstance.EVENT_PAUSE="pause";SoundInstance.EVENT_RESUME="resume";SoundInstance.EVENT_STOP="stop";SoundInstance.EVENT_END="end";if(!hasAudioContext()){Object.assign(SoundInstance.prototype,{play:function(){if(this._state!==STATE_STOPPED){this.stop();}if(!this.source){if(!this._createSource()){return false}}this.volume=this._volume;this.pitch=this._pitch;this.loop=this._loop;this.source.play();this._state=STATE_PLAYING;this._playWhenLoaded=false;this._manager.on("volumechange",this._onManagerVolumeChange,this);this._manager.on("suspend",this._onManagerSuspend,this);this._manager.on("resume",this._onManagerResume,this);this._manager.on("destroy",this._onManagerDestroy,this);if(this._manager.suspended){this._onManagerSuspend();}if(!this._suspendInstanceEvents){this._onPlay();}return true},pause:function(){if(!this.source||this._state!==STATE_PLAYING){return false}this._suspendEndEvent++;this.source.pause();this._playWhenLoaded=false;this._state=STATE_PAUSED;this._startOffset=null;if(!this._suspendInstanceEvents){this._onPause();}return true},resume:function(){if(!this.source||this._state!==STATE_PAUSED){return false}this._state=STATE_PLAYING;this._playWhenLoaded=false;if(this.source.paused){this.source.play();if(!this._suspendInstanceEvents){this._onResume();}}return true},stop:function(){if(!this.source||this._state===STATE_STOPPED){return false}this._manager.off("volumechange",this._onManagerVolumeChange,this);this._manager.off("suspend",this._onManagerSuspend,this);this._manager.off("resume",this._onManagerResume,this);this._manager.off("destroy",this._onManagerDestroy,this);this._suspendEndEvent++;this.source.pause();this._playWhenLoaded=false;this._state=STATE_STOPPED;this._startOffset=null;if(!this._suspendInstanceEvents){this._onStop();}return true},setExternalNodes:function(){},clearExternalNodes:function(){},getExternalNodes:function(){return [null,null]},_onLoadedMetadata:function(){this.source.removeEventListener("loadedmetadata",this._loadedMetadataHandler);this._isReady=true;let offset=capTime(this._startOffset,this.duration);offset=capTime(this._startTime+offset,this._sound.duration);this._startOffset=null;this.source.currentTime=offset;},_createSource:function(){if(this._sound&&this._sound.audio){this._isReady=false;this.source=this._sound.audio.cloneNode(true);this.source.addEventListener("loadedmetadata",this._loadedMetadataHandler);this.source.addEventListener("timeupdate",this._timeUpdateHandler);this.source.onended=this._endedHandler;}return this.source},_onTimeUpdate:function(){if(!this._duration){return}if(this.source.currentTime>capTime(this._startTime+this._duration,this.source.duration)){if(this.loop){this.source.currentTime=capTime(this._startTime,this.source.duration);}else {this.source.removeEventListener("timeupdate",this._timeUpdateHandler);this.source.pause();this._onEnded();}}},_onManagerDestroy:function(){if(this.source){this.source.pause();}}});Object.defineProperty(SoundInstance.prototype,"volume",{get:function(){return this._volume},set:function(volume){volume=math.clamp(volume,0,1);this._volume=volume;if(this.source){this.source.volume=volume*this._manager.volume;}}});Object.defineProperty(SoundInstance.prototype,"pitch",{get:function(){return this._pitch},set:function(pitch){this._pitch=Math.max(Number(pitch)||0,.01);if(this.source){this.source.playbackRate=this._pitch;}}});Object.defineProperty(SoundInstance.prototype,"sound",{get:function(){return this._sound},set:function(value){this.stop();this._sound=value;}});Object.defineProperty(SoundInstance.prototype,"currentTime",{get:function(){if(this._startOffset!==null){return this._startOffset}if(this._state===STATE_STOPPED||!this.source){return 0}return this.source.currentTime-this._startTime},set:function(value){if(value<0)return;this._startOffset=value;if(this.source&&this._isReady){this.source.currentTime=capTime(this._startTime+capTime(value,this.duration),this._sound.duration);this._startOffset=null;}}});}const MAX_DISTANCE=1e4;class SoundInstance3d extends SoundInstance{_initializeNodes(){this.gain=this._manager.context.createGain();this.panner=this._manager.context.createPanner();this.panner.connect(this.gain);this._inputNode=this.panner;this._connectorNode=this.gain;this._connectorNode.connect(this._manager.context.destination);}set position(value){this._position.copy(value);const panner=this.panner;if("positionX"in panner){panner.positionX.value=value.x;panner.positionY.value=value.y;panner.positionZ.value=value.z;}else if(panner.setPosition){panner.setPosition(value.x,value.y,value.z);}}get position(){return this._position}set velocity(velocity){this._velocity.copy(velocity);}get velocity(){return this._velocity}set maxDistance(value){this.panner.maxDistance=value;}get maxDistance(){return this.panner.maxDistance}set refDistance(value){this.panner.refDistance=value;}get refDistance(){return this.panner.refDistance}set rollOffFactor(value){this.panner.rolloffFactor=value;}get rollOffFactor(){return this.panner.rolloffFactor}set distanceModel(value){this.panner.distanceModel=value;}get distanceModel(){return this.panner.distanceModel}constructor(manager,sound,options={}){super(manager,sound,options);this._position=new Vec3;this._velocity=new Vec3;if(options.position){this.position=options.position;}this.maxDistance=options.maxDistance!==undefined?Number(options.maxDistance):MAX_DISTANCE;this.refDistance=options.refDistance!==undefined?Number(options.refDistance):1;this.rollOffFactor=options.rollOffFactor!==undefined?Number(options.rollOffFactor):1;this.distanceModel=options.distanceModel!==undefined?options.distanceModel:DISTANCE_LINEAR;}}if(!hasAudioContext()){let offset=new Vec3;const fallOff=function fallOff(posOne,posTwo,refDistance,maxDistance,rollOffFactor,distanceModel){offset=offset.sub2(posOne,posTwo);const distance=offset.length();if(distance<refDistance){return 1}else if(distance>maxDistance){return 0}let result=0;if(distanceModel===DISTANCE_LINEAR){result=1-rollOffFactor*(distance-refDistance)/(maxDistance-refDistance);}else if(distanceModel===DISTANCE_INVERSE){result=refDistance/(refDistance+rollOffFactor*(distance-refDistance));}else if(distanceModel===DISTANCE_EXPONENTIAL){result=Math.pow(distance/refDistance,-rollOffFactor);}return math.clamp(result,0,1)};Object.defineProperty(SoundInstance3d.prototype,"position",{get:function(){return this._position},set:function(position){this._position.copy(position);if(this.source){const listener=this._manager.listener;const lpos=listener.getPosition();const factor=fallOff(lpos,this._position,this.refDistance,this.maxDistance,this.rollOffFactor,this.distanceModel);const v=this.volume;this.source.volume=v*factor*this._manager.volume;}}});Object.defineProperty(SoundInstance3d.prototype,"maxDistance",{get:function(){return this._maxDistance},set:function(value){this._maxDistance=value;}});Object.defineProperty(SoundInstance3d.prototype,"refDistance",{get:function(){return this._refDistance},set:function(value){this._refDistance=value;}});Object.defineProperty(SoundInstance3d.prototype,"rollOffFactor",{get:function(){return this._rollOffFactor},set:function(value){this._rollOffFactor=value;}});Object.defineProperty(SoundInstance3d.prototype,"distanceModel",{get:function(){return this._distanceModel},set:function(value){this._distanceModel=value;}});}const BLEND_SUBTRACTIVE=0;const BLEND_ADDITIVE=1;const BLEND_NORMAL=2;const BLEND_NONE=3;const BLEND_PREMULTIPLIED=4;const BLEND_MULTIPLICATIVE=5;const BLEND_ADDITIVEALPHA=6;const BLEND_MULTIPLICATIVE2X=7;const BLEND_SCREEN=8;const BLEND_MIN=9;const BLEND_MAX=10;const FOG_NONE="none";const FOG_LINEAR="linear";const FOG_EXP="exp";const FOG_EXP2="exp2";const FRESNEL_NONE=0;const FRESNEL_SCHLICK=2;const LAYER_HUD=0;const LAYER_GIZMO=1;const LAYER_FX=2;const LAYER_WORLD=15;const LAYERID_WORLD=0;const LAYERID_DEPTH=1;const LAYERID_SKYBOX=2;const LAYERID_IMMEDIATE=3;const LAYERID_UI=4;const LIGHTTYPE_DIRECTIONAL=0;const LIGHTTYPE_OMNI=1;const LIGHTTYPE_POINT=LIGHTTYPE_OMNI;const LIGHTTYPE_SPOT=2;const LIGHTTYPE_COUNT=3;const LIGHTSHAPE_PUNCTUAL=0;const LIGHTSHAPE_RECT=1;const LIGHTSHAPE_DISK=2;const LIGHTSHAPE_SPHERE=3;const LIGHTFALLOFF_LINEAR=0;const LIGHTFALLOFF_INVERSESQUARED=1;const SHADOW_PCF3=0;const SHADOW_DEPTH=0;const SHADOW_VSM8=1;const SHADOW_VSM16=2;const SHADOW_VSM32=3;const SHADOW_PCF5=4;const SHADOW_PCF1=5;const SHADOW_PCSS=6;const shadowTypeToString={};shadowTypeToString[SHADOW_PCF3]="PCF3";shadowTypeToString[SHADOW_VSM8]="VSM8";shadowTypeToString[SHADOW_VSM16]="VSM16";shadowTypeToString[SHADOW_VSM32]="VSM32";shadowTypeToString[SHADOW_PCF5]="PCF5";shadowTypeToString[SHADOW_PCF1]="PCF1";shadowTypeToString[SHADOW_PCSS]="PCSS";const BLUR_BOX=0;const BLUR_GAUSSIAN=1;const PARTICLESORT_NONE=0;const PARTICLESORT_DISTANCE=1;const PARTICLESORT_NEWER_FIRST=2;const PARTICLESORT_OLDER_FIRST=3;const PARTICLEMODE_GPU=0;const PARTICLEMODE_CPU=1;const EMITTERSHAPE_BOX=0;const EMITTERSHAPE_SPHERE=1;const PARTICLEORIENTATION_SCREEN=0;const PARTICLEORIENTATION_WORLD=1;const PARTICLEORIENTATION_EMITTER=2;const PROJECTION_PERSPECTIVE=0;const PROJECTION_ORTHOGRAPHIC=1;const RENDERSTYLE_SOLID=0;const RENDERSTYLE_WIREFRAME=1;const RENDERSTYLE_POINTS=2;const CUBEPROJ_NONE=0;const CUBEPROJ_BOX=1;const SPECULAR_PHONG=0;const SPECULAR_BLINN=1;const DETAILMODE_MUL="mul";const DETAILMODE_ADD="add";const DETAILMODE_SCREEN="screen";const DETAILMODE_OVERLAY="overlay";const DETAILMODE_MIN="min";const DETAILMODE_MAX="max";const GAMMA_NONE=0;const GAMMA_SRGB=1;const GAMMA_SRGBFAST=2;const GAMMA_SRGBHDR=3;const TONEMAP_LINEAR=0;const TONEMAP_FILMIC=1;const TONEMAP_HEJL=2;const TONEMAP_ACES=3;const TONEMAP_ACES2=4;const TONEMAP_NEUTRAL=5;const SPECOCC_NONE=0;const SPECOCC_AO=1;const SPECOCC_GLOSSDEPENDENT=2;const SHADERDEF_NOSHADOW=1;const SHADERDEF_SKIN=2;const SHADERDEF_UV0=4;const SHADERDEF_UV1=8;const SHADERDEF_VCOLOR=16;const SHADERDEF_INSTANCING=32;const SHADERDEF_LM=64;const SHADERDEF_DIRLM=128;const SHADERDEF_SCREENSPACE=256;const SHADERDEF_TANGENTS=512;const SHADERDEF_MORPH_POSITION=1024;const SHADERDEF_MORPH_NORMAL=2048;const SHADERDEF_MORPH_TEXTURE_BASED=4096;const SHADERDEF_LMAMBIENT=8192;const SHADOWUPDATE_NONE=0;const SHADOWUPDATE_THISFRAME=1;const SHADOWUPDATE_REALTIME=2;const SORTKEY_FORWARD=0;const SORTKEY_DEPTH=1;const MASK_AFFECT_DYNAMIC=1;const MASK_AFFECT_LIGHTMAPPED=2;const MASK_BAKE=4;const SHADER_FORWARD=0;const SHADER_FORWARDHDR=1;const SHADER_DEPTH=2;const SHADER_PICK=3;const SHADER_SHADOW=4;const SHADER_PREPASS_VELOCITY=5;const SHADERPASS_FORWARD="forward";const SHADERPASS_ALBEDO="debug_albedo";const SHADERPASS_WORLDNORMAL="debug_world_normal";const SHADERPASS_OPACITY="debug_opacity";const SHADERPASS_SPECULARITY="debug_specularity";const SHADERPASS_GLOSS="debug_gloss";const SHADERPASS_METALNESS="debug_metalness";const SHADERPASS_AO="debug_ao";const SHADERPASS_EMISSION="debug_emission";const SHADERPASS_LIGHTING="debug_lighting";const SHADERPASS_UV0="debug_uv0";const SPRITE_RENDERMODE_SIMPLE=0;const SPRITE_RENDERMODE_SLICED=1;const SPRITE_RENDERMODE_TILED=2;const BAKE_COLOR=0;const BAKE_COLORDIR=1;const VIEW_CENTER=0;const VIEW_LEFT=1;const VIEW_RIGHT=2;const SORTMODE_NONE=0;const SORTMODE_MANUAL=1;const SORTMODE_MATERIALMESH=2;const SORTMODE_BACK2FRONT=3;const SORTMODE_FRONT2BACK=4;const SORTMODE_CUSTOM=5;const ASPECT_AUTO=0;const ASPECT_MANUAL=1;const ORIENTATION_HORIZONTAL=0;const ORIENTATION_VERTICAL=1;const SKYTYPE_INFINITE="infinite";const SKYTYPE_BOX="box";const SKYTYPE_DOME="dome";const DITHER_NONE="none";const DITHER_BAYER8="bayer8";const DITHER_BLUENOISE="bluenoise";const DITHER_IGNNOISE="ignnoise";var alphaTestPS=`
uniform float alpha_ref;
void alphaTest(float a) {
	if (a < alpha_ref) discard;
}
`;var ambientConstantPS=`
void addAmbient(vec3 worldNormal) {
	dDiffuseLight += light_globalAmbient;
}
`;var ambientEnvPS=`
#ifndef ENV_ATLAS
#define ENV_ATLAS
uniform sampler2D texture_envAtlas;
#endif
void addAmbient(vec3 worldNormal) {
	vec3 dir = normalize(cubeMapRotate(worldNormal) * vec3(-1.0, 1.0, 1.0));
	vec2 uv = mapUv(toSphericalUv(dir), vec4(128.0, 256.0 + 128.0, 64.0, 32.0) / atlasSize);
	vec4 raw = texture2D(texture_envAtlas, uv);
	vec3 linear = $DECODE(raw);
	dDiffuseLight += processEnvironment(linear);
}
`;var ambientSHPS=`
uniform vec3 ambientSH[9];
void addAmbient(vec3 worldNormal) {
	vec3 n = cubeMapRotate(worldNormal);
	vec3 color =
		ambientSH[0] +
		ambientSH[1] * n.x +
		ambientSH[2] * n.y +
		ambientSH[3] * n.z +
		ambientSH[4] * n.x * n.z +
		ambientSH[5] * n.z * n.y +
		ambientSH[6] * n.y * n.x +
		ambientSH[7] * (3.0 * n.z * n.z - 1.0) +
		ambientSH[8] * (n.x * n.x - n.y * n.y);
	dDiffuseLight += processEnvironment(max(color, vec3(0.0)));
}
`;var aoPS=`
void getAO() {
	dAo = 1.0;
	#ifdef MAPTEXTURE
	float aoBase = texture2DBias($SAMPLER, $UV, textureBias).$CH;
	dAo *= addAoDetail(aoBase);
	#endif
	#ifdef MAPVERTEX
	dAo *= saturate(vVertexColor.$VC);
	#endif
}
`;var aoDetailMapPS=`
float addAoDetail(float ao) {
#ifdef MAPTEXTURE
	float aoDetail = texture2DBias($SAMPLER, $UV, textureBias).$CH;
	return detailMode_$DETAILMODE(vec3(ao), vec3(aoDetail)).r;
#else
	return ao;
#endif
}
`;var aoDiffuseOccPS=`
void occludeDiffuse(float ao) {
	dDiffuseLight *= ao;
}
`;var aoSpecOccPS=`
uniform float material_occludeSpecularIntensity;
void occludeSpecular(float gloss, float ao, vec3 worldNormal, vec3 viewDir) {
	float specPow = exp2(gloss * 11.0);
	float specOcc = saturate(pow(dot(worldNormal, viewDir) + ao, 0.01*specPow) - 1.0 + ao);
	specOcc = mix(1.0, specOcc, material_occludeSpecularIntensity);
	dSpecularLight *= specOcc;
	dReflection *= specOcc;
	
#ifdef LIT_SHEEN
	sSpecularLight *= specOcc;
	sReflection *= specOcc;
#endif
}
`;var aoSpecOccConstPS=`
void occludeSpecular(float gloss, float ao, vec3 worldNormal, vec3 viewDir) {
	float specPow = exp2(gloss * 11.0);
	float specOcc = saturate(pow(dot(worldNormal, viewDir) + ao, 0.01*specPow) - 1.0 + ao);
	dSpecularLight *= specOcc;
	dReflection *= specOcc;
	
#ifdef LIT_SHEEN
	sSpecularLight *= specOcc;
	sReflection *= specOcc;
#endif
}
`;var aoSpecOccConstSimplePS=`
void occludeSpecular(float gloss, float ao, vec3 worldNormal, vec3 viewDir) {
	dSpecularLight *= ao;
	dReflection *= ao;
#ifdef LIT_SHEEN
	sSpecularLight *= ao;
	sReflection *= ao;
#endif
}
`;var aoSpecOccSimplePS=`
uniform float material_occludeSpecularIntensity;
void occludeSpecular(float gloss, float ao, vec3 worldNormal, vec3 viewDir) {
	float specOcc = mix(1.0, ao, material_occludeSpecularIntensity);
	dSpecularLight *= specOcc;
	dReflection *= specOcc;
#ifdef LIT_SHEEN
	sSpecularLight *= specOcc;
	sReflection *= specOcc;
#endif
}
`;var basePS=`
uniform vec3 view_position;
uniform vec3 light_globalAmbient;
float square(float x) {
	return x*x;
}
float saturate(float x) {
	return clamp(x, 0.0, 1.0);
}
vec3 saturate(vec3 x) {
	return clamp(x, vec3(0.0), vec3(1.0));
}
`;var baseVS=`
attribute vec3 vertex_position;
attribute vec3 vertex_normal;
attribute vec4 vertex_tangent;
attribute vec2 vertex_texCoord0;
attribute vec2 vertex_texCoord1;
attribute vec4 vertex_color;
uniform mat4 matrix_viewProjection;
uniform mat4 matrix_model;
uniform mat3 matrix_normal;
vec3 dPositionW;
mat4 dModelMatrix;
mat3 dNormalMatrix;
`;var baseNineSlicedPS=`
#define NINESLICED
varying vec2 vMask;
varying vec2 vTiledUv;
uniform mediump vec4 innerOffset;
uniform mediump vec2 outerScale;
uniform mediump vec4 atlasRect;
vec2 nineSlicedUv;
`;var baseNineSlicedVS=`
#define NINESLICED
varying vec2 vMask;
varying vec2 vTiledUv;
uniform mediump vec4 innerOffset;
uniform mediump vec2 outerScale;
uniform mediump vec4 atlasRect;
`;var baseNineSlicedTiledPS=`
#define NINESLICED
#define NINESLICETILED
varying vec2 vMask;
varying vec2 vTiledUv;
uniform mediump vec4 innerOffset;
uniform mediump vec2 outerScale;
uniform mediump vec4 atlasRect;
vec2 nineSlicedUv;
`;var bayerPS=`
float bayer2(vec2 p) {
	return mod(2.0 * p.y + p.x + 1.0, 4.0);
}
float bayer4(vec2 p) {
	vec2 p1 = mod(p, 2.0);
	vec2 p2 = floor(0.5 * mod(p, 4.0));
	return 4.0 * bayer2(p1) + bayer2(p2);
}
float bayer8(vec2 p) {
	vec2 p1 = mod(p, 2.0);
	vec2 p2 = floor(0.5 * mod(p, 4.0));
	vec2 p4 = floor(0.25 * mod(p, 8.0));
	return 4.0 * (4.0 * bayer2(p1) + bayer2(p2)) + bayer2(p4);
}
`;var biasConstPS=`
#define SHADOWBIAS
#define SHADOW_SAMPLE_Z_BIAS
float getShadowBias(float resolution, float maxBias) {
	return maxBias;
}
`;var blurVSMPS=`
varying vec2 vUv0;
uniform sampler2D source;
uniform vec2 pixelOffset;
#ifdef GAUSS
uniform float weight[SAMPLES];
#endif
#ifdef PACKED
float decodeFloatRG(vec2 rg) {
	return rg.y*(1.0/255.0) + rg.x;
}
vec2 encodeFloatRG( float v ) {
	vec2 enc = vec2(1.0, 255.0) * v;
	enc = fract(enc);
	enc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);
	return enc;
}
#endif
void main(void) {
	vec3 moments = vec3(0.0);
	vec2 uv = vUv0 - pixelOffset * (float(SAMPLES) * 0.5);
	for (int i=0; i<SAMPLES; i++) {
		vec4 c = texture2D(source, uv + pixelOffset * float(i));
		#ifdef PACKED
		c.xy = vec2(decodeFloatRG(c.xy), decodeFloatRG(c.zw));
		#endif
		#ifdef GAUSS
		moments += c.xyz * weight[i];
		#else
		moments += c.xyz;
		#endif
	}
	#ifndef GAUSS
	moments /= float(SAMPLES);
	#endif
	#ifdef PACKED
	gl_FragColor = vec4(encodeFloatRG(moments.x), encodeFloatRG(moments.y));
	#else
	gl_FragColor = vec4(moments.x, moments.y, moments.z, 1.0);
	#endif
}
`;var clearCoatPS=`
#ifdef MAPFLOAT
uniform float material_clearCoat;
#endif
void getClearCoat() {
	ccSpecularity = 1.0;
	#ifdef MAPFLOAT
	ccSpecularity *= material_clearCoat;
	#endif
	#ifdef MAPTEXTURE
	ccSpecularity *= texture2DBias($SAMPLER, $UV, textureBias).$CH;
	#endif
	#ifdef MAPVERTEX
	ccSpecularity *= saturate(vVertexColor.$VC);
	#endif
}
`;var clearCoatGlossPS=`
#ifdef MAPFLOAT
uniform float material_clearCoatGloss;
#endif
void getClearCoatGlossiness() {
	ccGlossiness = 1.0;
	#ifdef MAPFLOAT
	ccGlossiness *= material_clearCoatGloss;
	#endif
	#ifdef MAPTEXTURE
	ccGlossiness *= texture2DBias($SAMPLER, $UV, textureBias).$CH;
	#endif
	#ifdef MAPVERTEX
	ccGlossiness *= saturate(vVertexColor.$VC);
	#endif
	#ifdef MAPINVERT
	ccGlossiness = 1.0 - ccGlossiness;
	#endif
	ccGlossiness += 0.0000001;
}
`;var clearCoatNormalPS=`
#ifdef MAPTEXTURE
uniform float material_clearCoatBumpiness;
#endif
void getClearCoatNormal() {
#ifdef MAPTEXTURE
	vec3 normalMap = unpackNormal(texture2DBias($SAMPLER, $UV, textureBias));
	normalMap = mix(vec3(0.0, 0.0, 1.0), normalMap, material_clearCoatBumpiness);
	ccNormalW = normalize(dTBN * normalMap);
#else
	ccNormalW = dVertexNormalW;
#endif
}
`;var clusteredLightUtilsPS=`
vec2 getCubemapFaceCoordinates(const vec3 dir, out float faceIndex, out vec2 tileOffset)
{
	vec3 vAbs = abs(dir);
	float ma;
	vec2 uv;
	if (vAbs.z >= vAbs.x && vAbs.z >= vAbs.y) {
		faceIndex = dir.z < 0.0 ? 5.0 : 4.0;
		ma = 0.5 / vAbs.z;
		uv = vec2(dir.z < 0.0 ? -dir.x : dir.x, -dir.y);
		tileOffset.x = 2.0;
		tileOffset.y = dir.z < 0.0 ? 1.0 : 0.0;
	} else if(vAbs.y >= vAbs.x) {
		faceIndex = dir.y < 0.0 ? 3.0 : 2.0;
		ma = 0.5 / vAbs.y;
		uv = vec2(dir.x, dir.y < 0.0 ? -dir.z : dir.z);
		tileOffset.x = 1.0;
		tileOffset.y = dir.y < 0.0 ? 1.0 : 0.0;
	} else {
		faceIndex = dir.x < 0.0 ? 1.0 : 0.0;
		ma = 0.5 / vAbs.x;
		uv = vec2(dir.x < 0.0 ? dir.z : -dir.z, -dir.y);
		tileOffset.x = 0.0;
		tileOffset.y = dir.x < 0.0 ? 1.0 : 0.0;
	}
	return uv * ma + 0.5;
}
vec2 getCubemapAtlasCoordinates(const vec3 omniAtlasViewport, float shadowEdgePixels, float shadowTextureResolution, const vec3 dir) {
	float faceIndex;
	vec2 tileOffset;
	vec2 uv = getCubemapFaceCoordinates(dir, faceIndex, tileOffset);
	float atlasFaceSize = omniAtlasViewport.z;
	float tileSize = shadowTextureResolution * atlasFaceSize;
	float offset = shadowEdgePixels / tileSize;
	uv = uv * vec2(1.0 - offset * 2.0) + vec2(offset * 1.0);
	uv *= atlasFaceSize;
	uv += tileOffset * atlasFaceSize;
	uv += omniAtlasViewport.xy;
	return uv;
}
`;var clusteredLightCookiesPS=`
vec3 _getCookieClustered(TEXTURE_ACCEPT(tex), vec2 uv, float intensity, bool isRgb, vec4 cookieChannel) {
	vec4 pixel = mix(vec4(1.0), texture2DLodEXT(tex, uv, 0.0), intensity);
	return isRgb == true ? pixel.rgb : vec3(dot(pixel, cookieChannel));
}
vec3 getCookie2DClustered(TEXTURE_ACCEPT(tex), mat4 transform, vec3 worldPosition, float intensity, bool isRgb, vec4 cookieChannel) {
	vec4 projPos = transform * vec4(worldPosition, 1.0);
	return _getCookieClustered(TEXTURE_PASS(tex), projPos.xy / projPos.w, intensity, isRgb, cookieChannel);
}
vec3 getCookieCubeClustered(TEXTURE_ACCEPT(tex), vec3 dir, float intensity, bool isRgb, vec4 cookieChannel, float shadowTextureResolution, float shadowEdgePixels, vec3 omniAtlasViewport) {
	vec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, dir);
	return _getCookieClustered(TEXTURE_PASS(tex), uv, intensity, isRgb, cookieChannel);
}
`;var clusteredLightShadowsPS=`
void _getShadowCoordPerspZbuffer(mat4 shadowMatrix, vec4 shadowParams, vec3 wPos) {
	vec4 projPos = shadowMatrix * vec4(wPos, 1.0);
	projPos.xyz /= projPos.w;
	dShadowCoord = projPos.xyz;
}
void getShadowCoordPerspZbufferNormalOffset(mat4 shadowMatrix, vec4 shadowParams, vec3 normal) {
	vec3 wPos = vPositionW + normal * shadowParams.y;
	_getShadowCoordPerspZbuffer(shadowMatrix, shadowParams, wPos);
}
vec3 normalOffsetPointShadow(vec4 shadowParams, vec3 lightPos, inout vec3 lightDir, vec3 lightDirNorm, vec3 normal) {
	float distScale = length(lightDir);
	vec3 wPos = vPositionW + normal * shadowParams.y * clamp(1.0 - dot(normal, -lightDirNorm), 0.0, 1.0) * distScale;
	vec3 dir = wPos - lightPos;
	return dir;
}
#ifdef GL2
	#if defined(CLUSTER_SHADOW_TYPE_PCF1)
	float getShadowOmniClusteredPCF1(SHADOWMAP_ACCEPT(shadowMap), vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 lightDir) {
		float shadowTextureResolution = shadowParams.x;
		vec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, lightDir);
		float shadowZ = length(lightDir) * shadowParams.w + shadowParams.z;
		return textureShadow(shadowMap, vec3(uv, shadowZ));
	}
	#endif
	#if defined(CLUSTER_SHADOW_TYPE_PCF3)
	float getShadowOmniClusteredPCF3(SHADOWMAP_ACCEPT(shadowMap), vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 lightDir) {
		float shadowTextureResolution = shadowParams.x;
		vec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, lightDir);
		float shadowZ = length(lightDir) * shadowParams.w + shadowParams.z;
		vec3 shadowCoord = vec3(uv, shadowZ);
		return getShadowPCF3x3(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams);
	}
	#endif
	#if defined(CLUSTER_SHADOW_TYPE_PCF5)
	float getShadowOmniClusteredPCF5(SHADOWMAP_ACCEPT(shadowMap), vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 lightDir) {
		float shadowTextureResolution = shadowParams.x;
		vec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, lightDir);
		float shadowZ = length(lightDir) * shadowParams.w + shadowParams.z;
		vec3 shadowCoord = vec3(uv, shadowZ);
		return getShadowPCF5x5(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams);
	}
	#endif
#else
	#if defined(CLUSTER_SHADOW_TYPE_PCF1)
	float getShadowOmniClusteredPCF1(sampler2D shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 lightDir) {
		float shadowTextureResolution = shadowParams.x;
		vec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, lightDir);
		float depth = unpackFloat(textureShadow(shadowMap, uv));
		float shadowZ = length(lightDir) * shadowParams.w + shadowParams.z;
		return depth > shadowZ ? 1.0 : 0.0;
	}
	#endif
	#if defined(CLUSTER_SHADOW_TYPE_PCF3)
	float getShadowOmniClusteredPCF3(sampler2D shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 lightDir) {
		float shadowTextureResolution = shadowParams.x;
		vec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, lightDir);
		float shadowZ = length(lightDir) * shadowParams.w + shadowParams.z;
		vec3 shadowCoord = vec3(uv, shadowZ);
		return getShadowPCF3x3(shadowMap, shadowCoord, shadowParams);
	}
	#endif
	#if defined(CLUSTER_SHADOW_TYPE_PCF5)
	float getShadowOmniClusteredPCF5(sampler2D shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 lightDir) {
		float shadowTextureResolution = shadowParams.x;
		vec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, lightDir);
		float shadowZ = length(lightDir) * shadowParams.w + shadowParams.z;
		vec3 shadowCoord = vec3(uv, shadowZ);
		return getShadowPCF3x3(shadowMap, shadowCoord, shadowParams);
	}
	#endif
#endif
#ifdef GL2
	#if defined(CLUSTER_SHADOW_TYPE_PCF1)
	float getShadowSpotClusteredPCF1(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {
		return textureShadow(shadowMap, shadowCoord);
	}
	#endif
	#if defined(CLUSTER_SHADOW_TYPE_PCF3)
	float getShadowSpotClusteredPCF3(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {
		return getShadowSpotPCF3x3(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams);
	}
	#endif
	#if defined(CLUSTER_SHADOW_TYPE_PCF5)
	float getShadowSpotClusteredPCF5(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {
		return getShadowPCF5x5(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams);
	}
	#endif
#else
	#if defined(CLUSTER_SHADOW_TYPE_PCF1)
	float getShadowSpotClusteredPCF1(sampler2D shadowMap, vec3 shadowCoord, vec4 shadowParams) {
		float depth = unpackFloat(textureShadow(shadowMap, shadowCoord.xy));
		return depth > shadowCoord.z ? 1.0 : 0.0;
	}
	#endif
	#if defined(CLUSTER_SHADOW_TYPE_PCF3)
	float getShadowSpotClusteredPCF3(sampler2D shadowMap, vec3 shadowCoord, vec4 shadowParams) {
		return getShadowSpotPCF3x3(shadowMap, shadowCoord, shadowParams);
	}
	#endif
	#if defined(CLUSTER_SHADOW_TYPE_PCF5)
	float getShadowSpotClusteredPCF5(sampler2D shadowMap, vec3 shadowCoord, vec4 shadowParams) {
		return getShadowSpotPCF3x3(shadowMap, shadowCoord, shadowParams);
	}
	#endif
#endif
`;var clusteredLightPS=`
uniform highp sampler2D clusterWorldTexture;
uniform highp sampler2D lightsTexture8;
uniform highp sampler2D lightsTextureFloat;
#if defined(CLUSTER_COOKIES)
	#define CLUSTER_COOKIES_OR_SHADOWS
#endif
#if defined(CLUSTER_SHADOWS)
	#define CLUSTER_COOKIES_OR_SHADOWS
#endif
#ifdef CLUSTER_SHADOWS
	#ifdef GL2
		uniform sampler2DShadow shadowAtlasTexture;
	#else
		uniform sampler2D shadowAtlasTexture;
	#endif
#endif
#ifdef CLUSTER_COOKIES
	uniform sampler2D cookieAtlasTexture;
#endif
#ifdef GL2
	uniform int clusterMaxCells;
#else
	uniform float clusterMaxCells;
	uniform vec4 lightsTextureInvSize;
#endif
uniform float clusterSkip;
uniform vec3 clusterCellsCountByBoundsSize;
uniform vec3 clusterTextureSize;
uniform vec3 clusterBoundsMin;
uniform vec3 clusterBoundsDelta;
uniform vec3 clusterCellsDot;
uniform vec3 clusterCellsMax;
uniform vec2 clusterCompressionLimit0;
uniform vec2 shadowAtlasParams;
struct ClusterLightData {
	vec3 halfWidth;
	float lightType;
	vec3 halfHeight;
	#ifdef GL2
		int lightIndex;
	#else
		float lightV;
	#endif
	vec3 position;
	float shape;
	vec3 direction;
	float falloffMode;
	vec3 color;
	float shadowIntensity;
	vec3 omniAtlasViewport;
	float range;
	vec4 cookieChannelMask;
	float shadowBias;
	float shadowNormalBias;
	float innerConeAngleCos;
	float outerConeAngleCos;
	float cookie;
	float cookieRgb;
	float cookieIntensity;
	float mask;
};
mat4 lightProjectionMatrix;
#define isClusteredLightCastShadow(light) ( light.shadowIntensity > 0.0 )
#define isClusteredLightCookie(light) (light.cookie > 0.5 )
#define isClusteredLightCookieRgb(light) (light.cookieRgb > 0.5 )
#define isClusteredLightSpot(light) ( light.lightType > 0.5 )
#define isClusteredLightFalloffLinear(light) ( light.falloffMode < 0.5 )
#define isClusteredLightArea(light) ( light.shape > 0.1 )
#define isClusteredLightRect(light) ( light.shape < 0.3 )
#define isClusteredLightDisk(light) ( light.shape < 0.6 )
#ifdef CLUSTER_MESH_DYNAMIC_LIGHTS
	#define acceptLightMask(light) ( light.mask < 0.75)
#else
	#define acceptLightMask(light) ( light.mask > 0.25)
#endif
vec4 decodeClusterLowRange4Vec4(vec4 d0, vec4 d1, vec4 d2, vec4 d3) {
	return vec4(
		bytes2floatRange4(d0, -2.0, 2.0),
		bytes2floatRange4(d1, -2.0, 2.0),
		bytes2floatRange4(d2, -2.0, 2.0),
		bytes2floatRange4(d3, -2.0, 2.0)
	);
}
#ifdef GL2
	vec4 sampleLightsTexture8(const ClusterLightData clusterLightData, int index) {
		return texelFetch(lightsTexture8, ivec2(index, clusterLightData.lightIndex), 0);
	}
	vec4 sampleLightTextureF(const ClusterLightData clusterLightData, int index) {
		return texelFetch(lightsTextureFloat, ivec2(index, clusterLightData.lightIndex), 0);
	}
#else
	vec4 sampleLightsTexture8(const ClusterLightData clusterLightData, float index) {
		return texture2DLodEXT(lightsTexture8, vec2(index * lightsTextureInvSize.z, clusterLightData.lightV), 0.0);
	}
	vec4 sampleLightTextureF(const ClusterLightData clusterLightData, float index) {
		return texture2DLodEXT(lightsTextureFloat, vec2(index * lightsTextureInvSize.x, clusterLightData.lightV), 0.0);
	}
#endif
void decodeClusterLightCore(inout ClusterLightData clusterLightData, float lightIndex) {
	#ifdef GL2
		clusterLightData.lightIndex = int(lightIndex);
	#else
		clusterLightData.lightV = (lightIndex + 0.5) * lightsTextureInvSize.w;
	#endif
	vec4 lightInfo = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_FLAGS);
	clusterLightData.lightType = lightInfo.x;
	clusterLightData.shape = lightInfo.y;
	clusterLightData.falloffMode = lightInfo.z;
	clusterLightData.shadowIntensity = lightInfo.w;
	vec4 colorA = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_COLOR_A);
	vec4 colorB = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_COLOR_B);
	clusterLightData.color = vec3(bytes2float2(colorA.xy), bytes2float2(colorA.zw), bytes2float2(colorB.xy)) * clusterCompressionLimit0.y;
	clusterLightData.cookie = colorB.z;
	clusterLightData.mask = colorB.w;
	#ifdef CLUSTER_TEXTURE_FLOAT
		vec4 lightPosRange = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_POSITION_RANGE);
		clusterLightData.position = lightPosRange.xyz;
		clusterLightData.range = lightPosRange.w;
		vec4 lightDir_Unused = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_SPOT_DIRECTION);
		clusterLightData.direction = lightDir_Unused.xyz;
	#else
		vec4 encPosX = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_POSITION_X);
		vec4 encPosY = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_POSITION_Y);
		vec4 encPosZ = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_POSITION_Z);
		clusterLightData.position = vec3(bytes2float4(encPosX), bytes2float4(encPosY), bytes2float4(encPosZ)) * clusterBoundsDelta + clusterBoundsMin;
		vec4 encRange = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_RANGE);
		clusterLightData.range = bytes2float4(encRange) * clusterCompressionLimit0.x;
		vec4 encDirX = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SPOT_DIRECTION_X);
		vec4 encDirY = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SPOT_DIRECTION_Y);
		vec4 encDirZ = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SPOT_DIRECTION_Z);
		clusterLightData.direction = vec3(bytes2float4(encDirX), bytes2float4(encDirY), bytes2float4(encDirZ)) * 2.0 - 1.0;
	#endif
}
void decodeClusterLightSpot(inout ClusterLightData clusterLightData) {
	vec4 coneAngle = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SPOT_ANGLES);
	clusterLightData.innerConeAngleCos = bytes2float2(coneAngle.xy) * 2.0 - 1.0;
	clusterLightData.outerConeAngleCos = bytes2float2(coneAngle.zw) * 2.0 - 1.0;
}
void decodeClusterLightOmniAtlasViewport(inout ClusterLightData clusterLightData) {
	#ifdef CLUSTER_TEXTURE_FLOAT
		clusterLightData.omniAtlasViewport = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_0).xyz;
	#else
		vec4 viewportA = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_ATLAS_VIEWPORT_A);
		vec4 viewportB = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_ATLAS_VIEWPORT_B);
		clusterLightData.omniAtlasViewport = vec3(bytes2float2(viewportA.xy), bytes2float2(viewportA.zw), bytes2float2(viewportB.xy));
	#endif
}
void decodeClusterLightAreaData(inout ClusterLightData clusterLightData) {
	#ifdef CLUSTER_TEXTURE_FLOAT
		clusterLightData.halfWidth = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_AREA_DATA_WIDTH).xyz;
		clusterLightData.halfHeight = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_AREA_DATA_HEIGHT).xyz;
	#else
		vec4 areaWidthX = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_WIDTH_X);
		vec4 areaWidthY = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_WIDTH_Y);
		vec4 areaWidthZ = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_WIDTH_Z);
		clusterLightData.halfWidth = vec3(mantissaExponent2Float(areaWidthX), mantissaExponent2Float(areaWidthY), mantissaExponent2Float(areaWidthZ));
		vec4 areaHeightX = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_HEIGHT_X);
		vec4 areaHeightY = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_HEIGHT_Y);
		vec4 areaHeightZ = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_HEIGHT_Z);
		clusterLightData.halfHeight = vec3(mantissaExponent2Float(areaHeightX), mantissaExponent2Float(areaHeightY), mantissaExponent2Float(areaHeightZ));
	#endif
}
void decodeClusterLightProjectionMatrixData(inout ClusterLightData clusterLightData) {
	
	#ifdef CLUSTER_TEXTURE_FLOAT
		vec4 m0 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_0);
		vec4 m1 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_1);
		vec4 m2 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_2);
		vec4 m3 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_3);
	#else
		vec4 m00 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_00);
		vec4 m01 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_01);
		vec4 m02 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_02);
		vec4 m03 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_03);
		vec4 m0 = decodeClusterLowRange4Vec4(m00, m01, m02, m03);
		vec4 m10 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_10);
		vec4 m11 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_11);
		vec4 m12 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_12);
		vec4 m13 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_13);
		vec4 m1 = decodeClusterLowRange4Vec4(m10, m11, m12, m13);
		vec4 m20 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_20);
		vec4 m21 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_21);
		vec4 m22 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_22);
		vec4 m23 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_23);
		vec4 m2 = decodeClusterLowRange4Vec4(m20, m21, m22, m23);
		vec4 m30 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_30);
		vec4 m31 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_31);
		vec4 m32 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_32);
		vec4 m33 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_33);
		vec4 m3 = vec4(mantissaExponent2Float(m30), mantissaExponent2Float(m31), mantissaExponent2Float(m32), mantissaExponent2Float(m33));
	#endif
	
	lightProjectionMatrix = mat4(m0, m1, m2, m3);
}
void decodeClusterLightShadowData(inout ClusterLightData clusterLightData) {
	
	vec4 biases = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SHADOW_BIAS);
	clusterLightData.shadowBias = bytes2floatRange2(biases.xy, -1.0, 20.0),
	clusterLightData.shadowNormalBias = bytes2float2(biases.zw);
}
void decodeClusterLightCookieData(inout ClusterLightData clusterLightData) {
	vec4 cookieA = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_COOKIE_A);
	clusterLightData.cookieIntensity = cookieA.x;
	clusterLightData.cookieRgb = cookieA.y;
	clusterLightData.cookieChannelMask = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_COOKIE_B);
}
void evaluateLight(
	ClusterLightData light, 
	vec3 worldNormal, 
	vec3 viewDir, 
	vec3 reflectionDir,
#if defined(LIT_CLEARCOAT)
	vec3 clearcoatReflectionDir,
#endif
	float gloss, 
	vec3 specularity, 
	vec3 geometricNormal, 
	mat3 tbn, 
#if defined(LIT_IRIDESCENCE)
	vec3 iridescenceFresnel,
#endif
	vec3 clearcoat_worldNormal,
	float clearcoat_gloss,
	float sheen_gloss,
	float iridescence_intensity
) {
	vec3 cookieAttenuation = vec3(1.0);
	float diffuseAttenuation = 1.0;
	float falloffAttenuation = 1.0;
	getLightDirPoint(light.position);
	#ifdef CLUSTER_AREALIGHTS
	if (isClusteredLightArea(light)) {
		decodeClusterLightAreaData(light);
		if (isClusteredLightRect(light)) {
			calcRectLightValues(light.position, light.halfWidth, light.halfHeight);
		} else if (isClusteredLightDisk(light)) {
			calcDiskLightValues(light.position, light.halfWidth, light.halfHeight);
		} else {
			calcSphereLightValues(light.position, light.halfWidth, light.halfHeight);
		}
		falloffAttenuation = getFalloffWindow(light.range, dLightDirW);
	} else
	#endif
	{
		if (isClusteredLightFalloffLinear(light))
			falloffAttenuation = getFalloffLinear(light.range, dLightDirW);
		else
			falloffAttenuation = getFalloffInvSquared(light.range, dLightDirW);
	}
	if (falloffAttenuation > 0.00001) {
		#ifdef CLUSTER_AREALIGHTS
		if (isClusteredLightArea(light)) {
			if (isClusteredLightRect(light)) {
				diffuseAttenuation = getRectLightDiffuse(worldNormal, viewDir, dLightDirW, dLightDirNormW) * 16.0;
			} else if (isClusteredLightDisk(light)) {
				diffuseAttenuation = getDiskLightDiffuse(worldNormal, viewDir, dLightDirW, dLightDirNormW) * 16.0;
			} else {
				diffuseAttenuation = getSphereLightDiffuse(worldNormal, viewDir, dLightDirW, dLightDirNormW) * 16.0;
			}
		} else
		#endif
		{
			falloffAttenuation *= getLightDiffuse(worldNormal, viewDir, dLightDirW, dLightDirNormW); 
		}
		if (isClusteredLightSpot(light)) {
			decodeClusterLightSpot(light);
			falloffAttenuation *= getSpotEffect(light.direction, light.innerConeAngleCos, light.outerConeAngleCos, dLightDirNormW);
		}
		#if defined(CLUSTER_COOKIES_OR_SHADOWS)
		if (falloffAttenuation > 0.00001) {
			if (isClusteredLightCastShadow(light) || isClusteredLightCookie(light)) {
				if (isClusteredLightSpot(light)) {
					decodeClusterLightProjectionMatrixData(light);
				} else {
					decodeClusterLightOmniAtlasViewport(light);
				}
				float shadowTextureResolution = shadowAtlasParams.x;
				float shadowEdgePixels = shadowAtlasParams.y;
				#ifdef CLUSTER_COOKIES
				if (isClusteredLightCookie(light)) {
					decodeClusterLightCookieData(light);
					if (isClusteredLightSpot(light)) {
						cookieAttenuation = getCookie2DClustered(TEXTURE_PASS(cookieAtlasTexture), lightProjectionMatrix, vPositionW, light.cookieIntensity, isClusteredLightCookieRgb(light), light.cookieChannelMask);
					} else {
						cookieAttenuation = getCookieCubeClustered(TEXTURE_PASS(cookieAtlasTexture), dLightDirW, light.cookieIntensity, isClusteredLightCookieRgb(light), light.cookieChannelMask, shadowTextureResolution, shadowEdgePixels, light.omniAtlasViewport);
					}
				}
				#endif
				#ifdef CLUSTER_SHADOWS
				if (isClusteredLightCastShadow(light)) {
					decodeClusterLightShadowData(light);
					vec4 shadowParams = vec4(shadowTextureResolution, light.shadowNormalBias, light.shadowBias, 1.0 / light.range);
					if (isClusteredLightSpot(light)) {
						getShadowCoordPerspZbufferNormalOffset(lightProjectionMatrix, shadowParams, geometricNormal);
						
						#if defined(CLUSTER_SHADOW_TYPE_PCF1)
							float shadow = getShadowSpotClusteredPCF1(SHADOWMAP_PASS(shadowAtlasTexture), dShadowCoord, shadowParams);
						#elif defined(CLUSTER_SHADOW_TYPE_PCF3)
							float shadow = getShadowSpotClusteredPCF3(SHADOWMAP_PASS(shadowAtlasTexture), dShadowCoord, shadowParams);
						#elif defined(CLUSTER_SHADOW_TYPE_PCF5)
							float shadow = getShadowSpotClusteredPCF5(SHADOWMAP_PASS(shadowAtlasTexture), dShadowCoord, shadowParams);
						#elif defined(CLUSTER_SHADOW_TYPE_PCSS)
							float shadow = getShadowSpotClusteredPCSS(SHADOWMAP_PASS(shadowAtlasTexture), dShadowCoord, shadowParams);
						#endif
						falloffAttenuation *= mix(1.0, shadow, light.shadowIntensity);
					} else {
						vec3 dir = normalOffsetPointShadow(shadowParams, dLightPosW, dLightDirW, dLightDirNormW, geometricNormal);
						#if defined(CLUSTER_SHADOW_TYPE_PCF1)
							float shadow = getShadowOmniClusteredPCF1(SHADOWMAP_PASS(shadowAtlasTexture), shadowParams, light.omniAtlasViewport, shadowEdgePixels, dir);
						#elif defined(CLUSTER_SHADOW_TYPE_PCF3)
							float shadow = getShadowOmniClusteredPCF3(SHADOWMAP_PASS(shadowAtlasTexture), shadowParams, light.omniAtlasViewport, shadowEdgePixels, dir);
						#elif defined(CLUSTER_SHADOW_TYPE_PCF5)
							float shadow = getShadowOmniClusteredPCF5(SHADOWMAP_PASS(shadowAtlasTexture), shadowParams, light.omniAtlasViewport, shadowEdgePixels, dir);
						#endif
						falloffAttenuation *= mix(1.0, shadow, light.shadowIntensity);
					}
				}
				#endif
			}
		}
		#endif
		#ifdef CLUSTER_AREALIGHTS
		if (isClusteredLightArea(light)) {
			{
				vec3 areaDiffuse = (diffuseAttenuation * falloffAttenuation) * light.color * cookieAttenuation;
				#if defined(LIT_SPECULAR)
					#if defined(LIT_CONSERVE_ENERGY)
						areaDiffuse = mix(areaDiffuse, vec3(0), dLTCSpecFres);
					#endif
				#endif
				dDiffuseLight += areaDiffuse;
			}
			#ifdef LIT_SPECULAR
				float areaLightSpecular;
				if (isClusteredLightRect(light)) {
					areaLightSpecular = getRectLightSpecular(worldNormal, viewDir);
				} else if (isClusteredLightDisk(light)) {
					areaLightSpecular = getDiskLightSpecular(worldNormal, viewDir);
				} else {
					areaLightSpecular = getSphereLightSpecular(worldNormal, viewDir);
				}
				dSpecularLight += dLTCSpecFres * areaLightSpecular * falloffAttenuation * light.color * cookieAttenuation;
				#ifdef LIT_CLEARCOAT
					float areaLightSpecularCC;
					if (isClusteredLightRect(light)) {
						areaLightSpecularCC = getRectLightSpecular(clearcoat_worldNormal, viewDir);
					} else if (isClusteredLightDisk(light)) {
						areaLightSpecularCC = getDiskLightSpecular(clearcoat_worldNormal, viewDir);
					} else {
						areaLightSpecularCC = getSphereLightSpecular(clearcoat_worldNormal, viewDir);
					}
					ccSpecularLight += ccLTCSpecFres * areaLightSpecularCC * falloffAttenuation * light.color  * cookieAttenuation;
				#endif
			#endif
		} else
		#endif
		{
			{
				vec3 punctualDiffuse = falloffAttenuation * light.color * cookieAttenuation;
				#if defined(CLUSTER_AREALIGHTS)
				#if defined(LIT_SPECULAR)
				#if defined(LIT_CONSERVE_ENERGY)
					punctualDiffuse = mix(punctualDiffuse, vec3(0), specularity);
				#endif
				#endif
				#endif
				dDiffuseLight += punctualDiffuse;
			}
	 
			#ifdef LIT_SPECULAR
				vec3 halfDir = normalize(-dLightDirNormW + viewDir);
				
				#ifdef LIT_SPECULAR_FRESNEL
					dSpecularLight += 
						getLightSpecular(halfDir, reflectionDir, worldNormal, viewDir, dLightDirNormW, gloss, tbn) * falloffAttenuation * light.color * cookieAttenuation * 
						getFresnel(
							dot(viewDir, halfDir), 
							gloss, 
							specularity
						#if defined(LIT_IRIDESCENCE)
							, iridescenceFresnel,
							iridescence_intensity
						#endif
							);
				#else
					dSpecularLight += getLightSpecular(halfDir, reflectionDir, worldNormal, viewDir, dLightDirNormW, gloss, tbn) * falloffAttenuation * light.color * cookieAttenuation * specularity;
				#endif
				#ifdef LIT_CLEARCOAT
					#ifdef LIT_SPECULAR_FRESNEL
						ccSpecularLight += getLightSpecular(halfDir, clearcoatReflectionDir, clearcoat_worldNormal, viewDir, dLightDirNormW, clearcoat_gloss, tbn) * falloffAttenuation * light.color * cookieAttenuation * getFresnelCC(dot(viewDir, halfDir));
					#else
						ccSpecularLight += getLightSpecular(halfDir, clearcoatReflectionDir, clearcoat_worldNormal, viewDir, dLightDirNormW, clearcoat_gloss, tbn) * falloffAttenuation * light.color * cookieAttenuation; 
					#endif
				#endif
				#ifdef LIT_SHEEN
					sSpecularLight += getLightSpecularSheen(halfDir, worldNormal, viewDir, dLightDirNormW, sheen_gloss) * falloffAttenuation * light.color * cookieAttenuation;
				#endif
			#endif
		}
	}
	dAtten = falloffAttenuation;
	dAttenD = diffuseAttenuation;
	dAtten3 = cookieAttenuation;
}
void evaluateClusterLight(
	float lightIndex, 
	vec3 worldNormal, 
	vec3 viewDir, 
	vec3 reflectionDir, 
#if defined(LIT_CLEARCOAT)
	vec3 clearcoatReflectionDir,
#endif
	float gloss, 
	vec3 specularity, 
	vec3 geometricNormal, 
	mat3 tbn, 
#if defined(LIT_IRIDESCENCE)
	vec3 iridescenceFresnel,
#endif
	vec3 clearcoat_worldNormal,
	float clearcoat_gloss,
	float sheen_gloss,
	float iridescence_intensity
) {
	ClusterLightData clusterLightData;
	decodeClusterLightCore(clusterLightData, lightIndex);
	if (acceptLightMask(clusterLightData))
		evaluateLight(
			clusterLightData, 
			worldNormal, 
			viewDir, 
			reflectionDir, 
#if defined(LIT_CLEARCOAT)
			clearcoatReflectionDir, 
#endif
			gloss, 
			specularity, 
			geometricNormal, 
			tbn, 
#if defined(LIT_IRIDESCENCE)
			iridescenceFresnel,
#endif
			clearcoat_worldNormal,
			clearcoat_gloss,
			sheen_gloss,
			iridescence_intensity
		);
}
void addClusteredLights(
	vec3 worldNormal, 
	vec3 viewDir, 
	vec3 reflectionDir, 
#if defined(LIT_CLEARCOAT)
	vec3 clearcoatReflectionDir,
#endif
	float gloss, 
	vec3 specularity, 
	vec3 geometricNormal, 
	mat3 tbn, 
#if defined(LIT_IRIDESCENCE)
	vec3 iridescenceFresnel,
#endif
	vec3 clearcoat_worldNormal,
	float clearcoat_gloss,
	float sheen_gloss,
	float iridescence_intensity
) {
	if (clusterSkip > 0.5)
		return;
	vec3 cellCoords = floor((vPositionW - clusterBoundsMin) * clusterCellsCountByBoundsSize);
	if (!(any(lessThan(cellCoords, vec3(0.0))) || any(greaterThanEqual(cellCoords, clusterCellsMax)))) {
		float cellIndex = dot(clusterCellsDot, cellCoords);
		float clusterV = floor(cellIndex * clusterTextureSize.y);
		float clusterU = cellIndex - (clusterV * clusterTextureSize.x);
		#ifdef GL2
			for (int lightCellIndex = 0; lightCellIndex < clusterMaxCells; lightCellIndex++) {
				float lightIndex = texelFetch(clusterWorldTexture, ivec2(int(clusterU) + lightCellIndex, clusterV), 0).x;
				if (lightIndex <= 0.0)
						return;
				evaluateClusterLight(
					lightIndex * 255.0, 
					worldNormal, 
					viewDir, 
					reflectionDir,
#if defined(LIT_CLEARCOAT)
					clearcoatReflectionDir,
#endif
					gloss, 
					specularity, 
					geometricNormal, 
					tbn, 
#if defined(LIT_IRIDESCENCE)
					iridescenceFresnel,
#endif
					clearcoat_worldNormal,
					clearcoat_gloss,
					sheen_gloss,
					iridescence_intensity
				); 
			}
		#else
			clusterV = (clusterV + 0.5) * clusterTextureSize.z;
			const float maxLightCells = 256.0;
			for (float lightCellIndex = 0.5; lightCellIndex < maxLightCells; lightCellIndex++) {
				float lightIndex = texture2DLodEXT(clusterWorldTexture, vec2(clusterTextureSize.y * (clusterU + lightCellIndex), clusterV), 0.0).x;
				if (lightIndex <= 0.0)
					return;
				
				evaluateClusterLight(
					lightIndex * 255.0, 
					worldNormal, 
					viewDir, 
					reflectionDir,
#if defined(LIT_CLEARCOAT)
					clearcoatReflectionDir,
#endif
					gloss, 
					specularity, 
					geometricNormal, 
					tbn, 
#if defined(LIT_IRIDESCENCE)
					iridescenceFresnel,
#endif
					clearcoat_worldNormal,
					clearcoat_gloss,
					sheen_gloss,
					iridescence_intensity
				); 
				if (lightCellIndex >= clusterMaxCells) {
					break;
				}
			}
		#endif
	}
}
`;var combinePS=`
vec3 combineColor(vec3 albedo, vec3 sheenSpecularity, float clearcoatSpecularity) {
	vec3 ret = vec3(0);
#ifdef LIT_OLD_AMBIENT
	ret += (dDiffuseLight - light_globalAmbient) * albedo + material_ambient * light_globalAmbient;
#else
	ret += albedo * dDiffuseLight;
#endif
#ifdef LIT_SPECULAR
	ret += dSpecularLight;
#endif
#ifdef LIT_REFLECTIONS
	ret += dReflection.rgb * dReflection.a;
#endif
#ifdef LIT_SHEEN
	float sheenScaling = 1.0 - max(max(sheenSpecularity.r, sheenSpecularity.g), sheenSpecularity.b) * 0.157;
	ret = ret * sheenScaling + (sSpecularLight + sReflection.rgb) * sheenSpecularity;
#endif
#ifdef LIT_CLEARCOAT
	float clearCoatScaling = 1.0 - ccFresnel * clearcoatSpecularity;
	ret = ret * clearCoatScaling + (ccSpecularLight + ccReflection.rgb) * clearcoatSpecularity;
#endif
	return ret;
}
`;var cookiePS=`
vec4 getCookie2D(sampler2D tex, mat4 transform, float intensity) {
	vec4 projPos = transform * vec4(vPositionW, 1.0);
	projPos.xy /= projPos.w;
	return mix(vec4(1.0), texture2D(tex, projPos.xy), intensity);
}
vec4 getCookie2DClip(sampler2D tex, mat4 transform, float intensity) {
	vec4 projPos = transform * vec4(vPositionW, 1.0);
	projPos.xy /= projPos.w;
	if (projPos.x < 0.0 || projPos.x > 1.0 || projPos.y < 0.0 || projPos.y > 1.0 || projPos.z < 0.0) return vec4(0.0);
	return mix(vec4(1.0), texture2D(tex, projPos.xy), intensity);
}
vec4 getCookie2DXform(sampler2D tex, mat4 transform, float intensity, vec4 cookieMatrix, vec2 cookieOffset) {
	vec4 projPos = transform * vec4(vPositionW, 1.0);
	projPos.xy /= projPos.w;
	projPos.xy += cookieOffset;
	vec2 uv = mat2(cookieMatrix) * (projPos.xy-vec2(0.5)) + vec2(0.5);
	return mix(vec4(1.0), texture2D(tex, uv), intensity);
}
vec4 getCookie2DClipXform(sampler2D tex, mat4 transform, float intensity, vec4 cookieMatrix, vec2 cookieOffset) {
	vec4 projPos = transform * vec4(vPositionW, 1.0);
	projPos.xy /= projPos.w;
	projPos.xy += cookieOffset;
	if (projPos.x < 0.0 || projPos.x > 1.0 || projPos.y < 0.0 || projPos.y > 1.0 || projPos.z < 0.0) return vec4(0.0);
	vec2 uv = mat2(cookieMatrix) * (projPos.xy-vec2(0.5)) + vec2(0.5);
	return mix(vec4(1.0), texture2D(tex, uv), intensity);
}
vec4 getCookieCube(samplerCube tex, mat4 transform, float intensity) {
	return mix(vec4(1.0), textureCube(tex, dLightDirNormW * mat3(transform)), intensity);
}
`;var cubeMapProjectBoxPS=`
uniform vec3 envBoxMin;
uniform vec3 envBoxMax;
vec3 cubeMapProject(vec3 nrdir) {
	nrdir = cubeMapRotate(nrdir);
	vec3 rbmax = (envBoxMax - vPositionW) / nrdir;
	vec3 rbmin = (envBoxMin - vPositionW) / nrdir;
	vec3 rbminmax;
	rbminmax.x = nrdir.x>0.0? rbmax.x : rbmin.x;
	rbminmax.y = nrdir.y>0.0? rbmax.y : rbmin.y;
	rbminmax.z = nrdir.z>0.0? rbmax.z : rbmin.z;
	float fa = min(min(rbminmax.x, rbminmax.y), rbminmax.z);
	vec3 posonbox = vPositionW + nrdir * fa;
	vec3 envBoxPos = (envBoxMin + envBoxMax) * 0.5;
	return normalize(posonbox - envBoxPos);
}
`;var cubeMapProjectNonePS=`
vec3 cubeMapProject(vec3 dir) {
	return cubeMapRotate(dir);
}
`;var cubeMapRotatePS=`
#ifdef CUBEMAP_ROTATION
uniform mat3 cubeMapRotationMatrix;
#endif
vec3 cubeMapRotate(vec3 refDir) {
#ifdef CUBEMAP_ROTATION
	return refDir * cubeMapRotationMatrix;
#else
	return refDir;
#endif
}
`;var debugOutputPS=`
#ifdef DEBUG_ALBEDO_PASS
gl_FragColor = vec4(gammaCorrectOutput(dAlbedo), 1.0);
#endif
#ifdef DEBUG_UV0_PASS
gl_FragColor = vec4(litArgs_albedo , 1.0);
#endif
#ifdef DEBUG_WORLD_NORMAL_PASS
gl_FragColor = vec4(litArgs_worldNormal * 0.5 + 0.5, 1.0);
#endif
#ifdef DEBUG_OPACITY_PASS
gl_FragColor = vec4(vec3(litArgs_opacity) , 1.0);
#endif
#ifdef DEBUG_SPECULARITY_PASS
gl_FragColor = vec4(litArgs_specularity, 1.0);
#endif
#ifdef DEBUG_GLOSS_PASS
gl_FragColor = vec4(vec3(litArgs_gloss) , 1.0);
#endif
#ifdef DEBUG_METALNESS_PASS
gl_FragColor = vec4(vec3(litArgs_metalness) , 1.0);
#endif
#ifdef DEBUG_AO_PASS
gl_FragColor = vec4(vec3(litArgs_ao) , 1.0);
#endif
#ifdef DEBUG_EMISSION_PASS
gl_FragColor = vec4(gammaCorrectOutput(litArgs_emission), 1.0);
#endif
`;var debugProcessFrontendPS=`
#ifdef DEBUG_LIGHTING_PASS
litArgs_albedo = vec3(0.5);
#endif
#ifdef DEBUG_UV0_PASS
#ifdef VARYING_VUV0
litArgs_albedo = vec3(vUv0, 0);
#else
litArgs_albedo = vec3(0);
#endif
#endif
`;var decodePS=`
vec3 decodeLinear(vec4 raw) {
	return raw.rgb;
}
float decodeGamma(float raw) {
	return pow(raw, 2.2);
}
vec3 decodeGamma(vec3 raw) {
	return pow(raw, vec3(2.2));
}
vec3 decodeGamma(vec4 raw) {
	return pow(raw.xyz, vec3(2.2));
}
vec3 decodeRGBM(vec4 raw) {
	vec3 color = (8.0 * raw.a) * raw.rgb;
	return color * color;
}
vec3 decodeRGBP(vec4 raw) {
	vec3 color = raw.rgb * (-raw.a * 7.0 + 8.0);
	return color * color;
}
vec3 decodeRGBE(vec4 raw) {
	if (raw.a == 0.0) {
		return vec3(0.0, 0.0, 0.0);
	} else {
		return raw.xyz * pow(2.0, raw.w * 255.0 - 128.0);
	}
}
vec4 passThrough(vec4 raw) {
	return raw;
}
`;var detailModesPS=`
vec3 detailMode_mul(vec3 c1, vec3 c2) {
	return c1 * c2;
}
vec3 detailMode_add(vec3 c1, vec3 c2) {
	return c1 + c2;
}
vec3 detailMode_screen(vec3 c1, vec3 c2) {
	return 1.0 - (1.0 - c1)*(1.0 - c2);
}
vec3 detailMode_overlay(vec3 c1, vec3 c2) {
	return mix(1.0 - 2.0*(1.0 - c1)*(1.0 - c2), 2.0*c1*c2, step(c1, vec3(0.5)));
}
vec3 detailMode_min(vec3 c1, vec3 c2) {
	return min(c1, c2);
}
vec3 detailMode_max(vec3 c1, vec3 c2) {
	return max(c1, c2);
}
`;var diffusePS=`
#ifdef MAPCOLOR
uniform vec3 material_diffuse;
#endif
void getAlbedo() {
	dAlbedo = vec3(1.0);
#ifdef MAPCOLOR
	dAlbedo *= material_diffuse.rgb;
#endif
#ifdef MAPTEXTURE
	vec3 albedoBase = $DECODE(texture2DBias($SAMPLER, $UV, textureBias)).$CH;
	dAlbedo *= addAlbedoDetail(albedoBase);
#endif
#ifdef MAPVERTEX
	dAlbedo *= gammaCorrectInput(saturate(vVertexColor.$VC));
#endif
}
`;var diffuseDetailMapPS=`
vec3 addAlbedoDetail(vec3 albedo) {
#ifdef MAPTEXTURE
	vec3 albedoDetail = $DECODE(texture2DBias($SAMPLER, $UV, textureBias)).$CH;
	return detailMode_$DETAILMODE(albedo, albedoDetail);
#else
	return albedo;
#endif
}
`;var emissivePS=`
#ifdef MAPCOLOR
uniform vec3 material_emissive;
#endif
#ifdef MAPFLOAT
uniform float material_emissiveIntensity;
#endif
void getEmission() {
	dEmission = vec3(1.0);
	#ifdef MAPFLOAT
	dEmission *= material_emissiveIntensity;
	#endif
	#ifdef MAPCOLOR
	dEmission *= material_emissive;
	#endif
	#ifdef MAPTEXTURE
	dEmission *= $DECODE(texture2DBias($SAMPLER, $UV, textureBias)).$CH;
	#endif
	#ifdef MAPVERTEX
	dEmission *= gammaCorrectInput(saturate(vVertexColor.$VC));
	#endif
}
`;var encodePS=`
vec4 encodeLinear(vec3 source) {
	return vec4(source, 1.0);
}
vec4 encodeGamma(vec3 source) {
	return vec4(pow(source + 0.0000001, vec3(1.0 / 2.2)), 1.0);
}
vec4 encodeRGBM(vec3 source) {
	vec4 result;
	result.rgb = pow(source.rgb, vec3(0.5));
	result.rgb *= 1.0 / 8.0;
	result.a = saturate( max( max( result.r, result.g ), max( result.b, 1.0 / 255.0 ) ) );
	result.a = ceil(result.a * 255.0) / 255.0;
	result.rgb /= result.a;
	return result;
}
vec4 encodeRGBP(vec3 source) {
	vec3 gamma = pow(source, vec3(0.5));
	float maxVal = min(8.0, max(1.0, max(gamma.x, max(gamma.y, gamma.z))));
	float v = 1.0 - ((maxVal - 1.0) / 7.0);
	v = ceil(v * 255.0) / 255.0;
	return vec4(gamma / (-v * 7.0 + 8.0), v);	
}
vec4 encodeRGBE(vec3 source) {
	float maxVal = max(source.x, max(source.y, source.z));
	if (maxVal < 1e-32) {
		return vec4(0, 0, 0, 0);
	} else {
		float e = ceil(log2(maxVal));
		return vec4(source / pow(2.0, e), (e + 128.0) / 255.0);
	}
}
`;var endPS=`
	gl_FragColor.rgb = combineColor(litArgs_albedo, litArgs_sheen_specularity, litArgs_clearcoat_specularity);
	gl_FragColor.rgb += litArgs_emission;
	gl_FragColor.rgb = addFog(gl_FragColor.rgb);
	#ifndef HDR
	gl_FragColor.rgb = toneMap(gl_FragColor.rgb);
	gl_FragColor.rgb = gammaCorrectOutput(gl_FragColor.rgb);
	#endif
`;var endVS=`
`;var envAtlasPS=`
const float atlasSize = 512.0;
const float seamSize = 1.0 / atlasSize;
vec2 mapUv(vec2 uv, vec4 rect) {
	return vec2(mix(rect.x + seamSize, rect.x + rect.z - seamSize, uv.x),
				mix(rect.y + seamSize, rect.y + rect.w - seamSize, uv.y));
}
vec2 mapRoughnessUv(vec2 uv, float level) {
	float t = 1.0 / exp2(level);
	return mapUv(uv, vec4(0, 1.0 - t, t, t * 0.5));
}
vec2 mapShinyUv(vec2 uv, float level) {
	float t = 1.0 / exp2(level);
	return mapUv(uv, vec4(1.0 - t, 1.0 - t, t, t * 0.5));
}
`;var envConstPS=`
vec3 processEnvironment(vec3 color) {
	return color;
}
`;var envMultiplyPS=`
uniform float skyboxIntensity;
vec3 processEnvironment(vec3 color) {
	return color * skyboxIntensity;
}
`;var extensionPS=`
`;var extensionVS=`
`;var falloffInvSquaredPS=`
float getFalloffWindow(float lightRadius, vec3 lightDir) {
	float sqrDist = dot(lightDir, lightDir);
	float invRadius = 1.0 / lightRadius;
	return square( saturate( 1.0 - square( sqrDist * square(invRadius) ) ) );
}
float getFalloffInvSquared(float lightRadius, vec3 lightDir) {
	float sqrDist = dot(lightDir, lightDir);
	float falloff = 1.0 / (sqrDist + 1.0);
	float invRadius = 1.0 / lightRadius;
	falloff *= 16.0;
	falloff *= square( saturate( 1.0 - square( sqrDist * square(invRadius) ) ) );
	return falloff;
}
`;var falloffLinearPS=`
float getFalloffLinear(float lightRadius, vec3 lightDir) {
	float d = length(lightDir);
	return max(((lightRadius - d) / lightRadius), 0.0);
}
`;var fixCubemapSeamsNonePS=`
vec3 fixSeams(vec3 vec, float mipmapIndex) {
	return vec;
}
vec3 fixSeams(vec3 vec) {
	return vec;
}
vec3 fixSeamsStatic(vec3 vec, float invRecMipSize) {
	return vec;
}
vec3 calcSeam(vec3 vec) {
	return vec3(0);
}
vec3 applySeam(vec3 vec, vec3 seam, float scale) {
	return vec;
}
`;var fixCubemapSeamsStretchPS=`
vec3 fixSeams(vec3 vec, float mipmapIndex) {
	vec3 avec = abs(vec);
	float scale = 1.0 - exp2(mipmapIndex) / 128.0;
	float M = max(max(avec.x, avec.y), avec.z);
	if (avec.x != M) vec.x *= scale;
	if (avec.y != M) vec.y *= scale;
	if (avec.z != M) vec.z *= scale;
	return vec;
}
vec3 fixSeams(vec3 vec) {
	vec3 avec = abs(vec);
	float scale = 1.0 - 1.0 / 128.0;
	float M = max(max(avec.x, avec.y), avec.z);
	if (avec.x != M) vec.x *= scale;
	if (avec.y != M) vec.y *= scale;
	if (avec.z != M) vec.z *= scale;
	return vec;
}
vec3 fixSeamsStatic(vec3 vec, float invRecMipSize) {
	vec3 avec = abs(vec);
	float scale = invRecMipSize;
	float M = max(max(avec.x, avec.y), avec.z);
	if (avec.x != M) vec.x *= scale;
	if (avec.y != M) vec.y *= scale;
	if (avec.z != M) vec.z *= scale;
	return vec;
}
vec3 calcSeam(vec3 vec) {
	vec3 avec = abs(vec);
	float M = max(avec.x, max(avec.y, avec.z));
	return vec3(avec.x != M ? 1.0 : 0.0,
				avec.y != M ? 1.0 : 0.0,
				avec.z != M ? 1.0 : 0.0);
}
vec3 applySeam(vec3 vec, vec3 seam, float scale) {
	return vec * (seam * -scale + vec3(1.0));
}
`;var floatUnpackingPS=`
float bytes2float2(vec2 data) {
	return dot(data, vec2(1.0, 1.0 / 255.0));
}
float bytes2float3(vec3 data) {
	return dot(data, vec3(1.0, 1.0 / 255.0, 1.0 / 65025.0));
}
float bytes2float4(vec4 data) {
	return dot(data, vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));
}
float bytes2floatRange2(vec2 data, float min, float max) {
	return mix(min, max, bytes2float2(data));
}
float bytes2floatRange3(vec3 data, float min, float max) {
	return mix(min, max, bytes2float3(data));
}
float bytes2floatRange4(vec4 data, float min, float max) {
	return mix(min, max, bytes2float4(data));
}
float mantissaExponent2Float(vec4 pack)
{
	float value = bytes2floatRange3(pack.xyz, -1.0, 1.0);
	float exponent = floor(pack.w * 255.0 - 127.0);
	return value * exp2(exponent);
}
`;var fogExpPS=`
uniform vec3 fog_color;
uniform float fog_density;
float dBlendModeFogFactor = 1.0;
vec3 addFog(vec3 color) {
	float depth = gl_FragCoord.z / gl_FragCoord.w;
	float fogFactor = exp(-depth * fog_density);
	fogFactor = clamp(fogFactor, 0.0, 1.0);
	return mix(fog_color * dBlendModeFogFactor, color, fogFactor);
}
`;var fogExp2PS=`
uniform vec3 fog_color;
uniform float fog_density;
float dBlendModeFogFactor = 1.0;
vec3 addFog(vec3 color) {
	float depth = gl_FragCoord.z / gl_FragCoord.w;
	float fogFactor = exp(-depth * depth * fog_density * fog_density);
	fogFactor = clamp(fogFactor, 0.0, 1.0);
	return mix(fog_color * dBlendModeFogFactor, color, fogFactor);
}
`;var fogLinearPS=`
uniform vec3 fog_color;
uniform float fog_start;
uniform float fog_end;
float dBlendModeFogFactor = 1.0;
vec3 addFog(vec3 color) {
	float depth = gl_FragCoord.z / gl_FragCoord.w;
	float fogFactor = (fog_end - depth) / (fog_end - fog_start);
	fogFactor = clamp(fogFactor, 0.0, 1.0);
	return mix(fog_color * dBlendModeFogFactor, color, fogFactor);
}
`;var fogNonePS=`
float dBlendModeFogFactor = 1.0;
vec3 addFog(vec3 color) {
	return color;
}
`;var fresnelSchlickPS=`
vec3 getFresnel(
		float cosTheta, 
		float gloss, 
		vec3 specularity
#if defined(LIT_IRIDESCENCE)
		, vec3 iridescenceFresnel, 
		float iridescenceIntensity
#endif
	) {
	float fresnel = pow(1.0 - max(cosTheta, 0.0), 5.0);
	float glossSq = gloss * gloss;
	vec3 ret = specularity + (max(vec3(glossSq), specularity) - specularity) * fresnel;
#if defined(LIT_IRIDESCENCE)
	return mix(ret, iridescenceFresnel, iridescenceIntensity);
#else
	return ret;
#endif	
}
float getFresnelCC(float cosTheta) {
	float fresnel = pow(1.0 - max(cosTheta, 0.0), 5.0);
	return 0.04 + (1.0 - 0.04) * fresnel;
}
`;var fullscreenQuadPS=`
varying vec2 vUv0;
uniform sampler2D source;
void main(void) {
	gl_FragColor = texture2D(source, vUv0);
}
`;var fullscreenQuadVS=`
attribute vec2 vertex_position;
varying vec2 vUv0;
void main(void)
{
	gl_Position = vec4(vertex_position, 0.5, 1.0);
	vUv0 = vertex_position.xy*0.5+0.5;
}
`;var gamma1_0PS=`
float gammaCorrectInput(float color) {
	return color;
}
vec3 gammaCorrectInput(vec3 color) {
	return color;
}
vec4 gammaCorrectInput(vec4 color) {
	return color;
}
vec3 gammaCorrectOutput(vec3 color) {
	return color;
}
`;var gamma2_2PS=`
float gammaCorrectInput(float color) {
	return decodeGamma(color);
}
vec3 gammaCorrectInput(vec3 color) {
	return decodeGamma(color);
}
vec4 gammaCorrectInput(vec4 color) {
	return vec4(decodeGamma(color.xyz), color.w);
}
vec3 gammaCorrectOutput(vec3 color) {
#ifdef HDR
	return color;
#else
	return pow(color + 0.0000001, vec3(1.0 / 2.2));
#endif
}
`;var glossPS=`
#ifdef MAPFLOAT
uniform float material_gloss;
#endif
void getGlossiness() {
	dGlossiness = 1.0;
	#ifdef MAPFLOAT
	dGlossiness *= material_gloss;
	#endif
	#ifdef MAPTEXTURE
	dGlossiness *= texture2DBias($SAMPLER, $UV, textureBias).$CH;
	#endif
	#ifdef MAPVERTEX
	dGlossiness *= saturate(vVertexColor.$VC);
	#endif
	#ifdef MAPINVERT
	dGlossiness = 1.0 - dGlossiness;
	#endif
	dGlossiness += 0.0000001;
}
`;var iridescenceDiffractionPS=`
uniform float material_iridescenceRefractionIndex;
#ifndef PI
#define PI 3.14159265
#endif
float iridescence_iorToFresnel(float transmittedIor, float incidentIor) {
	return pow((transmittedIor - incidentIor) / (transmittedIor + incidentIor), 2.0);
}
vec3 iridescence_iorToFresnel(vec3 transmittedIor, float incidentIor) {
	return pow((transmittedIor - vec3(incidentIor)) / (transmittedIor + vec3(incidentIor)), vec3(2.0));
}
vec3 iridescence_fresnelToIor(vec3 f0) {
	vec3 sqrtF0 = sqrt(f0);
	return (vec3(1.0) + sqrtF0) / (vec3(1.0) - sqrtF0);
}
vec3 iridescence_sensitivity(float opd, vec3 shift) {
	float phase = 2.0 * PI * opd * 1.0e-9;
	const vec3 val = vec3(5.4856e-13, 4.4201e-13, 5.2481e-13);
	const vec3 pos = vec3(1.6810e+06, 1.7953e+06, 2.2084e+06);
	const vec3 var = vec3(4.3278e+09, 9.3046e+09, 6.6121e+09);
	vec3 xyz = val * sqrt(2.0 * PI * var) * cos(pos * phase + shift) * exp(-pow(phase, 2.0) * var);
	xyz.x += 9.7470e-14 * sqrt(2.0 * PI * 4.5282e+09) * cos(2.2399e+06 * phase + shift[0]) * exp(-4.5282e+09 * pow(phase, 2.0));
	xyz /= vec3(1.0685e-07);
	const mat3 XYZ_TO_REC709 = mat3(
		3.2404542, -0.9692660,  0.0556434,
	   -1.5371385,  1.8760108, -0.2040259,
	   -0.4985314,  0.0415560,  1.0572252
	);
	return XYZ_TO_REC709 * xyz;
}
float iridescence_fresnel(float cosTheta, float f0) {
	float x = clamp(1.0 - cosTheta, 0.0, 1.0);
	float x2 = x * x;
	float x5 = x * x2 * x2;
	return f0 + (1.0 - f0) * x5;
} 
vec3 iridescence_fresnel(float cosTheta, vec3 f0) {
	float x = clamp(1.0 - cosTheta, 0.0, 1.0);
	float x2 = x * x;
	float x5 = x * x2 * x2; 
	return f0 + (vec3(1.0) - f0) * x5;
}
vec3 calcIridescence(float outsideIor, float cosTheta, vec3 base_f0, float iridescenceThickness) {
	float iridescenceIor = mix(outsideIor, material_iridescenceRefractionIndex, smoothstep(0.0, 0.03, iridescenceThickness));
	float sinTheta2Sq = pow(outsideIor / iridescenceIor, 2.0) * (1.0 - pow(cosTheta, 2.0));
	float cosTheta2Sq = 1.0 - sinTheta2Sq;
	if (cosTheta2Sq < 0.0) {
		return vec3(1.0);
	}
	float cosTheta2 = sqrt(cosTheta2Sq);
	float r0 = iridescence_iorToFresnel(iridescenceIor, outsideIor);
	float r12 = iridescence_fresnel(cosTheta, r0);
	float r21 = r12;
	float t121 = 1.0 - r12;
	float phi12 = iridescenceIor < outsideIor ? PI : 0.0;
	float phi21 = PI - phi12;
	vec3 baseIor = iridescence_fresnelToIor(base_f0 + vec3(0.0001));
	vec3 r1 = iridescence_iorToFresnel(baseIor, iridescenceIor);
	vec3 r23 = iridescence_fresnel(cosTheta2, r1);
	vec3 phi23 = vec3(0.0);
	if (baseIor[0] < iridescenceIor) phi23[0] = PI;
	if (baseIor[1] < iridescenceIor) phi23[1] = PI;
	if (baseIor[2] < iridescenceIor) phi23[2] = PI;
	float opd = 2.0 * iridescenceIor * iridescenceThickness * cosTheta2;
	vec3 phi = vec3(phi21) + phi23; 
	vec3 r123Sq = clamp(r12 * r23, 1e-5, 0.9999);
	vec3 r123 = sqrt(r123Sq);
	vec3 rs = pow(t121, 2.0) * r23 / (1.0 - r123Sq);
	vec3 c0 = r12 + rs;
	vec3 i = c0;
	vec3 cm = rs - t121;
	for (int m = 1; m <= 2; m++) {
		cm *= r123;
		vec3 sm = 2.0 * iridescence_sensitivity(float(m) * opd, float(m) * phi);
		i += cm * sm;
	}
	return max(i, vec3(0.0));
}
vec3 getIridescence(float cosTheta, vec3 specularity, float iridescenceThickness) {
	return calcIridescence(1.0, cosTheta, specularity, iridescenceThickness);
}
`;var iridescencePS=`
#ifdef MAPFLOAT
uniform float material_iridescence;
#endif
void getIridescence() {
	float iridescence = 1.0;
	#ifdef MAPFLOAT
	iridescence *= material_iridescence;
	#endif
	#ifdef MAPTEXTURE
	iridescence *= texture2DBias($SAMPLER, $UV, textureBias).$CH;
	#endif
	dIridescence = iridescence; 
}
`;var iridescenceThicknessPS=`
uniform float material_iridescenceThicknessMax;
#ifdef MAPTEXTURE
uniform float material_iridescenceThicknessMin;
#endif
void getIridescenceThickness() {
	#ifdef MAPTEXTURE
	float blend = texture2DBias($SAMPLER, $UV, textureBias).$CH;
	float iridescenceThickness = mix(material_iridescenceThicknessMin, material_iridescenceThicknessMax, blend);
	#else
	float iridescenceThickness = material_iridescenceThicknessMax;
	#endif
	dIridescenceThickness = iridescenceThickness; 
}
`;var instancingVS=`
attribute vec4 instance_line1;
attribute vec4 instance_line2;
attribute vec4 instance_line3;
attribute vec4 instance_line4;
`;var iorPS=`
#ifdef MAPFLOAT
uniform float material_refractionIndex;
#endif
void getIor() {
#ifdef MAPFLOAT
	dIor = material_refractionIndex;
#else
	dIor = 1.0 / 1.5;
#endif
}
`;var lightDiffuseLambertPS=`
float getLightDiffuse(vec3 worldNormal, vec3 viewDir, vec3 lightDir, vec3 lightDirNorm) {
	return max(dot(worldNormal, -lightDirNorm), 0.0);
}
`;var lightDirPointPS=`
void getLightDirPoint(vec3 lightPosW) {
	dLightDirW = vPositionW - lightPosW;
	dLightDirNormW = normalize(dLightDirW);
	dLightPosW = lightPosW;
}
`;var lightmapAddPS=`
void addLightMap(
	vec3 lightmap, 
	vec3 dir, 
	vec3 worldNormal, 
	vec3 viewDir, 
	vec3 reflectionDir, 
	float gloss, 
	vec3 specularity, 
	vec3 vertexNormal, 
	mat3 tbn
#if defined(LIT_IRIDESCENCE)
	vec3 iridescenceFresnel, 
	float iridescenceIntensity
#endif
) {
	dDiffuseLight += lightmap;
}
`;var lightmapDirAddPS=`
void addLightMap(
	vec3 lightmap, 
	vec3 dir, 
	vec3 worldNormal, 
	vec3 viewDir, 
	vec3 reflectionDir, 
	float gloss, 
	vec3 specularity, 
	vec3 vertexNormal, 
	mat3 tbn
#if defined(LIT_IRIDESCENCE)
	vec3 iridescenceFresnel, 
	float iridescenceIntensity
#endif
) {
	if (dot(dir, dir) < 0.0001) {
		dDiffuseLight += lightmap;
	} else {
		float vlight = saturate(dot(dir, -vertexNormal));
		float flight = saturate(dot(dir, -worldNormal));
		float nlight = (flight / max(vlight, 0.01)) * 0.5;
		dDiffuseLight += lightmap * nlight * 2.0;
		vec3 halfDir = normalize(-dir + viewDir);
		vec3 specularLight = lightmap * getLightSpecular(halfDir, reflectionDir, worldNormal, viewDir, dir, gloss, tbn);
#ifdef LIT_SPECULAR_FRESNEL
		specularLight *= 
			getFresnel(dot(viewDir, halfDir), 
			gloss, 
			specularity
		#if defined(LIT_IRIDESCENCE)
			, iridescenceFresnel,
			iridescenceIntensity
		#endif
			);
#endif
		dSpecularLight += specularLight;
	}
}
`;var lightmapDirPS=`
uniform sampler2D texture_lightMap;
uniform sampler2D texture_dirLightMap;
void getLightMap() {
	dLightmap = $DECODE(texture2DBias(texture_lightMap, $UV, textureBias)).$CH;
	vec3 dir = texture2DBias(texture_dirLightMap, $UV, textureBias).xyz * 2.0 - 1.0;
	float dirDot = dot(dir, dir);
	dLightmapDir = (dirDot > 0.001) ? dir / sqrt(dirDot) : vec3(0.0);
}
`;var lightmapSinglePS=`
void getLightMap() {
	dLightmap = vec3(1.0);
	#ifdef MAPTEXTURE
	dLightmap *= $DECODE(texture2DBias($SAMPLER, $UV, textureBias)).$CH;
	#endif
	#ifdef MAPVERTEX
	dLightmap *= saturate(vVertexColor.$VC);
	#endif
}
`;var lightSpecularAnisoGGXPS=`
float calcLightSpecular(float gloss, vec3 worldNormal, vec3 viewDir, vec3 h, vec3 lightDirNorm, mat3 tbn) {
	float PI = 3.141592653589793;
	float roughness = max((1.0 - gloss) * (1.0 - gloss), 0.001);
	float anisotropy = material_anisotropy * roughness;
 
	float at = max((roughness + anisotropy), roughness / 4.0);
	float ab = max((roughness - anisotropy), roughness / 4.0);
	float NoH = dot(worldNormal, h);
	float ToH = dot(tbn[0], h);
	float BoH = dot(tbn[1], h);
	float a2 = at * ab;
	vec3 v = vec3(ab * ToH, at * BoH, a2 * NoH);
	float v2 = dot(v, v);
	float w2 = a2 / v2;
	float D = a2 * w2 * w2 * (1.0 / PI);
	float ToV = dot(tbn[0], viewDir);
	float BoV = dot(tbn[1], viewDir);
	float ToL = dot(tbn[0], -lightDirNorm);
	float BoL = dot(tbn[1], -lightDirNorm);
	float NoV = dot(worldNormal, viewDir);
	float NoL = dot(worldNormal, -lightDirNorm);
	float lambdaV = NoL * length(vec3(at * ToV, ab * BoV, NoV));
	float lambdaL = NoV * length(vec3(at * ToL, ab * BoL, NoL));
	float G = 0.5 / (lambdaV + lambdaL);
	return D * G;
}
float getLightSpecular(vec3 h, vec3 reflDir, vec3 worldNormal, vec3 viewDir, vec3 lightDirNorm, float gloss, mat3 tbn) {
	return calcLightSpecular(gloss, worldNormal, viewDir, h, lightDirNorm, tbn);
}
`;var lightSpecularBlinnPS=`
float calcLightSpecular(float gloss, vec3 worldNormal, vec3 h) {
	float nh = max( dot( h, worldNormal ), 0.0 );
	float specPow = exp2(gloss * 11.0);
	specPow = max(specPow, 0.0001);
	return pow(nh, specPow) * (specPow + 2.0) / 8.0;
}
float getLightSpecular(vec3 h, vec3 reflDir, vec3 worldNormal, vec3 viewDir, vec3 lightDirNorm, float gloss, mat3 tbn) {
	return calcLightSpecular(gloss, worldNormal, h);
}
`;var lightSpecularPhongPS=`
float calcLightSpecular(float gloss, vec3 reflDir, vec3 lightDirNorm) {
	float specPow = gloss;
	return pow(max(dot(reflDir, -lightDirNorm), 0.0), specPow + 0.0001);
}
float getLightSpecular(vec3 h, vec3 reflDir, vec3 worldNormal, vec3 viewDir, vec3 lightDirNorm, float gloss, mat3 tbn) {
	return calcLightSpecular(gloss, reflDir, lightDirNorm);
}
`;var lightSheenPS=`
float sheenD(vec3 normal, vec3 h, float roughness) {
	float invR = 1.0 / (roughness * roughness);
	float cos2h = max(dot(normal, h), 0.0);
	cos2h *= cos2h;
	float sin2h = max(1.0 - cos2h, 0.0078125);
	return (2.0 + invR) * pow(sin2h, invR * 0.5) / (2.0 * PI);
}
float sheenV(vec3 normal, vec3 viewDir, vec3 light) {
	float NoV = max(dot(normal, viewDir), 0.000001);
	float NoL = max(dot(normal, light), 0.000001);
	return 1.0 / (4.0 * (NoL + NoV - NoL * NoV));
}
float getLightSpecularSheen(vec3 h, vec3 worldNormal, vec3 viewDir, vec3 lightDirNorm, float sheenGloss) {
	float D = sheenD(worldNormal, h, sheenGloss);
	float V = sheenV(worldNormal, viewDir, -lightDirNorm);
	return D * V;
}
`;var linearizeDepthPS=`
#ifndef LINEARIZE_DEPTH
#define LINEARIZE_DEPTH
float linearizeDepth(float z, vec4 cameraParams) {
	if (cameraParams.w == 0.0)
		return (cameraParams.z * cameraParams.y) / (cameraParams.y + z * (cameraParams.z - cameraParams.y));
	else
		return cameraParams.z + z * (cameraParams.y - cameraParams.z);
}
#ifndef CAMERAPLANES
#define CAMERAPLANES
uniform vec4 camera_params;
#endif
#ifdef GL2
float linearizeDepth(float z) {
	return linearizeDepth(z, camera_params);
}
#else
#ifndef UNPACKFLOAT
#define UNPACKFLOAT
float unpackFloat(vec4 rgbaDepth) {
	const vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);
	return dot(rgbaDepth, bitShift);
}
#endif
#endif
#endif
`;var litShaderArgsPS=`
vec3 litArgs_albedo;
float litArgs_opacity;
vec3 litArgs_emission;
vec3 litArgs_worldNormal;
float litArgs_ao;
vec3 litArgs_lightmap;
vec3 litArgs_lightmapDir;
float litArgs_metalness;
vec3 litArgs_specularity;
float litArgs_specularityFactor;
float litArgs_gloss;
float litArgs_sheen_gloss;
vec3 litArgs_sheen_specularity;
float litArgs_transmission;
float litArgs_thickness;
float litArgs_ior;
float litArgs_dispersion;
float litArgs_iridescence_intensity;
float litArgs_iridescence_thickness;
vec3 litArgs_clearcoat_worldNormal;
float litArgs_clearcoat_specularity;
float litArgs_clearcoat_gloss;
`;var ltcPS=`
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
struct Coords {
	vec3 coord0;
	vec3 coord1;
	vec3 coord2;
	vec3 coord3;
};
float LTC_EvaluateRect( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in Coords rectCoords) {
	vec3 v1 = rectCoords.coord1 - rectCoords.coord0;
	vec3 v2 = rectCoords.coord3 - rectCoords.coord0;
	
	vec3 lightNormal = cross( v1, v2 );
	float factor = sign(-dot( lightNormal, P - rectCoords.coord0 ));
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 =  factor * cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords.coord0 - P );
	coords[ 1 ] = mat * ( rectCoords.coord1 - P );
	coords[ 2 ] = mat * ( rectCoords.coord2 - P );
	coords[ 3 ] = mat * ( rectCoords.coord3 - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return result;
}
Coords dLTCCoords;
Coords getLTCLightCoords(vec3 lightPos, vec3 halfWidth, vec3 halfHeight){
	Coords coords;
	coords.coord0 = lightPos + halfWidth - halfHeight;
	coords.coord1 = lightPos - halfWidth - halfHeight;
	coords.coord2 = lightPos - halfWidth + halfHeight;
	coords.coord3 = lightPos + halfWidth + halfHeight;
	return coords;
}
float dSphereRadius;
Coords getSphereLightCoords(vec3 lightPos, vec3 halfWidth, vec3 halfHeight){
	dSphereRadius = max(length(halfWidth), length(halfHeight));
	vec3 f = reflect(normalize(lightPos - view_position), vNormalW);
	vec3 w = normalize(cross(f, halfHeight));
	vec3 h = normalize(cross(f, w));
	return getLTCLightCoords(lightPos, w * dSphereRadius, h * dSphereRadius);
}
vec2 dLTCUV;
#ifdef LIT_CLEARCOAT
vec2 ccLTCUV;
#endif
vec2 getLTCLightUV(float gloss, vec3 worldNormal, vec3 viewDir)
{
	float roughness = max((1.0 - gloss) * (1.0 - gloss), 0.001);
	return LTC_Uv( worldNormal, viewDir, roughness );
}
vec3 dLTCSpecFres;
#ifdef LIT_CLEARCOAT
vec3 ccLTCSpecFres;
#endif
vec3 getLTCLightSpecFres(vec2 uv, vec3 specularity)
{
	vec4 t2 = texture2DLodEXT(areaLightsLutTex2, uv, 0.0);
	#ifdef AREA_R8_G8_B8_A8_LUTS
	t2 *= vec4(0.693103,1,1,1);
	t2 += vec4(0.306897,0,0,0);
	#endif
	return specularity * t2.x + ( vec3( 1.0 ) - specularity) * t2.y;
}
void calcLTCLightValues(float gloss, vec3 worldNormal, vec3 viewDir, vec3 specularity, float clearcoatGloss, vec3 clearcoatWorldNormal, float clearcoatSpecularity)
{
	dLTCUV = getLTCLightUV(gloss, worldNormal, viewDir);
	dLTCSpecFres = getLTCLightSpecFres(dLTCUV, specularity); 
#ifdef LIT_CLEARCOAT
	ccLTCUV = getLTCLightUV(clearcoatGloss, clearcoatWorldNormal, viewDir);
	ccLTCSpecFres = getLTCLightSpecFres(ccLTCUV, vec3(clearcoatSpecularity));
#endif
}
void calcRectLightValues(vec3 lightPos, vec3 halfWidth, vec3 halfHeight)
{
	dLTCCoords = getLTCLightCoords(lightPos, halfWidth, halfHeight);
}
void calcDiskLightValues(vec3 lightPos, vec3 halfWidth, vec3 halfHeight)
{
	calcRectLightValues(lightPos, halfWidth, halfHeight);
}
void calcSphereLightValues(vec3 lightPos, vec3 halfWidth, vec3 halfHeight)
{
	dLTCCoords = getSphereLightCoords(lightPos, halfWidth, halfHeight);
}
vec3 SolveCubic(vec4 Coefficient)
{
	float pi = 3.14159;
	Coefficient.xyz /= Coefficient.w;
	Coefficient.yz /= 3.0;
	float A = Coefficient.w;
	float B = Coefficient.z;
	float C = Coefficient.y;
	float D = Coefficient.x;
	vec3 Delta = vec3(
		-Coefficient.z * Coefficient.z + Coefficient.y,
		-Coefficient.y * Coefficient.z + Coefficient.x,
		dot(vec2(Coefficient.z, -Coefficient.y), Coefficient.xy)
	);
	float Discriminant = dot(vec2(4.0 * Delta.x, -Delta.y), Delta.zy);
	vec3 RootsA, RootsD;
	vec2 xlc, xsc;
	{
		float A_a = 1.0;
		float C_a = Delta.x;
		float D_a = -2.0 * B * Delta.x + Delta.y;
		float Theta = atan(sqrt(Discriminant), -D_a) / 3.0;
		float x_1a = 2.0 * sqrt(-C_a) * cos(Theta);
		float x_3a = 2.0 * sqrt(-C_a) * cos(Theta + (2.0 / 3.0) * pi);
		float xl;
		if ((x_1a + x_3a) > 2.0 * B)
			xl = x_1a;
		else
			xl = x_3a;
		xlc = vec2(xl - B, A);
	}
	{
		float A_d = D;
		float C_d = Delta.z;
		float D_d = -D * Delta.y + 2.0 * C * Delta.z;
		float Theta = atan(D * sqrt(Discriminant), -D_d) / 3.0;
		float x_1d = 2.0 * sqrt(-C_d) * cos(Theta);
		float x_3d = 2.0 * sqrt(-C_d) * cos(Theta + (2.0 / 3.0) * pi);
		float xs;
		if (x_1d + x_3d < 2.0 * C)
			xs = x_1d;
		else
			xs = x_3d;
		xsc = vec2(-D, xs + C);
	}
	float E =  xlc.y * xsc.y;
	float F = -xlc.x * xsc.y - xlc.y * xsc.x;
	float G =  xlc.x * xsc.x;
	vec2 xmc = vec2(C * F - B * G, -B * F + C * E);
	vec3 Root = vec3(xsc.x / xsc.y, xmc.x / xmc.y, xlc.x / xlc.y);
	if (Root.x < Root.y && Root.x < Root.z)
		Root.xyz = Root.yxz;
	else if (Root.z < Root.x && Root.z < Root.y)
		Root.xyz = Root.xzy;
	return Root;
}
float LTC_EvaluateDisk(vec3 N, vec3 V, vec3 P, mat3 Minv, Coords points)
{
	vec3 T1, T2;
	T1 = normalize(V - N * dot(V, N));
	T2 = cross(N, T1);
	mat3 R = transposeMat3( mat3( T1, T2, N ) );
	vec3 L_[ 3 ];
	L_[ 0 ] = R * ( points.coord0 - P );
	L_[ 1 ] = R * ( points.coord1 - P );
	L_[ 2 ] = R * ( points.coord2 - P );
	vec3 Lo_i = vec3(0);
	vec3 C  = 0.5 * (L_[0] + L_[2]);
	vec3 V1 = 0.5 * (L_[1] - L_[2]);
	vec3 V2 = 0.5 * (L_[1] - L_[0]);
	C  = Minv * C;
	V1 = Minv * V1;
	V2 = Minv * V2;
	float a, b;
	float d11 = dot(V1, V1);
	float d22 = dot(V2, V2);
	float d12 = dot(V1, V2);
	if (abs(d12) / sqrt(d11 * d22) > 0.0001)
	{
		float tr = d11 + d22;
		float det = -d12 * d12 + d11 * d22;
		det = sqrt(det);
		float u = 0.5 * sqrt(tr - 2.0 * det);
		float v = 0.5 * sqrt(tr + 2.0 * det);
		float e_max = (u + v) * (u + v);
		float e_min = (u - v) * (u - v);
		vec3 V1_, V2_;
		if (d11 > d22)
		{
			V1_ = d12 * V1 + (e_max - d11) * V2;
			V2_ = d12 * V1 + (e_min - d11) * V2;
		}
		else
		{
			V1_ = d12*V2 + (e_max - d22)*V1;
			V2_ = d12*V2 + (e_min - d22)*V1;
		}
		a = 1.0 / e_max;
		b = 1.0 / e_min;
		V1 = normalize(V1_);
		V2 = normalize(V2_);
	}
	else
	{
		a = 1.0 / dot(V1, V1);
		b = 1.0 / dot(V2, V2);
		V1 *= sqrt(a);
		V2 *= sqrt(b);
	}
	vec3 V3 = normalize(cross(V1, V2));
	if (dot(C, V3) < 0.0)
		V3 *= -1.0;
	float L  = dot(V3, C);
	float x0 = dot(V1, C) / L;
	float y0 = dot(V2, C) / L;
	float E1 = inversesqrt(a);
	float E2 = inversesqrt(b);
	a *= L * L;
	b *= L * L;
	float c0 = a * b;
	float c1 = a * b * (1.0 + x0 * x0 + y0 * y0) - a - b;
	float c2 = 1.0 - a * (1.0 + x0 * x0) - b * (1.0 + y0 * y0);
	float c3 = 1.0;
	vec3 roots = SolveCubic(vec4(c0, c1, c2, c3));
	float e1 = roots.x;
	float e2 = roots.y;
	float e3 = roots.z;
	vec3 avgDir = vec3(a * x0 / (a - e2), b * y0 / (b - e2), 1.0);
	mat3 rotate = mat3(V1, V2, V3);
	avgDir = rotate * avgDir;
	avgDir = normalize(avgDir);
	float L1 = sqrt(-e2 / e3);
	float L2 = sqrt(-e2 / e1);
	float formFactor = max(0.0, L1 * L2 * inversesqrt((1.0 + L1 * L1) * (1.0 + L2 * L2)));
	
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	vec2 uv = vec2(avgDir.z * 0.5 + 0.5, formFactor);
	uv = uv*LUT_SCALE + LUT_BIAS;
	float scale = texture2DLodEXT(areaLightsLutTex2, uv, 0.0).w;
	return formFactor*scale;
}
float getRectLightDiffuse(vec3 worldNormal, vec3 viewDir, vec3 lightDir, vec3 lightDirNorm) {
	return LTC_EvaluateRect( worldNormal, viewDir, vPositionW, mat3( 1.0 ), dLTCCoords );
}
float getDiskLightDiffuse(vec3 worldNormal, vec3 viewDir, vec3 lightDir, vec3 lightDirNorm) {
	return LTC_EvaluateDisk( worldNormal, viewDir, vPositionW, mat3( 1.0 ), dLTCCoords );
}
float getSphereLightDiffuse(vec3 worldNormal, vec3 viewDir, vec3 lightDir, vec3 lightDirNorm) {
	float falloff = dSphereRadius / (dot(lightDir, lightDir) + dSphereRadius);
	return getLightDiffuse(worldNormal, viewDir, lightDir, lightDirNorm) * falloff;
}
mat3 getLTCLightInvMat(vec2 uv)
{
	vec4 t1 = texture2DLodEXT(areaLightsLutTex1, uv, 0.0);
	#ifdef AREA_R8_G8_B8_A8_LUTS
	t1 *= vec4(1.001, 0.3239, 0.60437568, 1.0);
	t1 += vec4(0.0, -0.2976, -0.01381, 0.0);
	#endif
	return mat3(
		vec3( t1.x, 0, t1.y ),
		vec3(	0, 1,	0 ),
		vec3( t1.z, 0, t1.w )
	);
}
float calcRectLightSpecular(vec3 worldNormal, vec3 viewDir, vec2 uv) {
	mat3 mInv = getLTCLightInvMat(uv);
	return LTC_EvaluateRect( worldNormal, viewDir, vPositionW, mInv, dLTCCoords );
}
float getRectLightSpecular(vec3 worldNormal, vec3 viewDir) {
	return calcRectLightSpecular(worldNormal, viewDir, dLTCUV);
}
float calcDiskLightSpecular(vec3 worldNormal, vec3 viewDir, vec2 uv) {
	mat3 mInv = getLTCLightInvMat(uv);
	return LTC_EvaluateDisk( worldNormal, viewDir, vPositionW, mInv, dLTCCoords );
}
float getDiskLightSpecular(vec3 worldNormal, vec3 viewDir) {
	return calcDiskLightSpecular(worldNormal, viewDir, dLTCUV);
}
float getSphereLightSpecular(vec3 worldNormal, vec3 viewDir) {
	return calcDiskLightSpecular(worldNormal, viewDir, dLTCUV);
}
`;var metalnessPS=`
#ifdef MAPFLOAT
uniform float material_metalness;
#endif
void getMetalness() {
	float metalness = 1.0;
	#ifdef MAPFLOAT
	metalness *= material_metalness;
	#endif
	#ifdef MAPTEXTURE
	metalness *= texture2DBias($SAMPLER, $UV, textureBias).$CH;
	#endif
	#ifdef MAPVERTEX
	metalness *= saturate(vVertexColor.$VC);
	#endif
	dMetalness = metalness;
}
`;var msdfPS=`
uniform sampler2D texture_msdfMap;
#ifdef GL_OES_standard_derivatives
#define USE_FWIDTH
#endif
#ifdef GL2
#define USE_FWIDTH
#endif
float median(float r, float g, float b) {
	return max(min(r, g), min(max(r, g), b));
}
float map (float min, float max, float v) {
	return (v - min) / (max - min);
}
uniform float font_sdfIntensity;
uniform float font_pxrange;
uniform float font_textureWidth;
#ifdef UNIFORM_TEXT_PARAMETERS
uniform vec4 outline_color;
uniform float outline_thickness;
uniform vec4 shadow_color;
uniform vec2 shadow_offset;
#else
varying vec4 outline_color;
varying float outline_thickness;
varying vec4 shadow_color;
varying vec2 shadow_offset;
#endif
vec4 applyMsdf(vec4 color) {
	vec3 tsample = texture2D(texture_msdfMap, vUv0).rgb;
	vec2 uvShdw = vUv0 - shadow_offset;
	vec3 ssample = texture2D(texture_msdfMap, uvShdw).rgb;
	float sigDist = median(tsample.r, tsample.g, tsample.b);
	float sigDistShdw = median(ssample.r, ssample.g, ssample.b);
	float smoothingMax = 0.2;
	#ifdef USE_FWIDTH
	vec2 w = fwidth(vUv0);
	float smoothing = clamp(w.x * font_textureWidth / font_pxrange, 0.0, smoothingMax);
	#else
	float font_size = 16.0;
	float smoothing = clamp(font_pxrange / font_size, 0.0, smoothingMax);
	#endif
	float mapMin = 0.05;
	float mapMax = clamp(1.0 - font_sdfIntensity, mapMin, 1.0);
	float sigDistInner = map(mapMin, mapMax, sigDist);
	float sigDistOutline = map(mapMin, mapMax, sigDist + outline_thickness);
	sigDistShdw = map(mapMin, mapMax, sigDistShdw + outline_thickness);
	float center = 0.5;
	float inside = smoothstep(center-smoothing, center+smoothing, sigDistInner);
	float outline = smoothstep(center-smoothing, center+smoothing, sigDistOutline);
	float shadow = smoothstep(center-smoothing, center+smoothing, sigDistShdw);
	vec4 tcolor = (outline > inside) ? outline * vec4(outline_color.a * outline_color.rgb, outline_color.a) : vec4(0.0);
	tcolor = mix(tcolor, color, inside);
	vec4 scolor = (shadow > outline) ? shadow * vec4(shadow_color.a * shadow_color.rgb, shadow_color.a) : tcolor;
	tcolor = mix(scolor, tcolor, outline);
	
	return tcolor;
}
`;var metalnessModulatePS=`
vec3 getSpecularModulate(in vec3 specularity, in vec3 albedo, in float metalness, in float f0) {
	vec3 dielectricF0 = f0 * specularity;
	return mix(dielectricF0, albedo, metalness);
}
vec3 getAlbedoModulate(in vec3 albedo, in float metalness) {
	return albedo * (1.0 - metalness);
}
`;var msdfVS=`
attribute vec3 vertex_outlineParameters;
attribute vec3 vertex_shadowParameters;
varying vec4 outline_color;
varying float outline_thickness;
varying vec4 shadow_color;
varying vec2 shadow_offset;
void unpackMsdfParams() {
	vec3 little = mod(vertex_outlineParameters, 256.);
	vec3 big = (vertex_outlineParameters - little) / 256.;
	outline_color.rb = little.xy / 255.;
	outline_color.ga = big.xy / 255.;
	outline_thickness = little.z / 255. * 0.2;
	little = mod(vertex_shadowParameters, 256.);
	big = (vertex_shadowParameters - little) / 256.;
	shadow_color.rb = little.xy / 255.;
	shadow_color.ga = big.xy / 255.;
	shadow_offset = (vec2(little.z, big.z) / 127. - 1.) * 0.005;
}
`;var normalVS=`
#ifdef MORPHING_TEXTURE_BASED_NORMAL
uniform highp sampler2D morphNormalTex;
#endif
vec3 getNormal() {
	#ifdef SKIN
	dNormalMatrix = mat3(dModelMatrix[0].xyz, dModelMatrix[1].xyz, dModelMatrix[2].xyz);
	#elif defined(INSTANCING)
	dNormalMatrix = mat3(instance_line1.xyz, instance_line2.xyz, instance_line3.xyz);
	#else
	dNormalMatrix = matrix_normal;
	#endif
	vec3 tempNormal = vertex_normal;
	#ifdef MORPHING
	#ifdef MORPHING_NRM03
	tempNormal += morph_weights_a[0] * morph_nrm0;
	tempNormal += morph_weights_a[1] * morph_nrm1;
	tempNormal += morph_weights_a[2] * morph_nrm2;
	tempNormal += morph_weights_a[3] * morph_nrm3;
	#endif
	#ifdef MORPHING_NRM47
	tempNormal += morph_weights_b[0] * morph_nrm4;
	tempNormal += morph_weights_b[1] * morph_nrm5;
	tempNormal += morph_weights_b[2] * morph_nrm6;
	tempNormal += morph_weights_b[3] * morph_nrm7;
	#endif
	#endif
	#ifdef MORPHING_TEXTURE_BASED_NORMAL
		#ifdef WEBGPU
			ivec2 morphUV = getTextureMorphCoords();
			vec3 morphNormal = texelFetch(morphNormalTex, ivec2(morphUV), 0).xyz;
		#else
			vec2 morphUV = getTextureMorphCoords();
			vec3 morphNormal = texture2D(morphNormalTex, morphUV).xyz;
		#endif
	tempNormal += morphNormal;
	#endif
	return normalize(dNormalMatrix * tempNormal);
}
`;var normalDetailMapPS=`
#ifdef MAPTEXTURE
uniform float material_normalDetailMapBumpiness;
vec3 blendNormals(vec3 n1, vec3 n2) {
	n1 += vec3(0, 0, 1);
	n2 *= vec3(-1, -1, 1);
	return n1 * dot(n1, n2) / n1.z - n2;
}
#endif
vec3 addNormalDetail(vec3 normalMap) {
#ifdef MAPTEXTURE
	vec3 normalDetailMap = unpackNormal(texture2DBias($SAMPLER, $UV, textureBias));
	normalDetailMap = mix(vec3(0.0, 0.0, 1.0), normalDetailMap, material_normalDetailMapBumpiness);
	return blendNormals(normalMap, normalDetailMap);
#else
	return normalMap;
#endif
}
`;var normalInstancedVS=`
vec3 getNormal() {
	dNormalMatrix = mat3(instance_line1.xyz, instance_line2.xyz, instance_line3.xyz);
	return normalize(dNormalMatrix * vertex_normal);
}
`;var normalMapPS=`
#ifdef MAPTEXTURE
uniform float material_bumpiness;
#endif
void getNormal() {
#ifdef MAPTEXTURE
	vec3 normalMap = unpackNormal(texture2DBias($SAMPLER, $UV, textureBias));
	normalMap = mix(vec3(0.0, 0.0, 1.0), normalMap, material_bumpiness);
	dNormalW = normalize(dTBN * addNormalDetail(normalMap));
#else
	dNormalW = dVertexNormalW;
#endif
}
`;var normalSkinnedVS=`
vec3 getNormal() {
	dNormalMatrix = mat3(dModelMatrix[0].xyz, dModelMatrix[1].xyz, dModelMatrix[2].xyz);
	return normalize(dNormalMatrix * vertex_normal);
}
`;var normalXYPS=`
vec3 unpackNormal(vec4 nmap) {
	vec3 normal;
	normal.xy = nmap.wy * 2.0 - 1.0;
	normal.z = sqrt(1.0 - saturate(dot(normal.xy, normal.xy)));
	return normal;
}
`;var normalXYZPS=`
vec3 unpackNormal(vec4 nmap) {
	return nmap.xyz * 2.0 - 1.0;
}
`;var opacityPS=`
#ifdef MAPFLOAT
uniform float material_opacity;
#endif
void getOpacity() {
	dAlpha = 1.0;
	#ifdef MAPFLOAT
	dAlpha *= material_opacity;
	#endif
	#ifdef MAPTEXTURE
	dAlpha *= texture2DBias($SAMPLER, $UV, textureBias).$CH;
	#endif
	#ifdef MAPVERTEX
	dAlpha *= clamp(vVertexColor.$VC, 0.0, 1.0);
	#endif
}
`;var opacityDitherPS=`
uniform vec4 blueNoiseJitter;
#ifdef DITHER_BLUENOISE
	uniform sampler2D blueNoiseTex32;
#endif
void opacityDither(float alpha, float id) {
	#ifdef DITHER_BAYER8
		float noise = bayer8(floor(mod(gl_FragCoord.xy + blueNoiseJitter.xy + id, 8.0))) / 64.0;
	#else
		#ifdef DITHER_BLUENOISE
			vec2 uv = fract(gl_FragCoord.xy / 32.0 + blueNoiseJitter.xy + id);
			float noise = texture2DLodEXT(blueNoiseTex32, uv, 0.0).y;
		#endif
		#ifdef DITHER_IGNNOISE
			vec3 magic = vec3(0.06711056, 0.00583715, 52.9829189);
			float noise = fract(magic.z * fract(dot(gl_FragCoord.xy + blueNoiseJitter.xy + id, magic.xy)));
		#endif
	#endif
	if (alpha < noise)
		discard;
}
`;var outputPS=`
`;var outputAlphaPS=`
gl_FragColor.a = litArgs_opacity;
`;var outputAlphaOpaquePS=`
	gl_FragColor.a = 1.0;
`;var outputAlphaPremulPS=`
gl_FragColor.rgb *= litArgs_opacity;
gl_FragColor.a = litArgs_opacity;
`;var outputTex2DPS=`
varying vec2 vUv0;
uniform sampler2D source;
void main(void) {
	gl_FragColor = texture2D(source, vUv0);
}
`;var packDepthPS=`
vec4 packFloat(float depth) {
	const vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);
	const vec4 bit_mask  = vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);
	vec4 res = mod(depth * bit_shift * vec4(255), vec4(256) ) / vec4(255);
	res -= res.xxyz * bit_mask;
	return res;
}
`;var sheenPS=`
#ifdef MAPCOLOR
uniform vec3 material_sheen;
#endif
void getSheen() {
	vec3 sheenColor = vec3(1, 1, 1);
	#ifdef MAPCOLOR
	sheenColor *= material_sheen;
	#endif
	#ifdef MAPTEXTURE
	sheenColor *= $DECODE(texture2DBias($SAMPLER, $UV, textureBias)).$CH;
	#endif
	#ifdef MAPVERTEX
	sheenColor *= saturate(vVertexColor.$VC);
	#endif
	sSpecularity = sheenColor;
}
`;var sheenGlossPS=`
#ifdef MAPFLOAT
uniform float material_sheenGloss;
#endif
void getSheenGlossiness() {
	float sheenGlossiness = 1.0;
	#ifdef MAPFLOAT
	sheenGlossiness *= material_sheenGloss;
	#endif
	#ifdef MAPTEXTURE
	sheenGlossiness *= texture2DBias($SAMPLER, $UV, textureBias).$CH;
	#endif
	#ifdef MAPVERTEX
	sheenGlossiness *= saturate(vVertexColor.$VC);
	#endif
	#ifdef MAPINVERT
	sheenGlossiness = 1.0 - sheenGlossiness;
	#endif
	sheenGlossiness += 0.0000001;
	sGlossiness = sheenGlossiness;
}
`;var parallaxPS=`
uniform float material_heightMapFactor;
void getParallax() {
	float parallaxScale = material_heightMapFactor;
	float height = texture2DBias($SAMPLER, $UV, textureBias).$CH;
	height = height * parallaxScale - parallaxScale*0.5;
	vec3 viewDirT = dViewDirW * dTBN;
	viewDirT.z += 0.42;
	dUvOffset = height * (viewDirT.xy / viewDirT.z);
}
`;var particlePS=`
varying vec4 texCoordsAlphaLife;
uniform sampler2D colorMap;
uniform sampler2D colorParam;
uniform float graphSampleSize;
uniform float graphNumSamples;
#ifndef CAMERAPLANES
#define CAMERAPLANES
uniform vec4 camera_params;
#endif
uniform float softening;
uniform float colorMult;
float saturate(float x) {
	return clamp(x, 0.0, 1.0);
}
#ifndef UNPACKFLOAT
#define UNPACKFLOAT
float unpackFloat(vec4 rgbaDepth) {
	const vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);
	float depth = dot(rgbaDepth, bitShift);
	return depth;
}
#endif
void main(void) {
	vec4 tex  = gammaCorrectInput(texture2D(colorMap, vec2(texCoordsAlphaLife.x, 1.0 - texCoordsAlphaLife.y)));
	vec4 ramp = gammaCorrectInput(texture2D(colorParam, vec2(texCoordsAlphaLife.w, 0.0)));
	ramp.rgb *= colorMult;
	ramp.a += texCoordsAlphaLife.z;
	vec3 rgb = tex.rgb * ramp.rgb;
	float a  = tex.a * ramp.a;
`;var particleVS=`
vec3 unpack3NFloats(float src) {
	float r = fract(src);
	float g = fract(src * 256.0);
	float b = fract(src * 65536.0);
	return vec3(r, g, b);
}
float saturate(float x) {
	return clamp(x, 0.0, 1.0);
}
vec4 tex1Dlod_lerp(TEXTURE_ACCEPT_HIGHP(tex), vec2 tc) {
	return mix( texture2D(tex,tc), texture2D(tex,tc + graphSampleSize), fract(tc.x*graphNumSamples) );
}
vec4 tex1Dlod_lerp(TEXTURE_ACCEPT_HIGHP(tex), vec2 tc, out vec3 w) {
	vec4 a = texture2D(tex,tc);
	vec4 b = texture2D(tex,tc + graphSampleSize);
	float c = fract(tc.x*graphNumSamples);
	vec3 unpackedA = unpack3NFloats(a.w);
	vec3 unpackedB = unpack3NFloats(b.w);
	w = mix(unpackedA, unpackedB, c);
	return mix(a, b, c);
}
vec2 rotate(vec2 quadXY, float pRotation, out mat2 rotMatrix) {
	float c = cos(pRotation);
	float s = sin(pRotation);
	mat2 m = mat2(c, -s, s, c);
	rotMatrix = m;
	return m * quadXY;
}
vec3 billboard(vec3 InstanceCoords, vec2 quadXY) {
	#ifdef SCREEN_SPACE
		vec3 pos = vec3(-1, 0, 0) * quadXY.x + vec3(0, -1, 0) * quadXY.y;
	#else
		vec3 pos = -matrix_viewInverse[0].xyz * quadXY.x + -matrix_viewInverse[1].xyz * quadXY.y;
	#endif
	return pos;
}
vec3 customFace(vec3 InstanceCoords, vec2 quadXY) {
	vec3 pos = faceTangent * quadXY.x + faceBinorm * quadXY.y;
	return pos;
}
vec2 safeNormalize(vec2 v) {
	float l = length(v);
	return (l > 1e-06) ? v / l : v;
}
void main(void) {
	vec3 meshLocalPos = particle_vertexData.xyz;
	float id = floor(particle_vertexData.w);
	float rndFactor = fract(sin(id + 1.0 + seed));
	vec3 rndFactor3 = vec3(rndFactor, fract(rndFactor*10.0), fract(rndFactor*100.0));
	float uv = id / numParticlesPot;
	readInput(uv);
#ifdef LOCAL_SPACE
	inVel = mat3(matrix_model) * inVel;
#endif
	vec2 velocityV = safeNormalize((mat3(matrix_view) * inVel).xy);
	float particleLifetime = lifetime;
	if (inLife <= 0.0 || inLife > particleLifetime || !inShow) meshLocalPos = vec3(0.0);
	vec2 quadXY = meshLocalPos.xy;
	float nlife = clamp(inLife / particleLifetime, 0.0, 1.0);
	vec3 paramDiv;
	vec4 params = tex1Dlod_lerp(TEXTURE_PASS(internalTex2), vec2(nlife, 0), paramDiv);
	float scale = params.y;
	float scaleDiv = paramDiv.x;
	float alphaDiv = paramDiv.z;
	scale += (scaleDiv * 2.0 - 1.0) * scaleDivMult * fract(rndFactor*10000.0);
#ifndef USE_MESH
	texCoordsAlphaLife = vec4(quadXY * -0.5 + 0.5, (alphaDiv * 2.0 - 1.0) * alphaDivMult * fract(rndFactor*1000.0), nlife);
#else
	texCoordsAlphaLife = vec4(particle_uv, (alphaDiv * 2.0 - 1.0) * alphaDivMult * fract(rndFactor*1000.0), nlife);
#endif
	vec3 particlePos = inPos;
	vec3 particlePosMoved = vec3(0.0);
	mat2 rotMatrix;
`;var particleAnimFrameClampVS=`
	float animFrame = min(floor(texCoordsAlphaLife.w * animTexParams.y) + animTexParams.x, animTexParams.z);
`;var particleAnimFrameLoopVS=`
	float animFrame = floor(mod(texCoordsAlphaLife.w * animTexParams.y + animTexParams.x, animTexParams.z + 1.0));
`;var particleAnimTexVS=`
	float animationIndex;
	if (animTexIndexParams.y == 1.0) {
		animationIndex = floor((animTexParams.w + 1.0) * rndFactor3.z) * (animTexParams.z + 1.0);
	} else {
		animationIndex = animTexIndexParams.x * (animTexParams.z + 1.0);
	}
	float atlasX = (animationIndex + animFrame) * animTexTilesParams.x;
	float atlasY = 1.0 - floor(atlasX + 1.0) * animTexTilesParams.y;
	atlasX = fract(atlasX);
	texCoordsAlphaLife.xy *= animTexTilesParams.xy;
	texCoordsAlphaLife.xy += vec2(atlasX, atlasY);
`;var particleInputFloatPS=`
void readInput(float uv) {
	vec4 tex = texture2D(particleTexIN, vec2(uv, 0.25));
	vec4 tex2 = texture2D(particleTexIN, vec2(uv, 0.75));
	inPos = tex.xyz;
	inVel = tex2.xyz;
	inAngle = (tex.w < 0.0? -tex.w : tex.w) - 1000.0;
	inShow = tex.w >= 0.0;
	inLife = tex2.w;
}
`;var particleInputRgba8PS=`
#define PI2 6.283185307179586
uniform vec3 inBoundsSize;
uniform vec3 inBoundsCenter;
uniform float maxVel;
float decodeFloatRG(vec2 rg) {
	return rg.y*(1.0/255.0) + rg.x;
}
float decodeFloatRGBA( vec4 rgba ) {
	return dot( rgba, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/160581375.0) );
}
void readInput(float uv) {
	vec4 tex0 = texture2D(particleTexIN, vec2(uv, 0.125));
	vec4 tex1 = texture2D(particleTexIN, vec2(uv, 0.375));
	vec4 tex2 = texture2D(particleTexIN, vec2(uv, 0.625));
	vec4 tex3 = texture2D(particleTexIN, vec2(uv, 0.875));
	inPos = vec3(decodeFloatRG(tex0.rg), decodeFloatRG(tex0.ba), decodeFloatRG(tex1.rg));
	inPos = (inPos - vec3(0.5)) * inBoundsSize + inBoundsCenter;
	inVel = tex2.xyz;
	inVel = (inVel - vec3(0.5)) * maxVel;
	inAngle = decodeFloatRG(tex1.ba) * PI2;
	inShow = tex2.a > 0.5;
	inLife = decodeFloatRGBA(tex3);
	float maxNegLife = max(lifetime, (numParticles - 1.0) * (rate+rateDiv));
	float maxPosLife = lifetime+1.0;
	inLife = inLife * (maxNegLife + maxPosLife) - maxNegLife;
}
`;var particleOutputFloatPS=`
void writeOutput() {
	if (gl_FragCoord.y<1.0) {
		gl_FragColor = vec4(outPos, (outAngle + 1000.0) * visMode);
	} else {
		gl_FragColor = vec4(outVel, outLife);
	}
}
`;var particleOutputRgba8PS=`
uniform vec3 outBoundsMul;
uniform vec3 outBoundsAdd;
vec2 encodeFloatRG( float v ) {
	vec2 enc = vec2(1.0, 255.0) * v;
	enc = fract(enc);
	enc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);
	return enc;
}
vec4 encodeFloatRGBA( float v ) {
	vec4 enc = vec4(1.0, 255.0, 65025.0, 160581375.0) * v;
	enc = fract(enc);
	enc -= enc.yzww * vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);
	return enc;
}
void writeOutput() {
	outPos = outPos * outBoundsMul + outBoundsAdd;
	outAngle = fract(outAngle / PI2);
	outVel = (outVel / maxVel) + vec3(0.5);
	float maxNegLife = max(lifetime, (numParticles - 1.0) * (rate+rateDiv));
	float maxPosLife = lifetime+1.0;
	outLife = (outLife + maxNegLife) / (maxNegLife + maxPosLife);
	if (gl_FragCoord.y < 1.0) {
		gl_FragColor = vec4(encodeFloatRG(outPos.x), encodeFloatRG(outPos.y));
	} else if (gl_FragCoord.y < 2.0) {
		gl_FragColor = vec4(encodeFloatRG(outPos.z), encodeFloatRG(outAngle));
	} else if (gl_FragCoord.y < 3.0) {
		gl_FragColor = vec4(outVel, visMode*0.5+0.5);
	} else {
		gl_FragColor = encodeFloatRGBA(outLife);
	}
}
`;var particleUpdaterAABBPS=`
uniform mat3 spawnBounds;
uniform vec3 spawnPosInnerRatio;
vec3 calcSpawnPosition(vec3 inBounds, float rndFactor) {
	vec3 pos = inBounds - vec3(0.5);
	vec3 posAbs = abs(pos);
	vec3 maxPos = vec3(max(posAbs.x, max(posAbs.y, posAbs.z)));
	vec3 edge = maxPos + (vec3(0.5) - maxPos) * spawnPosInnerRatio;
	pos.x = edge.x * (maxPos.x == posAbs.x ? sign(pos.x) : 2.0 * pos.x);
	pos.y = edge.y * (maxPos.y == posAbs.y ? sign(pos.y) : 2.0 * pos.y);
	pos.z = edge.z * (maxPos.z == posAbs.z ? sign(pos.z) : 2.0 * pos.z);
#ifndef LOCAL_SPACE
	return emitterPos + spawnBounds * pos;
#else
	return spawnBounds * pos;
#endif
}
void addInitialVelocity(inout vec3 localVelocity, vec3 inBounds) {
	localVelocity -= vec3(0, 0, initialVelocity);
}
`;var particleUpdaterEndPS=`
	writeOutput();
}
`;var particleUpdaterInitPS=`
varying vec2 vUv0;
uniform highp sampler2D particleTexIN;
uniform highp sampler2D internalTex0;
uniform highp sampler2D internalTex1;
uniform highp sampler2D internalTex2;
uniform highp sampler2D internalTex3;
uniform mat3 emitterMatrix;
uniform mat3 emitterMatrixInv;
uniform vec3 emitterScale;
uniform vec3 emitterPos;
uniform vec3 frameRandom;
uniform vec3 localVelocityDivMult;
uniform vec3 velocityDivMult;
uniform float delta;
uniform float rate;
uniform float rateDiv;
uniform float lifetime;
uniform float numParticles;
uniform float rotSpeedDivMult;
uniform float radialSpeedDivMult;
uniform float seed;
uniform float startAngle;
uniform float startAngle2;
uniform float initialVelocity;
uniform float graphSampleSize;
uniform float graphNumSamples;
vec3 inPos;
vec3 inVel;
float inAngle;
bool inShow;
float inLife;
float visMode;
vec3 outPos;
vec3 outVel;
float outAngle;
bool outShow;
float outLife;
`;var particleUpdaterNoRespawnPS=`
	if (outLife >= lifetime) {
		outLife -= max(lifetime, (numParticles - 1.0) * particleRate);
		visMode = -1.0;
	}
`;var particleUpdaterOnStopPS=`
	visMode = outLife < 0.0? -1.0: visMode;
`;var particleUpdaterRespawnPS=`
	if (outLife >= lifetime) {
		outLife -= max(lifetime, (numParticles - 1.0) * particleRate);
		visMode = 1.0;
	}
	visMode = outLife < 0.0? 1.0: visMode;
`;var particleUpdaterSpherePS=`
uniform float spawnBoundsSphere;
uniform float spawnBoundsSphereInnerRatio;
vec3 calcSpawnPosition(vec3 inBounds, float rndFactor) {
	float rnd4 = fract(rndFactor * 1000.0);
	vec3 norm = normalize(inBounds.xyz - vec3(0.5));
	float r = rnd4 * (1.0 - spawnBoundsSphereInnerRatio) + spawnBoundsSphereInnerRatio;
#ifndef LOCAL_SPACE
	return emitterPos + norm * r * spawnBoundsSphere;
#else
	return norm * r * spawnBoundsSphere;
#endif
}
void addInitialVelocity(inout vec3 localVelocity, vec3 inBounds) {
	localVelocity += normalize(inBounds - vec3(0.5)) * initialVelocity;
}
`;var particleUpdaterStartPS=`
float saturate(float x) {
	return clamp(x, 0.0, 1.0);
}
vec3 unpack3NFloats(float src) {
	float r = fract(src);
	float g = fract(src * 256.0);
	float b = fract(src * 65536.0);
	return vec3(r, g, b);
}
vec3 tex1Dlod_lerp(TEXTURE_ACCEPT_HIGHP(tex), vec2 tc, out vec3 w) {
	vec4 a = texture2D(tex, tc);
	vec4 b = texture2D(tex, tc + graphSampleSize);
	float c = fract(tc.x * graphNumSamples);
	vec3 unpackedA = unpack3NFloats(a.w);
	vec3 unpackedB = unpack3NFloats(b.w);
	w = mix(unpackedA, unpackedB, c);
	return mix(a.xyz, b.xyz, c);
}
#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)
vec4 hash41(float p) {
	vec4 p4 = fract(vec4(p) * HASHSCALE4);
	p4 += dot(p4, p4.wzxy+19.19);
	return fract(vec4((p4.x + p4.y)*p4.z, (p4.x + p4.z)*p4.y, (p4.y + p4.z)*p4.w, (p4.z + p4.w)*p4.x));
}
void main(void) {
	if (gl_FragCoord.x > numParticles) discard;
	readInput(vUv0.x);
	visMode = inShow? 1.0 : -1.0;
	vec4 rndFactor = hash41(gl_FragCoord.x + seed);
	float particleRate = rate + rateDiv * rndFactor.x;
	outLife = inLife + delta;
	float nlife = clamp(outLife / lifetime, 0.0, 1.0);
	vec3 localVelocityDiv;
	vec3 velocityDiv;
	vec3 paramDiv;
	vec3 localVelocity = tex1Dlod_lerp(TEXTURE_PASS(internalTex0), vec2(nlife, 0), localVelocityDiv);
	vec3 velocity =	  tex1Dlod_lerp(TEXTURE_PASS(internalTex1), vec2(nlife, 0), velocityDiv);
	vec3 params =		tex1Dlod_lerp(TEXTURE_PASS(internalTex2), vec2(nlife, 0), paramDiv);
	float rotSpeed = params.x;
	float rotSpeedDiv = paramDiv.y;
	vec3 radialParams = tex1Dlod_lerp(TEXTURE_PASS(internalTex3), vec2(nlife, 0), paramDiv);
	float radialSpeed = radialParams.x;
	float radialSpeedDiv = radialParams.y;
	bool respawn = inLife <= 0.0 || outLife >= lifetime;
	inPos = respawn ? calcSpawnPosition(rndFactor.xyz, rndFactor.x) : inPos;
	inAngle = respawn ? mix(startAngle, startAngle2, rndFactor.x) : inAngle;
#ifndef LOCAL_SPACE
	vec3 radialVel = inPos - emitterPos;
#else
	vec3 radialVel = inPos;
#endif
	radialVel = (dot(radialVel, radialVel) > 1.0E-8) ? radialSpeed * normalize(radialVel) : vec3(0.0);
	radialVel += (radialSpeedDiv * vec3(2.0) - vec3(1.0)) * radialSpeedDivMult * rndFactor.xyz;
	localVelocity +=	(localVelocityDiv * vec3(2.0) - vec3(1.0)) * localVelocityDivMult * rndFactor.xyz;
	velocity +=		 (velocityDiv * vec3(2.0) - vec3(1.0)) * velocityDivMult * rndFactor.xyz;
	rotSpeed +=		 (rotSpeedDiv * 2.0 - 1.0) * rotSpeedDivMult * rndFactor.y;
	addInitialVelocity(localVelocity, rndFactor.xyz);
#ifndef LOCAL_SPACE
	outVel = emitterMatrix * localVelocity + (radialVel + velocity) * emitterScale;
#else
	outVel = (localVelocity + radialVel) / emitterScale + emitterMatrixInv * velocity;
#endif
	outPos = inPos + outVel * delta;
	outAngle = inAngle + rotSpeed * delta;
`;var particle_billboardVS=`
	quadXY = rotate(quadXY, inAngle, rotMatrix);
	vec3 localPos = billboard(particlePos, quadXY);
`;var particle_blendAddPS=`
	dBlendModeFogFactor = 0.0;
	rgb *= saturate(gammaCorrectInput(max(a, 0.0)));
	if ((rgb.r + rgb.g + rgb.b) < 0.000001) discard;
`;var particle_blendMultiplyPS=`
	rgb = mix(vec3(1.0), rgb, vec3(a));
	if (rgb.r + rgb.g + rgb.b > 2.99) discard;
`;var particle_blendNormalPS=`
	if (a < 0.01) discard;
`;var particle_cpuVS=`
attribute vec4 particle_vertexData;
attribute vec4 particle_vertexData2;
attribute vec4 particle_vertexData3;
attribute float particle_vertexData4;
#ifndef USE_MESH
attribute vec2 particle_vertexData5;
#else
attribute vec4 particle_vertexData5;
#endif
uniform mat4 matrix_viewProjection;
uniform mat4 matrix_model;
#ifndef VIEWMATRIX
#define VIEWMATRIX
uniform mat4 matrix_view;
#endif
uniform mat3 matrix_normal;
uniform mat4 matrix_viewInverse;
uniform float numParticles;
uniform float lifetime;
uniform float stretch;
uniform float seed;
uniform vec3 wrapBounds;
uniform vec3 emitterScale;
uniform vec3 faceTangent;
uniform vec3 faceBinorm;
#ifdef PARTICLE_GPU
	uniform highp sampler2D internalTex0;
	uniform highp sampler2D internalTex1;
	uniform highp sampler2D internalTex2;
#endif
uniform vec3 emitterPos;
varying vec4 texCoordsAlphaLife;
vec2 rotate(vec2 quadXY, float pRotation, out mat2 rotMatrix)
{
	float c = cos(pRotation);
	float s = sin(pRotation);
	mat2 m = mat2(c, -s, s, c);
	rotMatrix = m;
	return m * quadXY;
}
vec3 billboard(vec3 InstanceCoords, vec2 quadXY)
{
	vec3 pos = -matrix_viewInverse[0].xyz * quadXY.x + -matrix_viewInverse[1].xyz * quadXY.y;
	return pos;
}
vec3 customFace(vec3 InstanceCoords, vec2 quadXY)
{
	vec3 pos = faceTangent * quadXY.x + faceBinorm * quadXY.y;
	return pos;
}
void main(void)
{
	vec3 particlePos = particle_vertexData.xyz;
	vec3 inPos = particlePos;
	vec3 vertPos = particle_vertexData3.xyz;
	vec3 inVel = vec3(particle_vertexData2.w, particle_vertexData3.w, particle_vertexData5.x);
	float id = floor(particle_vertexData4);
	float rndFactor = fract(sin(id + 1.0 + seed));
	vec3 rndFactor3 = vec3(rndFactor, fract(rndFactor*10.0), fract(rndFactor*100.0));
#ifdef LOCAL_SPACE
	inVel = mat3(matrix_model) * inVel;
#endif
	vec2 velocityV = normalize((mat3(matrix_view) * inVel).xy);
	vec2 quadXY = vertPos.xy;
#ifdef USE_MESH
	texCoordsAlphaLife = vec4(particle_vertexData5.zw, particle_vertexData2.z, particle_vertexData.w);
#else
	texCoordsAlphaLife = vec4(quadXY * -0.5 + 0.5, particle_vertexData2.z, particle_vertexData.w);
#endif
	mat2 rotMatrix;
	float inAngle = particle_vertexData2.x;
	vec3 particlePosMoved = vec3(0.0);
	vec3 meshLocalPos = particle_vertexData3.xyz;
`;var particle_cpu_endVS=`
	localPos *= particle_vertexData2.y * emitterScale;
	localPos += particlePos;
	gl_Position = matrix_viewProjection * vec4(localPos, 1.0);
`;var particle_customFaceVS=`
	quadXY = rotate(quadXY, inAngle, rotMatrix);
	vec3 localPos = customFace(particlePos, quadXY);
`;var particle_endPS=`
	rgb = addFog(rgb);
	rgb = toneMap(rgb);
	rgb = gammaCorrectOutput(rgb);
	gl_FragColor = vec4(rgb, a);
}
`;var particle_endVS=`
	localPos *= scale * emitterScale;
	localPos += particlePos;
	#ifdef SCREEN_SPACE
	gl_Position = vec4(localPos.x, localPos.y, 0.0, 1.0);
	#else
	gl_Position = matrix_viewProjection * vec4(localPos.xyz, 1.0);
	#endif
`;var particle_halflambertPS=`
	vec3 negNormal = normal*0.5+0.5;
	vec3 posNormal = -normal*0.5+0.5;
	negNormal *= negNormal;
	posNormal *= posNormal;
`;var particle_initVS=`
attribute vec4 particle_vertexData;
#ifdef USE_MESH
attribute vec2 particle_uv;
#endif
uniform mat4 matrix_viewProjection;
uniform mat4 matrix_model;
uniform mat3 matrix_normal;
uniform mat4 matrix_viewInverse;
#ifndef VIEWMATRIX
#define VIEWMATRIX
uniform mat4 matrix_view;
#endif
uniform float numParticles;
uniform float numParticlesPot;
uniform float graphSampleSize;
uniform float graphNumSamples;
uniform float stretch;
uniform vec3 wrapBounds;
uniform vec3 emitterScale;
uniform vec3 emitterPos;
uniform vec3 faceTangent;
uniform vec3 faceBinorm;
uniform float rate;
uniform float rateDiv;
uniform float lifetime;
uniform float deltaRandomnessStatic;
uniform float scaleDivMult;
uniform float alphaDivMult;
uniform float seed;
uniform float delta;
uniform sampler2D particleTexOUT;
uniform sampler2D particleTexIN;
#ifdef PARTICLE_GPU
	uniform highp sampler2D internalTex0;
	uniform highp sampler2D internalTex1;
	uniform highp sampler2D internalTex2;
#endif
#ifndef CAMERAPLANES
#define CAMERAPLANES
uniform vec4 camera_params;
#endif
varying vec4 texCoordsAlphaLife;
vec3 inPos;
vec3 inVel;
float inAngle;
bool inShow;
float inLife;
`;var particle_lambertPS=`
	vec3 negNormal = max(normal, vec3(0.0));
	vec3 posNormal = max(-normal, vec3(0.0));
`;var particle_lightingPS=`
	vec3 light = negNormal.x*lightCube[0] + posNormal.x*lightCube[1] +
						negNormal.y*lightCube[2] + posNormal.y*lightCube[3] +
						negNormal.z*lightCube[4] + posNormal.z*lightCube[5];
	rgb *= light;
`;var particle_localShiftVS=`
	particlePos = (matrix_model * vec4(particlePos, 1.0)).xyz;
`;var particle_meshVS=`
	vec3 localPos = meshLocalPos;
	localPos.xy = rotate(localPos.xy, inAngle, rotMatrix);
	localPos.yz = rotate(localPos.yz, inAngle, rotMatrix);
	billboard(particlePos, quadXY);
`;var particle_normalVS=`
	Normal = normalize(localPos + matrix_viewInverse[2].xyz);
`;var particle_normalMapPS=`
	vec3 normalMap = normalize(texture2D(normalMap, vec2(texCoordsAlphaLife.x, 1.0 - texCoordsAlphaLife.y)).xyz * 2.0 - 1.0);
	vec3 normal = ParticleMat * normalMap;
`;var particle_pointAlongVS=`
	inAngle = atan(velocityV.x, velocityV.y);
`;var particle_softPS=`
	float depth = getLinearScreenDepth();
	float particleDepth = vDepth;
	float depthDiff = saturate(abs(particleDepth - depth) * softening);
	a *= depthDiff;
`;var particle_softVS=`
	vDepth = getLinearDepth(localPos);
`;var particle_stretchVS=`
	vec3 moveDir = inVel * stretch;
	vec3 posPrev = particlePos - moveDir;
	posPrev += particlePosMoved;
	vec2 centerToVertexV = normalize((mat3(matrix_view) * localPos).xy);
	float interpolation = dot(-velocityV, centerToVertexV) * 0.5 + 0.5;
	particlePos = mix(particlePos, posPrev, interpolation);
`;var particle_TBNVS=`
	mat3 rot3 = mat3(rotMatrix[0][0], rotMatrix[0][1], 0.0, rotMatrix[1][0], rotMatrix[1][1], 0.0, 0.0, 0.0, 1.0);
	ParticleMat = mat3(-matrix_viewInverse[0].xyz, -matrix_viewInverse[1].xyz, matrix_viewInverse[2].xyz) * rot3;
`;var particle_wrapVS=`
	vec3 origParticlePos = particlePos;
	particlePos -= matrix_model[3].xyz;
	particlePos = mod(particlePos, wrapBounds) - wrapBounds * 0.5;
	particlePos += matrix_model[3].xyz;
	particlePosMoved = particlePos - origParticlePos;
`;var reflDirPS=`
void getReflDir(vec3 worldNormal, vec3 viewDir, float gloss, mat3 tbn) {
	dReflDirW = normalize(-reflect(viewDir, worldNormal));
}
`;var reflDirAnisoPS=`
void getReflDir(vec3 worldNormal, vec3 viewDir, float gloss, mat3 tbn) {
	float roughness = sqrt(1.0 - min(gloss, 1.0));
	float anisotropy = material_anisotropy * roughness;
	vec3 anisotropicDirection = anisotropy >= 0.0 ? tbn[1] : tbn[0];
	vec3 anisotropicTangent = cross(anisotropicDirection, viewDir);
	vec3 anisotropicNormal = cross(anisotropicTangent, anisotropicDirection);
	vec3 bentNormal = normalize(mix(normalize(worldNormal), normalize(anisotropicNormal), anisotropy));
	dReflDirW = reflect(-viewDir, bentNormal);
}
`;var reflectionCCPS=`
#ifdef LIT_CLEARCOAT
void addReflectionCC(vec3 reflDir, float gloss) {
	ccReflection += calcReflection(reflDir, gloss);
}
#endif
`;var reflectionCubePS=`
uniform samplerCube texture_cubeMap;
uniform float material_reflectivity;
vec3 calcReflection(vec3 reflDir, float gloss) {
	vec3 lookupVec = fixSeams(cubeMapProject(reflDir));
	lookupVec.x *= -1.0;
	return $DECODE(textureCube(texture_cubeMap, lookupVec));
}
void addReflection(vec3 reflDir, float gloss) {   
	dReflection += vec4(calcReflection(reflDir, gloss), material_reflectivity);
}
`;var reflectionEnvHQPS=`
#ifndef ENV_ATLAS
#define ENV_ATLAS
uniform sampler2D texture_envAtlas;
#endif
uniform samplerCube texture_cubeMap;
uniform float material_reflectivity;
vec3 calcReflection(vec3 reflDir, float gloss) {
	vec3 dir = cubeMapProject(reflDir) * vec3(-1.0, 1.0, 1.0);
	vec2 uv = toSphericalUv(dir);
	float level = saturate(1.0 - gloss) * 5.0;
	float ilevel = floor(level);
	float flevel = level - ilevel;
	vec3 sharp = $DECODE_CUBEMAP(textureCube(texture_cubeMap, fixSeams(dir)));
	vec3 roughA = $DECODE(texture2D(texture_envAtlas, mapRoughnessUv(uv, ilevel)));
	vec3 roughB = $DECODE(texture2D(texture_envAtlas, mapRoughnessUv(uv, ilevel + 1.0)));
	return processEnvironment(mix(sharp, mix(roughA, roughB, flevel), min(level, 1.0)));
}
void addReflection(vec3 reflDir, float gloss) {   
	dReflection += vec4(calcReflection(reflDir, gloss), material_reflectivity);
}
`;var reflectionEnvPS=`
#ifndef ENV_ATLAS
#define ENV_ATLAS
uniform sampler2D texture_envAtlas;
#endif
uniform float material_reflectivity;
float shinyMipLevel(vec2 uv) {
	vec2 dx = dFdx(uv);
	vec2 dy = dFdy(uv);
	vec2 uv2 = vec2(fract(uv.x + 0.5), uv.y);
	vec2 dx2 = dFdx(uv2);
	vec2 dy2 = dFdy(uv2);
	float maxd = min(max(dot(dx, dx), dot(dy, dy)), max(dot(dx2, dx2), dot(dy2, dy2)));
	return clamp(0.5 * log2(maxd) - 1.0 + textureBias, 0.0, 5.0);
}
vec3 calcReflection(vec3 reflDir, float gloss) {
	vec3 dir = cubeMapProject(reflDir) * vec3(-1.0, 1.0, 1.0);
	vec2 uv = toSphericalUv(dir);
	float level = saturate(1.0 - gloss) * 5.0;
	float ilevel = floor(level);
	float level2 = shinyMipLevel(uv * atlasSize);
	float ilevel2 = floor(level2);
	vec2 uv0, uv1;
	float weight;
	if (ilevel == 0.0) {
		uv0 = mapShinyUv(uv, ilevel2);
		uv1 = mapShinyUv(uv, ilevel2 + 1.0);
		weight = level2 - ilevel2;
	} else {
		uv0 = uv1 = mapRoughnessUv(uv, ilevel);
		weight = 0.0;
	}
	vec3 linearA = $DECODE(texture2D(texture_envAtlas, uv0));
	vec3 linearB = $DECODE(texture2D(texture_envAtlas, uv1));
	vec3 linear0 = mix(linearA, linearB, weight);
	vec3 linear1 = $DECODE(texture2D(texture_envAtlas, mapRoughnessUv(uv, ilevel + 1.0)));
	return processEnvironment(mix(linear0, linear1, level - ilevel));
}
void addReflection(vec3 reflDir, float gloss) {   
	dReflection += vec4(calcReflection(reflDir, gloss), material_reflectivity);
}
`;var reflectionSpherePS=`
#ifndef VIEWMATRIX
#define VIEWMATRIX
uniform mat4 matrix_view;
#endif
uniform sampler2D texture_sphereMap;
uniform float material_reflectivity;
vec3 calcReflection(vec3 reflDir, float gloss) {
	vec3 reflDirV = (mat3(matrix_view) * reflDir).xyz;
	float m = 2.0 * sqrt( dot(reflDirV.xy, reflDirV.xy) + (reflDirV.z+1.0)*(reflDirV.z+1.0) );
	vec2 sphereMapUv = reflDirV.xy / m + 0.5;
	return $DECODE(texture2D(texture_sphereMap, sphereMapUv));
}
void addReflection(vec3 reflDir, float gloss) {   
	dReflection += vec4(calcReflection(reflDir, gloss), material_reflectivity);
}
`;var reflectionSheenPS=`
void addReflectionSheen(vec3 worldNormal, vec3 viewDir, float gloss) {
	float NoV = dot(worldNormal, viewDir);
	float alphaG = gloss * gloss;
	float a = gloss < 0.25 ? -339.2 * alphaG + 161.4 * gloss - 25.9 : -8.48 * alphaG + 14.3 * gloss - 9.95;
	float b = gloss < 0.25 ? 44.0 * alphaG - 23.7 * gloss + 3.26 : 1.97 * alphaG - 3.27 * gloss + 0.72;
	float DG = exp( a * NoV + b ) + ( gloss < 0.25 ? 0.0 : 0.1 * ( gloss - 0.25 ) );
	sReflection += calcReflection(worldNormal, 0.0) * saturate(DG);
}
`;var refractionCubePS=`
vec3 refract2(vec3 viewVec, vec3 normal, float IOR) {
	float vn = dot(viewVec, normal);
	float k = 1.0 - IOR * IOR * (1.0 - vn * vn);
	vec3 refrVec = IOR * viewVec - (IOR * vn + sqrt(k)) * normal;
	return refrVec;
}
void addRefraction(
	vec3 worldNormal, 
	vec3 viewDir, 
	float thickness, 
	float gloss, 
	vec3 specularity, 
	vec3 albedo, 
	float transmission,
	float refractionIndex,
	float dispersion
#if defined(LIT_IRIDESCENCE)
	, vec3 iridescenceFresnel,
	float iridescenceIntensity
#endif 
) {
	vec4 tmpRefl = dReflection;
	vec3 reflectionDir = refract2(-viewDir, worldNormal, refractionIndex);
	dReflection = vec4(0);
	addReflection(reflectionDir, gloss);
	dDiffuseLight = mix(dDiffuseLight, dReflection.rgb * albedo, transmission);
	dReflection = tmpRefl;
}
`;var refractionDynamicPS=`
uniform float material_invAttenuationDistance;
uniform vec3 material_attenuation;
vec3 evalRefractionColor(vec3 refractionVector, float gloss, float refractionIndex) {
	vec4 pointOfRefraction = vec4(vPositionW + refractionVector, 1.0);
	vec4 projectionPoint = matrix_viewProjection * pointOfRefraction;
	vec2 uv = getGrabScreenPos(projectionPoint);
	#ifdef SUPPORTS_TEXLOD
		float iorToRoughness = (1.0 - gloss) * clamp((1.0 / refractionIndex) * 2.0 - 2.0, 0.0, 1.0);
		float refractionLod = log2(uScreenSize.x) * iorToRoughness;
		vec3 refraction = texture2DLodEXT(uSceneColorMap, uv, refractionLod).rgb;
	#else
		vec3 refraction = texture2D(uSceneColorMap, uv).rgb;
	#endif
	return refraction;
}
void addRefraction(
	vec3 worldNormal, 
	vec3 viewDir, 
	float thickness, 
	float gloss, 
	vec3 specularity, 
	vec3 albedo, 
	float transmission,
	float refractionIndex,
	float dispersion
#if defined(LIT_IRIDESCENCE)
	, vec3 iridescenceFresnel,
	float iridescenceIntensity
#endif
) {
	vec3 modelScale;
	modelScale.x = length(vec3(matrix_model[0].xyz));
	modelScale.y = length(vec3(matrix_model[1].xyz));
	modelScale.z = length(vec3(matrix_model[2].xyz));
	vec3 scale = thickness * modelScale;
	vec3 refractionVector = normalize(refract(-viewDir, worldNormal, refractionIndex)) * scale;
	vec3 refraction = evalRefractionColor(refractionVector, gloss, refractionIndex);
	#ifdef DISPERSION
		float halfSpread = (1.0 / refractionIndex - 1.0) * 0.025 * dispersion;
		float refractionIndexR = refractionIndex - halfSpread;
		refractionVector = normalize(refract(-viewDir, worldNormal, refractionIndexR)) * scale;
		refraction.r = evalRefractionColor(refractionVector, gloss, refractionIndexR).r;
		float refractionIndexB = refractionIndex + halfSpread;
		refractionVector = normalize(refract(-viewDir, worldNormal, refractionIndexB)) * scale;
		refraction.b = evalRefractionColor(refractionVector, gloss, refractionIndexB).b;
	#endif
	vec3 transmittance;
	if (material_invAttenuationDistance != 0.0)
	{
		vec3 attenuation = -log(material_attenuation) * material_invAttenuationDistance;
		transmittance = exp(-attenuation * length(refractionVector));
	}
	else
	{
		transmittance = refraction;
	}
	vec3 fresnel = vec3(1.0) - 
		getFresnel(
			dot(viewDir, worldNormal), 
			gloss, 
			specularity
		#if defined(LIT_IRIDESCENCE)
			, iridescenceFresnel,
			iridescenceIntensity
		#endif
		);
	dDiffuseLight = mix(dDiffuseLight, refraction * transmittance * fresnel, transmission);
}
`;var reprojectPS=`
varying vec2 vUv0;
#ifdef CUBEMAP_SOURCE
	uniform samplerCube sourceCube;
#else
	uniform sampler2D sourceTex;
#endif
#ifdef USE_SAMPLES_TEX
	uniform sampler2D samplesTex;
	uniform vec2 samplesTexInverseSize;
#endif
uniform vec3 params;
float targetFace() { return params.x; }
float sourceCubeSeamScale() { return params.y; }
float targetCubeSeamScale() { return params.z; }
float PI = 3.141592653589793;
float saturate(float x) {
	return clamp(x, 0.0, 1.0);
}
${decodePS}
${encodePS}
vec3 modifySeams(vec3 dir, float scale) {
	vec3 adir = abs(dir);
	float M = max(max(adir.x, adir.y), adir.z);
	return dir / M * vec3(
		adir.x == M ? 1.0 : scale,
		adir.y == M ? 1.0 : scale,
		adir.z == M ? 1.0 : scale
	);
}
vec2 toSpherical(vec3 dir) {
	return vec2(dir.xz == vec2(0.0) ? 0.0 : atan(dir.x, dir.z), asin(dir.y));
}
vec3 fromSpherical(vec2 uv) {
	return vec3(cos(uv.y) * sin(uv.x),
				sin(uv.y),
				cos(uv.y) * cos(uv.x));
}
vec3 getDirectionEquirect() {
	return fromSpherical((vec2(vUv0.x, 1.0 - vUv0.y) * 2.0 - 1.0) * vec2(PI, PI * 0.5));
}
float signNotZero(float k){
	return(k >= 0.0) ? 1.0 : -1.0;
}
vec2 signNotZero(vec2 v) {
	return vec2(signNotZero(v.x), signNotZero(v.y));
}
vec3 octDecode(vec2 o) {
	vec3 v = vec3(o.x, 1.0 - abs(o.x) - abs(o.y), o.y);
	if (v.y < 0.0) {
		v.xz = (1.0 - abs(v.zx)) * signNotZero(v.xz);
	}
	return normalize(v);
}
vec3 getDirectionOctahedral() {
	return octDecode(vec2(vUv0.x, 1.0 - vUv0.y) * 2.0 - 1.0);
}
vec2 octEncode(in vec3 v) {
	float l1norm = abs(v.x) + abs(v.y) + abs(v.z);
	vec2 result = v.xz * (1.0 / l1norm);
	if (v.y < 0.0) {
		result = (1.0 - abs(result.yx)) * signNotZero(result.xy);
	}
	return result;
}
#ifdef CUBEMAP_SOURCE
	vec4 sampleCubemap(vec3 dir) {
		return textureCube(sourceCube, modifySeams(dir, 1.0 - sourceCubeSeamScale()));
	}
	vec4 sampleCubemap(vec2 sph) {
	return sampleCubemap(fromSpherical(sph));
}
	vec4 sampleCubemap(vec3 dir, float mipLevel) {
		return textureCubeLodEXT(sourceCube, modifySeams(dir, 1.0 - exp2(mipLevel) * sourceCubeSeamScale()), mipLevel);
	}
	vec4 sampleCubemap(vec2 sph, float mipLevel) {
		return sampleCubemap(fromSpherical(sph), mipLevel);
	}
#else
	vec4 sampleEquirect(vec2 sph) {
		vec2 uv = sph / vec2(PI * 2.0, PI) + 0.5;
		return texture2D(sourceTex, vec2(uv.x, 1.0 - uv.y));
	}
	vec4 sampleEquirect(vec3 dir) {
		return sampleEquirect(toSpherical(dir));
	}
	vec4 sampleEquirect(vec2 sph, float mipLevel) {
		vec2 uv = sph / vec2(PI * 2.0, PI) + 0.5;
		return texture2DLodEXT(sourceTex, vec2(uv.x, 1.0 - uv.y), mipLevel);
	}
	vec4 sampleEquirect(vec3 dir, float mipLevel) {
		return sampleEquirect(toSpherical(dir), mipLevel);
	}
	vec4 sampleOctahedral(vec3 dir) {
		vec2 uv = octEncode(dir) * 0.5 + 0.5;
		return texture2D(sourceTex, vec2(uv.x, 1.0 - uv.y));
	}
	vec4 sampleOctahedral(vec2 sph) {
		return sampleOctahedral(fromSpherical(sph));
	}
	vec4 sampleOctahedral(vec3 dir, float mipLevel) {
		vec2 uv = octEncode(dir) * 0.5 + 0.5;
		return texture2DLodEXT(sourceTex, vec2(uv.x, 1.0 - uv.y), mipLevel);
	}
	vec4 sampleOctahedral(vec2 sph, float mipLevel) {
		return sampleOctahedral(fromSpherical(sph), mipLevel);
	}
#endif
vec3 getDirectionCubemap() {
	vec2 st = vUv0 * 2.0 - 1.0;
	float face = targetFace();
	vec3 vec;
	if (face == 0.0) {
		vec = vec3(1, -st.y, -st.x);
	} else if (face == 1.0) {
		vec = vec3(-1, -st.y, st.x);
	} else if (face == 2.0) {
		vec = vec3(st.x, 1, st.y);
	} else if (face == 3.0) {
		vec = vec3(st.x, -1, -st.y);
	} else if (face == 4.0) {
		vec = vec3(st.x, -st.y, 1);
	} else {
		vec = vec3(-st.x, -st.y, -1);
	}
	return normalize(modifySeams(vec, 1.0 / (1.0 - targetCubeSeamScale())));
}
mat3 matrixFromVector(vec3 n) {
	float a = 1.0 / (1.0 + n.z);
	float b = -n.x * n.y * a;
	vec3 b1 = vec3(1.0 - n.x * n.x * a, b, -n.x);
	vec3 b2 = vec3(b, 1.0 - n.y * n.y * a, -n.y);
	return mat3(b1, b2, n);
}
mat3 matrixFromVectorSlow(vec3 n) {
	vec3 up = (1.0 - abs(n.y) <= 0.0000001) ? vec3(0.0, 0.0, n.y > 0.0 ? 1.0 : -1.0) : vec3(0.0, 1.0, 0.0);
	vec3 x = normalize(cross(up, n));
	vec3 y = cross(n, x);
	return mat3(x, y, n);
}
vec4 reproject() {
	if (NUM_SAMPLES <= 1) {
		return ENCODE_FUNC(DECODE_FUNC(SOURCE_FUNC(TARGET_FUNC())));
	} else {
		vec3 t = TARGET_FUNC();
		vec3 tu = dFdx(t);
		vec3 tv = dFdy(t);
		vec3 result = vec3(0.0);
		for (float u = 0.0; u < NUM_SAMPLES_SQRT; ++u) {
			for (float v = 0.0; v < NUM_SAMPLES_SQRT; ++v) {
				result += DECODE_FUNC(SOURCE_FUNC(normalize(t +
															tu * (u / NUM_SAMPLES_SQRT - 0.5) +
															tv * (v / NUM_SAMPLES_SQRT - 0.5))));
			}
		}
		return ENCODE_FUNC(result / (NUM_SAMPLES_SQRT * NUM_SAMPLES_SQRT));
	}
}
vec4 unpackFloat = vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0);
#ifdef USE_SAMPLES_TEX
	void unpackSample(int i, out vec3 L, out float mipLevel) {
		float u = (float(i * 4) + 0.5) * samplesTexInverseSize.x;
		float v = (floor(u) + 0.5) * samplesTexInverseSize.y;
		vec4 raw;
		raw.x = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat); u += samplesTexInverseSize.x;
		raw.y = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat); u += samplesTexInverseSize.x;
		raw.z = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat); u += samplesTexInverseSize.x;
		raw.w = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat);
		L.xyz = raw.xyz * 2.0 - 1.0;
		mipLevel = raw.w * 8.0;
	}
	vec4 prefilterSamples() {
		mat3 vecSpace = matrixFromVectorSlow(TARGET_FUNC());
		vec3 L;
		float mipLevel;
		vec3 result = vec3(0.0);
		float totalWeight = 0.0;
		for (int i = 0; i < NUM_SAMPLES; ++i) {
			unpackSample(i, L, mipLevel);
			result += DECODE_FUNC(SOURCE_FUNC(vecSpace * L, mipLevel)) * L.z;
			totalWeight += L.z;
		}
		return ENCODE_FUNC(result / totalWeight);
	}
	vec4 prefilterSamplesUnweighted() {
		mat3 vecSpace = matrixFromVectorSlow(TARGET_FUNC());
		vec3 L;
		float mipLevel;
		vec3 result = vec3(0.0);
		float totalWeight = 0.0;
		for (int i = 0; i < NUM_SAMPLES; ++i) {
			unpackSample(i, L, mipLevel);
			result += DECODE_FUNC(SOURCE_FUNC(vecSpace * L, mipLevel));
		}
		return ENCODE_FUNC(result / float(NUM_SAMPLES));
	}
#endif
void main(void) {
	gl_FragColor = PROCESS_FUNC();
}
`;var sampleCatmullRomPS=`
vec4 SampleTextureCatmullRom(TEXTURE_ACCEPT(tex), vec2 uv, vec2 texSize) {
	vec2 samplePos = uv * texSize;
	vec2 texPos1 = floor(samplePos - 0.5) + 0.5;
	vec2 f = samplePos - texPos1;
	vec2 w0 = f * (-0.5 + f * (1.0 - 0.5 * f));
	vec2 w1 = 1.0 + f * f * (-2.5 + 1.5 * f);
	vec2 w2 = f * (0.5 + f * (2.0 - 1.5 * f));
	vec2 w3 = f * f * (-0.5 + 0.5 * f);
	vec2 w12 = w1 + w2;
	vec2 offset12 = w2 / (w1 + w2);
	vec2 texPos0 = (texPos1 - 1.0) / texSize;
	vec2 texPos3 = (texPos1 + 2.0) / texSize;
	vec2 texPos12 = (texPos1 + offset12) / texSize;
	vec4 result = vec4(0.0);
	result += texture2DLodEXT(tex, vec2(texPos0.x, texPos0.y), 0.0) * w0.x * w0.y;
	result += texture2DLodEXT(tex, vec2(texPos12.x, texPos0.y), 0.0) * w12.x * w0.y;
	result += texture2DLodEXT(tex, vec2(texPos3.x, texPos0.y), 0.0) * w3.x * w0.y;
	result += texture2DLodEXT(tex, vec2(texPos0.x, texPos12.y), 0.0) * w0.x * w12.y;
	result += texture2DLodEXT(tex, vec2(texPos12.x, texPos12.y), 0.0) * w12.x * w12.y;
	result += texture2DLodEXT(tex, vec2(texPos3.x, texPos12.y), 0.0) * w3.x * w12.y;
	result += texture2DLodEXT(tex, vec2(texPos0.x, texPos3.y), 0.0) * w0.x * w3.y;
	result += texture2DLodEXT(tex, vec2(texPos12.x, texPos3.y), 0.0) * w12.x * w3.y;
	result += texture2DLodEXT(tex, vec2(texPos3.x, texPos3.y), 0.0) * w3.x * w3.y;
	return result;
}
`;var screenDepthPS=`
uniform highp sampler2D uSceneDepthMap;
#ifndef SCREENSIZE
#define SCREENSIZE
uniform vec4 uScreenSize;
#endif
#ifndef VIEWMATRIX
#define VIEWMATRIX
uniform mat4 matrix_view;
#endif
#ifndef LINEARIZE_DEPTH
#ifndef CAMERAPLANES
#define CAMERAPLANES
uniform vec4 camera_params;
#endif
#define LINEARIZE_DEPTH
#ifdef GL2
float linearizeDepth(float z) {
	if (camera_params.w == 0.0)
		return (camera_params.z * camera_params.y) / (camera_params.y + z * (camera_params.z - camera_params.y));
	else
		return camera_params.z + z * (camera_params.y - camera_params.z);
}
#else
#ifndef UNPACKFLOAT
#define UNPACKFLOAT
float unpackFloat(vec4 rgbaDepth) {
	const vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);
	return dot(rgbaDepth, bitShift);
}
#endif
#endif
#endif
float getLinearScreenDepth(vec2 uv) {
	#ifdef GL2
		return linearizeDepth(texture2D(uSceneDepthMap, uv).r);
	#else
		return unpackFloat(texture2D(uSceneDepthMap, uv)) * camera_params.y;
	#endif
}
#ifndef VERTEXSHADER
float getLinearScreenDepth() {
	vec2 uv = gl_FragCoord.xy * uScreenSize.zw;
	return getLinearScreenDepth(uv);
}
#endif
float getLinearDepth(vec3 pos) {
	return -(matrix_view * vec4(pos, 1.0)).z;
}
`;var shadowCascadesPS=`
const float maxCascades = 4.0;
mat4 cascadeShadowMat;
void getShadowCascadeMatrix(mat4 shadowMatrixPalette[4], float shadowCascadeDistances[4], float shadowCascadeCount) {
	float depth = 1.0 / gl_FragCoord.w;
	float cascadeIndex = 0.0;
	for (float i = 0.0; i < maxCascades; i++) {
		if (depth < shadowCascadeDistances[int(i)]) {
			cascadeIndex = i;
			break;
		}
	}
	cascadeIndex = min(cascadeIndex, shadowCascadeCount - 1.0);
	#ifdef GL2
		cascadeShadowMat = shadowMatrixPalette[int(cascadeIndex)];
	#else
		if (cascadeIndex == 0.0) {
			cascadeShadowMat = shadowMatrixPalette[0];
		}
		else if (cascadeIndex == 1.0) {
			cascadeShadowMat = shadowMatrixPalette[1];
		}
		else if (cascadeIndex == 2.0) {
			cascadeShadowMat = shadowMatrixPalette[2];
		}
		else {
			cascadeShadowMat = shadowMatrixPalette[3];
		}
	#endif
}
void fadeShadow(float shadowCascadeDistances[4]) {				  
	float depth = 1.0 / gl_FragCoord.w;
	if (depth > shadowCascadeDistances[int(maxCascades - 1.0)]) {
		dShadowCoord.z = -9999999.0;
	}
}
`;var shadowEVSMPS=`
float VSM$(TEXTURE_ACCEPT(tex), vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {
	vec3 moments = texture2D(tex, texCoords).xyz;
	return calculateEVSM(moments, Z, vsmBias, exponent);
}
float getShadowVSM$(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, float exponent, vec3 lightDir) {
	return VSM$(TEXTURE_PASS(shadowMap), shadowCoord.xy, shadowParams.x, shadowCoord.z, shadowParams.y, exponent);
}
float getShadowSpotVSM$(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, float exponent, vec3 lightDir) {
	return VSM$(TEXTURE_PASS(shadowMap), shadowCoord.xy, shadowParams.x, length(lightDir) * shadowParams.w + shadowParams.z, shadowParams.y, exponent);
}
`;var shadowEVSMnPS=`
float VSM$(TEXTURE_ACCEPT(tex), vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {
	float pixelSize = 1.0 / resolution;
	texCoords -= vec2(pixelSize);
	vec3 s00 = texture2D(tex, texCoords).xyz;
	vec3 s10 = texture2D(tex, texCoords + vec2(pixelSize, 0)).xyz;
	vec3 s01 = texture2D(tex, texCoords + vec2(0, pixelSize)).xyz;
	vec3 s11 = texture2D(tex, texCoords + vec2(pixelSize)).xyz;
	vec2 fr = fract(texCoords * resolution);
	vec3 h0 = mix(s00, s10, fr.x);
	vec3 h1 = mix(s01, s11, fr.x);
	vec3 moments = mix(h0, h1, fr.y);
	return calculateEVSM(moments, Z, vsmBias, exponent);
}
float getShadowVSM$(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, float exponent, vec3 lightDir) {
	return VSM$(TEXTURE_PASS(shadowMap), shadowCoord.xy, shadowParams.x, shadowCoord.z, shadowParams.y, exponent);
}
float getShadowSpotVSM$(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, float exponent, vec3 lightDir) {
	return VSM$(TEXTURE_PASS(shadowMap), shadowCoord.xy, shadowParams.x, length(lightDir) * shadowParams.w + shadowParams.z, shadowParams.y, exponent);
}
`;var shadowPCSSPS=`
#define PCSS_SAMPLE_COUNT 16
uniform float pcssDiskSamples[PCSS_SAMPLE_COUNT];
uniform float pcssSphereSamples[PCSS_SAMPLE_COUNT];
vec2 vogelDisk(int sampleIndex, float count, float phi, float r) {
	const float GoldenAngle = 2.4;
	float theta = float(sampleIndex) * GoldenAngle + phi;
	float sine = sin(theta);
	float cosine = cos(theta);
	return vec2(r * cosine, r * sine);
}
vec3 vogelSphere(int sampleIndex, float count, float phi, float r) {
	const float GoldenAngle = 2.4;
	float theta = float(sampleIndex) * GoldenAngle + phi;
	float weight = float(sampleIndex) / count;
	return vec3(cos(theta) * r, weight, sin(theta) * r);
}
float noise(vec2 screenPos) {
	const float PHI = 1.61803398874989484820459;
	return fract(sin(dot(screenPos * PHI, screenPos)) * screenPos.x);
}
#ifndef UNPACKFLOAT
#define UNPACKFLOAT
float unpackFloat(vec4 rgbaDepth) {
	const vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);
	return dot(rgbaDepth, bitShift);
}
#endif
float viewSpaceDepth(float depth, mat4 invProjection) {
	float z = depth * 2.0 - 1.0;
	vec4 clipSpace = vec4(0.0, 0.0, z, 1.0);
	vec4 viewSpace = invProjection * clipSpace;
	return viewSpace.z;
}
float PCSSBlockerDistance(TEXTURE_ACCEPT(shadowMap), vec2 sampleCoords[PCSS_SAMPLE_COUNT], vec2 shadowCoords, vec2 searchSize, float z) {
	float blockers = 0.0;
	float averageBlocker = 0.0;
	for (int i = 0; i < PCSS_SAMPLE_COUNT; i++) {
		vec2 offset = sampleCoords[i] * searchSize;
		vec2 sampleUV = shadowCoords + offset;
	#ifdef GL2
		float blocker = textureLod(shadowMap, sampleUV, 0.0).r;
	#else
		float blocker = unpackFloat(texture2D(shadowMap, sampleUV));
	#endif		
		float isBlocking = step(blocker, z);
		blockers += isBlocking;
		averageBlocker += blocker * isBlocking;
	}
	if (blockers > 0.0)
		return averageBlocker /= blockers;
	return -1.0;
}
float PCSS(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoords, vec4 cameraParams, vec2 shadowSearchArea) {
	float receiverDepth = shadowCoords.z;
#ifndef GL2
	receiverDepth *= 1.0 / (cameraParams.y - cameraParams.z);
#endif
	vec2 samplePoints[PCSS_SAMPLE_COUNT];
	float noise = noise( gl_FragCoord.xy ) * 2.0 * PI;
	for (int i = 0; i < PCSS_SAMPLE_COUNT; i++) {
		float pcssPresample = pcssDiskSamples[i];
		samplePoints[i] = vogelDisk(i, float(PCSS_SAMPLE_COUNT), noise, pcssPresample);
	}
	float averageBlocker = PCSSBlockerDistance(TEXTURE_PASS(shadowMap), samplePoints, shadowCoords.xy, shadowSearchArea, receiverDepth);
	if (averageBlocker == -1.0) {
		return 1.0;
	} else {
		vec2 filterRadius = ((receiverDepth - averageBlocker) / averageBlocker) * shadowSearchArea * cameraParams.x;
		float shadow = 0.0;
		for (int i = 0; i < PCSS_SAMPLE_COUNT; i ++)
		{
			vec2 sampleUV = samplePoints[i] * filterRadius;
			sampleUV = shadowCoords.xy + sampleUV;
		#ifdef GL2
			float depth = textureLod(shadowMap, sampleUV, 0.0).r;
		#else
			float depth = unpackFloat(texture2D(shadowMap, sampleUV));
		#endif
			shadow += step(receiverDepth, depth);
		}
		return shadow / float(PCSS_SAMPLE_COUNT);
	} 
}
float PCSSCubeBlockerDistance(samplerCube shadowMap, vec3 lightDirNorm, vec3 samplePoints[PCSS_SAMPLE_COUNT], float z, float shadowSearchArea) {
	float blockers = 0.0;
	float averageBlocker = 0.0;
	for (int i = 0; i < PCSS_SAMPLE_COUNT; i++) {
		vec3 sampleDir = lightDirNorm + samplePoints[i] * shadowSearchArea;
		sampleDir = normalize(sampleDir);
	#ifdef GL2
		float blocker = textureCubeLodEXT(shadowMap, sampleDir, 0.0).r;
	#else
		float blocker = unpackFloat(textureCube(shadowMap, sampleDir));
	#endif
		float isBlocking = step(blocker, z);
		blockers += isBlocking;
		averageBlocker += blocker * isBlocking;
	}
	if (blockers > 0.0)
		return averageBlocker /= float(blockers);
	return -1.0;
}
float PCSSCube(samplerCube shadowMap, vec4 shadowParams, vec3 shadowCoords, vec4 cameraParams, float shadowSearchArea, vec3 lightDir) {
	
	vec3 samplePoints[PCSS_SAMPLE_COUNT];
	float noise = noise( gl_FragCoord.xy ) * 2.0 * PI;
	for (int i = 0; i < PCSS_SAMPLE_COUNT; i++) {
		float r = pcssSphereSamples[i];
		samplePoints[i] = vogelSphere(i, float(PCSS_SAMPLE_COUNT), noise, r);
	}
	float receiverDepth = length(lightDir) * shadowParams.w + shadowParams.z;
	vec3 lightDirNorm = normalize(lightDir);
	
	float averageBlocker = PCSSCubeBlockerDistance(shadowMap, lightDirNorm, samplePoints, receiverDepth, shadowSearchArea);
	if (averageBlocker == -1.0) {
		return 1.0;
	} else {
		float filterRadius = ((receiverDepth - averageBlocker) / averageBlocker) * shadowSearchArea;
		float shadow = 0.0;
		for (int i = 0; i < PCSS_SAMPLE_COUNT; i++)
		{
			vec3 offset = samplePoints[i] * filterRadius;
			vec3 sampleDir = lightDirNorm + offset;
			sampleDir = normalize(sampleDir);
			#ifdef GL2
				float depth = textureCubeLodEXT(shadowMap, sampleDir, 0.0).r;
			#else
				float depth = unpackFloat(textureCube(shadowMap, sampleDir));
			#endif
			shadow += step(receiverDepth, depth);
		}
		return shadow / float(PCSS_SAMPLE_COUNT);
	}
}
float getShadowPointPCSS(samplerCube shadowMap, vec3 shadowCoord, vec4 shadowParams, vec4 cameraParams, vec2 shadowSearchArea, vec3 lightDir) {
	return PCSSCube(shadowMap, shadowParams, shadowCoord, cameraParams, shadowSearchArea.x, lightDir);
}
float getShadowSpotPCSS(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, vec4 cameraParams, vec2 shadowSearchArea, vec3 lightDir) {
	return PCSS(TEXTURE_PASS(shadowMap), shadowCoord, cameraParams, shadowSearchArea);
}
float getShadowPCSS(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, vec4 cameraParams, vec2 shadowSearchArea, vec3 lightDir) {
	return PCSS(TEXTURE_PASS(shadowMap), shadowCoord, cameraParams, shadowSearchArea);
}
`;var shadowSampleCoordPS=`
vec3 getShadowSampleCoord$LIGHT(mat4 shadowTransform, vec4 shadowParams, vec3 worldPosition, vec3 lightPos, inout vec3 lightDir, vec3 lightDirNorm, vec3 normal) {
	vec3 surfacePosition = worldPosition;
#ifdef SHADOW_SAMPLE_POINT
	#ifdef SHADOW_SAMPLE_NORMAL_OFFSET
		float distScale = length(lightDir);
		surfacePosition = worldPosition + normal * shadowParams.y * clamp(1.0 - dot(normal, -lightDirNorm), 0.0, 1.0) * distScale;
		lightDir = surfacePosition - lightPos;
		return lightDir;
	#endif
#else
	#ifdef SHADOW_SAMPLE_SOURCE_ZBUFFER
		#ifdef SHADOW_SAMPLE_NORMAL_OFFSET
			surfacePosition = worldPosition + normal * shadowParams.y;
		#endif
	#else
		#ifdef SHADOW_SAMPLE_NORMAL_OFFSET
			#ifdef SHADOW_SAMPLE_ORTHO
				float distScale = 1.0;
			#else
				float distScale = abs(dot(vPositionW - lightPos, lightDirNorm));
			#endif
			surfacePosition = worldPosition + normal * shadowParams.y * clamp(1.0 - dot(normal, -lightDirNorm), 0.0, 1.0) * distScale;
		#endif
	#endif
	vec4 positionInShadowSpace = shadowTransform * vec4(surfacePosition, 1.0);
	#ifdef SHADOW_SAMPLE_ORTHO
		positionInShadowSpace.z = saturate(positionInShadowSpace.z) - 0.0001;
	#else
		#ifdef SHADOW_SAMPLE_SOURCE_ZBUFFER
			positionInShadowSpace.xyz /= positionInShadowSpace.w;
		#else
			positionInShadowSpace.xy /= positionInShadowSpace.w;
			positionInShadowSpace.z = length(lightDir) * shadowParams.w;
		#endif
	#endif
	#ifdef SHADOW_SAMPLE_Z_BIAS
		positionInShadowSpace.z += getShadowBias(shadowParams.x, shadowParams.z);
	#endif
	surfacePosition = positionInShadowSpace.xyz;
#endif
	return surfacePosition;
}
`;var shadowStandardPS=`
vec3 lessThan2(vec3 a, vec3 b) {
	return clamp((b - a)*1000.0, 0.0, 1.0);
}
#ifndef UNPACKFLOAT
#define UNPACKFLOAT
	float unpackFloat(vec4 rgbaDepth) {
		const vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);
		return dot(rgbaDepth, bitShift);
	}
#endif
#ifdef GL2
float _getShadowPCF3x3(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec3 shadowParams) {
	float z = shadowCoord.z;
	vec2 uv = shadowCoord.xy * shadowParams.x;
	float shadowMapSizeInv = 1.0 / shadowParams.x;
	vec2 base_uv = floor(uv + 0.5);
	float s = (uv.x + 0.5 - base_uv.x);
	float t = (uv.y + 0.5 - base_uv.y);
	base_uv -= vec2(0.5);
	base_uv *= shadowMapSizeInv;
	float sum = 0.0;
	float uw0 = (3.0 - 2.0 * s);
	float uw1 = (1.0 + 2.0 * s);
	float u0 = (2.0 - s) / uw0 - 1.0;
	float u1 = s / uw1 + 1.0;
	float vw0 = (3.0 - 2.0 * t);
	float vw1 = (1.0 + 2.0 * t);
	float v0 = (2.0 - t) / vw0 - 1.0;
	float v1 = t / vw1 + 1.0;
	u0 = u0 * shadowMapSizeInv + base_uv.x;
	v0 = v0 * shadowMapSizeInv + base_uv.y;
	u1 = u1 * shadowMapSizeInv + base_uv.x;
	v1 = v1 * shadowMapSizeInv + base_uv.y;
	sum += uw0 * vw0 * textureShadow(shadowMap, vec3(u0, v0, z));
	sum += uw1 * vw0 * textureShadow(shadowMap, vec3(u1, v0, z));
	sum += uw0 * vw1 * textureShadow(shadowMap, vec3(u0, v1, z));
	sum += uw1 * vw1 * textureShadow(shadowMap, vec3(u1, v1, z));
	sum *= 1.0f / 16.0;
	return sum;
}
float getShadowPCF3x3(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {
	return _getShadowPCF3x3(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams.xyz);
}
float getShadowSpotPCF3x3(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {
	return _getShadowPCF3x3(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams.xyz);
}
float getShadowPCF1x1(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {
	return textureShadow(shadowMap, shadowCoord);
}
float getShadowSpotPCF1x1(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {
	return textureShadow(shadowMap, shadowCoord);
}
#else
float _xgetShadowPCF3x3(mat3 depthKernel, vec3 shadowCoord, sampler2D shadowMap, vec3 shadowParams) {
	mat3 shadowKernel;
	vec3 shadowZ = vec3(shadowCoord.z);
	shadowKernel[0] = vec3(greaterThan(depthKernel[0], shadowZ));
	shadowKernel[1] = vec3(greaterThan(depthKernel[1], shadowZ));
	shadowKernel[2] = vec3(greaterThan(depthKernel[2], shadowZ));
	vec2 fractionalCoord = fract( shadowCoord.xy * shadowParams.x );
	shadowKernel[0] = mix(shadowKernel[0], shadowKernel[1], fractionalCoord.x);
	shadowKernel[1] = mix(shadowKernel[1], shadowKernel[2], fractionalCoord.x);
	vec4 shadowValues;
	shadowValues.x = mix(shadowKernel[0][0], shadowKernel[0][1], fractionalCoord.y);
	shadowValues.y = mix(shadowKernel[0][1], shadowKernel[0][2], fractionalCoord.y);
	shadowValues.z = mix(shadowKernel[1][0], shadowKernel[1][1], fractionalCoord.y);
	shadowValues.w = mix(shadowKernel[1][1], shadowKernel[1][2], fractionalCoord.y);
	return dot( shadowValues, vec4( 1.0 ) ) * 0.25;
}
float _getShadowPCF3x3(sampler2D shadowMap, vec3 shadowCoord, vec3 shadowParams) {
	float xoffset = 1.0 / shadowParams.x;
	float dx0 = -xoffset;
	float dx1 = xoffset;
	mat3 depthKernel;
	depthKernel[0][0] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy + vec2(dx0, dx0)));
	depthKernel[0][1] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy + vec2(dx0, 0.0)));
	depthKernel[0][2] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy + vec2(dx0, dx1)));
	depthKernel[1][0] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy + vec2(0.0, dx0)));
	depthKernel[1][1] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy));
	depthKernel[1][2] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy + vec2(0.0, dx1)));
	depthKernel[2][0] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy + vec2(dx1, dx0)));
	depthKernel[2][1] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy + vec2(dx1, 0.0)));
	depthKernel[2][2] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy + vec2(dx1, dx1)));
	return _xgetShadowPCF3x3(depthKernel, shadowCoord, shadowMap, shadowParams);
}
float getShadowPCF3x3(sampler2D shadowMap, vec3 shadowCoord, vec4 shadowParams) {
	return _getShadowPCF3x3(shadowMap, shadowCoord, shadowParams.xyz);
}
float getShadowSpotPCF3x3(sampler2D shadowMap, vec3 shadowCoord, vec4 shadowParams) {
	return _getShadowPCF3x3(shadowMap, shadowCoord, shadowParams.xyz);
}
float _getShadowPCF1x1(sampler2D shadowMap, vec3 shadowCoord) {
	float shadowSample = unpackFloat(textureShadow(shadowMap, shadowCoord.xy));
	return shadowSample > shadowCoord.z ? 1.0 : 0.0;
}
float getShadowPCF1x1(sampler2D shadowMap, vec3 shadowCoord, vec4 shadowParams) {
	return _getShadowPCF1x1(shadowMap, shadowCoord);
}
float getShadowSpotPCF1x1(sampler2D shadowMap, vec3 shadowCoord, vec4 shadowParams) {
	return _getShadowPCF1x1(shadowMap, shadowCoord);
}
#endif
#ifndef WEBGPU
float _getShadowPoint(samplerCube shadowMap, vec4 shadowParams, vec3 dir) {
	vec3 tc = normalize(dir);
	vec3 tcAbs = abs(tc);
	vec4 dirX = vec4(1,0,0, tc.x);
	vec4 dirY = vec4(0,1,0, tc.y);
	float majorAxisLength = tc.z;
	if ((tcAbs.x > tcAbs.y) && (tcAbs.x > tcAbs.z)) {
		dirX = vec4(0,0,1, tc.z);
		dirY = vec4(0,1,0, tc.y);
		majorAxisLength = tc.x;
	} else if ((tcAbs.y > tcAbs.x) && (tcAbs.y > tcAbs.z)) {
		dirX = vec4(1,0,0, tc.x);
		dirY = vec4(0,0,1, tc.z);
		majorAxisLength = tc.y;
	}
	float shadowParamsInFaceSpace = ((1.0/shadowParams.x) * 2.0) * abs(majorAxisLength);
	vec3 xoffset = (dirX.xyz * shadowParamsInFaceSpace);
	vec3 yoffset = (dirY.xyz * shadowParamsInFaceSpace);
	vec3 dx0 = -xoffset;
	vec3 dy0 = -yoffset;
	vec3 dx1 = xoffset;
	vec3 dy1 = yoffset;
	mat3 shadowKernel;
	mat3 depthKernel;
	depthKernel[0][0] = unpackFloat(textureCube(shadowMap, tc + dx0 + dy0));
	depthKernel[0][1] = unpackFloat(textureCube(shadowMap, tc + dx0));
	depthKernel[0][2] = unpackFloat(textureCube(shadowMap, tc + dx0 + dy1));
	depthKernel[1][0] = unpackFloat(textureCube(shadowMap, tc + dy0));
	depthKernel[1][1] = unpackFloat(textureCube(shadowMap, tc));
	depthKernel[1][2] = unpackFloat(textureCube(shadowMap, tc + dy1));
	depthKernel[2][0] = unpackFloat(textureCube(shadowMap, tc + dx1 + dy0));
	depthKernel[2][1] = unpackFloat(textureCube(shadowMap, tc + dx1));
	depthKernel[2][2] = unpackFloat(textureCube(shadowMap, tc + dx1 + dy1));
	vec3 shadowZ = vec3(length(dir) * shadowParams.w + shadowParams.z);
	shadowKernel[0] = vec3(lessThan2(depthKernel[0], shadowZ));
	shadowKernel[1] = vec3(lessThan2(depthKernel[1], shadowZ));
	shadowKernel[2] = vec3(lessThan2(depthKernel[2], shadowZ));
	vec2 uv = (vec2(dirX.w, dirY.w) / abs(majorAxisLength)) * 0.5;
	vec2 fractionalCoord = fract( uv * shadowParams.x );
	shadowKernel[0] = mix(shadowKernel[0], shadowKernel[1], fractionalCoord.x);
	shadowKernel[1] = mix(shadowKernel[1], shadowKernel[2], fractionalCoord.x);
	vec4 shadowValues;
	shadowValues.x = mix(shadowKernel[0][0], shadowKernel[0][1], fractionalCoord.y);
	shadowValues.y = mix(shadowKernel[0][1], shadowKernel[0][2], fractionalCoord.y);
	shadowValues.z = mix(shadowKernel[1][0], shadowKernel[1][1], fractionalCoord.y);
	shadowValues.w = mix(shadowKernel[1][1], shadowKernel[1][2], fractionalCoord.y);
	return 1.0 - dot( shadowValues, vec4( 1.0 ) ) * 0.25;
}
float getShadowPointPCF3x3(samplerCube shadowMap, vec3 shadowCoord, vec4 shadowParams, vec3 lightDir) {
	return _getShadowPoint(shadowMap, shadowParams, lightDir);
}
#endif
`;var shadowStandardGL2PS=`
float _getShadowPCF5x5(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec3 shadowParams) {
	float z = shadowCoord.z;
	vec2 uv = shadowCoord.xy * shadowParams.x;
	float shadowMapSizeInv = 1.0 / shadowParams.x;
	vec2 base_uv = floor(uv + 0.5);
	float s = (uv.x + 0.5 - base_uv.x);
	float t = (uv.y + 0.5 - base_uv.y);
	base_uv -= vec2(0.5);
	base_uv *= shadowMapSizeInv;
	float uw0 = (4.0 - 3.0 * s);
	float uw1 = 7.0;
	float uw2 = (1.0 + 3.0 * s);
	float u0 = (3.0 - 2.0 * s) / uw0 - 2.0;
	float u1 = (3.0 + s) / uw1;
	float u2 = s / uw2 + 2.0;
	float vw0 = (4.0 - 3.0 * t);
	float vw1 = 7.0;
	float vw2 = (1.0 + 3.0 * t);
	float v0 = (3.0 - 2.0 * t) / vw0 - 2.0;
	float v1 = (3.0 + t) / vw1;
	float v2 = t / vw2 + 2.0;
	float sum = 0.0;
	u0 = u0 * shadowMapSizeInv + base_uv.x;
	v0 = v0 * shadowMapSizeInv + base_uv.y;
	u1 = u1 * shadowMapSizeInv + base_uv.x;
	v1 = v1 * shadowMapSizeInv + base_uv.y;
	u2 = u2 * shadowMapSizeInv + base_uv.x;
	v2 = v2 * shadowMapSizeInv + base_uv.y;
	sum += uw0 * vw0 * textureShadow(shadowMap, vec3(u0, v0, z));
	sum += uw1 * vw0 * textureShadow(shadowMap, vec3(u1, v0, z));
	sum += uw2 * vw0 * textureShadow(shadowMap, vec3(u2, v0, z));
	sum += uw0 * vw1 * textureShadow(shadowMap, vec3(u0, v1, z));
	sum += uw1 * vw1 * textureShadow(shadowMap, vec3(u1, v1, z));
	sum += uw2 * vw1 * textureShadow(shadowMap, vec3(u2, v1, z));
	sum += uw0 * vw2 * textureShadow(shadowMap, vec3(u0, v2, z));
	sum += uw1 * vw2 * textureShadow(shadowMap, vec3(u1, v2, z));
	sum += uw2 * vw2 * textureShadow(shadowMap, vec3(u2, v2, z));
	sum *= 1.0f / 144.0;
	sum = saturate(sum);
	return sum;
}
float getShadowPCF5x5(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {
	return _getShadowPCF5x5(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams.xyz);
}
float getShadowSpotPCF5x5(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {
	return _getShadowPCF5x5(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams.xyz);
}
`;var shadowVSM8PS=`
float calculateVSM8(vec3 moments, float Z, float vsmBias) {
	float VSMBias = vsmBias;
	float depthScale = VSMBias * Z;
	float minVariance1 = depthScale * depthScale;
	return chebyshevUpperBound(moments.xy, Z, minVariance1, 0.1);
}
float decodeFloatRG(vec2 rg) {
	return rg.y*(1.0/255.0) + rg.x;
}
float VSM8(TEXTURE_ACCEPT(tex), vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {
	vec4 c = texture2D(tex, texCoords);
	vec3 moments = vec3(decodeFloatRG(c.xy), decodeFloatRG(c.zw), 0.0);
	return calculateVSM8(moments, Z, vsmBias);
}
float getShadowVSM8(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, float exponent, vec3 lightDir) {
	return VSM8(TEXTURE_PASS(shadowMap), shadowCoord.xy, shadowParams.x, shadowCoord.z, shadowParams.y, 0.0);
}
float getShadowSpotVSM8(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, float exponent, vec3 lightDir) {
	return VSM8(TEXTURE_PASS(shadowMap), shadowCoord.xy, shadowParams.x, length(lightDir) * shadowParams.w + shadowParams.z, shadowParams.y, 0.0);
}
`;var shadowVSM_commonPS=`
float linstep(float a, float b, float v) {
	return saturate((v - a) / (b - a));
}
float reduceLightBleeding(float pMax, float amount) {
	 return linstep(amount, 1.0, pMax);
}
float chebyshevUpperBound(vec2 moments, float mean, float minVariance, float lightBleedingReduction) {
	float variance = moments.y - (moments.x * moments.x);
	variance = max(variance, minVariance);
	float d = mean - moments.x;
	float pMax = variance / (variance + (d * d));
	pMax = reduceLightBleeding(pMax, lightBleedingReduction);
	return (mean <= moments.x ? 1.0 : pMax);
}
float calculateEVSM(vec3 moments, float Z, float vsmBias, float exponent) {
	Z = 2.0 * Z - 1.0;
	float warpedDepth = exp(exponent * Z);
	moments.xy += vec2(warpedDepth, warpedDepth*warpedDepth) * (1.0 - moments.z);
	float VSMBias = vsmBias;
	float depthScale = VSMBias * exponent * warpedDepth;
	float minVariance1 = depthScale * depthScale;
	return chebyshevUpperBound(moments.xy, warpedDepth, minVariance1, 0.1);
}
`;var skinBatchConstVS=`
attribute float vertex_boneIndices;
uniform vec4 matrix_pose[BONE_LIMIT * 3];
mat4 getBoneMatrix(const in float i) {
	vec4 v1 = matrix_pose[int(3.0 * i)];
	vec4 v2 = matrix_pose[int(3.0 * i + 1.0)];
	vec4 v3 = matrix_pose[int(3.0 * i + 2.0)];
	return mat4(
		v1.x, v2.x, v3.x, 0,
		v1.y, v2.y, v3.y, 0,
		v1.z, v2.z, v3.z, 0,
		v1.w, v2.w, v3.w, 1
	);
}
`;var skinBatchTexVS=`
attribute float vertex_boneIndices;
uniform highp sampler2D texture_poseMap;
uniform vec4 texture_poseMapSize;
mat4 getBoneMatrix(const in float i) {
	float j = i * 3.0;
	float dx = texture_poseMapSize.z;
	float dy = texture_poseMapSize.w;
	float y = floor(j * dx);
	float x = j - (y * texture_poseMapSize.x);
	y = dy * (y + 0.5);
	vec4 v1 = texture2D(texture_poseMap, vec2(dx * (x + 0.5), y));
	vec4 v2 = texture2D(texture_poseMap, vec2(dx * (x + 1.5), y));
	vec4 v3 = texture2D(texture_poseMap, vec2(dx * (x + 2.5), y));
	return mat4(
		v1.x, v2.x, v3.x, 0,
		v1.y, v2.y, v3.y, 0,
		v1.z, v2.z, v3.z, 0,
		v1.w, v2.w, v3.w, 1
	);
}
`;var skinConstVS=`
attribute vec4 vertex_boneWeights;
attribute vec4 vertex_boneIndices;
uniform vec4 matrix_pose[BONE_LIMIT * 3];
void getBoneMatrix(const in float i, out vec4 v1, out vec4 v2, out vec4 v3) {
	v1 = matrix_pose[int(3.0 * i)];
	v2 = matrix_pose[int(3.0 * i + 1.0)];
	v3 = matrix_pose[int(3.0 * i + 2.0)];
}
mat4 getSkinMatrix(const in vec4 indices, const in vec4 weights) {
	vec4 a1, a2, a3;
	getBoneMatrix(indices.x, a1, a2, a3);
	vec4 b1, b2, b3;
	getBoneMatrix(indices.y, b1, b2, b3);
	vec4 c1, c2, c3;
	getBoneMatrix(indices.z, c1, c2, c3);
	vec4 d1, d2, d3;
	getBoneMatrix(indices.w, d1, d2, d3);
	vec4 v1 = a1 * weights.x + b1 * weights.y + c1 * weights.z + d1 * weights.w;
	vec4 v2 = a2 * weights.x + b2 * weights.y + c2 * weights.z + d2 * weights.w;
	vec4 v3 = a3 * weights.x + b3 * weights.y + c3 * weights.z + d3 * weights.w;
	float one = dot(weights, vec4(1.0));
	return mat4(
		v1.x, v2.x, v3.x, 0,
		v1.y, v2.y, v3.y, 0,
		v1.z, v2.z, v3.z, 0,
		v1.w, v2.w, v3.w, one
	);
}
`;var skinTexVS=`
attribute vec4 vertex_boneWeights;
attribute vec4 vertex_boneIndices;
uniform highp sampler2D texture_poseMap;
uniform vec4 texture_poseMapSize;
void getBoneMatrix(const in float index, out vec4 v1, out vec4 v2, out vec4 v3) {
	float i = float(index);
	float j = i * 3.0;
	float dx = texture_poseMapSize.z;
	float dy = texture_poseMapSize.w;
	
	float y = floor(j * dx);
	float x = j - (y * texture_poseMapSize.x);
	y = dy * (y + 0.5);
	v1 = texture2D(texture_poseMap, vec2(dx * (x + 0.5), y));
	v2 = texture2D(texture_poseMap, vec2(dx * (x + 1.5), y));
	v3 = texture2D(texture_poseMap, vec2(dx * (x + 2.5), y));
}
mat4 getSkinMatrix(const in vec4 indices, const in vec4 weights) {
	vec4 a1, a2, a3;
	getBoneMatrix(indices.x, a1, a2, a3);
	vec4 b1, b2, b3;
	getBoneMatrix(indices.y, b1, b2, b3);
	vec4 c1, c2, c3;
	getBoneMatrix(indices.z, c1, c2, c3);
	vec4 d1, d2, d3;
	getBoneMatrix(indices.w, d1, d2, d3);
	vec4 v1 = a1 * weights.x + b1 * weights.y + c1 * weights.z + d1 * weights.w;
	vec4 v2 = a2 * weights.x + b2 * weights.y + c2 * weights.z + d2 * weights.w;
	vec4 v3 = a3 * weights.x + b3 * weights.y + c3 * weights.z + d3 * weights.w;
	float one = dot(weights, vec4(1.0));
	return mat4(
		v1.x, v2.x, v3.x, 0,
		v1.y, v2.y, v3.y, 0,
		v1.z, v2.z, v3.z, 0,
		v1.w, v2.w, v3.w, one
	);
}
`;var skyboxEnvPS=`
varying vec3 vViewDir;
uniform sampler2D texture_envAtlas;
uniform float mipLevel;
void main(void) {
	vec3 dir = vViewDir * vec3(-1.0, 1.0, 1.0);
	vec2 uv = toSphericalUv(normalize(dir));
	vec3 linear = SKYBOX_DECODE_FNC(texture2D(texture_envAtlas, mapRoughnessUv(uv, mipLevel)));
	gl_FragColor = vec4(gammaCorrectOutput(toneMap(processEnvironment(linear))), 1.0);
}
`;var skyboxHDRPS=`
varying vec3 vViewDir;
uniform samplerCube texture_cubeMap;
#ifdef SKYMESH
	varying vec3 vWorldPos;
	uniform mat3 cubeMapRotationMatrix;
	uniform vec3 projectedSkydomeCenter;
#endif
void main(void) {
	#ifdef SKYMESH
		vec3 envDir = normalize(vWorldPos - projectedSkydomeCenter);
		vec3 dir = envDir * cubeMapRotationMatrix;
	#else
		vec3 dir = vViewDir;
	#endif
	dir.x *= -1.0;
	vec3 linear = SKYBOX_DECODE_FNC(textureCube(texture_cubeMap, fixSeamsStatic(dir, SKYBOX_MIP)));
	gl_FragColor = vec4(gammaCorrectOutput(toneMap(processEnvironment(linear))), 1.0);
}
`;var skyboxVS=`
attribute vec3 aPosition;
#ifndef VIEWMATRIX
#define VIEWMATRIX
uniform mat4 matrix_view;
#endif
uniform mat4 matrix_projectionSkybox;
uniform mat3 cubeMapRotationMatrix;
varying vec3 vViewDir;
#ifdef SKYMESH
	uniform mat4 matrix_model;
	varying vec3 vWorldPos;
#endif
void main(void) {
	mat4 view = matrix_view;
	#ifdef SKYMESH
		vec4 worldPos = matrix_model * vec4(aPosition, 1.0);
		vWorldPos = worldPos.xyz;
		gl_Position = matrix_projectionSkybox * view * worldPos;
	#else
		view[3][0] = view[3][1] = view[3][2] = 0.0;
		gl_Position = matrix_projectionSkybox * view * vec4(aPosition, 1.0);
		vViewDir = aPosition * cubeMapRotationMatrix;
	#endif
	gl_Position.z = gl_Position.w - 1.0e-7;
}
`;var specularPS=`
#ifdef MAPCOLOR
uniform vec3 material_specular;
#endif
void getSpecularity() {
	vec3 specularColor = vec3(1,1,1);
	#ifdef MAPCOLOR
	specularColor *= material_specular;
	#endif
	#ifdef MAPTEXTURE
	specularColor *= $DECODE(texture2DBias($SAMPLER, $UV, textureBias)).$CH;
	#endif
	#ifdef MAPVERTEX
	specularColor *= saturate(vVertexColor.$VC);
	#endif
	dSpecularity = specularColor;
}
`;var sphericalPS=`
const float PI = 3.141592653589793;
vec2 toSpherical(vec3 dir) {
	return vec2(dir.xz == vec2(0.0) ? 0.0 : atan(dir.x, dir.z), asin(dir.y));
}
vec2 toSphericalUv(vec3 dir) {
	vec2 uv = toSpherical(dir) / vec2(PI * 2.0, PI) + 0.5;
	return vec2(uv.x, 1.0 - uv.y);
}
`;var specularityFactorPS=`
#ifdef MAPFLOAT
uniform float material_specularityFactor;
#endif
void getSpecularityFactor() {
	float specularityFactor = 1.0;
	#ifdef MAPFLOAT
	specularityFactor *= material_specularityFactor;
	#endif
	#ifdef MAPTEXTURE
	specularityFactor *= texture2DBias($SAMPLER, $UV, textureBias).$CH;
	#endif
	#ifdef MAPVERTEX
	specularityFactor *= saturate(vVertexColor.$VC);
	#endif
	dSpecularityFactor = specularityFactor;
}
`;var spotPS=`
float getSpotEffect(vec3 lightSpotDir, float lightInnerConeAngle, float lightOuterConeAngle, vec3 lightDirNorm) {
	float cosAngle = dot(lightDirNorm, lightSpotDir);
	return smoothstep(lightOuterConeAngle, lightInnerConeAngle, cosAngle);
}
`;var startPS=`
void main(void) {
	dReflection = vec4(0);
	#ifdef LIT_CLEARCOAT
	ccSpecularLight = vec3(0);
	ccReflection = vec3(0);
	#endif
`;var startVS=`
void main(void) {
	gl_Position = getPosition();
`;var startNineSlicedPS=`
	nineSlicedUv = vUv0;
	nineSlicedUv.y = 1.0 - nineSlicedUv.y;
`;var startNineSlicedTiledPS=`
	vec2 tileMask = step(vMask, vec2(0.99999));
	vec2 tileSize = 0.5 * (innerOffset.xy + innerOffset.zw);
	vec2 tileScale = vec2(1.0) / (vec2(1.0) - tileSize);
	vec2 clampedUv = mix(innerOffset.xy * 0.5, vec2(1.0) - innerOffset.zw * 0.5, fract((vTiledUv - tileSize) * tileScale));
	clampedUv = clampedUv * atlasRect.zw + atlasRect.xy;
	nineSlicedUv = vUv0 * tileMask + clampedUv * (vec2(1.0) - tileMask);
	nineSlicedUv.y = 1.0 - nineSlicedUv.y;
	
`;var storeEVSMPS=`
float exponent = VSM_EXPONENT;
depth = 2.0 * depth - 1.0;
depth =  exp(exponent * depth);
gl_FragColor = vec4(depth, depth*depth, 1.0, 1.0);
`;var tangentBinormalVS=`
vec3 getTangent() {
	return normalize(dNormalMatrix * vertex_tangent.xyz);
}
vec3 getBinormal() {
	return cross(vNormalW, vTangentW) * vertex_tangent.w;
}
`;var TBNPS=`
void getTBN(vec3 tangent, vec3 binormal, vec3 normal) {
	dTBN = mat3(normalize(tangent), normalize(binormal), normalize(normal));
}
`;var TBNderivativePS=`
uniform float tbnBasis;
void getTBN(vec3 tangent, vec3 binormal, vec3 normal) {
	vec2 uv = $UV;
	vec3 dp1 = dFdx( vPositionW );
	vec3 dp2 = dFdy( vPositionW );
	vec2 duv1 = dFdx( uv );
	vec2 duv2 = dFdy( uv );
	vec3 dp2perp = cross( dp2, normal );
	vec3 dp1perp = cross( normal, dp1 );
	vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;
	vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;
	float denom = max( dot(T,T), dot(B,B) );
	float invmax = (denom == 0.0) ? 0.0 : tbnBasis / sqrt( denom );
	dTBN = mat3(T * invmax, -B * invmax, normal );
}
`;var TBNfastPS=`
void getTBN(vec3 tangent, vec3 binormal, vec3 normal) {
	dTBN = mat3(tangent, binormal, normal);
}
`;var TBNObjectSpacePS=`
void getTBN(vec3 tangent, vec3 binormal, vec3 normal) {
	vec3 B = cross(normal, vObjectSpaceUpW);
	vec3 T = cross(normal, B);
	if (dot(B,B)==0.0)
	{
		float major=max(max(normal.x, normal.y), normal.z);
		if (normal.x == major)
		{
			B=cross(normal, vec3(0,1,0));
			T=cross(normal, B);
		}
		else if (normal.y == major)
		{
			B=cross(normal, vec3(0,0,1));
			T=cross(normal, B);
		}
		else if (normal.z == major)
		{
			B=cross(normal, vec3(1,0,0));
			T=cross(normal, B);
		}
	}
	dTBN = mat3(normalize(T), normalize(B), normalize(normal));
}
`;var textureSamplePS=`
vec4 texture2DSRGB(sampler2D tex, vec2 uv) {
	return gammaCorrectInput(texture2D(tex, uv));
}
vec4 texture2DSRGB(sampler2D tex, vec2 uv, float bias) {
	return gammaCorrectInput(texture2D(tex, uv, bias));
}
vec3 texture2DRGBM(sampler2D tex, vec2 uv) {
	return decodeRGBM(texture2D(tex, uv));
}
vec3 texture2DRGBM(sampler2D tex, vec2 uv, float bias) {
	return decodeRGBM(texture2D(tex, uv, bias));
}
vec3 texture2DRGBE(sampler2D tex, vec2 uv) {
	return decodeRGBM(texture2D(tex, uv));
}
vec3 texture2DRGBE(sampler2D tex, vec2 uv, float bias) {
	return decodeRGBM(texture2D(tex, uv, bias));
}
`;var thicknessPS=`
#ifdef MAPFLOAT
uniform float material_thickness;
#endif
void getThickness() {
	dThickness = 1.0;
	#ifdef MAPFLOAT
	dThickness *= material_thickness;
	#endif
	#ifdef MAPTEXTURE
	dThickness *= texture2DBias($SAMPLER, $UV, textureBias).$CH;
	#endif
	#ifdef MAPVERTEX
	dThickness *= saturate(vVertexColor.$VC);
	#endif
}
`;var tonemappingAcesPS=`
uniform float exposure;
vec3 toneMap(vec3 color) {
	float tA = 2.51;
	float tB = 0.03;
	float tC = 2.43;
	float tD = 0.59;
	float tE = 0.14;
	vec3 x = color * exposure;
	return (x*(tA*x+tB))/(x*(tC*x+tD)+tE);
}
`;var tonemappingAces2PS=`
uniform float exposure;
const mat3 ACESInputMat = mat3(
	0.59719, 0.35458, 0.04823,
	0.07600, 0.90834, 0.01566,
	0.02840, 0.13383, 0.83777
);
const mat3 ACESOutputMat = mat3(
	 1.60475, -0.53108, -0.07367,
	-0.10208,  1.10813, -0.00605,
	-0.00327, -0.07276,  1.07602
);
vec3 RRTAndODTFit(vec3 v) {
	vec3 a = v * (v + 0.0245786) - 0.000090537;
	vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;
	return a / b;
}
vec3 toneMap(vec3 color) {
	color *= exposure / 0.6;
	color = color * ACESInputMat;
	color = RRTAndODTFit(color);
	color = color * ACESOutputMat;
	color = clamp(color, 0.0, 1.0);
	return color;
}
`;var tonemappingFilmicPS=`
const float A =  0.15;
const float B =  0.50;
const float C =  0.10;
const float D =  0.20;
const float E =  0.02;
const float F =  0.30;
const float W =  11.2;
uniform float exposure;
vec3 uncharted2Tonemap(vec3 x) {
	 return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;
}
vec3 toneMap(vec3 color) {
	color = uncharted2Tonemap(color * exposure);
	vec3 whiteScale = 1.0 / uncharted2Tonemap(vec3(W,W,W));
	color = color * whiteScale;
	return color;
}
`;var tonemappingHejlPS=`
uniform float exposure;
vec3 toneMap(vec3 color) {
	color *= exposure;
	const float  A = 0.22, B = 0.3, C = .1, D = 0.2, E = .01, F = 0.3;
	const float Scl = 1.25;
	vec3 h = max( vec3(0.0), color - vec3(0.004) );
	return (h*((Scl*A)*h+Scl*vec3(C*B,C*B,C*B))+Scl*vec3(D*E,D*E,D*E)) / (h*(A*h+vec3(B,B,B))+vec3(D*F,D*F,D*F)) - Scl*vec3(E/F,E/F,E/F);
}
`;var tonemappingLinearPS=`
uniform float exposure;
vec3 toneMap(vec3 color) {
	return color * exposure;
}
`;var tonemappingNeutralPS=`
uniform float exposure;
vec3 toneMap(vec3 color) {
	color *= exposure;
	float startCompression = 0.8 - 0.04;
	float desaturation = 0.15;
	float x = min(color.r, min(color.g, color.b));
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max(color.r, max(color.g, color.b));
	if (peak < startCompression) return color;
	float d = 1. - startCompression;
	float newPeak = 1. - d * d / (peak + d - startCompression);
	color *= newPeak / peak;
	float g = 1. - 1. / (desaturation * (peak - newPeak) + 1.);
	return mix(color, newPeak * vec3(1, 1, 1), g);
}
`;var tonemappingNonePS=`
vec3 toneMap(vec3 color) {
	return color;
}
`;var transformVS=`
#ifdef PIXELSNAP
uniform vec4 uScreenSize;
#endif
#ifdef SCREENSPACE
uniform float projectionFlipY;
#endif
#ifdef MORPHING
uniform vec4 morph_weights_a;
uniform vec4 morph_weights_b;
#endif
#ifdef MORPHING_TEXTURE_BASED
	uniform vec4 morph_tex_params;
	#ifdef WEBGPU
		ivec2 getTextureMorphCoords() {
			ivec2 textureSize = ivec2(morph_tex_params.xy);
			int morphGridV = int(morph_vertex_id / textureSize.x);
			int morphGridU = int(morph_vertex_id - (morphGridV * textureSize.x));
			morphGridV = textureSize.y - morphGridV - 1;
			return ivec2(morphGridU, morphGridV);
		}
	#else
		vec2 getTextureMorphCoords() {
			vec2 textureSize = morph_tex_params.xy;
			vec2 invTextureSize = morph_tex_params.zw;
			float morphGridV = floor(morph_vertex_id * invTextureSize.x);
			float morphGridU = morph_vertex_id - (morphGridV * textureSize.x);
			return vec2(morphGridU, morphGridV) * invTextureSize + (0.5 * invTextureSize);
		}
	#endif
#endif
#ifdef MORPHING_TEXTURE_BASED_POSITION
uniform highp sampler2D morphPositionTex;
#endif
mat4 getModelMatrix() {
	#ifdef DYNAMICBATCH
	return getBoneMatrix(vertex_boneIndices);
	#elif defined(SKIN)
	return matrix_model * getSkinMatrix(vertex_boneIndices, vertex_boneWeights);
	#elif defined(INSTANCING)
	return mat4(instance_line1, instance_line2, instance_line3, instance_line4);
	#else
	return matrix_model;
	#endif
}
vec4 getPosition() {
	dModelMatrix = getModelMatrix();
	vec3 localPos = vertex_position;
	#ifdef NINESLICED
	localPos.xz *= outerScale;
	vec2 positiveUnitOffset = clamp(vertex_position.xz, vec2(0.0), vec2(1.0));
	vec2 negativeUnitOffset = clamp(-vertex_position.xz, vec2(0.0), vec2(1.0));
	localPos.xz += (-positiveUnitOffset * innerOffset.xy + negativeUnitOffset * innerOffset.zw) * vertex_texCoord0.xy;
	vTiledUv = (localPos.xz - outerScale + innerOffset.xy) * -0.5 + 1.0;
	localPos.xz *= -0.5;
	localPos = localPos.xzy;
	#endif
	#ifdef MORPHING
	#ifdef MORPHING_POS03
	localPos.xyz += morph_weights_a[0] * morph_pos0;
	localPos.xyz += morph_weights_a[1] * morph_pos1;
	localPos.xyz += morph_weights_a[2] * morph_pos2;
	localPos.xyz += morph_weights_a[3] * morph_pos3;
	#endif
	#ifdef MORPHING_POS47
	localPos.xyz += morph_weights_b[0] * morph_pos4;
	localPos.xyz += morph_weights_b[1] * morph_pos5;
	localPos.xyz += morph_weights_b[2] * morph_pos6;
	localPos.xyz += morph_weights_b[3] * morph_pos7;
	#endif
	#endif
	#ifdef MORPHING_TEXTURE_BASED_POSITION
		#ifdef WEBGPU
			ivec2 morphUV = getTextureMorphCoords();
			vec3 morphPos = texelFetch(morphPositionTex, ivec2(morphUV), 0).xyz;
		#else
			vec2 morphUV = getTextureMorphCoords();
			vec3 morphPos = texture2D(morphPositionTex, morphUV).xyz;
		#endif
		localPos += morphPos;
	#endif
	vec4 posW = dModelMatrix * vec4(localPos, 1.0);
	#ifdef SCREENSPACE
	posW.zw = vec2(0.0, 1.0);
	#endif
	dPositionW = posW.xyz;
	vec4 screenPos;
	#ifdef UV1LAYOUT
	screenPos = vec4(vertex_texCoord1.xy * 2.0 - 1.0, 0.5, 1);
		#ifdef WEBGPU
		screenPos.y *= -1.0;
		#endif
	#else
	#ifdef SCREENSPACE
	screenPos = posW;
	screenPos.y *= projectionFlipY;
	#else
	screenPos = matrix_viewProjection * posW;
	#endif
	#ifdef PIXELSNAP
	screenPos.xy = (screenPos.xy * 0.5) + 0.5;
	screenPos.xy *= uScreenSize.xy;
	screenPos.xy = floor(screenPos.xy);
	screenPos.xy *= uScreenSize.zw;
	screenPos.xy = (screenPos.xy * 2.0) - 1.0;
	#endif
	#endif
	return screenPos;
}
vec3 getWorldPosition() {
	return dPositionW;
}
`;var transformDeclVS=`
attribute vec3 vertex_position;
uniform mat4 matrix_model;
uniform mat4 matrix_viewProjection;
vec3 dPositionW;
mat4 dModelMatrix;
`;var transmissionPS=`
#ifdef MAPFLOAT
uniform float material_refraction;
#endif
void getRefraction() {
	float refraction = 1.0;
	#ifdef MAPFLOAT
	refraction = material_refraction;
	#endif
	#ifdef MAPTEXTURE
	refraction *= texture2DBias($SAMPLER, $UV, textureBias).$CH;
	#endif
	#ifdef MAPVERTEX
	refraction *= saturate(vVertexColor.$VC);
	#endif
	dTransmission = refraction;
}
`;var twoSidedLightingPS=`
uniform float twoSidedLightingNegScaleFactor;
void handleTwoSidedLighting() {
	dTBN[2] *= gl_FrontFacing ? twoSidedLightingNegScaleFactor : -twoSidedLightingNegScaleFactor;
}
`;var uv0VS=`
#ifdef NINESLICED
vec2 getUv0() {
	vec2 uv = vertex_position.xz;
	vec2 positiveUnitOffset = clamp(vertex_position.xz, vec2(0.0), vec2(1.0));
	vec2 negativeUnitOffset = clamp(-vertex_position.xz, vec2(0.0), vec2(1.0));
	uv += (-positiveUnitOffset * innerOffset.xy + negativeUnitOffset * innerOffset.zw) * vertex_texCoord0.xy;
	uv = uv * -0.5 + 0.5;
	uv = uv * atlasRect.zw + atlasRect.xy;
	vMask = vertex_texCoord0.xy;
	return uv;
}
#else
vec2 getUv0() {
	return vertex_texCoord0;
}
#endif
`;var uv1VS=`
vec2 getUv1() {
	return vertex_texCoord1;
}
`;var viewDirPS=`
void getViewDir() {
	dViewDirW = normalize(view_position - vPositionW);
}
`;var viewNormalVS=`
#ifndef VIEWMATRIX
#define VIEWMATRIX
uniform mat4 matrix_view;
#endif
vec3 getViewNormal() {
	return mat3(matrix_view) * vNormalW;
}
`;const shaderChunks={alphaTestPS,ambientConstantPS,ambientEnvPS,ambientSHPS,aoPS,aoDetailMapPS,aoDiffuseOccPS,aoSpecOccPS,aoSpecOccConstPS,aoSpecOccConstSimplePS,aoSpecOccSimplePS,basePS,baseVS,baseNineSlicedPS,baseNineSlicedVS,baseNineSlicedTiledPS,bayerPS,biasConstPS,blurVSMPS,clearCoatPS,clearCoatGlossPS,clearCoatNormalPS,clusteredLightCookiesPS,clusteredLightShadowsPS,clusteredLightUtilsPS,clusteredLightPS,combinePS,cookiePS,cubeMapProjectBoxPS,cubeMapProjectNonePS,cubeMapRotatePS,debugOutputPS,debugProcessFrontendPS,detailModesPS,diffusePS,diffuseDetailMapPS,decodePS,emissivePS,encodePS,endPS,endVS,envAtlasPS,envConstPS,envMultiplyPS,extensionPS,extensionVS,falloffInvSquaredPS,falloffLinearPS,fixCubemapSeamsNonePS,fixCubemapSeamsStretchPS,floatUnpackingPS,fogExpPS,fogExp2PS,fogLinearPS,fogNonePS,fresnelSchlickPS,fullscreenQuadPS,fullscreenQuadVS,gamma1_0PS,gamma2_2PS,gles2PS,gles2VS,gles3PS,gles3VS,glossPS,iridescenceDiffractionPS,iridescencePS,iridescenceThicknessPS,instancingVS,iorPS,lightDiffuseLambertPS,lightDirPointPS,lightmapAddPS,lightmapDirAddPS,lightmapDirPS,lightmapSinglePS,lightSpecularAnisoGGXPS,lightSpecularBlinnPS,lightSpecularPhongPS,lightSheenPS,linearizeDepthPS,litShaderArgsPS,ltcPS,metalnessPS,metalnessModulatePS,msdfPS,msdfVS,normalVS,normalDetailMapPS,normalInstancedVS,normalMapPS,normalSkinnedVS,normalXYPS,normalXYZPS,opacityPS,opacityDitherPS,outputPS,outputAlphaPS,outputAlphaOpaquePS,outputAlphaPremulPS,outputTex2DPS,packDepthPS,sheenPS,sheenGlossPS,parallaxPS,particlePS,particleVS,particleAnimFrameClampVS,particleAnimFrameLoopVS,particleAnimTexVS,particleInputFloatPS,particleInputRgba8PS,particleOutputFloatPS,particleOutputRgba8PS,particleUpdaterAABBPS,particleUpdaterEndPS,particleUpdaterInitPS,particleUpdaterNoRespawnPS,particleUpdaterOnStopPS,particleUpdaterRespawnPS,particleUpdaterSpherePS,particleUpdaterStartPS,particle_billboardVS,particle_blendAddPS,particle_blendMultiplyPS,particle_blendNormalPS,particle_cpuVS,particle_cpu_endVS,particle_customFaceVS,particle_endPS,particle_endVS,particle_halflambertPS,particle_initVS,particle_lambertPS,particle_lightingPS,particle_localShiftVS,particle_meshVS,particle_normalVS,particle_normalMapPS,particle_pointAlongVS,particle_softPS,particle_softVS,particle_stretchVS,particle_TBNVS,particle_wrapVS,reflDirPS,reflDirAnisoPS,reflectionCCPS,reflectionCubePS,reflectionEnvHQPS,reflectionEnvPS,reflectionSpherePS,reflectionSheenPS,refractionCubePS,refractionDynamicPS,reprojectPS,sampleCatmullRomPS,screenDepthPS,shadowCascadesPS,shadowEVSMPS,shadowEVSMnPS,shadowPCSSPS,shadowSampleCoordPS,shadowStandardPS,shadowStandardGL2PS,shadowVSM8PS,shadowVSM_commonPS,skinBatchConstVS,skinBatchTexVS,skinConstVS,skinTexVS,skyboxEnvPS,skyboxHDRPS,skyboxVS,specularPS,sphericalPS,specularityFactorPS,spotPS,startPS,startVS,startNineSlicedPS,startNineSlicedTiledPS,storeEVSMPS,tangentBinormalVS,TBNPS,TBNderivativePS,TBNfastPS,TBNObjectSpacePS,textureSamplePS,thicknessPS,tonemappingAcesPS,tonemappingAces2PS,tonemappingFilmicPS,tonemappingHejlPS,tonemappingLinearPS,tonemappingNeutralPS,tonemappingNonePS,transformVS,transformDeclVS,transmissionPS,twoSidedLightingPS,uv0VS,uv1VS,viewDirPS,viewNormalVS,webgpuPS,webgpuVS};const programLibraryDeviceCache=new DeviceCache;function getProgramLibrary(device){const library=programLibraryDeviceCache.get(device);return library}function setProgramLibrary(device,library){programLibraryDeviceCache.get(device,()=>{return library});}class ShaderGenerator{static begin(){return "void main(void)\n{\n"}static end(){return "}\n"}static skinCode(device,chunks=shaderChunks){if(device.supportsBoneTextures){return chunks.skinTexVS}return `#define BONE_LIMIT ${device.getBoneLimit()}
${chunks.skinConstVS}`}static fogCode(value,chunks=shaderChunks){if(value==="linear"){return chunks.fogLinearPS?chunks.fogLinearPS:shaderChunks.fogLinearPS}else if(value==="exp"){return chunks.fogExpPS?chunks.fogExpPS:shaderChunks.fogExpPS}else if(value==="exp2"){return chunks.fogExp2PS?chunks.fogExp2PS:shaderChunks.fogExp2PS}return chunks.fogNonePS?chunks.fogNonePS:shaderChunks.fogNonePS}static gammaCode(value,chunks=shaderChunks){if(value===GAMMA_SRGB||value===GAMMA_SRGBFAST){return chunks.gamma2_2PS?chunks.gamma2_2PS:shaderChunks.gamma2_2PS}else if(value===GAMMA_SRGBHDR){return `#define HDR
${chunks.gamma2_2PS?chunks.gamma2_2PS:shaderChunks.gamma2_2PS}`}return chunks.gamma1_0PS?chunks.gamma1_0PS:shaderChunks.gamma1_0PS}static tonemapCode(value,chunks=shaderChunks){var _chunks$tonemappingFi,_chunks$tonemappingLi,_chunks$tonemappingHe,_chunks$tonemappingAc,_chunks$tonemappingAc2,_chunks$tonemappingNe,_chunks$tonemapingNon;switch(value){case TONEMAP_FILMIC:return (_chunks$tonemappingFi=chunks.tonemappingFilmicPS)!=null?_chunks$tonemappingFi:shaderChunks.tonemappingFilmicPS;case TONEMAP_LINEAR:return (_chunks$tonemappingLi=chunks.tonemappingLinearPS)!=null?_chunks$tonemappingLi:shaderChunks.tonemappingLinearPS;case TONEMAP_HEJL:return (_chunks$tonemappingHe=chunks.tonemappingHejlPS)!=null?_chunks$tonemappingHe:shaderChunks.tonemappingHejlPS;case TONEMAP_ACES:return (_chunks$tonemappingAc=chunks.tonemappingAcesPS)!=null?_chunks$tonemappingAc:shaderChunks.tonemappingAcesPS;case TONEMAP_ACES2:return (_chunks$tonemappingAc2=chunks.tonemappingAces2PS)!=null?_chunks$tonemappingAc2:shaderChunks.tonemappingAces2PS;case TONEMAP_NEUTRAL:return (_chunks$tonemappingNe=chunks.tonemappingNeutralPS)!=null?_chunks$tonemappingNe:shaderChunks.tonemappingNeutralPS}return (_chunks$tonemapingNon=chunks.tonemapingNonePS)!=null?_chunks$tonemapingNon:shaderChunks.tonemappingNonePS}}function createShader(device,vsName,fsName,useTransformFeedback=false,shaderDefinitionOptions={}){if(typeof useTransformFeedback==="boolean"){shaderDefinitionOptions.useTransformFeedback=useTransformFeedback;}else if(typeof useTransformFeedback==="object"){shaderDefinitionOptions=_extends({},shaderDefinitionOptions,useTransformFeedback);}return new Shader(device,ShaderUtils.createDefinition(device,_extends({},shaderDefinitionOptions,{name:`${vsName}_${fsName}`,vertexCode:shaderChunks[vsName],fragmentCode:shaderChunks[fsName]})))}function createShaderFromCode(device,vsCode,fsCode,uniqueName,attributes,useTransformFeedback=false,shaderDefinitionOptions={}){if(typeof useTransformFeedback==="boolean"){shaderDefinitionOptions.useTransformFeedback=useTransformFeedback;}else if(typeof useTransformFeedback==="object"){shaderDefinitionOptions=_extends({},shaderDefinitionOptions,useTransformFeedback);}const programLibrary=getProgramLibrary(device);let shader=programLibrary.getCachedShader(uniqueName);if(!shader){shader=new Shader(device,ShaderUtils.createDefinition(device,_extends({},shaderDefinitionOptions,{name:uniqueName,vertexCode:vsCode,fragmentCode:fsCode,attributes:attributes})));programLibrary.setCachedShader(uniqueName,shader);}return shader}class ShaderGeneratorPassThrough extends ShaderGenerator{generateKey(options){return this.key}createShaderDefinition(device,options){return this.shaderDefinition}constructor(key,shaderDefinition){super();this.key=key;this.shaderDefinition=shaderDefinition;}}function processShader(shader,processingOptions){var _shaderDefinition$nam;const shaderDefinition=shader.definition;const name=(_shaderDefinition$nam=shaderDefinition.name)!=null?_shaderDefinition$nam:"shader";const key=`${name}-id-${shader.id}`;const materialGenerator=new ShaderGeneratorPassThrough(key,shaderDefinition);const libraryModuleName="shader";const library=getProgramLibrary(shader.device);library.register(libraryModuleName,materialGenerator);const variant=library.getProgram(libraryModuleName,{},processingOptions);if(shader.definition.shaderLanguage===SHADERLANGUAGE_WGSL){variant.meshUniformBufferFormat=shaderDefinition.meshUniformBufferFormat;variant.meshBindGroupFormat=shaderDefinition.meshBindGroupFormat;}library.unregister(libraryModuleName);return variant}shaderChunks.createShader=createShader;shaderChunks.createShaderFromCode=createShaderFromCode;const _quadPrimitive={type:PRIMITIVE_TRISTRIP,base:0,count:4,indexed:false};const _tempViewport=new Vec4;const _tempScissor=new Vec4;class QuadRender{destroy(){var _this$uniformBuffer,_this$bindGroup;(_this$uniformBuffer=this.uniformBuffer)==null||_this$uniformBuffer.destroy();this.uniformBuffer=null;(_this$bindGroup=this.bindGroup)==null||_this$bindGroup.destroy();this.bindGroup=null;}render(viewport,scissor){const device=this.shader.device;if(viewport){var _scissor;_tempViewport.set(device.vx,device.vy,device.vw,device.vh);_tempScissor.set(device.sx,device.sy,device.sw,device.sh);scissor=(_scissor=scissor)!=null?_scissor:viewport;device.setViewport(viewport.x,viewport.y,viewport.z,viewport.w);device.setScissor(scissor.x,scissor.y,scissor.z,scissor.w);}device.setVertexBuffer(device.quadVertexBuffer,0);const shader=this.shader;device.setShader(shader);if(device.supportsUniformBuffers){var _bindGroup$defaultUni;const bindGroup=this.bindGroup;(_bindGroup$defaultUni=bindGroup.defaultUniformBuffer)==null||_bindGroup$defaultUni.update();bindGroup.update();device.setBindGroup(BINDGROUP_MESH,bindGroup);}device.draw(_quadPrimitive);if(viewport){device.setViewport(_tempViewport.x,_tempViewport.y,_tempViewport.z,_tempViewport.w);device.setScissor(_tempScissor.x,_tempScissor.y,_tempScissor.z,_tempScissor.w);}}constructor(shader){this.uniformBuffer=void 0;this.bindGroup=void 0;const device=shader.device;this.shader=shader;if(device.supportsUniformBuffers){const processingOptions=new ShaderProcessorOptions;this.shader=processShader(shader,processingOptions);const ubFormat=this.shader.meshUniformBufferFormat;if(ubFormat){this.uniformBuffer=new UniformBuffer(device,ubFormat,false);}const bindGroupFormat=this.shader.meshBindGroupFormat;this.bindGroup=new BindGroup(device,bindGroupFormat,this.uniformBuffer);}}}class RenderPassQuad extends RenderPass{execute(){const{device}=this;device.setCullMode(CULLFACE_NONE);device.setDepthState(DepthState.NODEPTH);device.setStencilState(null,null);this.quad.render(this.rect,this.scissorRect);}constructor(device,quad,rect,scissorRect){super(device);this.quad=quad;this.rect=rect;this.scissorRect=scissorRect;}}const _tempRect=new Vec4;function drawQuadWithShader(device,target,shader,rect,scissorRect){const quad=new QuadRender(shader);if(!rect){rect=_tempRect;rect.x=0;rect.y=0;rect.z=target?target.width:device.width;rect.w=target?target.height:device.height;}const renderPass=new RenderPassQuad(device,quad,rect,scissorRect);renderPass.init(target);renderPass.colorOps.clear=false;renderPass.depthStencilOps.clearDepth=false;if(device.isWebGPU&&target===null&&device.samples>1){renderPass.colorOps.store=true;}renderPass.render();quad.destroy();}function drawTexture(device,texture,target,shader,rect,scissorRect){shader=shader||device.getCopyShader();device.constantTexSource.setValue(texture);drawQuadWithShader(device,target,shader,rect,scissorRect);}const shaderPassDeviceCache=new DeviceCache;class ShaderPassInfo{buildShaderDefines(){let keyword;if(this.isShadow){keyword="SHADOW";}else if(this.isForward){keyword="FORWARD";}else if(this.index===SHADER_DEPTH){keyword="DEPTH";}else if(this.index===SHADER_PICK){keyword="PICK";}const define1=keyword?`#define ${keyword}_PASS
`:"";const define2=`#define ${this.name.toUpperCase()}_PASS
`;return define1+define2}constructor(name,index,options={}){this.index=void 0;this.name=void 0;this.shaderDefines=void 0;this.name=name;this.index=index;Object.assign(this,options);this.shaderDefines=this.buildShaderDefines();}}class ShaderPass{static get(device){return shaderPassDeviceCache.get(device,()=>{return new ShaderPass})}allocate(name,options){let info=this.passesNamed.get(name);if(info===undefined){info=new ShaderPassInfo(name,this.nextIndex,options);this.passesNamed.set(info.name,info);this.passesIndexed[info.index]=info;this.nextIndex++;}return info}getByIndex(index){const info=this.passesIndexed[index];return info}getByName(name){return this.passesNamed.get(name)}constructor(){this.passesNamed=new Map;this.passesIndexed=[];this.nextIndex=0;const add=(name,index,options)=>{this.allocate(name,options);};add("forward",SHADER_FORWARD,{isForward:true});add("forward_hdr",SHADER_FORWARDHDR,{isForward:true});add("depth");add("pick");add("shadow");add("prepass");}}const vShader=`

		#include "shaderPassDefines"
		#include "transformDeclVS"

		#ifdef SKIN
				#include "skinCode"
		#endif

		#include "transformVS"

		#ifdef VERTEX_COLORS
				attribute vec4 vertex_color;
				varying vec4 vColor;
		#endif

		#ifdef DIFFUSE_MAP
				attribute vec2 vertex_texCoord0;
				varying vec2 vUv0;
		#endif

		#ifdef DEPTH_PASS
				varying float vDepth;
				
				#ifndef VIEWMATRIX
				#define VIEWMATRIX
						uniform mat4 matrix_view;
				#endif

				#ifndef CAMERAPLANES
				#define CAMERAPLANES
						uniform vec4 camera_params;
				#endif
		#endif

		void main(void) {
				gl_Position = getPosition();

				#ifdef DEPTH_PASS
						vDepth = -(matrix_view * vec4(getWorldPosition(),1.0)).z * camera_params.x;
				#endif        

				#ifdef VERTEX_COLORS
						vColor = vertex_color;
				#endif

				#ifdef DIFFUSE_MAP
						vUv0 = vertex_texCoord0;
				#endif
		}
`;const fShader$1=`

		#include "shaderPassDefines"

		#ifdef VERTEX_COLORS
				varying vec4 vColor;
		#else
				uniform vec4 uColor;
		#endif

		#ifdef DIFFUSE_MAP
				varying vec2 vUv0;
				uniform sampler2D texture_diffuseMap;
		#endif

		#ifdef FOG
				#include "fogCode"
		#endif

		#ifdef ALPHA_TEST
				#include "alphaTestPS"
		#endif

		#ifdef DEPTH_PASS
				varying float vDepth;
				#include "packDepthPS"
		#endif

		void main(void) {

				#ifdef VERTEX_COLORS
						gl_FragColor = vColor;
				#else
						gl_FragColor = uColor;
				#endif

				#ifdef DIFFUSE_MAP
						gl_FragColor *= texture2D(texture_diffuseMap, vUv0);
				#endif

				#ifdef ALPHA_TEST
						alphaTest(gl_FragColor.a);
				#endif

				#ifndef PICK_PASS

						#ifdef DEPTH_PASS
								gl_FragColor = packFloat(vDepth);
						#else
								#ifdef FOG
										glFragColor.rgb = addFog(gl_FragColor.rgb);
								#endif
						#endif
				#endif
		}
`;class ShaderGeneratorBasic extends ShaderGenerator{generateKey(options){let key="basic";if(options.fog)key+="_fog";if(options.alphaTest)key+="_atst";if(options.vertexColors)key+="_vcol";if(options.diffuseMap)key+="_diff";if(options.skin)key+="_skin";if(options.screenSpace)key+="_ss";if(options.useInstancing)key+="_inst";if(options.useMorphPosition)key+="_morphp";if(options.useMorphNormal)key+="_morphn";if(options.useMorphTextureBased)key+="_morpht";key+=`_${options.pass}`;return key}createAttributesDefinition(definitionOptions,options){const attributes={vertex_position:SEMANTIC_POSITION};if(options.skin){attributes.vertex_boneWeights=SEMANTIC_BLENDWEIGHT;attributes.vertex_boneIndices=SEMANTIC_BLENDINDICES;}if(options.vertexColors){attributes.vertex_color=SEMANTIC_COLOR;}if(options.diffuseMap){attributes.vertex_texCoord0=SEMANTIC_TEXCOORD0;}definitionOptions.attributes=attributes;}createVertexDefinition(device,definitionOptions,options,shaderPassInfo){const includes=new Map;const defines=new Map;includes.set("shaderPassDefines",shaderPassInfo.shaderDefines);includes.set("transformDeclVS",shaderChunks.transformDeclVS);includes.set("transformVS",shaderChunks.transformVS);includes.set("skinCode",ShaderGenerator.skinCode(device));if(options.skin)defines.set("SKIN",true);if(options.vertexColors)defines.set("VERTEX_COLORS",true);if(options.diffuseMap)defines.set("DIFFUSE_MAP",true);definitionOptions.vertexCode=vShader;definitionOptions.vertexIncludes=includes;definitionOptions.vertexDefines=defines;}createFragmentDefinition(definitionOptions,options,shaderPassInfo){const includes=new Map;const defines=new Map;includes.set("shaderPassDefines",shaderPassInfo.shaderDefines);includes.set("fogCode",ShaderGenerator.fogCode(options.fog));includes.set("alphaTestPS",shaderChunks.alphaTestPS);includes.set("packDepthPS",shaderChunks.packDepthPS);if(options.vertexColors)defines.set("VERTEX_COLORS",true);if(options.diffuseMap)defines.set("DIFFUSE_MAP",true);if(options.fog)defines.set("FOG",true);if(options.alphaTest)defines.set("ALPHA_TEST",true);definitionOptions.fragmentCode=fShader$1;definitionOptions.fragmentIncludes=includes;definitionOptions.fragmentDefines=defines;}createShaderDefinition(device,options){const definitionOptions={name:"BasicShader"};const shaderPassInfo=ShaderPass.get(device).getByIndex(options.pass);this.createAttributesDefinition(definitionOptions,options);this.createVertexDefinition(device,definitionOptions,options,shaderPassInfo);this.createFragmentDefinition(definitionOptions,options,shaderPassInfo);return ShaderUtils.createDefinition(device,definitionOptions)}}const basic=new ShaderGeneratorBasic;const defaultMaterialDeviceCache=new DeviceCache;function getDefaultMaterial(device){const material=defaultMaterialDeviceCache.get(device);return material}function setDefaultMaterial(device,material){defaultMaterialDeviceCache.get(device,()=>{return material});}const blendModes=[];blendModes[BLEND_SUBTRACTIVE]={src:BLENDMODE_ONE,dst:BLENDMODE_ONE,op:BLENDEQUATION_REVERSE_SUBTRACT};blendModes[BLEND_NONE]={src:BLENDMODE_ONE,dst:BLENDMODE_ZERO,op:BLENDEQUATION_ADD};blendModes[BLEND_NORMAL]={src:BLENDMODE_SRC_ALPHA,dst:BLENDMODE_ONE_MINUS_SRC_ALPHA,op:BLENDEQUATION_ADD};blendModes[BLEND_PREMULTIPLIED]={src:BLENDMODE_ONE,dst:BLENDMODE_ONE_MINUS_SRC_ALPHA,op:BLENDEQUATION_ADD};blendModes[BLEND_ADDITIVE]={src:BLENDMODE_ONE,dst:BLENDMODE_ONE,op:BLENDEQUATION_ADD};blendModes[BLEND_ADDITIVEALPHA]={src:BLENDMODE_SRC_ALPHA,dst:BLENDMODE_ONE,op:BLENDEQUATION_ADD};blendModes[BLEND_MULTIPLICATIVE2X]={src:BLENDMODE_DST_COLOR,dst:BLENDMODE_SRC_COLOR,op:BLENDEQUATION_ADD};blendModes[BLEND_SCREEN]={src:BLENDMODE_ONE_MINUS_DST_COLOR,dst:BLENDMODE_ONE,op:BLENDEQUATION_ADD};blendModes[BLEND_MULTIPLICATIVE]={src:BLENDMODE_DST_COLOR,dst:BLENDMODE_ZERO,op:BLENDEQUATION_ADD};blendModes[BLEND_MIN]={src:BLENDMODE_ONE,dst:BLENDMODE_ONE,op:BLENDEQUATION_MIN};blendModes[BLEND_MAX]={src:BLENDMODE_ONE,dst:BLENDMODE_ONE,op:BLENDEQUATION_MAX};let id$3=0;class Material{set depthBias(value){this._depthState.depthBias=value;}get depthBias(){return this._depthState.depthBias}set slopeDepthBias(value){this._depthState.depthBiasSlope=value;}get slopeDepthBias(){return this._depthState.depthBiasSlope}set redWrite(value){this._blendState.redWrite=value;}get redWrite(){return this._blendState.redWrite}set greenWrite(value){this._blendState.greenWrite=value;}get greenWrite(){return this._blendState.greenWrite}set blueWrite(value){this._blendState.blueWrite=value;}get blueWrite(){return this._blendState.blueWrite}set alphaWrite(value){this._blendState.alphaWrite=value;}get alphaWrite(){return this._blendState.alphaWrite}set shader(shader){this._shader=shader;}get shader(){return this._shader}get transparent(){return this._blendState.blend}_updateTransparency(){const transparent=this.transparent;const meshInstances=this.meshInstances;for(let i=0;i<meshInstances.length;i++){meshInstances[i].transparent=transparent;}}set blendState(value){this._blendState.copy(value);this._updateTransparency();}get blendState(){return this._blendState}set blendType(type){const blendMode=blendModes[type];this._blendState.setColorBlend(blendMode.op,blendMode.src,blendMode.dst);this._blendState.setAlphaBlend(blendMode.op,blendMode.src,blendMode.dst);const blend=type!==BLEND_NONE;if(this._blendState.blend!==blend){this._blendState.blend=blend;this._updateTransparency();}this._updateMeshInstanceKeys();}get blendType(){if(!this.transparent){return BLEND_NONE}const{colorOp,colorSrcFactor,colorDstFactor,alphaOp,alphaSrcFactor,alphaDstFactor}=this._blendState;for(let i=0;i<blendModes.length;i++){const blendMode=blendModes[i];if(blendMode.src===colorSrcFactor&&blendMode.dst===colorDstFactor&&blendMode.op===colorOp&&blendMode.src===alphaSrcFactor&&blendMode.dst===alphaDstFactor&&blendMode.op===alphaOp){return i}}return BLEND_NORMAL}set depthState(value){this._depthState.copy(value);}get depthState(){return this._depthState}set depthTest(value){this._depthState.test=value;}get depthTest(){return this._depthState.test}set depthFunc(value){this._depthState.func=value;}get depthFunc(){return this._depthState.func}set depthWrite(value){this._depthState.write=value;}get depthWrite(){return this._depthState.write}copy(source){var _source$stencilFront;this.name=source.name;this._shader=source._shader;this.alphaTest=source.alphaTest;this.alphaToCoverage=source.alphaToCoverage;this._blendState.copy(source._blendState);this._depthState.copy(source._depthState);this.cull=source.cull;this.stencilFront=(_source$stencilFront=source.stencilFront)==null?void 0:_source$stencilFront.clone();if(source.stencilBack){this.stencilBack=source.stencilFront===source.stencilBack?this.stencilFront:source.stencilBack.clone();}return this}clone(){const clone=new this.constructor;return clone.copy(this)}_updateMeshInstanceKeys(){const meshInstances=this.meshInstances;for(let i=0;i<meshInstances.length;i++){meshInstances[i].updateKey();}}updateUniforms(device,scene){}getShaderVariant(device,scene,objDefs,unused,pass,sortedLights,viewUniformFormat,viewBindGroupFormat,vertexFormat){const processingOptions=new ShaderProcessorOptions(viewUniformFormat,viewBindGroupFormat,vertexFormat);return processShader(this._shader,processingOptions)}update(){this.dirty=true;if(this._shader)this._shader.failed=false;}clearParameters(){this.parameters={};}getParameters(){return this.parameters}clearVariants(){this.variants.clear();const meshInstances=this.meshInstances;const count=meshInstances.length;for(let i=0;i<count;i++){meshInstances[i].clearShaders();}}getParameter(name){return this.parameters[name]}setParameter(name,data){if(data===undefined&&typeof name==="object"){const uniformObject=name;if(uniformObject.length){for(let i=0;i<uniformObject.length;i++){this.setParameter(uniformObject[i]);}return}name=uniformObject.name;data=uniformObject.value;}const param=this.parameters[name];if(param){param.data=data;}else {this.parameters[name]={scopeId:null,data:data};}}deleteParameter(name){if(this.parameters[name]){delete this.parameters[name];}}setParameters(device,names){const parameters=this.parameters;if(names===undefined)names=parameters;for(const paramName in names){const parameter=parameters[paramName];if(parameter){if(!parameter.scopeId){parameter.scopeId=device.scope.resolve(paramName);}parameter.scopeId.setValue(parameter.data);}}}destroy(){this.variants.clear();this._shader=null;for(let i=0;i<this.meshInstances.length;i++){const meshInstance=this.meshInstances[i];meshInstance.clearShaders();meshInstance._material=null;if(meshInstance.mesh){const defaultMaterial=getDefaultMaterial(meshInstance.mesh.device);if(this!==defaultMaterial){meshInstance.material=defaultMaterial;}}}this.meshInstances.length=0;}addMeshInstanceRef(meshInstance){this.meshInstances.push(meshInstance);}removeMeshInstanceRef(meshInstance){const meshInstances=this.meshInstances;const i=meshInstances.indexOf(meshInstance);if(i!==-1){meshInstances.splice(i,1);}}constructor(){this._shader=null;this.meshInstances=[];this.name="Untitled";this.userId="";this.id=id$3++;this.variants=new Map;this.parameters={};this.alphaTest=0;this.alphaToCoverage=false;this._blendState=new BlendState;this._depthState=new DepthState;this.cull=CULLFACE_BACK;this.stencilFront=null;this.stencilBack=null;this._shaderVersion=0;this._scene=null;this.dirty=true;}}class BasicMaterial extends Material{copy(source){super.copy(source);this.color.copy(source.color);this.colorMap=source.colorMap;this.vertexColors=source.vertexColors;return this}updateUniforms(device,scene){this.clearParameters();this.colorUniform[0]=this.color.r;this.colorUniform[1]=this.color.g;this.colorUniform[2]=this.color.b;this.colorUniform[3]=this.color.a;this.setParameter("uColor",this.colorUniform);if(this.colorMap){this.setParameter("texture_diffuseMap",this.colorMap);}}getShaderVariant(device,scene,objDefs,unused,pass,sortedLights,viewUniformFormat,viewBindGroupFormat,vertexFormat){const options={skin:objDefs&&(objDefs&SHADERDEF_SKIN)!==0,screenSpace:objDefs&&(objDefs&SHADERDEF_SCREENSPACE)!==0,useInstancing:objDefs&&(objDefs&SHADERDEF_INSTANCING)!==0,useMorphPosition:objDefs&&(objDefs&SHADERDEF_MORPH_POSITION)!==0,useMorphNormal:objDefs&&(objDefs&SHADERDEF_MORPH_NORMAL)!==0,useMorphTextureBased:objDefs&&(objDefs&SHADERDEF_MORPH_TEXTURE_BASED)!==0,alphaTest:this.alphaTest>0,vertexColors:this.vertexColors,diffuseMap:!!this.colorMap,pass:pass};const processingOptions=new ShaderProcessorOptions(viewUniformFormat,viewBindGroupFormat,vertexFormat);const library=getProgramLibrary(device);library.register("basic",basic);return library.getProgram("basic",options,processingOptions,this.userId)}constructor(...args){super(...args);this.color=new Color(1,1,1,1);this.colorUniform=new Float32Array(4);this.colorMap=null;this.vertexColors=false;}}class Batch{destroy(scene,layers){if(this.meshInstance){this.removeFromLayers(scene,layers);this.meshInstance.destroy();this.meshInstance=null;}}addToLayers(scene,layers){for(let i=0;i<layers.length;i++){const layer=scene.layers.getLayerById(layers[i]);if(layer){layer.addMeshInstances([this.meshInstance]);}}}removeFromLayers(scene,layers){for(let i=0;i<layers.length;i++){const layer=scene.layers.getLayerById(layers[i]);if(layer){layer.removeMeshInstances([this.meshInstance]);}}}updateBoundingBox(){this._aabb.copy(this.origMeshInstances[0].aabb);for(let i=1;i<this.origMeshInstances.length;i++){this._aabb.add(this.origMeshInstances[i].aabb);}this.meshInstance.aabb=this._aabb;this.meshInstance._aabbVer=0;}constructor(meshInstances,dynamic,batchGroupId){this._aabb=new BoundingBox;this.origMeshInstances=void 0;this.meshInstance=null;this.dynamic=void 0;this.batchGroupId=void 0;this.origMeshInstances=meshInstances;this.dynamic=dynamic;this.batchGroupId=batchGroupId;}}class BatchGroup{constructor(id,name,dynamic,maxAabbSize,layers=[LAYERID_WORLD]){this._ui=false;this._sprite=false;this._obj={model:[],element:[],sprite:[],render:[]};this.id=void 0;this.name=void 0;this.dynamic=void 0;this.maxAabbSize=void 0;this.layers=void 0;this.id=id;this.name=name;this.dynamic=dynamic;this.maxAabbSize=maxAabbSize;this.layers=layers;}}BatchGroup.MODEL="model";BatchGroup.ELEMENT="element";BatchGroup.SPRITE="sprite";BatchGroup.RENDER="render";const _invMatrix=new Mat4;class SkinInstance{set rootBone(rootBone){this._rootBone=rootBone;}get rootBone(){return this._rootBone}init(device,numBones){if(device.supportsBoneTextures){const numPixels=numBones*3;let width=Math.ceil(Math.sqrt(numPixels));width=math.roundUp(width,3);const height=Math.ceil(numPixels/width);this.boneTexture=new Texture(device,{width:width,height:height,format:PIXELFORMAT_RGBA32F,mipmaps:false,minFilter:FILTER_NEAREST,magFilter:FILTER_NEAREST,name:"skin"});this.boneTextureSize=[width,height,1/width,1/height];this.matrixPalette=this.boneTexture.lock({mode:TEXTURELOCK_READ});this.boneTexture.unlock();}else {this.matrixPalette=new Float32Array(numBones*12);}}destroy(){if(this.boneTexture){this.boneTexture.destroy();this.boneTexture=null;}}resolve(rootBone,entity){this.rootBone=rootBone;const skin=this.skin;const bones=[];for(let j=0;j<skin.boneNames.length;j++){const boneName=skin.boneNames[j];let bone=rootBone.findByName(boneName);if(!bone){bone=entity;}bones.push(bone);}this.bones=bones;}initSkin(skin){this.skin=skin;this.bones=[];const numBones=skin.inverseBindPose.length;this.init(skin.device,numBones);this.matrices=[];for(let i=0;i<numBones;i++){this.matrices[i]=new Mat4;}}uploadBones(device){if(device.supportsBoneTextures){this.boneTexture.lock();this.boneTexture.unlock();}}_updateMatrices(rootNode,skinUpdateIndex){if(this._skinUpdateIndex!==skinUpdateIndex){this._skinUpdateIndex=skinUpdateIndex;_invMatrix.copy(rootNode.getWorldTransform()).invert();for(let i=this.bones.length-1;i>=0;i--){this.matrices[i].mulAffine2(_invMatrix,this.bones[i].getWorldTransform());this.matrices[i].mulAffine2(this.matrices[i],this.skin.inverseBindPose[i]);}}}updateMatrices(rootNode,skinUpdateIndex){if(this._updateBeforeCull){this._updateMatrices(rootNode,skinUpdateIndex);}}updateMatrixPalette(rootNode,skinUpdateIndex){this._updateMatrices(rootNode,skinUpdateIndex);const mp=this.matrixPalette;const count=this.bones.length;for(let i=0;i<count;i++){const pe=this.matrices[i].data;const base=i*12;mp[base]=pe[0];mp[base+1]=pe[4];mp[base+2]=pe[8];mp[base+3]=pe[12];mp[base+4]=pe[1];mp[base+5]=pe[5];mp[base+6]=pe[9];mp[base+7]=pe[13];mp[base+8]=pe[2];mp[base+9]=pe[6];mp[base+10]=pe[10];mp[base+11]=pe[14];}this.uploadBones(this.skin.device);}constructor(skin){this.bones=void 0;this.boneTextureSize=void 0;this._dirty=true;this._rootBone=null;this._skinUpdateIndex=-1;this._updateBeforeCull=true;if(skin){this.initSkin(skin);}}}class SkinBatchInstance extends SkinInstance{updateMatrices(rootNode,skinUpdateIndex){}updateMatrixPalette(rootNode,skinUpdateIndex){const mp=this.matrixPalette;const count=this.bones.length;for(let i=0;i<count;i++){const pe=this.bones[i].getWorldTransform().data;const base=i*12;mp[base]=pe[0];mp[base+1]=pe[4];mp[base+2]=pe[8];mp[base+3]=pe[12];mp[base+4]=pe[1];mp[base+5]=pe[5];mp[base+6]=pe[9];mp[base+7]=pe[13];mp[base+8]=pe[2];mp[base+9]=pe[6];mp[base+10]=pe[10];mp[base+11]=pe[14];}this.uploadBones(this.device);}constructor(device,nodes,rootNode){super();const numBones=nodes.length;this.init(device,numBones);this.device=device;this.rootNode=rootNode;this.bones=nodes;}}class RefCountedObject{incRefCount(){this._refCount++;}decRefCount(){this._refCount--;}get refCount(){return this._refCount}constructor(){this._refCount=0;}}let id$2=0;class GeometryData{initDefaults(){this.recreate=false;this.verticesUsage=BUFFER_STATIC;this.indicesUsage=BUFFER_STATIC;this.maxVertices=0;this.maxIndices=0;this.vertexCount=0;this.indexCount=0;this.vertexStreamsUpdated=false;this.indexStreamUpdated=false;this.vertexStreamDictionary={};this.indices=null;}_changeVertexCount(count,semantic){if(!this.vertexCount){this.vertexCount=count;}}constructor(){this.initDefaults();}}GeometryData.DEFAULT_COMPONENTS_POSITION=3;GeometryData.DEFAULT_COMPONENTS_NORMAL=3;GeometryData.DEFAULT_COMPONENTS_UV=2;GeometryData.DEFAULT_COMPONENTS_COLORS=4;class GeometryVertexStream{constructor(data,componentCount,dataType,dataTypeNormalize,asInt){this.data=data;this.componentCount=componentCount;this.dataType=dataType;this.dataTypeNormalize=dataTypeNormalize;this.asInt=asInt;}}class Mesh extends RefCountedObject{static fromGeometry(graphicsDevice,geometry,options={}){const mesh=new Mesh(graphicsDevice,options);const{positions,normals,tangents,colors,uvs,uvs1,blendIndices,blendWeights,indices}=geometry;if(positions){mesh.setPositions(positions);}if(normals){mesh.setNormals(normals);}if(tangents){mesh.setVertexStream(SEMANTIC_TANGENT,tangents,4);}if(colors){mesh.setColors32(colors);}if(uvs){mesh.setUvs(0,uvs);}if(uvs1){mesh.setUvs(1,uvs1);}if(blendIndices){mesh.setVertexStream(SEMANTIC_BLENDINDICES,blendIndices,4,blendIndices.length/4,TYPE_UINT8);}if(blendWeights){mesh.setVertexStream(SEMANTIC_BLENDWEIGHT,blendWeights,4);}if(indices){mesh.setIndices(indices);}mesh.update();return mesh}set morph(morph){if(morph!==this._morph){if(this._morph){this._morph.decRefCount();}this._morph=morph;if(morph){morph.incRefCount();}}}get morph(){return this._morph}set aabb(aabb){this._aabb=aabb;this._aabbVer++;}get aabb(){return this._aabb}destroy(){const morph=this.morph;if(morph){this.morph=null;if(morph.refCount<1){morph.destroy();}}if(this.vertexBuffer){this.vertexBuffer.destroy();this.vertexBuffer=null;}for(let j=0;j<this.indexBuffer.length;j++){this._destroyIndexBuffer(j);}this.indexBuffer.length=0;this._geometryData=null;}_destroyIndexBuffer(index){if(this.indexBuffer[index]){this.indexBuffer[index].destroy();this.indexBuffer[index]=null;}}_initBoneAabbs(morphTargets){this.boneAabb=[];this.boneUsed=[];let x,y,z;let bMax,bMin;const boneMin=[];const boneMax=[];const boneUsed=this.boneUsed;const numBones=this.skin.boneNames.length;let maxMorphX,maxMorphY,maxMorphZ;for(let i=0;i<numBones;i++){boneMin[i]=new Vec3(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE);boneMax[i]=new Vec3(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);}const iterator=new VertexIterator(this.vertexBuffer);const posElement=iterator.element[SEMANTIC_POSITION];const weightsElement=iterator.element[SEMANTIC_BLENDWEIGHT];const indicesElement=iterator.element[SEMANTIC_BLENDINDICES];const numVerts=this.vertexBuffer.numVertices;for(let j=0;j<numVerts;j++){for(let k=0;k<4;k++){const boneWeight=weightsElement.array[weightsElement.index+k];if(boneWeight>0){const boneIndex=indicesElement.array[indicesElement.index+k];boneUsed[boneIndex]=true;x=posElement.array[posElement.index];y=posElement.array[posElement.index+1];z=posElement.array[posElement.index+2];bMax=boneMax[boneIndex];bMin=boneMin[boneIndex];if(bMin.x>x)bMin.x=x;if(bMin.y>y)bMin.y=y;if(bMin.z>z)bMin.z=z;if(bMax.x<x)bMax.x=x;if(bMax.y<y)bMax.y=y;if(bMax.z<z)bMax.z=z;if(morphTargets){let minMorphX=maxMorphX=x;let minMorphY=maxMorphY=y;let minMorphZ=maxMorphZ=z;for(let l=0;l<morphTargets.length;l++){const target=morphTargets[l];const dx=target.deltaPositions[j*3];const dy=target.deltaPositions[j*3+1];const dz=target.deltaPositions[j*3+2];if(dx<0){minMorphX+=dx;}else {maxMorphX+=dx;}if(dy<0){minMorphY+=dy;}else {maxMorphY+=dy;}if(dz<0){minMorphZ+=dz;}else {maxMorphZ+=dz;}}if(bMin.x>minMorphX)bMin.x=minMorphX;if(bMin.y>minMorphY)bMin.y=minMorphY;if(bMin.z>minMorphZ)bMin.z=minMorphZ;if(bMax.x<maxMorphX)bMax.x=maxMorphX;if(bMax.y<maxMorphY)bMax.y=maxMorphY;if(bMax.z<maxMorphZ)bMax.z=maxMorphZ;}}}iterator.next();}const positionElement=this.vertexBuffer.getFormat().elements.find(e=>e.name===SEMANTIC_POSITION);if(positionElement&&positionElement.normalize){const func=(()=>{switch(positionElement.dataType){case TYPE_INT8:return x=>Math.max(x/127,-1);case TYPE_UINT8:return x=>x/255;case TYPE_INT16:return x=>Math.max(x/32767,-1);case TYPE_UINT16:return x=>x/65535;default:return x=>x}})();for(let i=0;i<numBones;i++){if(boneUsed[i]){const min=boneMin[i];const max=boneMax[i];min.set(func(min.x),func(min.y),func(min.z));max.set(func(max.x),func(max.y),func(max.z));}}}for(let i=0;i<numBones;i++){const aabb=new BoundingBox;aabb.setMinMax(boneMin[i],boneMax[i]);this.boneAabb.push(aabb);}}_initGeometryData(){if(!this._geometryData){this._geometryData=new GeometryData;if(this.vertexBuffer){this._geometryData.vertexCount=this.vertexBuffer.numVertices;this._geometryData.maxVertices=this.vertexBuffer.numVertices;}if(this.indexBuffer.length>0&&this.indexBuffer[0]){this._geometryData.indexCount=this.indexBuffer[0].numIndices;this._geometryData.maxIndices=this.indexBuffer[0].numIndices;}}}clear(verticesDynamic,indicesDynamic,maxVertices=0,maxIndices=0){this._initGeometryData();this._geometryData.initDefaults();this._geometryData.recreate=true;this._geometryData.maxVertices=maxVertices;this._geometryData.maxIndices=maxIndices;this._geometryData.verticesUsage=verticesDynamic?BUFFER_STATIC:BUFFER_DYNAMIC;this._geometryData.indicesUsage=indicesDynamic?BUFFER_STATIC:BUFFER_DYNAMIC;}setVertexStream(semantic,data,componentCount,numVertices,dataType=TYPE_FLOAT32,dataTypeNormalize=false,asInt=false){this._initGeometryData();const vertexCount=numVertices||data.length/componentCount;this._geometryData._changeVertexCount(vertexCount,semantic);this._geometryData.vertexStreamsUpdated=true;this._geometryData.vertexStreamDictionary[semantic]=new GeometryVertexStream(data,componentCount,dataType,dataTypeNormalize,asInt);}getVertexStream(semantic,data){let count=0;let done=false;if(this._geometryData){const stream=this._geometryData.vertexStreamDictionary[semantic];if(stream){done=true;count=this._geometryData.vertexCount;if(ArrayBuffer.isView(data)){data.set(stream.data);}else {data.length=0;data.push(stream.data);}}}if(!done){if(this.vertexBuffer){const iterator=new VertexIterator(this.vertexBuffer);count=iterator.readData(semantic,data);}}return count}setPositions(positions,componentCount=GeometryData.DEFAULT_COMPONENTS_POSITION,numVertices){this.setVertexStream(SEMANTIC_POSITION,positions,componentCount,numVertices,TYPE_FLOAT32,false);}setNormals(normals,componentCount=GeometryData.DEFAULT_COMPONENTS_NORMAL,numVertices){this.setVertexStream(SEMANTIC_NORMAL,normals,componentCount,numVertices,TYPE_FLOAT32,false);}setUvs(channel,uvs,componentCount=GeometryData.DEFAULT_COMPONENTS_UV,numVertices){this.setVertexStream(SEMANTIC_TEXCOORD+channel,uvs,componentCount,numVertices,TYPE_FLOAT32,false);}setColors(colors,componentCount=GeometryData.DEFAULT_COMPONENTS_COLORS,numVertices){this.setVertexStream(SEMANTIC_COLOR,colors,componentCount,numVertices,TYPE_FLOAT32,false);}setColors32(colors,numVertices){this.setVertexStream(SEMANTIC_COLOR,colors,GeometryData.DEFAULT_COMPONENTS_COLORS,numVertices,TYPE_UINT8,true);}setIndices(indices,numIndices){this._initGeometryData();this._geometryData.indexStreamUpdated=true;this._geometryData.indices=indices;this._geometryData.indexCount=numIndices||indices.length;}getPositions(positions){return this.getVertexStream(SEMANTIC_POSITION,positions)}getNormals(normals){return this.getVertexStream(SEMANTIC_NORMAL,normals)}getUvs(channel,uvs){return this.getVertexStream(SEMANTIC_TEXCOORD+channel,uvs)}getColors(colors){return this.getVertexStream(SEMANTIC_COLOR,colors)}getIndices(indices){let count=0;if(this._geometryData&&this._geometryData.indices){const streamIndices=this._geometryData.indices;count=this._geometryData.indexCount;if(ArrayBuffer.isView(indices)){indices.set(streamIndices);}else {indices.length=0;for(let i=0,il=streamIndices.length;i<il;i++){indices.push(streamIndices[i]);}}}else {if(this.indexBuffer.length>0&&this.indexBuffer[0]){const indexBuffer=this.indexBuffer[0];count=indexBuffer.readData(indices);}}return count}update(primitiveType=PRIMITIVE_TRIANGLES,updateBoundingBox=true){if(this._geometryData){if(updateBoundingBox){const stream=this._geometryData.vertexStreamDictionary[SEMANTIC_POSITION];if(stream){if(stream.componentCount===3){this._aabb.compute(stream.data,this._geometryData.vertexCount);this._aabbVer++;}}}let destroyVB=this._geometryData.recreate;if(this._geometryData.vertexCount>this._geometryData.maxVertices){destroyVB=true;this._geometryData.maxVertices=this._geometryData.vertexCount;}if(destroyVB){if(this.vertexBuffer){this.vertexBuffer.destroy();this.vertexBuffer=null;}}let destroyIB=this._geometryData.recreate;if(this._geometryData.indexCount>this._geometryData.maxIndices){destroyIB=true;this._geometryData.maxIndices=this._geometryData.indexCount;}if(destroyIB){if(this.indexBuffer.length>0&&this.indexBuffer[0]){this.indexBuffer[0].destroy();this.indexBuffer[0]=null;}}if(this._geometryData.vertexStreamsUpdated){this._updateVertexBuffer();}if(this._geometryData.indexStreamUpdated){this._updateIndexBuffer();}this.primitive[0].type=primitiveType;if(this.indexBuffer.length>0&&this.indexBuffer[0]){if(this._geometryData.indexStreamUpdated){this.primitive[0].count=this._geometryData.indexCount;this.primitive[0].indexed=true;}}else {if(this._geometryData.vertexStreamsUpdated){this.primitive[0].count=this._geometryData.vertexCount;this.primitive[0].indexed=false;}}this._geometryData.vertexCount=0;this._geometryData.indexCount=0;this._geometryData.vertexStreamsUpdated=false;this._geometryData.indexStreamUpdated=false;this._geometryData.recreate=false;this.updateRenderStates();}}_buildVertexFormat(vertexCount){const vertexDesc=[];for(const semantic in this._geometryData.vertexStreamDictionary){const stream=this._geometryData.vertexStreamDictionary[semantic];vertexDesc.push({semantic:semantic,components:stream.componentCount,type:stream.dataType,normalize:stream.dataTypeNormalize,asInt:stream.asInt});}return new VertexFormat(this.device,vertexDesc,vertexCount)}_updateVertexBuffer(){if(!this.vertexBuffer){const allocateVertexCount=this._geometryData.maxVertices;const format=this._buildVertexFormat(allocateVertexCount);this.vertexBuffer=new VertexBuffer(this.device,format,allocateVertexCount,{usage:this._geometryData.verticesUsage,storage:this._storageVertex});}const iterator=new VertexIterator(this.vertexBuffer);const numVertices=this._geometryData.vertexCount;for(const semantic in this._geometryData.vertexStreamDictionary){const stream=this._geometryData.vertexStreamDictionary[semantic];iterator.writeData(semantic,stream.data,numVertices);delete this._geometryData.vertexStreamDictionary[semantic];}iterator.end();}_updateIndexBuffer(){if(this.indexBuffer.length<=0||!this.indexBuffer[0]){const maxVertices=this._geometryData.maxVertices;const createFormat=maxVertices>65535||maxVertices===0?INDEXFORMAT_UINT32:INDEXFORMAT_UINT16;const options=this._storageIndex?{storage:true}:undefined;this.indexBuffer[0]=new IndexBuffer(this.device,createFormat,this._geometryData.maxIndices,this._geometryData.indicesUsage,undefined,options);}const srcIndices=this._geometryData.indices;if(srcIndices){const indexBuffer=this.indexBuffer[0];indexBuffer.writeData(srcIndices,this._geometryData.indexCount);this._geometryData.indices=null;}}prepareRenderState(renderStyle){if(renderStyle===RENDERSTYLE_WIREFRAME){this.generateWireframe();}else if(renderStyle===RENDERSTYLE_POINTS){this.primitive[RENDERSTYLE_POINTS]={type:PRIMITIVE_POINTS,base:0,count:this.vertexBuffer?this.vertexBuffer.numVertices:0,indexed:false};}}updateRenderStates(){if(this.primitive[RENDERSTYLE_POINTS]){this.prepareRenderState(RENDERSTYLE_POINTS);}if(this.primitive[RENDERSTYLE_WIREFRAME]){this.prepareRenderState(RENDERSTYLE_WIREFRAME);}}generateWireframe(){this._destroyIndexBuffer(RENDERSTYLE_WIREFRAME);const numVertices=this.vertexBuffer.numVertices;const lines=[];let format;if(this.indexBuffer.length>0&&this.indexBuffer[0]){const offsets=[[0,1],[1,2],[2,0]];const base=this.primitive[RENDERSTYLE_SOLID].base;const count=this.primitive[RENDERSTYLE_SOLID].count;const indexBuffer=this.indexBuffer[RENDERSTYLE_SOLID];const srcIndices=new typedArrayIndexFormats[indexBuffer.format](indexBuffer.storage);const seen=new Set;for(let j=base;j<base+count;j+=3){for(let k=0;k<3;k++){const i1=srcIndices[j+offsets[k][0]];const i2=srcIndices[j+offsets[k][1]];const hash=i1>i2?i2*numVertices+i1:i1*numVertices+i2;if(!seen.has(hash)){seen.add(hash);lines.push(i1,i2);}}}format=indexBuffer.format;}else {for(let i=0;i<numVertices;i+=3){lines.push(i,i+1,i+1,i+2,i+2,i);}format=lines.length>65535?INDEXFORMAT_UINT32:INDEXFORMAT_UINT16;}const wireBuffer=new IndexBuffer(this.vertexBuffer.device,format,lines.length);const dstIndices=new typedArrayIndexFormats[wireBuffer.format](wireBuffer.storage);dstIndices.set(lines);wireBuffer.unlock();this.primitive[RENDERSTYLE_WIREFRAME]={type:PRIMITIVE_LINES,base:0,count:lines.length,indexed:true};this.indexBuffer[RENDERSTYLE_WIREFRAME]=wireBuffer;}constructor(graphicsDevice,options){super();this._aabbVer=0;this._aabb=new BoundingBox;this._storageVertex=false;this._storageIndex=false;this.id=id$2++;this.device=graphicsDevice;this._storageIndex=(options==null?void 0:options.storageIndex)||false;this._storageVertex=(options==null?void 0:options.storageVertex)||false;this.vertexBuffer=null;this.indexBuffer=[null];this.primitive=[{type:0,base:0,count:0}];this.skin=null;this._morph=null;this._geometryData=null;this.boneAabb=null;}}const scaleCompensatePosTransform=new Mat4;const scaleCompensatePos=new Vec3;const scaleCompensateRot=new Quat;const scaleCompensateRot2=new Quat;const scaleCompensateScale=new Vec3;const scaleCompensateScaleForParent=new Vec3;const tmpMat4=new Mat4;const tmpQuat=new Quat;const position$1=new Vec3;const invParentWtm$1=new Mat4;const rotation=new Quat;const invParentRot=new Quat;const matrix=new Mat4;const target=new Vec3;const up=new Vec3;function createTest(attr,value){if(attr instanceof Function){return attr}return node=>{let x=node[attr];if(x instanceof Function){x=x();}return x===value}}function findNode(node,test){if(test(node)){return node}const children=node._children;const len=children.length;for(let i=0;i<len;++i){const result=findNode(children[i],test);if(result){return result}}return null}class GraphNode extends EventHandler{get right(){if(!this._right){this._right=new Vec3;}return this.getWorldTransform().getX(this._right).normalize()}get up(){if(!this._up){this._up=new Vec3;}return this.getWorldTransform().getY(this._up).normalize()}get forward(){if(!this._forward){this._forward=new Vec3;}return this.getWorldTransform().getZ(this._forward).normalize().mulScalar(-1)}get normalMatrix(){const normalMat=this._normalMatrix;if(this._dirtyNormal){normalMat.invertMat4(this.getWorldTransform()).transpose();this._dirtyNormal=false;}return normalMat}set enabled(enabled){if(this._enabled!==enabled){var _this$_parent;this._enabled=enabled;if(enabled&&(_this$_parent=this._parent)!=null&&_this$_parent.enabled||!enabled){this._notifyHierarchyStateChanged(this,enabled);}}}get enabled(){return this._enabled&&this._enabledInHierarchy}get parent(){return this._parent}get path(){let node=this._parent;if(!node){return ""}let result=this.name;while(node&&node._parent){result=`${node.name}/${result}`;node=node._parent;}return result}get root(){let result=this;while(result._parent){result=result._parent;}return result}get children(){return this._children}get graphDepth(){return this._graphDepth}_notifyHierarchyStateChanged(node,enabled){node._onHierarchyStateChanged(enabled);const c=node._children;for(let i=0,len=c.length;i<len;i++){if(c[i]._enabled){this._notifyHierarchyStateChanged(c[i],enabled);}}}_onHierarchyStateChanged(enabled){this._enabledInHierarchy=enabled;if(enabled&&!this._frozen){this._unfreezeParentToRoot();}}_cloneInternal(clone){clone.name=this.name;const tags=this.tags._list;clone.tags.clear();for(let i=0;i<tags.length;i++){clone.tags.add(tags[i]);}clone._labels=Object.assign({},this._labels);clone.localPosition.copy(this.localPosition);clone.localRotation.copy(this.localRotation);clone.localScale.copy(this.localScale);clone.localEulerAngles.copy(this.localEulerAngles);clone.position.copy(this.position);clone.rotation.copy(this.rotation);clone.eulerAngles.copy(this.eulerAngles);clone.localTransform.copy(this.localTransform);clone._dirtyLocal=this._dirtyLocal;clone.worldTransform.copy(this.worldTransform);clone._dirtyWorld=this._dirtyWorld;clone._dirtyNormal=this._dirtyNormal;clone._aabbVer=this._aabbVer+1;clone._enabled=this._enabled;clone.scaleCompensation=this.scaleCompensation;clone._enabledInHierarchy=false;}clone(){const clone=new this.constructor;this._cloneInternal(clone);return clone}copy(source){source._cloneInternal(this);return this}destroy(){this.remove();const children=this._children;while(children.length){const child=children.pop();child._parent=null;child.destroy();}this.fire("destroy",this);this.off();}find(attr,value){const results=[];const test=createTest(attr,value);this.forEach(node=>{if(test(node)){results.push(node);}});return results}findOne(attr,value){const test=createTest(attr,value);return findNode(this,test)}findByTag(){const query=arguments;const results=[];const queryNode=(node,checkNode)=>{if(checkNode&&node.tags.has(...query)){results.push(node);}for(let i=0;i<node._children.length;i++){queryNode(node._children[i],true);}};queryNode(this,false);return results}findByName(name){return this.findOne("name",name)}findByPath(path){const parts=Array.isArray(path)?path:path.split("/");let result=this;for(let i=0,imax=parts.length;i<imax;++i){result=result.children.find(c=>c.name===parts[i]);if(!result){return null}}return result}forEach(callback,thisArg){callback.call(thisArg,this);const children=this._children;const len=children.length;for(let i=0;i<len;++i){children[i].forEach(callback,thisArg);}}isDescendantOf(node){let parent=this._parent;while(parent){if(parent===node){return true}parent=parent._parent;}return false}isAncestorOf(node){return node.isDescendantOf(this)}getEulerAngles(){this.getWorldTransform().getEulerAngles(this.eulerAngles);return this.eulerAngles}getLocalEulerAngles(){this.localRotation.getEulerAngles(this.localEulerAngles);return this.localEulerAngles}getLocalPosition(){return this.localPosition}getLocalRotation(){return this.localRotation}getLocalScale(){return this.localScale}getLocalTransform(){if(this._dirtyLocal){this.localTransform.setTRS(this.localPosition,this.localRotation,this.localScale);this._dirtyLocal=false;}return this.localTransform}getPosition(){this.getWorldTransform().getTranslation(this.position);return this.position}getRotation(){this.rotation.setFromMat4(this.getWorldTransform());return this.rotation}getScale(){if(!this._scale){this._scale=new Vec3;}return this.getWorldTransform().getScale(this._scale)}getWorldTransform(){if(!this._dirtyLocal&&!this._dirtyWorld){return this.worldTransform}if(this._parent){this._parent.getWorldTransform();}this._sync();return this.worldTransform}get worldScaleSign(){if(this._worldScaleSign===0){this._worldScaleSign=this.getWorldTransform().scaleSign;}return this._worldScaleSign}remove(){var _this$_parent2;(_this$_parent2=this._parent)==null||_this$_parent2.removeChild(this);}reparent(parent,index){this.remove();if(parent){if(index>=0){parent.insertChild(this,index);}else {parent.addChild(this);}}}setLocalEulerAngles(x,y,z){this.localRotation.setFromEulerAngles(x,y,z);if(!this._dirtyLocal){this._dirtifyLocal();}}setLocalPosition(x,y,z){if(x instanceof Vec3){this.localPosition.copy(x);}else {this.localPosition.set(x,y,z);}if(!this._dirtyLocal){this._dirtifyLocal();}}setLocalRotation(x,y,z,w){if(x instanceof Quat){this.localRotation.copy(x);}else {this.localRotation.set(x,y,z,w);}if(!this._dirtyLocal){this._dirtifyLocal();}}setLocalScale(x,y,z){if(x instanceof Vec3){this.localScale.copy(x);}else {this.localScale.set(x,y,z);}if(!this._dirtyLocal){this._dirtifyLocal();}}_dirtifyLocal(){if(!this._dirtyLocal){this._dirtyLocal=true;if(!this._dirtyWorld){this._dirtifyWorld();}}}_unfreezeParentToRoot(){let p=this._parent;while(p){p._frozen=false;p=p._parent;}}_dirtifyWorld(){if(!this._dirtyWorld){this._unfreezeParentToRoot();}this._dirtifyWorldInternal();}_dirtifyWorldInternal(){if(!this._dirtyWorld){this._frozen=false;this._dirtyWorld=true;for(let i=0;i<this._children.length;i++){if(!this._children[i]._dirtyWorld){this._children[i]._dirtifyWorldInternal();}}}this._dirtyNormal=true;this._worldScaleSign=0;this._aabbVer++;}setPosition(x,y,z){if(x instanceof Vec3){position$1.copy(x);}else {position$1.set(x,y,z);}if(this._parent===null){this.localPosition.copy(position$1);}else {invParentWtm$1.copy(this._parent.getWorldTransform()).invert();invParentWtm$1.transformPoint(position$1,this.localPosition);}if(!this._dirtyLocal){this._dirtifyLocal();}}setRotation(x,y,z,w){if(x instanceof Quat){rotation.copy(x);}else {rotation.set(x,y,z,w);}if(this._parent===null){this.localRotation.copy(rotation);}else {const parentRot=this._parent.getRotation();invParentRot.copy(parentRot).invert();this.localRotation.copy(invParentRot).mul(rotation);}if(!this._dirtyLocal){this._dirtifyLocal();}}setPositionAndRotation(position,rotation){if(this._parent===null){this.localPosition.copy(position);this.localRotation.copy(rotation);}else {const parentWtm=this._parent.getWorldTransform();invParentWtm$1.copy(parentWtm).invert();invParentWtm$1.transformPoint(position,this.localPosition);this.localRotation.setFromMat4(invParentWtm$1).mul(rotation);}if(!this._dirtyLocal){this._dirtifyLocal();}}setEulerAngles(x,y,z){this.localRotation.setFromEulerAngles(x,y,z);if(this._parent!==null){const parentRot=this._parent.getRotation();invParentRot.copy(parentRot).invert();this.localRotation.mul2(invParentRot,this.localRotation);}if(!this._dirtyLocal){this._dirtifyLocal();}}addChild(node){this._prepareInsertChild(node);this._children.push(node);this._onInsertChild(node);}addChildAndSaveTransform(node){const wPos=node.getPosition();const wRot=node.getRotation();this._prepareInsertChild(node);node.setPosition(tmpMat4.copy(this.worldTransform).invert().transformPoint(wPos));node.setRotation(tmpQuat.copy(this.getRotation()).invert().mul(wRot));this._children.push(node);this._onInsertChild(node);}insertChild(node,index){this._prepareInsertChild(node);this._children.splice(index,0,node);this._onInsertChild(node);}_prepareInsertChild(node){node.remove();}_fireOnHierarchy(name,nameHierarchy,parent){this.fire(name,parent);for(let i=0;i<this._children.length;i++){this._children[i]._fireOnHierarchy(nameHierarchy,nameHierarchy,parent);}}_onInsertChild(node){node._parent=this;const enabledInHierarchy=node._enabled&&this.enabled;if(node._enabledInHierarchy!==enabledInHierarchy){node._enabledInHierarchy=enabledInHierarchy;node._notifyHierarchyStateChanged(node,enabledInHierarchy);}node._updateGraphDepth();node._dirtifyWorld();if(this._frozen){node._unfreezeParentToRoot();}node._fireOnHierarchy("insert","inserthierarchy",this);if(this.fire)this.fire("childinsert",node);}_updateGraphDepth(){this._graphDepth=this._parent?this._parent._graphDepth+1:0;for(let i=0,len=this._children.length;i<len;i++){this._children[i]._updateGraphDepth();}}removeChild(child){const index=this._children.indexOf(child);if(index===-1){return}this._children.splice(index,1);child._parent=null;child._fireOnHierarchy("remove","removehierarchy",this);this.fire("childremove",child);}_sync(){if(this._dirtyLocal){this.localTransform.setTRS(this.localPosition,this.localRotation,this.localScale);this._dirtyLocal=false;}if(this._dirtyWorld){if(this._parent===null){this.worldTransform.copy(this.localTransform);}else {if(this.scaleCompensation){let parentWorldScale;const parent=this._parent;let scale=this.localScale;let parentToUseScaleFrom=parent;if(parentToUseScaleFrom){while(parentToUseScaleFrom&&parentToUseScaleFrom.scaleCompensation){parentToUseScaleFrom=parentToUseScaleFrom._parent;}if(parentToUseScaleFrom){parentToUseScaleFrom=parentToUseScaleFrom._parent;if(parentToUseScaleFrom){parentWorldScale=parentToUseScaleFrom.worldTransform.getScale();scaleCompensateScale.mul2(parentWorldScale,this.localScale);scale=scaleCompensateScale;}}}scaleCompensateRot2.setFromMat4(parent.worldTransform);scaleCompensateRot.mul2(scaleCompensateRot2,this.localRotation);let tmatrix=parent.worldTransform;if(parent.scaleCompensation){scaleCompensateScaleForParent.mul2(parentWorldScale,parent.getLocalScale());scaleCompensatePosTransform.setTRS(parent.worldTransform.getTranslation(scaleCompensatePos),scaleCompensateRot2,scaleCompensateScaleForParent);tmatrix=scaleCompensatePosTransform;}tmatrix.transformPoint(this.localPosition,scaleCompensatePos);this.worldTransform.setTRS(scaleCompensatePos,scaleCompensateRot,scale);}else {this.worldTransform.mulAffine2(this._parent.worldTransform,this.localTransform);}}this._dirtyWorld=false;}}syncHierarchy(){if(!this._enabled){return}if(this._frozen){return}this._frozen=true;if(this._dirtyLocal||this._dirtyWorld){this._sync();}const children=this._children;for(let i=0,len=children.length;i<len;i++){children[i].syncHierarchy();}}lookAt(x,y,z,ux=0,uy=1,uz=0){if(x instanceof Vec3){target.copy(x);if(y instanceof Vec3){up.copy(y);}else {up.copy(Vec3.UP);}}else if(z===undefined){return}else {target.set(x,y,z);up.set(ux,uy,uz);}matrix.setLookAt(this.getPosition(),target,up);rotation.setFromMat4(matrix);this.setRotation(rotation);}translate(x,y,z){if(x instanceof Vec3){position$1.copy(x);}else {position$1.set(x,y,z);}position$1.add(this.getPosition());this.setPosition(position$1);}translateLocal(x,y,z){if(x instanceof Vec3){position$1.copy(x);}else {position$1.set(x,y,z);}this.localRotation.transformVector(position$1,position$1);this.localPosition.add(position$1);if(!this._dirtyLocal){this._dirtifyLocal();}}rotate(x,y,z){rotation.setFromEulerAngles(x,y,z);if(this._parent===null){this.localRotation.mul2(rotation,this.localRotation);}else {const rot=this.getRotation();const parentRot=this._parent.getRotation();invParentRot.copy(parentRot).invert();rotation.mul2(invParentRot,rotation);this.localRotation.mul2(rotation,rot);}if(!this._dirtyLocal){this._dirtifyLocal();}}rotateLocal(x,y,z){rotation.setFromEulerAngles(x,y,z);this.localRotation.mul(rotation);if(!this._dirtyLocal){this._dirtifyLocal();}}constructor(name="Untitled"){super();this.name=void 0;this.tags=new Tags(this);this._labels={};this.localPosition=new Vec3;this.localRotation=new Quat;this.localScale=new Vec3(1,1,1);this.localEulerAngles=new Vec3;this.position=new Vec3;this.rotation=new Quat;this.eulerAngles=new Vec3;this._scale=null;this.localTransform=new Mat4;this._dirtyLocal=false;this._aabbVer=0;this._frozen=false;this.worldTransform=new Mat4;this._dirtyWorld=false;this._worldScaleSign=0;this._normalMatrix=new Mat3;this._dirtyNormal=true;this._right=null;this._up=null;this._forward=null;this._parent=null;this._children=[];this._graphDepth=0;this._enabled=true;this._enabledInHierarchy=false;this.scaleCompensation=false;this.name=name;}}class RefCountedCache{destroy(){this.cache.forEach((refCount,object)=>{object.destroy();});this.cache.clear();}incRef(object){const refCount=(this.cache.get(object)||0)+1;this.cache.set(object,refCount);}decRef(object){if(object){let refCount=this.cache.get(object);if(refCount){refCount--;if(refCount===0){this.cache.delete(object);object.destroy();}else {this.cache.set(object,refCount);}}}}constructor(){this.cache=new Map;}}class LightmapCache{static incRef(texture){this.cache.incRef(texture);}static decRef(texture){this.cache.decRef(texture);}static destroy(){this.cache.destroy();}}LightmapCache.cache=new RefCountedCache;let id$1=0;const _tmpAabb=new BoundingBox;const _tempBoneAabb=new BoundingBox;const _tempSphere=new BoundingSphere;const _meshSet=new Set;class InstancingData{constructor(numObjects){this.vertexBuffer=null;this.count=numObjects;}}class ShaderInstance{getBindGroup(device){if(!this.bindGroup){const shader=this.shader;const ubFormat=shader.meshUniformBufferFormat;const uniformBuffer=new UniformBuffer(device,ubFormat,false);const bindGroupFormat=shader.meshBindGroupFormat;this.bindGroup=new BindGroup(device,bindGroupFormat,uniformBuffer);}return this.bindGroup}destroy(){const group=this.bindGroup;if(group){var _group$defaultUniform;(_group$defaultUniform=group.defaultUniformBuffer)==null||_group$defaultUniform.destroy();group.destroy();this.bindGroup=null;}}constructor(){this.shader=void 0;this.bindGroup=null;}}class ShaderCacheEntry{destroy(){this.shaderInstances.forEach(instance=>instance.destroy());this.shaderInstances.clear();}constructor(){this.shaderInstances=new Map;}}class MeshInstance{set renderStyle(renderStyle){this._renderStyle=renderStyle;this.mesh.prepareRenderState(renderStyle);}get renderStyle(){return this._renderStyle}set mesh(mesh){if(mesh===this._mesh){return}if(this._mesh){this._mesh.decRefCount();}this._mesh=mesh;if(mesh){mesh.incRefCount();}}get mesh(){return this._mesh}set aabb(aabb){this._aabb=aabb;}get aabb(){if(!this._updateAabb){return this._aabb}if(this._updateAabbFunc){return this._updateAabbFunc(this._aabb)}let localAabb=this._customAabb;let toWorldSpace=!!localAabb;if(!localAabb){localAabb=_tmpAabb;if(this.skinInstance){if(!this.mesh.boneAabb){const morphTargets=this._morphInstance?this._morphInstance.morph._targets:null;this.mesh._initBoneAabbs(morphTargets);}const boneUsed=this.mesh.boneUsed;let first=true;for(let i=0;i<this.mesh.boneAabb.length;i++){if(boneUsed[i]){_tempBoneAabb.setFromTransformedAabb(this.mesh.boneAabb[i],this.skinInstance.matrices[i]);if(first){first=false;localAabb.center.copy(_tempBoneAabb.center);localAabb.halfExtents.copy(_tempBoneAabb.halfExtents);}else {localAabb.add(_tempBoneAabb);}}}toWorldSpace=true;}else if(this.node._aabbVer!==this._aabbVer||this.mesh._aabbVer!==this._aabbMeshVer){if(this.mesh){localAabb.center.copy(this.mesh.aabb.center);localAabb.halfExtents.copy(this.mesh.aabb.halfExtents);}else {localAabb.center.set(0,0,0);localAabb.halfExtents.set(0,0,0);}if(this.mesh&&this.mesh.morph){const morphAabb=this.mesh.morph.aabb;localAabb._expand(morphAabb.getMin(),morphAabb.getMax());}toWorldSpace=true;this._aabbVer=this.node._aabbVer;this._aabbMeshVer=this.mesh._aabbVer;}}if(toWorldSpace){this._aabb.setFromTransformedAabb(localAabb,this.node.getWorldTransform());}return this._aabb}clearShaders(){const shaderCache=this._shaderCache;for(let i=0;i<shaderCache.length;i++){var _shaderCache$i;(_shaderCache$i=shaderCache[i])==null||_shaderCache$i.destroy();shaderCache[i]=null;}}getShaderInstance(shaderPass,lightHash,scene,viewUniformFormat,viewBindGroupFormat,sortedLights){let shaderInstance;let passEntry=this._shaderCache[shaderPass];if(passEntry){shaderInstance=passEntry.shaderInstances.get(lightHash);}else {passEntry=new ShaderCacheEntry;this._shaderCache[shaderPass]=passEntry;}if(!shaderInstance){const mat=this._material;const shaderDefs=this._shaderDefs;const variantKey=`${shaderPass}_${shaderDefs}_${lightHash}`;shaderInstance=new ShaderInstance;shaderInstance.shader=mat.variants.get(variantKey);if(!shaderInstance.shader){var _this$_mesh$vertexBuf;const shader=mat.getShaderVariant(this.mesh.device,scene,shaderDefs,null,shaderPass,sortedLights,viewUniformFormat,viewBindGroupFormat,(_this$_mesh$vertexBuf=this._mesh.vertexBuffer)==null?void 0:_this$_mesh$vertexBuf.format);mat.variants.set(variantKey,shader);shaderInstance.shader=shader;}passEntry.shaderInstances.set(lightHash,shaderInstance);}return shaderInstance}set material(material){this.clearShaders();const prevMat=this._material;if(prevMat){prevMat.removeMeshInstanceRef(this);}this._material=material;if(material){material.addMeshInstanceRef(this);this.transparent=material.transparent;this.updateKey();}}get material(){return this._material}set layer(layer){this._layer=layer;this.updateKey();}get layer(){return this._layer}_updateShaderDefs(shaderDefs){if(shaderDefs!==this._shaderDefs){this._shaderDefs=shaderDefs;this.clearShaders();}}set calculateSortDistance(calculateSortDistance){this._calculateSortDistance=calculateSortDistance;}get calculateSortDistance(){return this._calculateSortDistance}set receiveShadow(val){if(this._receiveShadow!==val){this._receiveShadow=val;this._updateShaderDefs(val?this._shaderDefs&~SHADERDEF_NOSHADOW:this._shaderDefs|SHADERDEF_NOSHADOW);}}get receiveShadow(){return this._receiveShadow}set skinInstance(val){this._skinInstance=val;this._updateShaderDefs(val?this._shaderDefs|SHADERDEF_SKIN:this._shaderDefs&~SHADERDEF_SKIN);this._setupSkinUpdate();}get skinInstance(){return this._skinInstance}set morphInstance(val){var _this$_morphInstance;(_this$_morphInstance=this._morphInstance)==null||_this$_morphInstance.destroy();this._morphInstance=val;let shaderDefs=this._shaderDefs;shaderDefs=val&&val.morph.useTextureMorph?shaderDefs|SHADERDEF_MORPH_TEXTURE_BASED:shaderDefs&~SHADERDEF_MORPH_TEXTURE_BASED;shaderDefs=val&&val.morph.morphPositions?shaderDefs|SHADERDEF_MORPH_POSITION:shaderDefs&~SHADERDEF_MORPH_POSITION;shaderDefs=val&&val.morph.morphNormals?shaderDefs|SHADERDEF_MORPH_NORMAL:shaderDefs&~SHADERDEF_MORPH_NORMAL;this._updateShaderDefs(shaderDefs);}get morphInstance(){return this._morphInstance}set screenSpace(val){if(this._screenSpace!==val){this._screenSpace=val;this._updateShaderDefs(val?this._shaderDefs|SHADERDEF_SCREENSPACE:this._shaderDefs&~SHADERDEF_SCREENSPACE);}}get screenSpace(){return this._screenSpace}set key(val){this._key[SORTKEY_FORWARD]=val;}get key(){return this._key[SORTKEY_FORWARD]}set mask(val){const toggles=this._shaderDefs&65535;this._updateShaderDefs(toggles|val<<16);}get mask(){return this._shaderDefs>>16}set instancingCount(value){if(this.instancingData){this.instancingData.count=value;}}get instancingCount(){return this.instancingData?this.instancingData.count:0}destroy(){var _this$_skinInstance,_this$morphInstance;const mesh=this.mesh;if(mesh){this.mesh=null;if(mesh.refCount<1){mesh.destroy();}}this.setRealtimeLightmap(MeshInstance.lightmapParamNames[0],null);this.setRealtimeLightmap(MeshInstance.lightmapParamNames[1],null);(_this$_skinInstance=this._skinInstance)==null||_this$_skinInstance.destroy();this._skinInstance=null;(_this$morphInstance=this.morphInstance)==null||_this$morphInstance.destroy();this.morphInstance=null;this.clearShaders();this.material=null;}static _prepareRenderStyleForArray(meshInstances,renderStyle){if(meshInstances){for(let i=0;i<meshInstances.length;i++){meshInstances[i]._renderStyle=renderStyle;const mesh=meshInstances[i].mesh;if(!_meshSet.has(mesh)){_meshSet.add(mesh);mesh.prepareRenderState(renderStyle);}}_meshSet.clear();}}_isVisible(camera){if(this.visible){if(this.isVisibleFunc){return this.isVisibleFunc(camera)}_tempSphere.center=this.aabb.center;_tempSphere.radius=this._aabb.halfExtents.length();return camera.frustum.containsSphere(_tempSphere)}return false}updateKey(){const material=this.material;const blendType=material.alphaToCoverage||material.alphaTest?BLEND_NORMAL:material.blendType;this._key[SORTKEY_FORWARD]=(this.layer&15)<<27|(blendType===BLEND_NONE?1:0)<<26|(material.id&33554431)<<0;}setInstancing(vertexBuffer,cull=false){if(vertexBuffer){this.instancingData=new InstancingData(vertexBuffer.numVertices);this.instancingData.vertexBuffer=vertexBuffer;vertexBuffer.format.instancing=true;this.cull=cull;}else {this.instancingData=null;this.cull=true;}this._updateShaderDefs(vertexBuffer?this._shaderDefs|SHADERDEF_INSTANCING:this._shaderDefs&~SHADERDEF_INSTANCING);}ensureMaterial(device){if(!this.material){this.material=getDefaultMaterial(device);}}clearParameters(){this.parameters={};}getParameters(){return this.parameters}getParameter(name){return this.parameters[name]}setParameter(name,data,passFlags=-262141){if(data===undefined&&typeof name==="object"){const uniformObject=name;if(uniformObject.length){for(let i=0;i<uniformObject.length;i++){this.setParameter(uniformObject[i]);}return}name=uniformObject.name;data=uniformObject.value;}const param=this.parameters[name];if(param){param.data=data;param.passFlags=passFlags;}else {this.parameters[name]={scopeId:null,data:data,passFlags:passFlags};}}setRealtimeLightmap(name,texture){const old=this.getParameter(name);if(old===texture){return}if(old){LightmapCache.decRef(old.data);}if(texture){LightmapCache.incRef(texture);this.setParameter(name,texture);}else {this.deleteParameter(name);}}deleteParameter(name){if(this.parameters[name]){delete this.parameters[name];}}setParameters(device,passFlag){const parameters=this.parameters;for(const paramName in parameters){const parameter=parameters[paramName];if(parameter.passFlags&passFlag){if(!parameter.scopeId){parameter.scopeId=device.scope.resolve(paramName);}parameter.scopeId.setValue(parameter.data);}}}setLightmapped(value){if(value){this.mask=(this.mask|MASK_AFFECT_LIGHTMAPPED)&~(MASK_AFFECT_DYNAMIC|MASK_BAKE);}else {this.setRealtimeLightmap(MeshInstance.lightmapParamNames[0],null);this.setRealtimeLightmap(MeshInstance.lightmapParamNames[1],null);this._shaderDefs&=~(SHADERDEF_LM|SHADERDEF_DIRLM|SHADERDEF_LMAMBIENT);this.mask=(this.mask|MASK_AFFECT_DYNAMIC)&~(MASK_AFFECT_LIGHTMAPPED|MASK_BAKE);}}setCustomAabb(aabb){if(aabb){if(this._customAabb){this._customAabb.copy(aabb);}else {this._customAabb=aabb.clone();}}else {this._customAabb=null;this._aabbVer=-1;}this._setupSkinUpdate();}_setupSkinUpdate(){if(this._skinInstance){this._skinInstance._updateBeforeCull=!this._customAabb;}}constructor(mesh,material,node=null){this.visible=true;this.castShadow=false;this.transparent=false;this._material=null;this._shaderCache=[];this.id=id$1++;this.pick=true;if(mesh instanceof GraphNode){const temp=mesh;mesh=material;material=node;node=temp;}this._key=[0,0];this.node=node;this._mesh=mesh;mesh.incRefCount();this.material=material;this._shaderDefs=MASK_AFFECT_DYNAMIC<<16;if(mesh.vertexBuffer){const format=mesh.vertexBuffer.format;this._shaderDefs|=format.hasUv0?SHADERDEF_UV0:0;this._shaderDefs|=format.hasUv1?SHADERDEF_UV1:0;this._shaderDefs|=format.hasColor?SHADERDEF_VCOLOR:0;this._shaderDefs|=format.hasTangents?SHADERDEF_TANGENTS:0;}this.layer=LAYER_WORLD;this._renderStyle=RENDERSTYLE_SOLID;this._receiveShadow=true;this._screenSpace=false;this.cull=true;this._updateAabb=true;this._updateAabbFunc=null;this._calculateSortDistance=null;this.updateKey();this._skinInstance=null;this._morphInstance=null;this.gsplatInstance=null;this.instancingData=null;this._customAabb=null;this.aabb=new BoundingBox;this._aabbVer=-1;this._aabbMeshVer=-1;this.drawOrder=0;this.visibleThisFrame=false;this.isVisibleFunc=null;this.parameters={};this.stencilFront=null;this.stencilBack=null;this.flipFacesFactor=1;}}MeshInstance.lightmapParamNames=["texture_lightMap","texture_dirLightMap"];function paramsIdentical(a,b){if(a&&!b)return false;if(!a&&b)return false;a=a.data;b=b.data;if(a===b)return true;if(a instanceof Float32Array&&b instanceof Float32Array){if(a.length!==b.length)return false;for(let i=0;i<a.length;i++){if(a[i]!==b[i])return false}return true}return false}function equalParamSets(params1,params2){for(const param in params1){if(params1.hasOwnProperty(param)&&!paramsIdentical(params1[param],params2[param])){return false}}for(const param in params2){if(params2.hasOwnProperty(param)&&!paramsIdentical(params2[param],params1[param])){return false}}return true}const _triFanIndices=[0,1,3,2,3,1];const _triStripIndices=[0,1,3,0,3,2];const mat3=new Mat3;function getScaleSign(mi){return mi.node.worldTransform.scaleSign}class BatchManager{destroy(){this.device=null;this.rootNode=null;this.scene=null;this._batchGroups={};this._batchList=[];this._dirtyGroups=[];}addGroup(name,dynamic,maxAabbSize,id,layers){if(id===undefined){id=this._batchGroupCounter;this._batchGroupCounter++;}if(this._batchGroups[id]){return undefined}const group=new BatchGroup(id,name,dynamic,maxAabbSize,layers);this._batchGroups[id]=group;return group}removeGroup(id){if(!this._batchGroups[id]){return}const newBatchList=[];for(let i=0;i<this._batchList.length;i++){if(this._batchList[i].batchGroupId===id){this.destroyBatch(this._batchList[i]);}else {newBatchList.push(this._batchList[i]);}}this._batchList=newBatchList;this._removeModelsFromBatchGroup(this.rootNode,id);delete this._batchGroups[id];}markGroupDirty(id){if(this._dirtyGroups.indexOf(id)<0){this._dirtyGroups.push(id);}}getGroupByName(name){const groups=this._batchGroups;for(const group in groups){if(!groups.hasOwnProperty(group))continue;if(groups[group].name===name){return groups[group]}}return null}getBatches(batchGroupId){const results=[];const len=this._batchList.length;for(let i=0;i<len;i++){const batch=this._batchList[i];if(batch.batchGroupId===batchGroupId){results.push(batch);}}return results}_removeModelsFromBatchGroup(node,id){if(!node.enabled)return;if(node.model&&node.model.batchGroupId===id){node.model.batchGroupId=-1;}if(node.render&&node.render.batchGroupId===id){node.render.batchGroupId=-1;}if(node.element&&node.element.batchGroupId===id){node.element.batchGroupId=-1;}if(node.sprite&&node.sprite.batchGroupId===id){node.sprite.batchGroupId=-1;}for(let i=0;i<node._children.length;i++){this._removeModelsFromBatchGroup(node._children[i],id);}}insert(type,groupId,node){const group=this._batchGroups[groupId];if(group){if(group._obj[type].indexOf(node)<0){group._obj[type].push(node);this.markGroupDirty(groupId);}}}remove(type,groupId,node){const group=this._batchGroups[groupId];if(group){const idx=group._obj[type].indexOf(node);if(idx>=0){group._obj[type].splice(idx,1);this.markGroupDirty(groupId);}}}_extractRender(node,arr,group,groupMeshInstances){if(node.render){arr=groupMeshInstances[node.render.batchGroupId]=arr.concat(node.render.meshInstances);node.render.removeFromLayers();}return arr}_extractModel(node,arr,group,groupMeshInstances){if(node.model&&node.model.model){arr=groupMeshInstances[node.model.batchGroupId]=arr.concat(node.model.meshInstances);node.model.removeModelFromLayers();}return arr}_extractElement(node,arr,group){if(!node.element)return;let valid=false;if(node.element._text&&node.element._text._model.meshInstances.length>0){arr.push(node.element._text._model.meshInstances[0]);node.element.removeModelFromLayers(node.element._text._model);valid=true;}else if(node.element._image){arr.push(node.element._image._renderable.meshInstance);node.element.removeModelFromLayers(node.element._image._renderable.model);if(node.element._image._renderable.unmaskMeshInstance){arr.push(node.element._image._renderable.unmaskMeshInstance);if(!node.element._image._renderable.unmaskMeshInstance.stencilFront||!node.element._image._renderable.unmaskMeshInstance.stencilBack){node.element._dirtifyMask();node.element._onPrerender();}}valid=true;}if(valid){group._ui=true;}}_collectAndRemoveMeshInstances(groupMeshInstances,groupIds){for(let g=0;g<groupIds.length;g++){const id=groupIds[g];const group=this._batchGroups[id];if(!group)continue;let arr=groupMeshInstances[id];if(!arr)arr=groupMeshInstances[id]=[];for(let m=0;m<group._obj.model.length;m++){arr=this._extractModel(group._obj.model[m],arr,group,groupMeshInstances);}for(let r=0;r<group._obj.render.length;r++){arr=this._extractRender(group._obj.render[r],arr,group,groupMeshInstances);}for(let e=0;e<group._obj.element.length;e++){this._extractElement(group._obj.element[e],arr,group);}for(let s=0;s<group._obj.sprite.length;s++){const node=group._obj.sprite[s];if(node.sprite&&node.sprite._meshInstance&&(group.dynamic||node.sprite.sprite._renderMode===SPRITE_RENDERMODE_SIMPLE)){arr.push(node.sprite._meshInstance);node.sprite.removeModelFromLayers();group._sprite=true;node.sprite._batchGroup=group;}}}}generate(groupIds){const groupMeshInstances={};if(!groupIds){groupIds=Object.keys(this._batchGroups);}const newBatchList=[];for(let i=0;i<this._batchList.length;i++){if(groupIds.indexOf(this._batchList[i].batchGroupId)<0){newBatchList.push(this._batchList[i]);continue}this.destroyBatch(this._batchList[i]);}this._batchList=newBatchList;this._collectAndRemoveMeshInstances(groupMeshInstances,groupIds);if(groupIds===this._dirtyGroups){this._dirtyGroups.length=0;}else {const newDirtyGroups=[];for(let i=0;i<this._dirtyGroups.length;i++){if(groupIds.indexOf(this._dirtyGroups[i])<0)newDirtyGroups.push(this._dirtyGroups[i]);}this._dirtyGroups=newDirtyGroups;}let group,lists,groupData,batch;for(const groupId in groupMeshInstances){if(!groupMeshInstances.hasOwnProperty(groupId))continue;group=groupMeshInstances[groupId];groupData=this._batchGroups[groupId];if(!groupData){continue}lists=this.prepare(group,groupData.dynamic,groupData.maxAabbSize,groupData._ui||groupData._sprite);for(let i=0;i<lists.length;i++){batch=this.create(lists[i],groupData.dynamic,parseInt(groupId,10));if(batch){batch.addToLayers(this.scene,groupData.layers);}}}}prepare(meshInstances,dynamic,maxAabbSize=Number.POSITIVE_INFINITY,translucent){if(meshInstances.length===0)return [];const halfMaxAabbSize=maxAabbSize*.5;const maxInstanceCount=this.device.supportsBoneTextures?1024:this.device.boneLimit;const maxNumVertices=this.device.extUintElement?4294967295:65535;const aabb=new BoundingBox;const testAabb=new BoundingBox;let skipTranslucentAabb=null;let sf;const lists=[];let j=0;if(translucent){meshInstances.sort((a,b)=>{return a.drawOrder-b.drawOrder});}let meshInstancesLeftA=meshInstances;let meshInstancesLeftB;const skipMesh=translucent?function(mi){if(skipTranslucentAabb){skipTranslucentAabb.add(mi.aabb);}else {skipTranslucentAabb=mi.aabb.clone();}meshInstancesLeftB.push(mi);}:function(mi){meshInstancesLeftB.push(mi);};while(meshInstancesLeftA.length>0){lists[j]=[meshInstancesLeftA[0]];meshInstancesLeftB=[];const material=meshInstancesLeftA[0].material;const layer=meshInstancesLeftA[0].layer;const defs=meshInstancesLeftA[0]._shaderDefs;const params=meshInstancesLeftA[0].parameters;const stencil=meshInstancesLeftA[0].stencilFront;let vertCount=meshInstancesLeftA[0].mesh.vertexBuffer.getNumVertices();const drawOrder=meshInstancesLeftA[0].drawOrder;aabb.copy(meshInstancesLeftA[0].aabb);const scaleSign=getScaleSign(meshInstancesLeftA[0]);const vertexFormatBatchingHash=meshInstancesLeftA[0].mesh.vertexBuffer.format.batchingHash;const indexed=meshInstancesLeftA[0].mesh.primitive[0].indexed;skipTranslucentAabb=null;for(let i=1;i<meshInstancesLeftA.length;i++){const mi=meshInstancesLeftA[i];if(dynamic&&lists[j].length>=maxInstanceCount){meshInstancesLeftB=meshInstancesLeftB.concat(meshInstancesLeftA.slice(i));break}if(material!==mi.material||layer!==mi.layer||vertexFormatBatchingHash!==mi.mesh.vertexBuffer.format.batchingHash||indexed!==mi.mesh.primitive[0].indexed||defs!==mi._shaderDefs||vertCount+mi.mesh.vertexBuffer.getNumVertices()>maxNumVertices){skipMesh(mi);continue}testAabb.copy(aabb);testAabb.add(mi.aabb);if(testAabb.halfExtents.x>halfMaxAabbSize||testAabb.halfExtents.y>halfMaxAabbSize||testAabb.halfExtents.z>halfMaxAabbSize){skipMesh(mi);continue}if(stencil){if(!(sf=mi.stencilFront)||stencil.func!==sf.func||stencil.zpass!==sf.zpass){skipMesh(mi);continue}}if(scaleSign!==getScaleSign(mi)){skipMesh(mi);continue}if(!equalParamSets(params,mi.parameters)){skipMesh(mi);continue}if(translucent&&skipTranslucentAabb&&skipTranslucentAabb.intersects(mi.aabb)&&mi.drawOrder!==drawOrder){skipMesh(mi);continue}aabb.add(mi.aabb);vertCount+=mi.mesh.vertexBuffer.getNumVertices();lists[j].push(mi);}j++;meshInstancesLeftA=meshInstancesLeftB;}return lists}collectBatchedMeshData(meshInstances,dynamic){let streams=null;let batchNumVerts=0;let batchNumIndices=0;let material=null;for(let i=0;i<meshInstances.length;i++){if(meshInstances[i].visible){const mesh=meshInstances[i].mesh;const numVerts=mesh.vertexBuffer.numVertices;batchNumVerts+=numVerts;if(mesh.primitive[0].indexed){batchNumIndices+=mesh.primitive[0].count;}else {const primitiveType=mesh.primitive[0].type;if(primitiveType===PRIMITIVE_TRIFAN||primitiveType===PRIMITIVE_TRISTRIP){if(mesh.primitive[0].count===4){batchNumIndices+=6;}}}if(!streams){material=meshInstances[i].material;streams={};const elems=mesh.vertexBuffer.format.elements;for(let j=0;j<elems.length;j++){const semantic=elems[j].name;streams[semantic]={numComponents:elems[j].numComponents,dataType:elems[j].dataType,normalize:elems[j].normalize,count:0};}if(dynamic){streams[SEMANTIC_BLENDINDICES]={numComponents:1,dataType:TYPE_FLOAT32,normalize:false,count:0};}}}}return {streams:streams,batchNumVerts:batchNumVerts,batchNumIndices:batchNumIndices,material:material}}create(meshInstances,dynamic,batchGroupId){if(!this._init){const boneLimit=`#define BONE_LIMIT ${this.device.getBoneLimit()}
`;this.transformVS=`${boneLimit}#define DYNAMICBATCH
${shaderChunks.transformVS}`;this.skinTexVS=shaderChunks.skinBatchTexVS;this.skinConstVS=shaderChunks.skinBatchConstVS;this.vertexFormats={};this._init=true;}let stream=null;let semantic;let mesh,numVerts;let batch=null;const batchData=this.collectBatchedMeshData(meshInstances,dynamic);if(batchData.streams){const streams=batchData.streams;let material=batchData.material;const batchNumVerts=batchData.batchNumVerts;const batchNumIndices=batchData.batchNumIndices;batch=new Batch(meshInstances,dynamic,batchGroupId);this._batchList.push(batch);let indexBase,numIndices,indexData;let verticesOffset=0;let indexOffset=0;let transform;const indexArrayType=batchNumVerts<=65535?Uint16Array:Uint32Array;const indices=new indexArrayType(batchNumIndices);for(semantic in streams){stream=streams[semantic];stream.typeArrayType=typedArrayTypes[stream.dataType];stream.elementByteSize=typedArrayTypesByteSize[stream.dataType];stream.buffer=new stream.typeArrayType(batchNumVerts*stream.numComponents);}for(let i=0;i<meshInstances.length;i++){if(!meshInstances[i].visible){continue}mesh=meshInstances[i].mesh;numVerts=mesh.vertexBuffer.numVertices;if(!dynamic){transform=meshInstances[i].node.getWorldTransform();}for(semantic in streams){if(semantic!==SEMANTIC_BLENDINDICES){stream=streams[semantic];const subarray=new stream.typeArrayType(stream.buffer.buffer,stream.elementByteSize*stream.count);const totalComponents=mesh.getVertexStream(semantic,subarray)*stream.numComponents;stream.count+=totalComponents;if(!dynamic&&stream.numComponents>=3){if(semantic===SEMANTIC_POSITION){const m=transform.data;const m0=m[0];const m1=m[1];const m2=m[2];const m4=m[4];const m5=m[5];const m6=m[6];const m8=m[8];const m9=m[9];const m10=m[10];const m12=m[12];const m13=m[13];const m14=m[14];let x,y,z;for(let j=0;j<totalComponents;j+=stream.numComponents){x=subarray[j];y=subarray[j+1];z=subarray[j+2];subarray[j]=x*m0+y*m4+z*m8+m12;subarray[j+1]=x*m1+y*m5+z*m9+m13;subarray[j+2]=x*m2+y*m6+z*m10+m14;}}else if(semantic===SEMANTIC_NORMAL||semantic===SEMANTIC_TANGENT){mat3.invertMat4(transform).transpose();const[m0,m1,m2,m3,m4,m5,m6,m7,m8]=mat3.data;let x,y,z;for(let j=0;j<totalComponents;j+=stream.numComponents){x=subarray[j];y=subarray[j+1];z=subarray[j+2];subarray[j]=x*m0+y*m3+z*m6;subarray[j+1]=x*m1+y*m4+z*m7;subarray[j+2]=x*m2+y*m5+z*m8;}}}}}if(dynamic){stream=streams[SEMANTIC_BLENDINDICES];for(let j=0;j<numVerts;j++){stream.buffer[stream.count++]=i;}}if(mesh.primitive[0].indexed){indexBase=mesh.primitive[0].base;numIndices=mesh.primitive[0].count;const srcFormat=mesh.indexBuffer[0].getFormat();indexData=new typedArrayIndexFormats[srcFormat](mesh.indexBuffer[0].storage);}else {const primitiveType=mesh.primitive[0].type;if(primitiveType===PRIMITIVE_TRIFAN||primitiveType===PRIMITIVE_TRISTRIP){if(mesh.primitive[0].count===4){indexBase=0;numIndices=6;indexData=primitiveType===PRIMITIVE_TRIFAN?_triFanIndices:_triStripIndices;}else {numIndices=0;continue}}}for(let j=0;j<numIndices;j++){indices[j+indexOffset]=indexData[indexBase+j]+verticesOffset;}indexOffset+=numIndices;verticesOffset+=numVerts;}mesh=new Mesh(this.device);for(semantic in streams){stream=streams[semantic];mesh.setVertexStream(semantic,stream.buffer,stream.numComponents,undefined,stream.dataType,stream.normalize);}if(indices.length>0){mesh.setIndices(indices);}mesh.update(PRIMITIVE_TRIANGLES,false);if(dynamic){material=material.clone();material.chunks.transformVS=this.transformVS;material.chunks.skinTexVS=this.skinTexVS;material.chunks.skinConstVS=this.skinConstVS;material.update();}const meshInstance=new MeshInstance(mesh,material,this.rootNode);meshInstance.castShadow=batch.origMeshInstances[0].castShadow;meshInstance.parameters=batch.origMeshInstances[0].parameters;meshInstance.layer=batch.origMeshInstances[0].layer;meshInstance._shaderDefs=batch.origMeshInstances[0]._shaderDefs;meshInstance.cull=batch.origMeshInstances[0].cull;const batchGroup=this._batchGroups[batchGroupId];if(batchGroup&&batchGroup._ui){meshInstance.cull=false;}if(dynamic){const nodes=[];for(let i=0;i<batch.origMeshInstances.length;i++){nodes.push(batch.origMeshInstances[i].node);}meshInstance.skinInstance=new SkinBatchInstance(this.device,nodes,this.rootNode);}meshInstance._updateAabb=false;meshInstance.drawOrder=batch.origMeshInstances[0].drawOrder;meshInstance.stencilFront=batch.origMeshInstances[0].stencilFront;meshInstance.stencilBack=batch.origMeshInstances[0].stencilBack;meshInstance.flipFacesFactor=getScaleSign(batch.origMeshInstances[0]);meshInstance.castShadow=batch.origMeshInstances[0].castShadow;batch.meshInstance=meshInstance;batch.updateBoundingBox();}return batch}updateAll(){if(this._dirtyGroups.length>0){this.generate(this._dirtyGroups);}for(let i=0;i<this._batchList.length;i++){if(!this._batchList[i].dynamic)continue;this._batchList[i].updateBoundingBox();}}clone(batch,clonedMeshInstances){const batch2=new Batch(clonedMeshInstances,batch.dynamic,batch.batchGroupId);this._batchList.push(batch2);const nodes=[];for(let i=0;i<clonedMeshInstances.length;i++){nodes.push(clonedMeshInstances[i].node);}batch2.meshInstance=new MeshInstance(batch.meshInstance.mesh,batch.meshInstance.material,batch.meshInstance.node);batch2.meshInstance._updateAabb=false;batch2.meshInstance.parameters=clonedMeshInstances[0].parameters;batch2.meshInstance.cull=clonedMeshInstances[0].cull;batch2.meshInstance.layer=clonedMeshInstances[0].layer;if(batch.dynamic){batch2.meshInstance.skinInstance=new SkinBatchInstance(this.device,nodes,this.rootNode);}batch2.meshInstance.castShadow=batch.meshInstance.castShadow;batch2.meshInstance._shader=batch.meshInstance._shader.slice();batch2.meshInstance.castShadow=batch.meshInstance.castShadow;return batch2}destroyBatch(batch){batch.destroy(this.scene,this._batchGroups[batch.batchGroupId].layers);}constructor(device,root,scene){this.device=device;this.rootNode=root;this.scene=scene;this._init=false;this._batchGroups={};this._batchGroupCounter=0;this._batchList=[];this._dirtyGroups=[];}}const _colorUniformNames=["uSceneColorMap","texture_grabPass"];class RenderPassColorGrab extends RenderPass{destroy(){super.destroy();this.releaseRenderTarget(this.colorRenderTarget);}shouldReallocate(targetRT,sourceTexture,sourceFormat){const targetFormat=targetRT==null?void 0:targetRT.colorBuffer.format;if(targetFormat!==sourceFormat){return true}const width=(sourceTexture==null?void 0:sourceTexture.width)||this.device.width;const height=(sourceTexture==null?void 0:sourceTexture.height)||this.device.height;return !targetRT||width!==targetRT.width||height!==targetRT.height}allocateRenderTarget(renderTarget,sourceRenderTarget,device,format){const mipmaps=device.isWebGL2;const texture=new Texture(device,{name:_colorUniformNames[0],format,width:sourceRenderTarget?sourceRenderTarget.colorBuffer.width:device.width,height:sourceRenderTarget?sourceRenderTarget.colorBuffer.height:device.height,mipmaps,minFilter:mipmaps?FILTER_LINEAR_MIPMAP_LINEAR:FILTER_LINEAR,magFilter:FILTER_LINEAR,addressU:ADDRESS_CLAMP_TO_EDGE,addressV:ADDRESS_CLAMP_TO_EDGE});if(renderTarget){renderTarget.destroyFrameBuffers();renderTarget._colorBuffer=texture;renderTarget._colorBuffers=[texture];}else {renderTarget=new RenderTarget({name:"ColorGrabRT",colorBuffer:texture,depth:false,stencil:false,autoResolve:false});}return renderTarget}releaseRenderTarget(rt){if(rt){rt.destroyTextureBuffers();rt.destroy();}}frameUpdate(){var _sourceRt$colorBuffer;const device=this.device;const sourceRt=this.source;const sourceFormat=(_sourceRt$colorBuffer=sourceRt==null?void 0:sourceRt.colorBuffer.format)!=null?_sourceRt$colorBuffer:this.device.backBufferFormat;if(this.shouldReallocate(this.colorRenderTarget,sourceRt==null?void 0:sourceRt.colorBuffer,sourceFormat)){this.releaseRenderTarget(this.colorRenderTarget);this.colorRenderTarget=this.allocateRenderTarget(this.colorRenderTarget,sourceRt,device,sourceFormat);}const colorBuffer=this.colorRenderTarget.colorBuffer;_colorUniformNames.forEach(name=>device.scope.resolve(name).setValue(colorBuffer));}execute(){const device=this.device;const sourceRt=this.source;const colorBuffer=this.colorRenderTarget.colorBuffer;if(device.isWebGPU){device.copyRenderTarget(sourceRt,this.colorRenderTarget,true,false);device.mipmapRenderer.generate(this.colorRenderTarget.colorBuffer.impl);}else if(device.isWebGL2){device.copyRenderTarget(sourceRt,this.colorRenderTarget,true,false);device.activeTexture(device.maxCombinedTextures-1);device.bindTexture(colorBuffer);device.gl.generateMipmap(colorBuffer.impl._glTarget);}else {if(!colorBuffer.impl._glTexture){colorBuffer.impl.initialize(device,colorBuffer);}device.bindTexture(colorBuffer);const gl=device.gl;gl.copyTexImage2D(gl.TEXTURE_2D,0,colorBuffer.impl._glFormat,0,0,colorBuffer.width,colorBuffer.height,0);colorBuffer._needsUpload=false;colorBuffer._needsMipmapsUpload=false;}}constructor(...args){super(...args);this.colorRenderTarget=null;this.source=null;}}const _depthUniformNames$1=["uSceneDepthMap","uDepthMap"];class RenderPassDepthGrab extends RenderPass{destroy(){super.destroy();this.releaseRenderTarget(this.depthRenderTarget);}shouldReallocate(targetRT,sourceTexture){const width=(sourceTexture==null?void 0:sourceTexture.width)||this.device.width;const height=(sourceTexture==null?void 0:sourceTexture.height)||this.device.height;return !targetRT||width!==targetRT.width||height!==targetRT.height}allocateRenderTarget(renderTarget,sourceRenderTarget,device,format,isDepth){const texture=new Texture(device,{name:_depthUniformNames$1[0],format,width:sourceRenderTarget?sourceRenderTarget.colorBuffer.width:device.width,height:sourceRenderTarget?sourceRenderTarget.colorBuffer.height:device.height,mipmaps:false,minFilter:FILTER_NEAREST,magFilter:FILTER_NEAREST,addressU:ADDRESS_CLAMP_TO_EDGE,addressV:ADDRESS_CLAMP_TO_EDGE});if(renderTarget){renderTarget.destroyFrameBuffers();if(isDepth){renderTarget._depthBuffer=texture;}else {renderTarget._colorBuffer=texture;renderTarget._colorBuffers=[texture];}}else {renderTarget=new RenderTarget({name:"DepthGrabRT",colorBuffer:isDepth?null:texture,depthBuffer:isDepth?texture:null,depth:!isDepth,stencil:device.supportsStencil,autoResolve:false});}return renderTarget}releaseRenderTarget(rt){if(rt){rt.destroyTextureBuffers();rt.destroy();}}before(){var _camera$renderTarget,_camera$renderTarget$,_camera$renderTarget2,_camera$renderTarget3;const camera=this.camera;const device=this.device;const destinationRt=(_camera$renderTarget=camera==null?void 0:camera.renderTarget)!=null?_camera$renderTarget:device.backBuffer;let useDepthBuffer=true;let format=destinationRt.stencil?PIXELFORMAT_DEPTHSTENCIL:PIXELFORMAT_DEPTH;if(device.isWebGPU){const numSamples=destinationRt.samples;if(numSamples>1){format=PIXELFORMAT_R32F;useDepthBuffer=false;}}const sourceTexture=(_camera$renderTarget$=(_camera$renderTarget2=camera.renderTarget)==null?void 0:_camera$renderTarget2.depthBuffer)!=null?_camera$renderTarget$:(_camera$renderTarget3=camera.renderTarget)==null?void 0:_camera$renderTarget3.colorBuffer;if(this.shouldReallocate(this.depthRenderTarget,sourceTexture)){this.releaseRenderTarget(this.depthRenderTarget);this.depthRenderTarget=this.allocateRenderTarget(this.depthRenderTarget,camera.renderTarget,device,format,useDepthBuffer);}const colorBuffer=useDepthBuffer?this.depthRenderTarget.depthBuffer:this.depthRenderTarget.colorBuffer;_depthUniformNames$1.forEach(name=>device.scope.resolve(name).setValue(colorBuffer));}execute(){const device=this.device;if(device.isWebGL2&&device.renderTarget.samples>1){const src=device.renderTarget.impl._glFrameBuffer;const dest=this.depthRenderTarget;device.renderTarget=dest;device.updateBegin();this.depthRenderTarget.impl.internalResolve(device,src,dest.impl._glFrameBuffer,this.depthRenderTarget,device.gl.DEPTH_BUFFER_BIT);}else {device.copyRenderTarget(device.renderTarget,this.depthRenderTarget,false,true);}}constructor(device,camera){super(device);this.depthRenderTarget=null;this.camera=null;this.camera=camera;}}const webgl1DepthClearColor=new Color(254/255,254/255,254/255,254/255);const tempMeshInstances$2=[];const lights$1=[[],[],[]];const _depthUniformNames=["uSceneDepthMap","uDepthMap"];class RenderPassDepth extends RenderPass{destroy(){super.destroy();if(this.renderTarget){this.renderTarget.destroyTextureBuffers();this.renderTarget.destroy();this.renderTarget=null;}}update(scene){this.scene=scene;}setupRenderTarget(){const texture=new Texture(this.device,{name:_depthUniformNames[0],format:PIXELFORMAT_RGBA8,width:4,height:4,mipmaps:false,minFilter:FILTER_NEAREST,magFilter:FILTER_NEAREST,addressU:ADDRESS_CLAMP_TO_EDGE,addressV:ADDRESS_CLAMP_TO_EDGE});const renderTarget=new RenderTarget({name:`${_depthUniformNames[0]}RT}`,colorBuffer:texture,depth:true,stencil:false});this.init(renderTarget,{});this.setClearColor(webgl1DepthClearColor);this.setClearDepth(1);}before(){const device=this.device;const colorBuffer=this.renderTarget.colorBuffer;_depthUniformNames.forEach(name=>device.scope.resolve(name).setValue(colorBuffer));}execute(){const{device,renderer,camera,scene,renderTarget}=this;const layers=scene.layers.layerList;const subLayerEnabled=scene.layers.subLayerEnabled;const isTransparent=scene.layers.subLayerList;for(let i=0;i<layers.length;i++){const layer=layers[i];if(layer.enabled&&subLayerEnabled[i]){if(layer.camerasSet.has(camera)){if(layer.id===LAYERID_DEPTH){break}const culledInstances=layer.getCulledInstances(camera);const meshInstances=isTransparent[i]?culledInstances.transparent:culledInstances.opaque;for(let j=0;j<meshInstances.length;j++){var _meshInstance$materia;const meshInstance=meshInstances[j];if((_meshInstance$materia=meshInstance.material)!=null&&_meshInstance$materia.depthWrite){tempMeshInstances$2.push(meshInstance);}}renderer.setCameraUniforms(camera,renderTarget);renderer.renderForward(camera,tempMeshInstances$2,lights$1,SHADER_DEPTH,meshInstance=>{device.setBlendState(BlendState.NOBLEND);},layer);tempMeshInstances$2.length=0;}}}}constructor(device,renderer,camera){super(device);this.renderer=renderer;this.camera=camera;this.setupRenderTarget();}}const _deviceCoord=new Vec3;const _halfSize=new Vec3;const _point$1=new Vec3;const _invViewProjMat=new Mat4;const _frustumPoints=[new Vec3,new Vec3,new Vec3,new Vec3,new Vec3,new Vec3,new Vec3,new Vec3];class Camera{destroy(){var _this$renderPassColor,_this$renderPassDepth;(_this$renderPassColor=this.renderPassColorGrab)==null||_this$renderPassColor.destroy();this.renderPassColorGrab=null;(_this$renderPassDepth=this.renderPassDepthGrab)==null||_this$renderPassDepth.destroy();this.renderPassDepthGrab=null;this.renderPasses.length=0;}_storeShaderMatrices(viewProjMat,jitterX,jitterY,renderVersion){if(this._shaderMatricesVersion!==renderVersion){var _this$_viewProjCurren,_this$_viewProjCurren2;this._shaderMatricesVersion=renderVersion;this._viewProjPrevious.copy((_this$_viewProjCurren=this._viewProjCurrent)!=null?_this$_viewProjCurren:viewProjMat);(_this$_viewProjCurren2=this._viewProjCurrent)!=null?_this$_viewProjCurren2:this._viewProjCurrent=new Mat4;this._viewProjCurrent.copy(viewProjMat);this._viewProjInverse.invert(viewProjMat);this._jitters[2]=this._jitters[0];this._jitters[3]=this._jitters[1];this._jitters[0]=jitterX;this._jitters[1]=jitterY;}}get fullSizeClearRect(){const rect=this._scissorRectClear?this.scissorRect:this._rect;return rect.x===0&&rect.y===0&&rect.z===1&&rect.w===1}set aspectRatio(newValue){if(this._aspectRatio!==newValue){this._aspectRatio=newValue;this._projMatDirty=true;}}get aspectRatio(){var _this$xr;return (_this$xr=this.xr)!=null&&_this$xr.active?this._xrProperties.aspectRatio:this._aspectRatio}set aspectRatioMode(newValue){if(this._aspectRatioMode!==newValue){this._aspectRatioMode=newValue;this._projMatDirty=true;}}get aspectRatioMode(){return this._aspectRatioMode}set calculateProjection(newValue){this._calculateProjection=newValue;this._projMatDirty=true;}get calculateProjection(){return this._calculateProjection}set calculateTransform(newValue){this._calculateTransform=newValue;}get calculateTransform(){return this._calculateTransform}set clearColor(newValue){this._clearColor.copy(newValue);}get clearColor(){return this._clearColor}set clearColorBuffer(newValue){this._clearColorBuffer=newValue;}get clearColorBuffer(){return this._clearColorBuffer}set clearDepth(newValue){this._clearDepth=newValue;}get clearDepth(){return this._clearDepth}set clearDepthBuffer(newValue){this._clearDepthBuffer=newValue;}get clearDepthBuffer(){return this._clearDepthBuffer}set clearStencil(newValue){this._clearStencil=newValue;}get clearStencil(){return this._clearStencil}set clearStencilBuffer(newValue){this._clearStencilBuffer=newValue;}get clearStencilBuffer(){return this._clearStencilBuffer}set cullFaces(newValue){this._cullFaces=newValue;}get cullFaces(){return this._cullFaces}set farClip(newValue){if(this._farClip!==newValue){this._farClip=newValue;this._projMatDirty=true;}}get farClip(){var _this$xr2;return (_this$xr2=this.xr)!=null&&_this$xr2.active?this._xrProperties.farClip:this._farClip}set flipFaces(newValue){this._flipFaces=newValue;}get flipFaces(){return this._flipFaces}set fov(newValue){if(this._fov!==newValue){this._fov=newValue;this._projMatDirty=true;}}get fov(){var _this$xr3;return (_this$xr3=this.xr)!=null&&_this$xr3.active?this._xrProperties.fov:this._fov}set frustumCulling(newValue){this._frustumCulling=newValue;}get frustumCulling(){return this._frustumCulling}set horizontalFov(newValue){if(this._horizontalFov!==newValue){this._horizontalFov=newValue;this._projMatDirty=true;}}get horizontalFov(){var _this$xr4;return (_this$xr4=this.xr)!=null&&_this$xr4.active?this._xrProperties.horizontalFov:this._horizontalFov}set layers(newValue){this._layers=newValue.slice(0);this._layersSet=new Set(this._layers);}get layers(){return this._layers}get layersSet(){return this._layersSet}set nearClip(newValue){if(this._nearClip!==newValue){this._nearClip=newValue;this._projMatDirty=true;}}get nearClip(){var _this$xr5;return (_this$xr5=this.xr)!=null&&_this$xr5.active?this._xrProperties.nearClip:this._nearClip}set node(newValue){this._node=newValue;}get node(){return this._node}set orthoHeight(newValue){if(this._orthoHeight!==newValue){this._orthoHeight=newValue;this._projMatDirty=true;}}get orthoHeight(){return this._orthoHeight}set projection(newValue){if(this._projection!==newValue){this._projection=newValue;this._projMatDirty=true;}}get projection(){return this._projection}get projectionMatrix(){this._evaluateProjectionMatrix();return this._projMat}set rect(newValue){this._rect.copy(newValue);}get rect(){return this._rect}set renderTarget(newValue){this._renderTarget=newValue;}get renderTarget(){return this._renderTarget}set scissorRect(newValue){this._scissorRect.copy(newValue);}get scissorRect(){return this._scissorRect}get viewMatrix(){if(this._viewMatDirty){const wtm=this._node.getWorldTransform();this._viewMat.copy(wtm).invert();this._viewMatDirty=false;}return this._viewMat}set aperture(newValue){this._aperture=newValue;}get aperture(){return this._aperture}set sensitivity(newValue){this._sensitivity=newValue;}get sensitivity(){return this._sensitivity}set shutter(newValue){this._shutter=newValue;}get shutter(){return this._shutter}set xr(newValue){if(this._xr!==newValue){this._xr=newValue;this._projMatDirty=true;}}get xr(){return this._xr}clone(){return new Camera().copy(this)}copy(other){this._aspectRatio=other._aspectRatio;this._farClip=other._farClip;this._fov=other._fov;this._horizontalFov=other._horizontalFov;this._nearClip=other._nearClip;this._xrProperties.aspectRatio=other._xrProperties.aspectRatio;this._xrProperties.farClip=other._xrProperties.farClip;this._xrProperties.fov=other._xrProperties.fov;this._xrProperties.horizontalFov=other._xrProperties.horizontalFov;this._xrProperties.nearClip=other._xrProperties.nearClip;this.aspectRatioMode=other.aspectRatioMode;this.calculateProjection=other.calculateProjection;this.calculateTransform=other.calculateTransform;this.clearColor=other.clearColor;this.clearColorBuffer=other.clearColorBuffer;this.clearDepth=other.clearDepth;this.clearDepthBuffer=other.clearDepthBuffer;this.clearStencil=other.clearStencil;this.clearStencilBuffer=other.clearStencilBuffer;this.cullFaces=other.cullFaces;this.flipFaces=other.flipFaces;this.frustumCulling=other.frustumCulling;this.layers=other.layers;this.orthoHeight=other.orthoHeight;this.projection=other.projection;this.rect=other.rect;this.renderTarget=other.renderTarget;this.scissorRect=other.scissorRect;this.aperture=other.aperture;this.shutter=other.shutter;this.sensitivity=other.sensitivity;this.shaderPassInfo=other.shaderPassInfo;this.jitter=other.jitter;this._projMatDirty=true;return this}_enableRenderPassColorGrab(device,enable){if(enable){if(!this.renderPassColorGrab){this.renderPassColorGrab=new RenderPassColorGrab(device);}}else {var _this$renderPassColor2;(_this$renderPassColor2=this.renderPassColorGrab)==null||_this$renderPassColor2.destroy();this.renderPassColorGrab=null;}}_enableRenderPassDepthGrab(device,renderer,enable){if(enable){if(!this.renderPassDepthGrab){this.renderPassDepthGrab=device.isWebGL1?new RenderPassDepth(device,renderer,this):new RenderPassDepthGrab(device,this);}}else {var _this$renderPassDepth2;(_this$renderPassDepth2=this.renderPassDepthGrab)==null||_this$renderPassDepth2.destroy();this.renderPassDepthGrab=null;}}_updateViewProjMat(){if(this._projMatDirty||this._viewMatDirty||this._viewProjMatDirty){this._viewProjMat.mul2(this.projectionMatrix,this.viewMatrix);this._viewProjMatDirty=false;}}worldToScreen(worldCoord,cw,ch,screenCoord=new Vec3){this._updateViewProjMat();this._viewProjMat.transformPoint(worldCoord,screenCoord);const vpm=this._viewProjMat.data;const w=worldCoord.x*vpm[3]+worldCoord.y*vpm[7]+worldCoord.z*vpm[11]+1*vpm[15];screenCoord.x=(screenCoord.x/w+1)*.5*cw;screenCoord.y=(1-screenCoord.y/w)*.5*ch;return screenCoord}screenToWorld(x,y,z,cw,ch,worldCoord=new Vec3){const range=this.farClip-this.nearClip;_deviceCoord.set(x/cw,(ch-y)/ch,z/range);_deviceCoord.mulScalar(2);_deviceCoord.sub(Vec3.ONE);if(this._projection===PROJECTION_PERSPECTIVE){Mat4._getPerspectiveHalfSize(_halfSize,this.fov,this.aspectRatio,this.nearClip,this.horizontalFov);_halfSize.x*=_deviceCoord.x;_halfSize.y*=_deviceCoord.y;const invView=this._node.getWorldTransform();_halfSize.z=-this.nearClip;invView.transformPoint(_halfSize,_point$1);const cameraPos=this._node.getPosition();worldCoord.sub2(_point$1,cameraPos);worldCoord.normalize();worldCoord.mulScalar(z);worldCoord.add(cameraPos);}else {this._updateViewProjMat();_invViewProjMat.copy(this._viewProjMat).invert();_invViewProjMat.transformPoint(_deviceCoord,worldCoord);}return worldCoord}_evaluateProjectionMatrix(){if(this._projMatDirty){if(this._projection===PROJECTION_PERSPECTIVE){this._projMat.setPerspective(this.fov,this.aspectRatio,this.nearClip,this.farClip,this.horizontalFov);this._projMatSkybox.copy(this._projMat);}else {const y=this._orthoHeight;const x=y*this.aspectRatio;this._projMat.setOrtho(-x,x,-y,y,this.nearClip,this.farClip);this._projMatSkybox.setPerspective(this.fov,this.aspectRatio,this.nearClip,this.farClip);}this._projMatDirty=false;}}getProjectionMatrixSkybox(){this._evaluateProjectionMatrix();return this._projMatSkybox}getExposure(){const ev100=Math.log2(this._aperture*this._aperture/this._shutter*100/this._sensitivity);return 1/(Math.pow(2,ev100)*1.2)}getScreenSize(sphere){if(this._projection===PROJECTION_PERSPECTIVE){const distance=this._node.getPosition().distance(sphere.center);if(distance<sphere.radius){return 1}const viewAngle=Math.asin(sphere.radius/distance);const sphereViewHeight=Math.tan(viewAngle);const screenViewHeight=Math.tan(this.fov/2*math.DEG_TO_RAD);return Math.min(sphereViewHeight/screenViewHeight,1)}return math.clamp(sphere.radius/this._orthoHeight,0,1)}getFrustumCorners(near=this.nearClip,far=this.farClip){const fov=this.fov*Math.PI/180;let y=this._projection===PROJECTION_PERSPECTIVE?Math.tan(fov/2)*near:this._orthoHeight;let x=y*this.aspectRatio;const points=_frustumPoints;points[0].x=x;points[0].y=-y;points[0].z=-near;points[1].x=x;points[1].y=y;points[1].z=-near;points[2].x=-x;points[2].y=y;points[2].z=-near;points[3].x=-x;points[3].y=-y;points[3].z=-near;if(this._projection===PROJECTION_PERSPECTIVE){y=Math.tan(fov/2)*far;x=y*this.aspectRatio;}points[4].x=x;points[4].y=-y;points[4].z=-far;points[5].x=x;points[5].y=y;points[5].z=-far;points[6].x=-x;points[6].y=y;points[6].z=-far;points[7].x=-x;points[7].y=-y;points[7].z=-far;return points}setXrProperties(properties){Object.assign(this._xrProperties,properties);this._projMatDirty=true;}constructor(){this.shaderPassInfo=null;this.renderPassColorGrab=null;this.renderPassDepthGrab=null;this.renderPasses=[];this.jitter=0;this._aspectRatio=16/9;this._aspectRatioMode=ASPECT_AUTO;this._calculateProjection=null;this._calculateTransform=null;this._clearColor=new Color(.75,.75,.75,1);this._clearColorBuffer=true;this._clearDepth=1;this._clearDepthBuffer=true;this._clearStencil=0;this._clearStencilBuffer=true;this._cullFaces=true;this._farClip=1e3;this._flipFaces=false;this._fov=45;this._frustumCulling=true;this._horizontalFov=false;this._layers=[LAYERID_WORLD,LAYERID_DEPTH,LAYERID_SKYBOX,LAYERID_UI,LAYERID_IMMEDIATE];this._layersSet=new Set(this._layers);this._nearClip=.1;this._node=null;this._orthoHeight=10;this._projection=PROJECTION_PERSPECTIVE;this._rect=new Vec4(0,0,1,1);this._renderTarget=null;this._scissorRect=new Vec4(0,0,1,1);this._scissorRectClear=false;this._aperture=16;this._shutter=1/1e3;this._sensitivity=1e3;this._projMat=new Mat4;this._projMatDirty=true;this._projMatSkybox=new Mat4;this._viewMat=new Mat4;this._viewMatDirty=true;this._viewProjMat=new Mat4;this._viewProjMatDirty=true;this._shaderMatricesVersion=0;this._viewProjInverse=new Mat4;this._viewProjCurrent=null;this._viewProjPrevious=new Mat4;this._jitters=[0,0,0,0];this.frustum=new Frustum;this._xr=null;this._xrProperties={horizontalFov:this._horizontalFov,fov:this._fov,aspectRatio:this._aspectRatio,farClip:this._farClip,nearClip:this._nearClip};}}class LitShaderOptions{constructor(){this.hasTangents=false;this.chunks={};this.pass=0;this.alphaTest=false;this.blendType=BLEND_NONE;this.separateAmbient=false;this.screenSpace=false;this.skin=false;this.useInstancing=false;this.useMorphPosition=false;this.useMorphNormal=false;this.useMorphTextureBased=false;this.nineSlicedMode=0;this.clusteredLightingEnabled=true;this.clusteredLightingCookiesEnabled=false;this.clusteredLightingShadowsEnabled=false;this.clusteredLightingShadowType=0;this.clusteredLightingAreaLightsEnabled=false;this.vertexColors=false;this.lightMapEnabled=false;this.dirLightMapEnabled=false;this.useHeights=false;this.useNormals=false;this.useClearCoatNormals=false;this.useAo=false;this.diffuseMapEnabled=false;this.useAmbientTint=false;this.customFragmentShader=null;this.pixelSnap=false;this.shadingModel=0;this.ambientSH=false;this.fastTbn=false;this.twoSidedLighting=false;this.occludeDirect=false;this.occludeSpecular=0;this.occludeSpecularFloat=false;this.useMsdf=false;this.msdfTextAttribute=false;this.alphaToCoverage=false;this.opacityFadesSpecular=false;this.opacityDither=DITHER_NONE;this.opacityShadowDither=DITHER_NONE;this.cubeMapProjection=0;this.conserveEnergy=false;this.useSpecular=false;this.useSpecularityFactor=false;this.enableGGXSpecular=false;this.fresnelModel=0;this.useRefraction=false;this.useClearCoat=false;this.useSheen=false;this.useIridescence=false;this.useMetalness=false;this.useDynamicRefraction=false;this.dispersion=false;this.fog=FOG_NONE;this.gamma=GAMMA_NONE;this.toneMap=-1;this.fixSeams=false;this.reflectionSource=null;this.reflectionEncoding=null;this.reflectionCubemapEncoding=null;this.ambientSource="constant";this.ambientEncoding=null;this.skyboxIntensity=1;this.useCubeMapRotation=false;this.lightMapWithoutAmbient=false;this.lights=[];this.noShadow=false;this.lightMaskDynamic=0;this.userAttributes={};}}class LitMaterialOptions{constructor(){this.usedUvs=void 0;this.shaderChunk=void 0;this.litOptions=new LitShaderOptions;}}class LitMaterialOptionsBuilder{static update(litOptions,material,scene,objDefs,pass,sortedLights){LitMaterialOptionsBuilder.updateSharedOptions(litOptions,material,scene,objDefs,pass);LitMaterialOptionsBuilder.updateMaterialOptions(litOptions,material);LitMaterialOptionsBuilder.updateEnvOptions(litOptions,material,scene);LitMaterialOptionsBuilder.updateLightingOptions(litOptions,material,objDefs,sortedLights);if(pass===SHADER_FORWARDHDR){litOptions.gamma=GAMMA_SRGBHDR;litOptions.toneMap=TONEMAP_LINEAR;}}static updateSharedOptions(litOptions,material,scene,objDefs,pass){litOptions.chunks=material.chunks;litOptions.pass=pass;litOptions.alphaTest=material.alphaTest>0;litOptions.blendType=material.blendType;litOptions.screenSpace=objDefs&&(objDefs&SHADERDEF_SCREENSPACE)!==0;litOptions.skin=objDefs&&(objDefs&SHADERDEF_SKIN)!==0;litOptions.useInstancing=objDefs&&(objDefs&SHADERDEF_INSTANCING)!==0;litOptions.useMorphPosition=objDefs&&(objDefs&SHADERDEF_MORPH_POSITION)!==0;litOptions.useMorphNormal=objDefs&&(objDefs&SHADERDEF_MORPH_NORMAL)!==0;litOptions.useMorphTextureBased=objDefs&&(objDefs&SHADERDEF_MORPH_TEXTURE_BASED)!==0;litOptions.hasTangents=objDefs&&(objDefs&SHADERDEF_TANGENTS)!==0;litOptions.nineSlicedMode=material.nineSlicedMode||SPRITE_RENDERMODE_SIMPLE;if(material.useLighting&&scene.clusteredLightingEnabled){litOptions.clusteredLightingEnabled=true;litOptions.clusteredLightingCookiesEnabled=scene.lighting.cookiesEnabled;litOptions.clusteredLightingShadowsEnabled=scene.lighting.shadowsEnabled;litOptions.clusteredLightingShadowType=scene.lighting.shadowType;litOptions.clusteredLightingAreaLightsEnabled=scene.lighting.areaLightsEnabled;}else {litOptions.clusteredLightingEnabled=false;litOptions.clusteredLightingCookiesEnabled=false;litOptions.clusteredLightingShadowsEnabled=false;litOptions.clusteredLightingAreaLightsEnabled=false;}}static updateMaterialOptions(litOptions,material){litOptions.useAmbientTint=false;litOptions.separateAmbient=false;litOptions.customFragmentShader=null;litOptions.pixelSnap=material.pixelSnap;litOptions.shadingModel=material.shadingModel;litOptions.ambientSH=material.ambientSH;litOptions.fastTbn=material.fastTbn;litOptions.twoSidedLighting=material.twoSidedLighting;litOptions.occludeDirect=material.occludeDirect;litOptions.occludeSpecular=material.occludeSpecular;litOptions.occludeSpecularFloat=material.occludeSpecularIntensity!==1;litOptions.useMsdf=false;litOptions.msdfTextAttribute=false;litOptions.alphaToCoverage=material.alphaToCoverage;litOptions.opacityFadesSpecular=material.opacityFadesSpecular;litOptions.opacityDither=material.opacityDither;litOptions.cubeMapProjection=CUBEPROJ_NONE;litOptions.conserveEnergy=material.conserveEnergy&&material.shadingModel===SPECULAR_BLINN;litOptions.useSpecular=material.hasSpecular;litOptions.useSpecularityFactor=material.hasSpecularityFactor;litOptions.enableGGXSpecular=material.ggxSpecular;litOptions.fresnelModel=material.fresnelModel;litOptions.useRefraction=material.hasRefraction;litOptions.useClearCoat=material.hasClearCoat;litOptions.useSheen=material.hasSheen;litOptions.useIridescence=material.hasIrridescence;litOptions.useMetalness=material.hasMetalness;litOptions.useDynamicRefraction=material.dynamicRefraction;litOptions.dispersion=material.dispersion>0;litOptions.vertexColors=false;litOptions.lightMapEnabled=material.hasLighting;litOptions.dirLightMapEnabled=material.dirLightMap;litOptions.useHeights=material.hasHeights;litOptions.useNormals=material.hasNormals;litOptions.useClearCoatNormals=material.hasClearCoatNormals;litOptions.useAo=material.hasAo;litOptions.diffuseMapEnabled=material.hasDiffuseMap;}static updateEnvOptions(litOptions,material,scene){litOptions.fog=material.useFog?scene.fog:"none";litOptions.gamma=material.useGammaTonemap?scene.gammaCorrection:GAMMA_NONE;litOptions.toneMap=material.useGammaTonemap?scene.toneMapping:-1;litOptions.fixSeams=false;if(material.useSkybox&&scene.envAtlas&&scene.skybox){litOptions.reflectionSource="envAtlasHQ";litOptions.reflectionEncoding=scene.envAtlas.encoding;litOptions.reflectionCubemapEncoding=scene.skybox.encoding;}else if(material.useSkybox&&scene.envAtlas){litOptions.reflectionSource="envAtlas";litOptions.reflectionEncoding=scene.envAtlas.encoding;}else if(material.useSkybox&&scene.skybox){litOptions.reflectionSource="cubeMap";litOptions.reflectionEncoding=scene.skybox.encoding;}else {litOptions.reflectionSource=null;litOptions.reflectionEncoding=null;}if(material.ambientSH){litOptions.ambientSource="ambientSH";litOptions.ambientEncoding=null;}else if(litOptions.reflectionSource&&scene.envAtlas){litOptions.ambientSource="envAtlas";litOptions.ambientEncoding=scene.envAtlas.encoding;}else {litOptions.ambientSource="constant";litOptions.ambientEncoding=null;}const hasSkybox=!!litOptions.reflectionSource;litOptions.skyboxIntensity=hasSkybox;litOptions.useCubeMapRotation=hasSkybox&&scene._skyboxRotationShaderInclude;}static updateLightingOptions(litOptions,material,objDefs,sortedLights){litOptions.lightMapWithoutAmbient=false;if(material.useLighting){const lightsFiltered=[];const mask=objDefs?objDefs>>16:MASK_AFFECT_DYNAMIC;litOptions.lightMaskDynamic=!!(mask&MASK_AFFECT_DYNAMIC);litOptions.lightMapWithoutAmbient=false;if(sortedLights){LitMaterialOptionsBuilder.collectLights(LIGHTTYPE_DIRECTIONAL,sortedLights[LIGHTTYPE_DIRECTIONAL],lightsFiltered,mask);LitMaterialOptionsBuilder.collectLights(LIGHTTYPE_OMNI,sortedLights[LIGHTTYPE_OMNI],lightsFiltered,mask);LitMaterialOptionsBuilder.collectLights(LIGHTTYPE_SPOT,sortedLights[LIGHTTYPE_SPOT],lightsFiltered,mask);}litOptions.lights=lightsFiltered;}else {litOptions.lights=[];}if(litOptions.lights.length===0||(objDefs&SHADERDEF_NOSHADOW)!==0){litOptions.noShadow=true;}}static collectLights(lType,lights,lightsFiltered,mask){for(let i=0;i<lights.length;i++){const light=lights[i];if(light.enabled){if(light.mask&mask){lightsFiltered.push(light);}}}}}class ChunkBuilder{append(...chunks){chunks.forEach(chunk=>{if(chunk.endsWith("\n")){this.code+=chunk;}else {this.code+=`${chunk}
`;}});}prepend(...chunks){chunks.forEach(chunk=>{if(chunk.endsWith("\n")){this.code=chunk+this.code;}else {this.code=`${chunk}
${this.code}`;}});}constructor(){this.code="";}}const decodeTable={"linear":"decodeLinear","srgb":"decodeGamma","rgbm":"decodeRGBM","rgbe":"decodeRGBE","rgbp":"decodeRGBP"};const encodeTable={"linear":"encodeLinear","srgb":"encodeGamma","rgbm":"encodeRGBM","rgbe":"encodeRGBE","rgbp":"encodeRGBP"};class ChunkUtils{static decodeFunc(encoding){return decodeTable[encoding]||"decodeGamma"}static encodeFunc(encoding){return encodeTable[encoding]||"encodeGamma"}}const _viewMat=new Mat4;const _viewProjMat=new Mat4;const _viewportMatrix=new Mat4;class LightCamera{static create(name,lightType,face){const camera=new Camera;camera.node=new GraphNode(name);camera.aspectRatio=1;camera.aspectRatioMode=ASPECT_MANUAL;camera._scissorRectClear=true;switch(lightType){case LIGHTTYPE_OMNI:camera.node.setRotation(LightCamera.pointLightRotations[face]);camera.fov=90;camera.projection=PROJECTION_PERSPECTIVE;break;case LIGHTTYPE_SPOT:camera.projection=PROJECTION_PERSPECTIVE;break;case LIGHTTYPE_DIRECTIONAL:camera.projection=PROJECTION_ORTHOGRAPHIC;break}return camera}static evalSpotCookieMatrix(light){let cookieCamera=LightCamera._spotCookieCamera;if(!cookieCamera){cookieCamera=LightCamera.create("SpotCookieCamera",LIGHTTYPE_SPOT);LightCamera._spotCookieCamera=cookieCamera;}cookieCamera.fov=light._outerConeAngle*2;const cookieNode=cookieCamera._node;cookieNode.setPosition(light._node.getPosition());cookieNode.setRotation(light._node.getRotation());cookieNode.rotateLocal(-90,0,0);_viewMat.setTRS(cookieNode.getPosition(),cookieNode.getRotation(),Vec3.ONE).invert();_viewProjMat.mul2(cookieCamera.projectionMatrix,_viewMat);const cookieMatrix=light.cookieMatrix;const rectViewport=light.atlasViewport;_viewportMatrix.setViewport(rectViewport.x,rectViewport.y,rectViewport.z,rectViewport.w);cookieMatrix.mul2(_viewportMatrix,_viewProjMat);return cookieMatrix}}LightCamera.pointLightRotations=[new Quat().setFromEulerAngles(0,90,180),new Quat().setFromEulerAngles(0,-90,180),new Quat().setFromEulerAngles(90,0,0),new Quat().setFromEulerAngles(-90,0,0),new Quat().setFromEulerAngles(0,180,180),new Quat().setFromEulerAngles(0,0,180)];LightCamera._spotCookieCamera=null;const epsilon$1=1e-6;const tempVec3$1=new Vec3;const tempAreaLightSizes=new Float32Array(6);const areaHalfAxisWidth=new Vec3(-.5,0,0);const areaHalfAxisHeight=new Vec3(0,0,.5);const TextureIndex8={FLAGS:0,COLOR_A:1,COLOR_B:2,SPOT_ANGLES:3,SHADOW_BIAS:4,COOKIE_A:5,COOKIE_B:6,COUNT_ALWAYS:7,POSITION_X:7,POSITION_Y:8,POSITION_Z:9,RANGE:10,SPOT_DIRECTION_X:11,SPOT_DIRECTION_Y:12,SPOT_DIRECTION_Z:13,PROJ_MAT_00:14,ATLAS_VIEWPORT_A:14,PROJ_MAT_01:15,ATLAS_VIEWPORT_B:15,PROJ_MAT_02:16,PROJ_MAT_03:17,PROJ_MAT_10:18,PROJ_MAT_11:19,PROJ_MAT_12:20,PROJ_MAT_13:21,PROJ_MAT_20:22,PROJ_MAT_21:23,PROJ_MAT_22:24,PROJ_MAT_23:25,PROJ_MAT_30:26,PROJ_MAT_31:27,PROJ_MAT_32:28,PROJ_MAT_33:29,AREA_DATA_WIDTH_X:30,AREA_DATA_WIDTH_Y:31,AREA_DATA_WIDTH_Z:32,AREA_DATA_HEIGHT_X:33,AREA_DATA_HEIGHT_Y:34,AREA_DATA_HEIGHT_Z:35,COUNT:36};const TextureIndexFloat={POSITION_RANGE:0,SPOT_DIRECTION:1,PROJ_MAT_0:2,ATLAS_VIEWPORT:2,PROJ_MAT_1:3,PROJ_MAT_2:4,PROJ_MAT_3:5,AREA_DATA_WIDTH:6,AREA_DATA_HEIGHT:7,COUNT:8};const FORMAT_FLOAT=0;const FORMAT_8BIT=1;const shaderDefinesDeviceCache=new DeviceCache;class LightsBuffer{static getLightTextureFormat(device){return device.extTextureFloat&&device.maxTextures>8?FORMAT_FLOAT:FORMAT_8BIT}static getShaderDefines(device){return shaderDefinesDeviceCache.get(device,()=>{const buildShaderDefines=(device,object,prefix,floatOffset)=>{return Object.keys(object).map(key=>`#define ${prefix}${key} ${object[key]}${floatOffset}`).join("\n")};const lightTextureFormat=LightsBuffer.getLightTextureFormat(device);const clusterTextureFormat=lightTextureFormat===FORMAT_FLOAT?"FLOAT":"8BIT";const floatOffset=device.supportsTextureFetch?"":".5";return `
								
#define CLUSTER_TEXTURE_${clusterTextureFormat}
								${buildShaderDefines(device,TextureIndex8,"CLUSTER_TEXTURE_8_",floatOffset)}
								${buildShaderDefines(device,TextureIndexFloat,"CLUSTER_TEXTURE_F_",floatOffset)}
						`})}destroy(){if(this.lightsTexture8){this.lightsTexture8.destroy();this.lightsTexture8=null;}if(this.lightsTextureFloat){this.lightsTextureFloat.destroy();this.lightsTextureFloat=null;}}createTexture(device,width,height,format,name){const tex=new Texture(device,{name:name,width:width,height:height,mipmaps:false,format:format,addressU:ADDRESS_CLAMP_TO_EDGE,addressV:ADDRESS_CLAMP_TO_EDGE,type:TEXTURETYPE_DEFAULT,magFilter:FILTER_NEAREST,minFilter:FILTER_NEAREST,anisotropy:1});return tex}setCompressionRanges(maxAttenuation,maxColorValue){this.invMaxColorValue=1/maxColorValue;this.invMaxAttenuation=1/maxAttenuation;}setBounds(min,delta){this.boundsMin.copy(min);this.boundsDelta.copy(delta);}uploadTextures(){if(this.lightsTextureFloat){this.lightsTextureFloat.lock().set(this.lightsFloat);this.lightsTextureFloat.unlock();}this.lightsTexture8.lock().set(this.lights8);this.lightsTexture8.unlock();}updateUniforms(){this._lightsTexture8Id.setValue(this.lightsTexture8);if(this.lightTextureFormat===FORMAT_FLOAT){this._lightsTextureFloatId.setValue(this.lightsTextureFloat);}this._lightsTextureInvSizeId.setValue(this._lightsTextureInvSizeData);}getSpotDirection(direction,spot){const mat=spot._node.getWorldTransform();mat.getY(direction).mulScalar(-1);direction.normalize();}getLightAreaSizes(light){const mat=light._node.getWorldTransform();mat.transformVector(areaHalfAxisWidth,tempVec3$1);tempAreaLightSizes[0]=tempVec3$1.x;tempAreaLightSizes[1]=tempVec3$1.y;tempAreaLightSizes[2]=tempVec3$1.z;mat.transformVector(areaHalfAxisHeight,tempVec3$1);tempAreaLightSizes[3]=tempVec3$1.x;tempAreaLightSizes[4]=tempVec3$1.y;tempAreaLightSizes[5]=tempVec3$1.z;return tempAreaLightSizes}addLightDataFlags(data8,index,light,isSpot,castShadows,shadowIntensity){data8[index+0]=isSpot?255:0;data8[index+1]=light._shape*64;data8[index+2]=light._falloffMode*255;data8[index+3]=castShadows?shadowIntensity*255:0;}addLightDataColor(data8,index,light,gammaCorrection,isCookie){const invMaxColorValue=this.invMaxColorValue;const color=gammaCorrection?light._linearFinalColor:light._finalColor;FloatPacking.float2Bytes(color[0]*invMaxColorValue,data8,index+0,2);FloatPacking.float2Bytes(color[1]*invMaxColorValue,data8,index+2,2);FloatPacking.float2Bytes(color[2]*invMaxColorValue,data8,index+4,2);data8[index+6]=isCookie?255:0;const isDynamic=!!(light.mask&MASK_AFFECT_DYNAMIC);const isLightmapped=!!(light.mask&MASK_AFFECT_LIGHTMAPPED);data8[index+7]=isDynamic&&isLightmapped?127:isLightmapped?255:0;}addLightDataSpotAngles(data8,index,light){FloatPacking.float2Bytes(light._innerConeAngleCos*(.5-epsilon$1)+.5,data8,index+0,2);FloatPacking.float2Bytes(light._outerConeAngleCos*(.5-epsilon$1)+.5,data8,index+2,2);}addLightDataShadowBias(data8,index,light){const lightRenderData=light.getRenderData(null,0);const biases=light._getUniformBiasValues(lightRenderData);FloatPacking.float2BytesRange(biases.bias,data8,index,-1,20,2);FloatPacking.float2Bytes(biases.normalBias,data8,index+2,2);}addLightDataPositionRange(data8,index,light,pos){const normPos=tempVec3$1.sub2(pos,this.boundsMin).div(this.boundsDelta);FloatPacking.float2Bytes(normPos.x,data8,index+0,4);FloatPacking.float2Bytes(normPos.y,data8,index+4,4);FloatPacking.float2Bytes(normPos.z,data8,index+8,4);FloatPacking.float2Bytes(light.attenuationEnd*this.invMaxAttenuation,data8,index+12,4);}addLightDataSpotDirection(data8,index,light){this.getSpotDirection(tempVec3$1,light);FloatPacking.float2Bytes(tempVec3$1.x*(.5-epsilon$1)+.5,data8,index+0,4);FloatPacking.float2Bytes(tempVec3$1.y*(.5-epsilon$1)+.5,data8,index+4,4);FloatPacking.float2Bytes(tempVec3$1.z*(.5-epsilon$1)+.5,data8,index+8,4);}addLightDataLightProjMatrix(data8,index,lightProjectionMatrix){const matData=lightProjectionMatrix.data;for(let m=0;m<12;m++){FloatPacking.float2BytesRange(matData[m],data8,index+4*m,-2,2,4);}for(let m=12;m<16;m++){FloatPacking.float2MantissaExponent(matData[m],data8,index+4*m,4);}}addLightDataCookies(data8,index,light){const isRgb=light._cookieChannel==="rgb";data8[index+0]=Math.floor(light.cookieIntensity*255);data8[index+1]=isRgb?255:0;if(!isRgb){const channel=light._cookieChannel;data8[index+4]=channel==="rrr"?255:0;data8[index+5]=channel==="ggg"?255:0;data8[index+6]=channel==="bbb"?255:0;data8[index+7]=channel==="aaa"?255:0;}}addLightAtlasViewport(data8,index,atlasViewport){FloatPacking.float2Bytes(atlasViewport.x,data8,index+0,2);FloatPacking.float2Bytes(atlasViewport.y,data8,index+2,2);FloatPacking.float2Bytes(atlasViewport.z/3,data8,index+4,2);}addLightAreaSizes(data8,index,light){const areaSizes=this.getLightAreaSizes(light);for(let i=0;i<6;i++){FloatPacking.float2MantissaExponent(areaSizes[i],data8,index+4*i,4);}}addLightData(light,lightIndex,gammaCorrection){const isSpot=light._type===LIGHTTYPE_SPOT;const hasAtlasViewport=light.atlasViewportAllocated;const isCookie=this.cookiesEnabled&&!!light._cookie&&hasAtlasViewport;const isArea=this.areaLightsEnabled&&light.shape!==LIGHTSHAPE_PUNCTUAL;const castShadows=this.shadowsEnabled&&light.castShadows&&hasAtlasViewport;const pos=light._node.getPosition();let lightProjectionMatrix=null;let atlasViewport=null;if(isSpot){if(castShadows){const lightRenderData=light.getRenderData(null,0);lightProjectionMatrix=lightRenderData.shadowMatrix;}else if(isCookie){lightProjectionMatrix=LightCamera.evalSpotCookieMatrix(light);}}else {if(castShadows||isCookie){atlasViewport=light.atlasViewport;}}const data8=this.lights8;const data8Start=lightIndex*this.lightsTexture8.width*4;this.addLightDataFlags(data8,data8Start+4*TextureIndex8.FLAGS,light,isSpot,castShadows,light.shadowIntensity);this.addLightDataColor(data8,data8Start+4*TextureIndex8.COLOR_A,light,gammaCorrection,isCookie);if(isSpot){this.addLightDataSpotAngles(data8,data8Start+4*TextureIndex8.SPOT_ANGLES,light);}if(light.castShadows){this.addLightDataShadowBias(data8,data8Start+4*TextureIndex8.SHADOW_BIAS,light);}if(isCookie){this.addLightDataCookies(data8,data8Start+4*TextureIndex8.COOKIE_A,light);}if(this.lightTextureFormat===FORMAT_FLOAT){const dataFloat=this.lightsFloat;const dataFloatStart=lightIndex*this.lightsTextureFloat.width*4;dataFloat[dataFloatStart+4*TextureIndexFloat.POSITION_RANGE+0]=pos.x;dataFloat[dataFloatStart+4*TextureIndexFloat.POSITION_RANGE+1]=pos.y;dataFloat[dataFloatStart+4*TextureIndexFloat.POSITION_RANGE+2]=pos.z;dataFloat[dataFloatStart+4*TextureIndexFloat.POSITION_RANGE+3]=light.attenuationEnd;if(isSpot){this.getSpotDirection(tempVec3$1,light);dataFloat[dataFloatStart+4*TextureIndexFloat.SPOT_DIRECTION+0]=tempVec3$1.x;dataFloat[dataFloatStart+4*TextureIndexFloat.SPOT_DIRECTION+1]=tempVec3$1.y;dataFloat[dataFloatStart+4*TextureIndexFloat.SPOT_DIRECTION+2]=tempVec3$1.z;}if(lightProjectionMatrix){const matData=lightProjectionMatrix.data;for(let m=0;m<16;m++){dataFloat[dataFloatStart+4*TextureIndexFloat.PROJ_MAT_0+m]=matData[m];}}if(atlasViewport){dataFloat[dataFloatStart+4*TextureIndexFloat.ATLAS_VIEWPORT+0]=atlasViewport.x;dataFloat[dataFloatStart+4*TextureIndexFloat.ATLAS_VIEWPORT+1]=atlasViewport.y;dataFloat[dataFloatStart+4*TextureIndexFloat.ATLAS_VIEWPORT+2]=atlasViewport.z/3;}if(isArea){const areaSizes=this.getLightAreaSizes(light);dataFloat[dataFloatStart+4*TextureIndexFloat.AREA_DATA_WIDTH+0]=areaSizes[0];dataFloat[dataFloatStart+4*TextureIndexFloat.AREA_DATA_WIDTH+1]=areaSizes[1];dataFloat[dataFloatStart+4*TextureIndexFloat.AREA_DATA_WIDTH+2]=areaSizes[2];dataFloat[dataFloatStart+4*TextureIndexFloat.AREA_DATA_HEIGHT+0]=areaSizes[3];dataFloat[dataFloatStart+4*TextureIndexFloat.AREA_DATA_HEIGHT+1]=areaSizes[4];dataFloat[dataFloatStart+4*TextureIndexFloat.AREA_DATA_HEIGHT+2]=areaSizes[5];}}else {this.addLightDataPositionRange(data8,data8Start+4*TextureIndex8.POSITION_X,light,pos);if(isSpot){this.addLightDataSpotDirection(data8,data8Start+4*TextureIndex8.SPOT_DIRECTION_X,light);}if(lightProjectionMatrix){this.addLightDataLightProjMatrix(data8,data8Start+4*TextureIndex8.PROJ_MAT_00,lightProjectionMatrix);}if(atlasViewport){this.addLightAtlasViewport(data8,data8Start+4*TextureIndex8.ATLAS_VIEWPORT_A,atlasViewport);}if(isArea){this.addLightAreaSizes(data8,data8Start+4*TextureIndex8.AREA_DATA_WIDTH_X,light);}}}constructor(device){this.device=device;this.cookiesEnabled=false;this.shadowsEnabled=false;this.areaLightsEnabled=false;this.maxLights=255;let pixelsPerLight8=TextureIndex8.COUNT_ALWAYS;let pixelsPerLightFloat=0;this.lightTextureFormat=LightsBuffer.getLightTextureFormat(device);if(this.lightTextureFormat===FORMAT_FLOAT){pixelsPerLightFloat=TextureIndexFloat.COUNT;}else {pixelsPerLight8=TextureIndex8.COUNT;}this.lights8=new Uint8ClampedArray(4*pixelsPerLight8*this.maxLights);this.lightsTexture8=this.createTexture(this.device,pixelsPerLight8,this.maxLights,PIXELFORMAT_RGBA8,"LightsTexture8");this._lightsTexture8Id=this.device.scope.resolve("lightsTexture8");if(pixelsPerLightFloat){this.lightsFloat=new Float32Array(4*pixelsPerLightFloat*this.maxLights);this.lightsTextureFloat=this.createTexture(this.device,pixelsPerLightFloat,this.maxLights,PIXELFORMAT_RGBA32F,"LightsTextureFloat");this._lightsTextureFloatId=this.device.scope.resolve("lightsTextureFloat");}else {this.lightsFloat=null;this.lightsTextureFloat=null;this._lightsTextureFloatId=undefined;}this._lightsTextureInvSizeId=this.device.scope.resolve("lightsTextureInvSize");this._lightsTextureInvSizeData=new Float32Array(4);this._lightsTextureInvSizeData[0]=pixelsPerLightFloat?1/this.lightsTextureFloat.width:0;this._lightsTextureInvSizeData[1]=pixelsPerLightFloat?1/this.lightsTextureFloat.height:0;this._lightsTextureInvSizeData[2]=1/this.lightsTexture8.width;this._lightsTextureInvSizeData[3]=1/this.lightsTexture8.height;this.invMaxColorValue=0;this.invMaxAttenuation=0;this.boundsMin=new Vec3;this.boundsDelta=new Vec3;}}const builtinAttributes={vertex_normal:SEMANTIC_NORMAL,vertex_tangent:SEMANTIC_TANGENT,vertex_texCoord0:SEMANTIC_TEXCOORD0,vertex_texCoord1:SEMANTIC_TEXCOORD1,vertex_color:SEMANTIC_COLOR,vertex_boneWeights:SEMANTIC_BLENDWEIGHT,vertex_boneIndices:SEMANTIC_BLENDINDICES};const builtinVaryings={vVertexColor:"vec4",vPositionW:"vec3",vNormalV:"vec3",vNormalW:"vec3",vTangentW:"vec3",vBinormalW:"vec3",vObjectSpaceUpW:"vec3",vUv0:"vec2",vUv1:"vec2"};class LitShader{_vsAddBaseCode(code,chunks,options){code+=chunks.baseVS;if(options.nineSlicedMode===SPRITE_RENDERMODE_SLICED||options.nineSlicedMode===SPRITE_RENDERMODE_TILED){code+=chunks.baseNineSlicedVS;}return code}_vsAddTransformCode(code,device,chunks,options){code+=this.chunks.transformVS;return code}_setMapTransform(codes,name,id,uv){const checkId=id+uv*100;if(!codes[3][checkId]){const varName=`texture_${name}MapTransform`;codes[0]+=`uniform vec3 ${varName}0;
`;codes[0]+=`uniform vec3 ${varName}1;
`;codes[1]+=`varying vec2 vUV${uv}_${id};
`;codes[2]+=`   vUV${uv}_${id} = vec2(dot(vec3(uv${uv}, 1), ${varName}0), dot(vec3(uv${uv}, 1), ${varName}1));
`;codes[3][checkId]=true;}return codes}_fsGetBaseCode(){const options=this.options;const chunks=this.chunks;let result=this.chunks.basePS;if(options.nineSlicedMode===SPRITE_RENDERMODE_SLICED){result+=chunks.baseNineSlicedPS;}else if(options.nineSlicedMode===SPRITE_RENDERMODE_TILED){result+=chunks.baseNineSlicedTiledPS;}return result}_fsGetStartCode(code,device,chunks,options){let result=chunks.startPS;if(options.nineSlicedMode===SPRITE_RENDERMODE_SLICED){result+=chunks.startNineSlicedPS;}else if(options.nineSlicedMode===SPRITE_RENDERMODE_TILED){result+=chunks.startNineSlicedTiledPS;}return result}_getLightSourceShapeString(shape){switch(shape){case LIGHTSHAPE_RECT:return "Rect";case LIGHTSHAPE_DISK:return "Disk";case LIGHTSHAPE_SPHERE:return "Sphere";default:return ""}}generateVertexShader(useUv,useUnmodifiedUv,mapTransforms){const device=this.device;const options=this.options;const chunks=this.chunks;let code="";let codeBody="";code=this._vsAddBaseCode(code,chunks,options);codeBody+="   vPositionW    = getWorldPosition();\n";if(this.options.pass===SHADER_DEPTH||this.options.pass===SHADER_PREPASS_VELOCITY){code+="varying float vDepth;\n";code+="#ifndef VIEWMATRIX\n";code+="#define VIEWMATRIX\n";code+="uniform mat4 matrix_view;\n";code+="#endif\n";code+="#ifndef CAMERAPLANES\n";code+="#define CAMERAPLANES\n";code+="uniform vec4 camera_params;\n\n";code+="#endif\n";codeBody+="    vDepth = -(matrix_view * vec4(vPositionW,1.0)).z * camera_params.x;\n";}if(this.options.pass===SHADER_PREPASS_VELOCITY);if(this.options.useInstancing){this.attributes.instance_line1=SEMANTIC_ATTR12;this.attributes.instance_line2=SEMANTIC_ATTR13;this.attributes.instance_line3=SEMANTIC_ATTR14;this.attributes.instance_line4=SEMANTIC_ATTR15;code+=chunks.instancingVS;}if(this.needsNormal){this.attributes.vertex_normal=SEMANTIC_NORMAL;codeBody+="   vNormalW = getNormal();\n";if(options.reflectionSource==="sphereMap"&&device.fragmentUniformsCount<=16){code+=chunks.viewNormalVS;codeBody+="   vNormalV    = getViewNormal();\n";}if(options.hasTangents&&(options.useHeights||options.useNormals||options.enableGGXSpecular)){this.attributes.vertex_tangent=SEMANTIC_TANGENT;code+=chunks.tangentBinormalVS;codeBody+="   vTangentW   = getTangent();\n";codeBody+="   vBinormalW  = getBinormal();\n";}else if(options.enableGGXSpecular||!device.extStandardDerivatives){codeBody+="   vObjectSpaceUpW = normalize(dNormalMatrix * vec3(0, 1, 0));\n";}}const maxUvSets=2;for(let i=0;i<maxUvSets;i++){if(useUv[i]){this.attributes[`vertex_texCoord${i}`]=`TEXCOORD${i}`;code+=chunks[`uv${i}VS`];codeBody+=`   vec2 uv${i} = getUv${i}();
`;}if(useUnmodifiedUv[i]){codeBody+=`   vUv${i} = uv${i};
`;}}const codes=[code,this.varyings,codeBody,[]];mapTransforms.forEach(mapTransform=>{this._setMapTransform(codes,mapTransform.name,mapTransform.id,mapTransform.uv);});code=codes[0];this.varyings=codes[1];codeBody=codes[2];if(options.vertexColors){this.attributes.vertex_color=SEMANTIC_COLOR;codeBody+="   vVertexColor = vertex_color;\n";}if(options.useMsdf&&options.msdfTextAttribute){this.attributes.vertex_outlineParameters=SEMANTIC_ATTR8;this.attributes.vertex_shadowParameters=SEMANTIC_ATTR9;codeBody+="    unpackMsdfParams();\n";code+=chunks.msdfVS;}if(options.useMorphPosition||options.useMorphNormal){if(options.useMorphTextureBased){code+="#define MORPHING_TEXTURE_BASED\n";if(options.useMorphPosition){code+="#define MORPHING_TEXTURE_BASED_POSITION\n";}if(options.useMorphNormal){code+="#define MORPHING_TEXTURE_BASED_NORMAL\n";}this.attributes.morph_vertex_id=SEMANTIC_ATTR15;const morphIdType=device.isWebGPU?"uint":"float";code+=`attribute ${morphIdType} morph_vertex_id;
`;}else {code+="#define MORPHING\n";if(options.useMorphPosition){this.attributes.morph_pos0=SEMANTIC_ATTR8;this.attributes.morph_pos1=SEMANTIC_ATTR9;this.attributes.morph_pos2=SEMANTIC_ATTR10;this.attributes.morph_pos3=SEMANTIC_ATTR11;code+="#define MORPHING_POS03\n";code+="attribute vec3 morph_pos0;\n";code+="attribute vec3 morph_pos1;\n";code+="attribute vec3 morph_pos2;\n";code+="attribute vec3 morph_pos3;\n";}else if(options.useMorphNormal){this.attributes.morph_nrm0=SEMANTIC_ATTR8;this.attributes.morph_nrm1=SEMANTIC_ATTR9;this.attributes.morph_nrm2=SEMANTIC_ATTR10;this.attributes.morph_nrm3=SEMANTIC_ATTR11;code+="#define MORPHING_NRM03\n";code+="attribute vec3 morph_nrm0;\n";code+="attribute vec3 morph_nrm1;\n";code+="attribute vec3 morph_nrm2;\n";code+="attribute vec3 morph_nrm3;\n";}if(!options.useMorphNormal){this.attributes.morph_pos4=SEMANTIC_ATTR12;this.attributes.morph_pos5=SEMANTIC_ATTR13;this.attributes.morph_pos6=SEMANTIC_ATTR14;this.attributes.morph_pos7=SEMANTIC_ATTR15;code+="#define MORPHING_POS47\n";code+="attribute vec3 morph_pos4;\n";code+="attribute vec3 morph_pos5;\n";code+="attribute vec3 morph_pos6;\n";code+="attribute vec3 morph_pos7;\n";}else {this.attributes.morph_nrm4=SEMANTIC_ATTR12;this.attributes.morph_nrm5=SEMANTIC_ATTR13;this.attributes.morph_nrm6=SEMANTIC_ATTR14;this.attributes.morph_nrm7=SEMANTIC_ATTR15;code+="#define MORPHING_NRM47\n";code+="attribute vec3 morph_nrm4;\n";code+="attribute vec3 morph_nrm5;\n";code+="attribute vec3 morph_nrm6;\n";code+="attribute vec3 morph_nrm7;\n";}}}if(options.skin){this.attributes.vertex_boneWeights=SEMANTIC_BLENDWEIGHT;this.attributes.vertex_boneIndices=SEMANTIC_BLENDINDICES;code+=ShaderGenerator.skinCode(device,chunks);code+="#define SKIN\n";}else if(options.useInstancing){code+="#define INSTANCING\n";}if(options.screenSpace){code+="#define SCREENSPACE\n";}if(options.pixelSnap){code+="#define PIXELSNAP\n";}code=this._vsAddTransformCode(code,device,chunks,options);if(this.needsNormal){code+=chunks.normalVS;}code+="\n";code+=chunks.startVS;code+=codeBody;code+=chunks.endVS;code+="}";Object.keys(builtinVaryings).forEach(v=>{if(code.indexOf(v)>=0){this.varyings+=`varying ${builtinVaryings[v]} ${v};
`;this.varyingDefines+=`#define VARYING_${v.toUpperCase()}
`;}});const shaderPassDefines=this.shaderPassInfo.shaderDefines;this.vshader=shaderPassDefines+this.varyings+code;}_fsGetBeginCode(){let code=this.shaderPassInfo.shaderDefines;for(let i=0;i<this.defines.length;i++){code+=`#define ${this.defines[i]}
`;}return code}_fsGetPickPassCode(){let code=this._fsGetBeginCode();code+="uniform vec4 uColor;\n";code+=this.varyings;code+=this.varyingDefines;code+=this.frontendDecl;code+=this.frontendCode;code+=ShaderGenerator.begin();code+=this.frontendFunc;code+="    gl_FragColor = uColor;\n";code+=ShaderGenerator.end();return code}_fsGetDepthPassCode(){const chunks=this.chunks;let code=this._fsGetBeginCode();code+="varying float vDepth;\n";code+=this.varyings;code+=this.varyingDefines;code+=chunks.packDepthPS;code+=this.frontendDecl;code+=this.frontendCode;code+=ShaderGenerator.begin();code+=this.frontendFunc;code+="    gl_FragColor = packFloat(vDepth);\n";code+=ShaderGenerator.end();return code}_fsGetPrePassVelocityCode(){return this._fsGetDepthPassCode()}_fsGetShadowPassCode(){const device=this.device;const options=this.options;const chunks=this.chunks;const varyings=this.varyings;const lightType=this.shaderPassInfo.lightType;let shadowType=this.shaderPassInfo.shadowType;if(lightType!==LIGHTTYPE_DIRECTIONAL&&options.clusteredLightingEnabled){if(shadowType===SHADOW_VSM8||shadowType===SHADOW_VSM16||shadowType===SHADOW_VSM32||shadowType===SHADOW_PCSS){shadowType=SHADOW_PCF3;}}let code=this._fsGetBeginCode();if(device.extStandardDerivatives&&device.isWebGL1){code+="uniform vec2 polygonOffset;\n";}if(shadowType===SHADOW_VSM32){if(device.textureFloatHighPrecision){code+="#define VSM_EXPONENT 15.0\n\n";}else {code+="#define VSM_EXPONENT 5.54\n\n";}}else if(shadowType===SHADOW_VSM16){code+="#define VSM_EXPONENT 5.54\n\n";}if(lightType!==LIGHTTYPE_DIRECTIONAL){code+="uniform vec3 view_position;\n";code+="uniform float light_radius;\n";}code+=varyings;code+=this.varyingDefines;code+=this.frontendDecl;code+=this.frontendCode;const mayPackDepth=shadowType===SHADOW_PCF1||shadowType===SHADOW_PCF3||shadowType===SHADOW_PCF5||shadowType===SHADOW_PCSS;const mustPackDepth=lightType===LIGHTTYPE_OMNI&&shadowType!==SHADOW_PCSS&&!options.clusteredLightingEnabled;const usePackedDepth=mayPackDepth&&!device.supportsDepthShadow||mustPackDepth;if(usePackedDepth){code+=chunks.packDepthPS;}else if(shadowType===SHADOW_VSM8){code+="vec2 encodeFloatRG( float v ) {\n";code+="    vec2 enc = vec2(1.0, 255.0) * v;\n";code+="    enc = fract(enc);\n";code+="    enc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);\n";code+="    return enc;\n";code+="}\n\n";}if(shadowType===SHADOW_PCSS){code+=shaderChunks.linearizeDepthPS;}code+=ShaderGenerator.begin();code+=this.frontendFunc;const isVsm=shadowType===SHADOW_VSM8||shadowType===SHADOW_VSM16||shadowType===SHADOW_VSM32;const applySlopeScaleBias=device.isWebGL1&&device.extStandardDerivatives;const usePerspectiveDepth=lightType===LIGHTTYPE_DIRECTIONAL||!isVsm&&lightType===LIGHTTYPE_SPOT;let hasModifiedDepth=false;if(usePerspectiveDepth){code+="    float depth = gl_FragCoord.z;\n";}else {code+="    float depth = min(distance(view_position, vPositionW) / light_radius, 0.99999);\n";hasModifiedDepth=true;}if(applySlopeScaleBias){code+="    float minValue = 2.3374370500153186e-10; //(1.0 / 255.0) / (256.0 * 256.0 * 256.0);\n";code+="    depth += polygonOffset.x * max(abs(dFdx(depth)), abs(dFdy(depth))) + minValue * polygonOffset.y;\n";hasModifiedDepth=true;}if(usePackedDepth){code+="    gl_FragColor = packFloat(depth);\n";}else if(!isVsm){const exportR32=shadowType===SHADOW_PCSS;if(exportR32){code+="    gl_FragColor.r = depth;\n";}else {if(hasModifiedDepth){code+="    gl_FragDepth = depth;\n";}code+="    gl_FragColor = vec4(1.0);\n";}}else if(shadowType===SHADOW_VSM8){code+="    gl_FragColor = vec4(encodeFloatRG(depth), encodeFloatRG(depth*depth));\n";}else {code+=chunks.storeEVSMPS;}code+=ShaderGenerator.end();return code}_fsGetLitPassCode(){const device=this.device;const options=this.options;const chunks=this.chunks;const decl=new ChunkBuilder;const func=new ChunkBuilder;const backend=new ChunkBuilder;const code=new ChunkBuilder;if(options.opacityFadesSpecular===false){decl.append("uniform float material_alphaFade;");}if(options.useSpecular){this.defines.push("LIT_SPECULAR");if(this.reflections){this.defines.push("LIT_REFLECTIONS");}if(options.useClearCoat){this.defines.push("LIT_CLEARCOAT");}if(options.fresnelModel>0){this.defines.push("LIT_SPECULAR_FRESNEL");}if(options.conserveEnergy){this.defines.push("LIT_CONSERVE_ENERGY");}if(options.useSheen){this.defines.push("LIT_SHEEN");}if(options.useIridescence){this.defines.push("LIT_IRIDESCENCE");}}const shadowTypeUsed=[];let numShadowLights=0;let shadowedDirectionalLightUsed=false;let useVsm=false;let usePcss=false;let hasAreaLights=options.lights.some(light=>{return light._shape&&light._shape!==LIGHTSHAPE_PUNCTUAL});if(options.clusteredLightingEnabled&&options.clusteredLightingAreaLightsEnabled){hasAreaLights=true;}if(hasAreaLights||options.clusteredLightingEnabled){let areaLutsPrecision="highp";if(device.areaLightLutFormat===PIXELFORMAT_RGBA8){decl.append("#define AREA_R8_G8_B8_A8_LUTS");areaLutsPrecision="lowp";}decl.append("#define AREA_LIGHTS");decl.append(`uniform ${areaLutsPrecision} sampler2D areaLightsLutTex1;`);decl.append(`uniform ${areaLutsPrecision} sampler2D areaLightsLutTex2;`);}for(let i=0;i<options.lights.length;i++){const light=options.lights[i];const lightType=light._type;if(options.clusteredLightingEnabled&&lightType!==LIGHTTYPE_DIRECTIONAL){continue}const lightShape=hasAreaLights&&light._shape?light._shape:LIGHTSHAPE_PUNCTUAL;decl.append(`uniform vec3 light${i}_color;`);if(light._shadowType===SHADOW_PCSS&&light.castShadows&&!options.noShadow){decl.append(`uniform float light${i}_shadowSearchArea;`);decl.append(`uniform vec4 light${i}_cameraParams;`);}if(lightType===LIGHTTYPE_DIRECTIONAL){decl.append(`uniform vec3 light${i}_direction;`);}else {decl.append(`uniform vec3 light${i}_position;`);decl.append(`uniform float light${i}_radius;`);if(lightType===LIGHTTYPE_SPOT){decl.append(`uniform vec3 light${i}_direction;`);decl.append(`uniform float light${i}_innerConeAngle;`);decl.append(`uniform float light${i}_outerConeAngle;`);}}if(lightShape!==LIGHTSHAPE_PUNCTUAL){if(lightType===LIGHTTYPE_DIRECTIONAL){decl.append(`uniform vec3 light${i}_position;`);}decl.append(`uniform vec3 light${i}_halfWidth;`);decl.append(`uniform vec3 light${i}_halfHeight;`);}if(light.castShadows&&!options.noShadow){decl.append(`uniform mat4 light${i}_shadowMatrix;`);decl.append(`uniform float light${i}_shadowIntensity;`);if(lightType===LIGHTTYPE_DIRECTIONAL){decl.append(`uniform mat4 light${i}_shadowMatrixPalette[4];`);decl.append(`uniform float light${i}_shadowCascadeDistances[4];`);decl.append(`uniform float light${i}_shadowCascadeCount;`);}decl.append(`uniform vec4 light${i}_shadowParams;`);if(lightType===LIGHTTYPE_DIRECTIONAL){shadowedDirectionalLightUsed=true;}if(lightType===LIGHTTYPE_OMNI){decl.append(`uniform samplerCube light${i}_shadowMap;`);}else {if(light._isPcf&&device.supportsDepthShadow){decl.append(`uniform sampler2DShadow light${i}_shadowMap;`);}else {decl.append(`uniform sampler2D light${i}_shadowMap;`);}}numShadowLights++;shadowTypeUsed[light._shadowType]=true;if(light._isVsm)useVsm=true;if(light._shadowType===SHADOW_PCSS)usePcss=true;}if(light._cookie){if(light._cookie._cubemap){if(lightType===LIGHTTYPE_OMNI){decl.append(`uniform samplerCube light${i}_cookie;`);decl.append(`uniform float light${i}_cookieIntensity;`);if(!light.castShadows||options.noShadow){decl.append(`uniform mat4 light${i}_shadowMatrix;`);}}}else {if(lightType===LIGHTTYPE_SPOT){decl.append(`uniform sampler2D light${i}_cookie;`);decl.append(`uniform float light${i}_cookieIntensity;`);if(!light.castShadows||options.noShadow){decl.append(`uniform mat4 light${i}_shadowMatrix;`);}if(light._cookieTransform){decl.append(`uniform vec4 light${i}_cookieMatrix;`);decl.append(`uniform vec2 light${i}_cookieOffset;`);}}}}}const hasTBN=this.needsNormal&&(options.useNormals||options.useClearCoatNormals||options.enableGGXSpecular&&!options.useHeights);if(hasTBN){if(options.hasTangents){func.append(options.fastTbn?chunks.TBNfastPS:chunks.TBNPS);}else {if(device.extStandardDerivatives&&(options.useNormals||options.useClearCoatNormals)){func.append(chunks.TBNderivativePS.replace(/\$UV/g,this.lightingUv));}else {func.append(chunks.TBNObjectSpacePS);}}if(options.twoSidedLighting){func.append(chunks.twoSidedLightingPS);}}func.append(chunks.sphericalPS);func.append(chunks.decodePS);func.append(ShaderGenerator.gammaCode(options.gamma,chunks));func.append(ShaderGenerator.tonemapCode(options.toneMap,chunks));func.append(ShaderGenerator.fogCode(options.fog,chunks));func.append(this.frontendCode);if(options.useCubeMapRotation){decl.append("#define CUBEMAP_ROTATION");}if(this.needsNormal){func.append(chunks.cubeMapRotatePS);func.append(options.cubeMapProjection>0?chunks.cubeMapProjectBoxPS:chunks.cubeMapProjectNonePS);func.append(options.skyboxIntensity?chunks.envMultiplyPS:chunks.envConstPS);}if(this.lighting&&options.useSpecular||this.reflections){if(options.useMetalness){func.append(chunks.metalnessModulatePS);}if(options.fresnelModel===FRESNEL_SCHLICK){func.append(chunks.fresnelSchlickPS);}if(options.useIridescence){func.append(chunks.iridescenceDiffractionPS);}}if(options.useAo){func.append(chunks.aoDiffuseOccPS);switch(options.occludeSpecular){case SPECOCC_AO:func.append(options.occludeSpecularFloat?chunks.aoSpecOccSimplePS:chunks.aoSpecOccConstSimplePS);break;case SPECOCC_GLOSSDEPENDENT:func.append(options.occludeSpecularFloat?chunks.aoSpecOccPS:chunks.aoSpecOccConstPS);break}}if(options.reflectionSource==="envAtlasHQ"){func.append(options.fixSeams?chunks.fixCubemapSeamsStretchPS:chunks.fixCubemapSeamsNonePS);func.append(chunks.envAtlasPS);func.append(chunks.reflectionEnvHQPS.replace(/\$DECODE_CUBEMAP/g,ChunkUtils.decodeFunc(options.reflectionCubemapEncoding)).replace(/\$DECODE/g,ChunkUtils.decodeFunc(options.reflectionEncoding)));}else if(options.reflectionSource==="envAtlas"){func.append(chunks.envAtlasPS);func.append(chunks.reflectionEnvPS.replace(/\$DECODE/g,ChunkUtils.decodeFunc(options.reflectionEncoding)));}else if(options.reflectionSource==="cubeMap"){func.append(options.fixSeams?chunks.fixCubemapSeamsStretchPS:chunks.fixCubemapSeamsNonePS);func.append(chunks.reflectionCubePS.replace(/\$DECODE/g,ChunkUtils.decodeFunc(options.reflectionEncoding)));}else if(options.reflectionSource==="sphereMap"){func.append(chunks.reflectionSpherePS.replace(/\$DECODE/g,ChunkUtils.decodeFunc(options.reflectionEncoding)));}if(this.reflections){if(options.useClearCoat){func.append(chunks.reflectionCCPS);}if(options.useSheen){func.append(chunks.reflectionSheenPS);}}if(options.useRefraction){if(options.useDynamicRefraction){if(options.dispersion){decl.append("uniform float material_dispersion;");decl.append("#define DISPERSION\n");}func.append(chunks.refractionDynamicPS);}else if(this.reflections){func.append(chunks.refractionCubePS);}}if(options.useSheen){func.append(chunks.lightSheenPS);}if(options.clusteredLightingEnabled){func.append(chunks.clusteredLightUtilsPS);if(options.clusteredLightingCookiesEnabled){func.append(chunks.clusteredLightCookiesPS);}if(options.clusteredLightingShadowsEnabled&&!options.noShadow){shadowTypeUsed[SHADOW_PCF3]=true;shadowTypeUsed[SHADOW_PCF5]=true;shadowTypeUsed[SHADOW_PCSS]=true;}}if(numShadowLights>0||options.clusteredLightingEnabled){if(shadowedDirectionalLightUsed){func.append(chunks.shadowCascadesPS);}if(shadowTypeUsed[SHADOW_PCF1]||shadowTypeUsed[SHADOW_PCF3]){func.append(chunks.shadowStandardPS);}if(shadowTypeUsed[SHADOW_PCF5]&&!device.isWebGL1){func.append(chunks.shadowStandardGL2PS);}if(useVsm){func.append(chunks.shadowVSM_commonPS);if(shadowTypeUsed[SHADOW_VSM8]){func.append(chunks.shadowVSM8PS);}if(shadowTypeUsed[SHADOW_VSM16]){func.append(device.extTextureHalfFloatLinear?chunks.shadowEVSMPS.replace(/\$/g,"16"):chunks.shadowEVSMnPS.replace(/\$/g,"16"));}if(shadowTypeUsed[SHADOW_VSM32]){func.append(device.extTextureFloatLinear?chunks.shadowEVSMPS.replace(/\$/g,"32"):chunks.shadowEVSMnPS.replace(/\$/g,"32"));}}if(usePcss){func.append(chunks.linearizeDepthPS);func.append(chunks.shadowPCSSPS);}if(!(device.isWebGL2||device.isWebGPU||device.extStandardDerivatives)){func.append(chunks.biasConstPS);}}if(options.enableGGXSpecular)func.append("uniform float material_anisotropy;");if(this.lighting){func.append(chunks.lightDiffuseLambertPS);if(hasAreaLights||options.clusteredLightingAreaLightsEnabled){func.append(chunks.ltcPS);}}let useOldAmbient=false;if(options.useSpecular){if(this.lighting){func.append(options.shadingModel===SPECULAR_PHONG?chunks.lightSpecularPhongPS:options.enableGGXSpecular?chunks.lightSpecularAnisoGGXPS:chunks.lightSpecularBlinnPS);}if(!options.fresnelModel&&!this.reflections&&!options.diffuseMapEnabled){decl.append("uniform vec3 material_ambient;");decl.append("#define LIT_OLD_AMBIENT");useOldAmbient=true;}}func.append(chunks.combinePS);if(options.lightMapEnabled){func.append(options.useSpecular&&options.dirLightMapEnabled?chunks.lightmapDirAddPS:chunks.lightmapAddPS);}const addAmbient=!options.lightMapEnabled||options.lightMapWithoutAmbient;if(addAmbient){if(options.ambientSource==="ambientSH"){func.append(chunks.ambientSHPS);}else if(options.ambientSource==="envAtlas"){if(options.reflectionSource!=="envAtlas"&&options.reflectionSource!=="envAtlasHQ"){func.append(chunks.envAtlasPS);}func.append(chunks.ambientEnvPS.replace(/\$DECODE/g,ChunkUtils.decodeFunc(options.ambientEncoding)));}else {func.append(chunks.ambientConstantPS);}}if(options.useAmbientTint&&!useOldAmbient){decl.append("uniform vec3 material_ambient;");}if(options.useMsdf){if(!options.msdfTextAttribute){decl.append("#define UNIFORM_TEXT_PARAMETERS");}func.append(chunks.msdfPS);}if(this.needsNormal){func.append(chunks.viewDirPS);if(options.useSpecular){func.append(options.enableGGXSpecular?chunks.reflDirAnisoPS:chunks.reflDirPS);}}let hasPointLights=false;let usesLinearFalloff=false;let usesInvSquaredFalloff=false;let usesSpot=false;let usesCookie=false;let usesCookieNow;if(options.clusteredLightingEnabled&&this.lighting){usesSpot=true;hasPointLights=true;usesLinearFalloff=true;usesCookie=true;func.append(chunks.floatUnpackingPS);if(options.lightMaskDynamic){decl.append("#define CLUSTER_MESH_DYNAMIC_LIGHTS");}if(options.clusteredLightingCookiesEnabled){decl.append("#define CLUSTER_COOKIES");}if(options.clusteredLightingShadowsEnabled&&!options.noShadow){decl.append("#define CLUSTER_SHADOWS");decl.append(`#define CLUSTER_SHADOW_TYPE_${shadowTypeToString[options.clusteredLightingShadowType]}`);}if(options.clusteredLightingAreaLightsEnabled){decl.append("#define CLUSTER_AREALIGHTS");}decl.append(LightsBuffer.getShaderDefines(device));if(options.clusteredLightingShadowsEnabled&&!options.noShadow){func.append(chunks.clusteredLightShadowsPS);}func.append(chunks.clusteredLightPS);}code.append(this._fsGetStartCode(code,device,chunks,options));if(this.needsNormal){code.append("    dVertexNormalW = normalize(vNormalW);");if((options.useHeights||options.useNormals)&&options.hasTangents){code.append("    dTangentW = vTangentW;");code.append("    dBinormalW = vBinormalW;");}code.append("    getViewDir();");if(hasTBN){code.append("    getTBN(dTangentW, dBinormalW, dVertexNormalW);");if(options.twoSidedLighting){code.append("    handleTwoSidedLighting();");}}}code.append(this.frontendFunc);if(this.needsNormal){if(options.useSpecular){backend.append("    getReflDir(litArgs_worldNormal, dViewDirW, litArgs_gloss, dTBN);");}if(options.useClearCoat){backend.append("    ccReflDirW = normalize(-reflect(dViewDirW, litArgs_clearcoat_worldNormal));");}}if(this.lighting&&options.useSpecular||this.reflections){if(options.useMetalness){backend.append("    float f0 = 1.0 / litArgs_ior; f0 = (f0 - 1.0) / (f0 + 1.0); f0 *= f0;");backend.append("    litArgs_specularity = getSpecularModulate(litArgs_specularity, litArgs_albedo, litArgs_metalness, f0);");backend.append("    litArgs_albedo = getAlbedoModulate(litArgs_albedo, litArgs_metalness);");}if(options.useIridescence){backend.append("    vec3 iridescenceFresnel = getIridescence(saturate(dot(dViewDirW, litArgs_worldNormal)), litArgs_specularity, litArgs_iridescence_thickness);");}}if(addAmbient){backend.append("    addAmbient(litArgs_worldNormal);");if(options.conserveEnergy&&options.useSpecular){backend.append("   dDiffuseLight = dDiffuseLight * (1.0 - litArgs_specularity);");}if(options.separateAmbient){backend.append(`
										vec3 dAmbientLight = dDiffuseLight;
										dDiffuseLight = vec3(0);
								`);}}if(options.useAmbientTint&&!useOldAmbient){backend.append("    dDiffuseLight *= material_ambient;");}if(options.useAo&&!options.occludeDirect){backend.append("    occludeDiffuse(litArgs_ao);");}if(options.lightMapEnabled){backend.append(`    addLightMap(
								litArgs_lightmap, 
								litArgs_lightmapDir, 
								litArgs_worldNormal, 
								dViewDirW, 
								dReflDirW, 
								litArgs_gloss, 
								litArgs_specularity, 
								dVertexNormalW,
								dTBN
						#if defined(LIT_IRIDESCENCE)
								, iridescenceFresnel,
								litArgs_iridescence_intensity
						#endif
								);`);}if(this.lighting||this.reflections){if(this.reflections){if(options.useClearCoat){backend.append("    addReflectionCC(ccReflDirW, litArgs_clearcoat_gloss);");if(options.fresnelModel>0){backend.append("    ccFresnel = getFresnelCC(dot(dViewDirW, litArgs_clearcoat_worldNormal));");backend.append("    ccReflection.rgb *= ccFresnel;");}else {backend.append("    ccFresnel = 0.0;");}}if(options.useSpecularityFactor){backend.append("    ccReflection.rgb *= litArgs_specularityFactor;");}if(options.useSheen){backend.append("    addReflectionSheen(litArgs_worldNormal, dViewDirW, litArgs_sheen_gloss);");}backend.append("    addReflection(dReflDirW, litArgs_gloss);");if(options.fresnelModel>0){backend.append(`    dReflection.rgb *= 
												getFresnel(
														dot(dViewDirW, litArgs_worldNormal), 
														litArgs_gloss, 
														litArgs_specularity
												#if defined(LIT_IRIDESCENCE)
														, iridescenceFresnel,
														litArgs_iridescence_intensity
												#endif
														);`);}else {backend.append("    dReflection.rgb *= litArgs_specularity;");}if(options.useSpecularityFactor){backend.append("    dReflection.rgb *= litArgs_specularityFactor;");}}if(hasAreaLights){backend.append("    dSpecularLight *= litArgs_specularity;");if(options.useSpecular){backend.append("    calcLTCLightValues(litArgs_gloss, litArgs_worldNormal, dViewDirW, litArgs_specularity, litArgs_clearcoat_gloss, litArgs_clearcoat_worldNormal, litArgs_clearcoat_specularity);");}}for(let i=0;i<options.lights.length;i++){const light=options.lights[i];const lightType=light._type;if(options.clusteredLightingEnabled&&lightType!==LIGHTTYPE_DIRECTIONAL){continue}usesCookieNow=false;const lightShape=hasAreaLights&&light._shape?light.shape:LIGHTSHAPE_PUNCTUAL;const shapeString=hasAreaLights&&light._shape?this._getLightSourceShapeString(lightShape):"";if(lightShape!==LIGHTSHAPE_PUNCTUAL){backend.append(`    calc${shapeString}LightValues(light${i}_position, light${i}_halfWidth, light${i}_halfHeight);`);}if(lightType===LIGHTTYPE_DIRECTIONAL){backend.append(`    dLightDirNormW = light${i}_direction;`);backend.append("    dAtten = 1.0;");}else {if(light._cookie){if(lightType===LIGHTTYPE_SPOT&&!light._cookie._cubemap){usesCookie=true;usesCookieNow=true;}else if(lightType===LIGHTTYPE_OMNI&&light._cookie._cubemap){usesCookie=true;usesCookieNow=true;}}backend.append(`    getLightDirPoint(light${i}_position);`);hasPointLights=true;if(usesCookieNow){if(lightType===LIGHTTYPE_SPOT){backend.append(`    dAtten3 = getCookie2D${light._cookieFalloff?"":"Clip"}${light._cookieTransform?"Xform":""}(light${i}_cookie, light${i}_shadowMatrix, light${i}_cookieIntensity${light._cookieTransform?`, light${i}_cookieMatrix, light${i}_cookieOffset`:""}).${light._cookieChannel};`);}else {backend.append(`    dAtten3 = getCookieCube(light${i}_cookie, light${i}_shadowMatrix, light${i}_cookieIntensity).${light._cookieChannel};`);}}if(lightShape===LIGHTSHAPE_PUNCTUAL){if(light._falloffMode===LIGHTFALLOFF_LINEAR){backend.append(`    dAtten = getFalloffLinear(light${i}_radius, dLightDirW);`);usesLinearFalloff=true;}else {backend.append(`    dAtten = getFalloffInvSquared(light${i}_radius, dLightDirW);`);usesInvSquaredFalloff=true;}}else {backend.append(`    dAtten = getFalloffWindow(light${i}_radius, dLightDirW);`);usesInvSquaredFalloff=true;}backend.append("    if (dAtten > 0.00001) {");if(lightType===LIGHTTYPE_SPOT){if(!(usesCookieNow&&!light._cookieFalloff)){backend.append(`    dAtten *= getSpotEffect(light${i}_direction, light${i}_innerConeAngle, light${i}_outerConeAngle, dLightDirNormW);`);usesSpot=true;}}}if(lightShape!==LIGHTSHAPE_PUNCTUAL){if(lightType===LIGHTTYPE_DIRECTIONAL){backend.append("    dAttenD = getLightDiffuse(litArgs_worldNormal, dViewDirW, dLightDirW, dLightDirNormW);");}else {backend.append(`    dAttenD = get${shapeString}LightDiffuse(litArgs_worldNormal, dViewDirW, dLightDirW, dLightDirNormW) * 16.0;`);}}else {backend.append("    dAtten *= getLightDiffuse(litArgs_worldNormal, dViewDirW, dLightDirW, dLightDirNormW);");}if(light.castShadows&&!options.noShadow){const pcssShadows=light._shadowType===SHADOW_PCSS;const vsmShadows=light._shadowType===SHADOW_VSM8||light._shadowType===SHADOW_VSM16||light._shadowType===SHADOW_VSM32;const pcfShadows=light._shadowType===SHADOW_PCF1||light._shadowType===SHADOW_PCF3||light._shadowType===SHADOW_PCF5;let shadowReadMode=null;let evsmExp;switch(light._shadowType){case SHADOW_VSM8:shadowReadMode="VSM8";evsmExp="0.0";break;case SHADOW_VSM16:shadowReadMode="VSM16";evsmExp="5.54";break;case SHADOW_VSM32:shadowReadMode="VSM32";if(device.textureFloatHighPrecision){evsmExp="15.0";}else {evsmExp="5.54";}break;case SHADOW_PCF1:shadowReadMode="PCF1x1";break;case SHADOW_PCF5:shadowReadMode="PCF5x5";break;case SHADOW_PCSS:shadowReadMode="PCSS";break;case SHADOW_PCF3:default:shadowReadMode="PCF3x3";break}if(shadowReadMode!==null){if(light._normalOffsetBias&&!light._isVsm){func.append("#define SHADOW_SAMPLE_NORMAL_OFFSET");}if(lightType===LIGHTTYPE_DIRECTIONAL){func.append("#define SHADOW_SAMPLE_ORTHO");}if((pcfShadows||pcssShadows)&&device.isWebGL2||device.isWebGPU||device.extStandardDerivatives){func.append("#define SHADOW_SAMPLE_SOURCE_ZBUFFER");}if(lightType===LIGHTTYPE_OMNI){func.append("#define SHADOW_SAMPLE_POINT");}const coordCode=chunks.shadowSampleCoordPS;func.append(coordCode.replace("$LIGHT",i));func.append("#undef SHADOW_SAMPLE_NORMAL_OFFSET");func.append("#undef SHADOW_SAMPLE_ORTHO");func.append("#undef SHADOW_SAMPLE_SOURCE_ZBUFFER");func.append("#undef SHADOW_SAMPLE_POINT");let shadowMatrix=`light${i}_shadowMatrix`;if(lightType===LIGHTTYPE_DIRECTIONAL&&light.numCascades>1){backend.append(`    getShadowCascadeMatrix(light${i}_shadowMatrixPalette, light${i}_shadowCascadeDistances, light${i}_shadowCascadeCount);`);shadowMatrix="cascadeShadowMat";}backend.append(`    dShadowCoord = getShadowSampleCoord${i}(${shadowMatrix}, light${i}_shadowParams, vPositionW, dLightPosW, dLightDirW, dLightDirNormW, dVertexNormalW);`);if(lightType===LIGHTTYPE_DIRECTIONAL){backend.append(`    fadeShadow(light${i}_shadowCascadeDistances);`);}let shadowCoordArgs=`SHADOWMAP_PASS(light${i}_shadowMap), dShadowCoord, light${i}_shadowParams`;if(vsmShadows){shadowCoordArgs=`${shadowCoordArgs}, ${evsmExp}, dLightDirW`;}else if(pcssShadows){let penumbraSizeArg=`vec2(light${i}_shadowSearchArea)`;if(lightShape!==LIGHTSHAPE_PUNCTUAL){penumbraSizeArg=`vec2(length(light${i}_halfWidth), length(light${i}_halfHeight)) * light${i}_shadowSearchArea`;}shadowCoordArgs=`${shadowCoordArgs}, light${i}_cameraParams, ${penumbraSizeArg}, dLightDirW`;}if(lightType===LIGHTTYPE_OMNI){shadowReadMode=`Point${shadowReadMode}`;if(!pcssShadows){shadowCoordArgs=`${shadowCoordArgs}, dLightDirW`;}}else if(lightType===LIGHTTYPE_SPOT){shadowReadMode=`Spot${shadowReadMode}`;}backend.append(`    float shadow${i} = getShadow${shadowReadMode}(${shadowCoordArgs});`);backend.append(`    dAtten *= mix(1.0, shadow${i}, light${i}_shadowIntensity);`);}}if(lightShape!==LIGHTSHAPE_PUNCTUAL){if(options.conserveEnergy&&options.useSpecular){backend.append(`    dDiffuseLight += ((dAttenD * dAtten) * light${i}_color${usesCookieNow?" * dAtten3":""}) * (1.0 - dLTCSpecFres);`);}else {backend.append(`    dDiffuseLight += (dAttenD * dAtten) * light${i}_color${usesCookieNow?" * dAtten3":""};`);}}else {if(hasAreaLights&&options.conserveEnergy&&options.useSpecular){backend.append(`    dDiffuseLight += (dAtten * light${i}_color${usesCookieNow?" * dAtten3":""}) * (1.0 - litArgs_specularity);`);}else {backend.append(`    dDiffuseLight += dAtten * light${i}_color${usesCookieNow?" * dAtten3":""};`);}}if(options.useSpecular){backend.append("    dHalfDirW = normalize(-dLightDirNormW + dViewDirW);");}if(light.affectSpecularity){if(lightShape!==LIGHTSHAPE_PUNCTUAL){if(options.useClearCoat){backend.append(`    ccSpecularLight += ccLTCSpecFres * get${shapeString}LightSpecular(litArgs_clearcoat_worldNormal, dViewDirW) * dAtten * light${i}_color${usesCookieNow?" * dAtten3":""};`);}if(options.useSpecular){backend.append(`    dSpecularLight += dLTCSpecFres * get${shapeString}LightSpecular(litArgs_worldNormal, dViewDirW) * dAtten * light${i}_color${usesCookieNow?" * dAtten3":""};`);}}else {let calcFresnel=false;if(lightType===LIGHTTYPE_DIRECTIONAL&&options.fresnelModel>0){calcFresnel=true;}if(options.useClearCoat){backend.append(`    ccSpecularLight += getLightSpecular(dHalfDirW, ccReflDirW, litArgs_clearcoat_worldNormal, dViewDirW, dLightDirNormW, litArgs_clearcoat_gloss, dTBN) * dAtten * light${i}_color${usesCookieNow?" * dAtten3":""}${calcFresnel?" * getFresnelCC(dot(dViewDirW, dHalfDirW));":";"}`);}if(options.useSheen){backend.append(`    sSpecularLight += getLightSpecularSheen(dHalfDirW, litArgs_worldNormal, dViewDirW, dLightDirNormW, litArgs_sheen_gloss) * dAtten * light${i}_color${usesCookieNow?" * dAtten3;":";"}`);}if(options.useSpecular){backend.append(`    dSpecularLight += getLightSpecular(dHalfDirW, dReflDirW, litArgs_worldNormal, dViewDirW, dLightDirNormW, litArgs_gloss, dTBN) * dAtten * light${i}_color${usesCookieNow?" * dAtten3":""}${calcFresnel?` 
																		* getFresnel(
																				dot(dViewDirW, dHalfDirW), 
																				litArgs_gloss, 
																				litArgs_specularity
																		#if defined(LIT_IRIDESCENCE)
																				, iridescenceFresnel, 
																				litArgs_iridescence_intensity
																		#endif
																		);`:"* litArgs_specularity;"}`);}}}if(lightType!==LIGHTTYPE_DIRECTIONAL){backend.append("    }");}}if(options.clusteredLightingEnabled&&this.lighting){usesLinearFalloff=true;usesInvSquaredFalloff=true;hasPointLights=true;backend.append(`    addClusteredLights(
																				litArgs_worldNormal, 
																				dViewDirW, 
																				dReflDirW,
																#if defined(LIT_CLEARCOAT)
																				ccReflDirW,
																#endif
																				litArgs_gloss, 
																				litArgs_specularity, 
																				dVertexNormalW, 
																				dTBN, 
																#if defined(LIT_IRIDESCENCE)
																				iridescenceFresnel,
																#endif
																				litArgs_clearcoat_worldNormal, 
																				litArgs_clearcoat_gloss,
																				litArgs_sheen_gloss,
																				litArgs_iridescence_intensity
																		);`);}if(hasAreaLights){if(options.useClearCoat){backend.append("    litArgs_clearcoat_specularity = 1.0;");}if(options.useSpecular){backend.append("    litArgs_specularity = vec3(1);");}}if(options.useRefraction){backend.append(`    addRefraction(
												litArgs_worldNormal, 
												dViewDirW, 
												litArgs_thickness, 
												litArgs_gloss, 
												litArgs_specularity, 
												litArgs_albedo, 
												litArgs_transmission,
												litArgs_ior,
												litArgs_dispersion
										#if defined(LIT_IRIDESCENCE)
												, iridescenceFresnel, 
												litArgs_iridescence_intensity
										#endif
										);`);}}if(options.useAo){if(options.occludeDirect){backend.append("    occludeDiffuse(litArgs_ao);");}if(options.occludeSpecular===SPECOCC_AO||options.occludeSpecular===SPECOCC_GLOSSDEPENDENT){backend.append("    occludeSpecular(litArgs_gloss, litArgs_ao, litArgs_worldNormal, dViewDirW);");}}if(options.useSpecularityFactor){backend.append("    dSpecularLight *= litArgs_specularityFactor;");}if(options.opacityFadesSpecular===false){if(options.blendType===BLEND_NORMAL||options.blendType===BLEND_PREMULTIPLIED){backend.append("float specLum = dot((dSpecularLight + dReflection.rgb * dReflection.a), vec3( 0.2126, 0.7152, 0.0722 ));");backend.append("#ifdef LIT_CLEARCOAT\n specLum += dot(ccSpecularLight * litArgs_clearcoat_specularity + ccReflection.rgb * litArgs_clearcoat_specularity, vec3( 0.2126, 0.7152, 0.0722 ));\n#endif");backend.append("litArgs_opacity = clamp(litArgs_opacity + gammaCorrectInput(specLum), 0.0, 1.0);");}backend.append("litArgs_opacity *= material_alphaFade;");}backend.append(chunks.endPS);if(options.blendType===BLEND_NORMAL||options.blendType===BLEND_ADDITIVEALPHA||options.alphaToCoverage){backend.append(chunks.outputAlphaPS);}else if(options.blendType===BLEND_PREMULTIPLIED){backend.append(chunks.outputAlphaPremulPS);}else {backend.append(chunks.outputAlphaOpaquePS);}if(options.useMsdf){backend.append("    gl_FragColor = applyMsdf(gl_FragColor);");}backend.append(chunks.outputPS);backend.append(chunks.debugOutputPS);if(hasPointLights){func.prepend(chunks.lightDirPointPS);}if(usesLinearFalloff){func.prepend(chunks.falloffLinearPS);}if(usesInvSquaredFalloff){func.prepend(chunks.falloffInvSquaredPS);}if(usesSpot){func.prepend(chunks.spotPS);}if(usesCookie&&!options.clusteredLightingEnabled){func.prepend(chunks.cookiePS);}let structCode="";const backendCode=`void evaluateBackend() {
${backend.code}
}`;func.append(backendCode);code.append(chunks.debugProcessFrontendPS);code.append("    evaluateBackend();");code.append(ShaderGenerator.end());const mergedCode=decl.code+func.code+code.code;if(mergedCode.includes("dTBN"))structCode+="mat3 dTBN;\n";if(mergedCode.includes("dVertexNormalW"))structCode+="vec3 dVertexNormalW;\n";if(mergedCode.includes("dTangentW"))structCode+="vec3 dTangentW;\n";if(mergedCode.includes("dBinormalW"))structCode+="vec3 dBinormalW;\n";if(mergedCode.includes("dViewDirW"))structCode+="vec3 dViewDirW;\n";if(mergedCode.includes("dReflDirW"))structCode+="vec3 dReflDirW;\n";if(mergedCode.includes("dHalfDirW"))structCode+="vec3 dHalfDirW;\n";if(mergedCode.includes("ccReflDirW"))structCode+="vec3 ccReflDirW;\n";if(mergedCode.includes("dLightDirNormW"))structCode+="vec3 dLightDirNormW;\n";if(mergedCode.includes("dLightDirW"))structCode+="vec3 dLightDirW;\n";if(mergedCode.includes("dLightPosW"))structCode+="vec3 dLightPosW;\n";if(mergedCode.includes("dShadowCoord"))structCode+="vec3 dShadowCoord;\n";if(mergedCode.includes("dReflection"))structCode+="vec4 dReflection;\n";if(mergedCode.includes("dDiffuseLight"))structCode+="vec3 dDiffuseLight;\n";if(mergedCode.includes("dSpecularLight"))structCode+="vec3 dSpecularLight;\n";if(mergedCode.includes("dAtten"))structCode+="float dAtten;\n";if(mergedCode.includes("dAttenD"))structCode+="float dAttenD;\n";if(mergedCode.includes("dAtten3"))structCode+="vec3 dAtten3;\n";if(mergedCode.includes("dMsdf"))structCode+="vec4 dMsdf;\n";if(mergedCode.includes("ccFresnel"))structCode+="float ccFresnel;\n";if(mergedCode.includes("ccReflection"))structCode+="vec3 ccReflection;\n";if(mergedCode.includes("ccSpecularLight"))structCode+="vec3 ccSpecularLight;\n";if(mergedCode.includes("ccSpecularityNoFres"))structCode+="float ccSpecularityNoFres;\n";if(mergedCode.includes("sSpecularLight"))structCode+="vec3 sSpecularLight;\n";if(mergedCode.includes("sReflection"))structCode+="vec3 sReflection;\n";const result=this._fsGetBeginCode()+this.varyings+this.varyingDefines+this._fsGetBaseCode()+structCode+this.frontendDecl+mergedCode;return result}generateFragmentShader(frontendDecl,frontendCode,frontendFunc,lightingUv){var _this$handleCompatibi;const options=this.options;this.frontendDecl=frontendDecl;this.frontendCode=frontendCode;this.frontendFunc=frontendFunc;this.lightingUv=lightingUv;if(options.pass===SHADER_PICK){this.fshader=this._fsGetPickPassCode();}else if(options.pass===SHADER_DEPTH){this.fshader=this._fsGetDepthPassCode();}else if(options.pass===SHADER_PREPASS_VELOCITY){this.fshader=this._fsGetPrePassVelocityCode();}else if(this.shadowPass){this.fshader=this._fsGetShadowPassCode();}else if(options.customFragmentShader){this.fshader=this._fsGetBeginCode()+options.customFragmentShader;}else {this.fshader=this._fsGetLitPassCode();}(_this$handleCompatibi=this.handleCompatibility)==null||_this$handleCompatibi.call(this);}getDefinition(){const definition=ShaderUtils.createDefinition(this.device,{name:"LitShader",attributes:this.attributes,vertexCode:this.vshader,fragmentCode:this.fshader});if(this.shaderPassInfo.isForward){definition.tag=SHADERTAG_MATERIAL;}return definition}constructor(device,options){this.device=device;this.options=options;this.attributes={vertex_position:SEMANTIC_POSITION};if(options.userAttributes){for(const[semantic,name]of Object.entries(options.userAttributes)){this.attributes[name]=semantic;}}if(options.chunks){const userChunks=options.chunks;this.chunks=Object.create(shaderChunks);for(const chunkName in shaderChunks){if(userChunks.hasOwnProperty(chunkName)){const chunk=userChunks[chunkName];for(const a in builtinAttributes){if(builtinAttributes.hasOwnProperty(a)&&chunk.indexOf(a)>=0){this.attributes[a]=builtinAttributes[a];}}this.chunks[chunkName]=chunk;}}}else {this.chunks=shaderChunks;}this.shaderPassInfo=ShaderPass.get(this.device).getByIndex(options.pass);this.shadowPass=this.shaderPassInfo.isShadow;this.lighting=options.lights.length>0||options.dirLightMapEnabled||options.clusteredLightingEnabled;this.reflections=!!options.reflectionSource;this.needsNormal=this.lighting||this.reflections||options.useSpecular||options.ambientSH||options.useHeights||options.enableGGXSpecular||options.clusteredLightingEnabled&&!this.shadowPass||options.useClearCoatNormals;this.needsNormal=this.needsNormal&&!this.shadowPass;this.needsSceneColor=options.useDynamicRefraction;this.needsScreenSize=options.useDynamicRefraction;this.needsTransforms=options.useDynamicRefraction;this.varyings="";this.varyingDefines="";this.vshader=null;this.frontendDecl=null;this.frontendCode=null;this.frontendFunc=null;this.lightingUv=null;this.defines=[];this.fshader=null;}}const LitOptionsUtils={generateKey(options){return `lit${Object.keys(options).sort().map(key=>{if(key==="chunks"){return LitOptionsUtils.generateChunksKey(options)}else if(key==="lights"){return LitOptionsUtils.generateLightsKey(options)}return key+options[key]}).join("\n")}`},generateLightsKey(options){return `lights:${options.lights.map(light=>{return !options.clusteredLightingEnabled||light._type===LIGHTTYPE_DIRECTIONAL?`${light.key},`:""}).join("")}`},generateChunksKey(options){var _options$chunks;return `chunks:
${Object.keys((_options$chunks=options.chunks)!=null?_options$chunks:{}).sort().map(key=>key+options.chunks[key]).join("")}`}};const dummyUvs=[0,1,2,3,4,5,6,7];class ShaderGeneratorLit extends ShaderGenerator{generateKey(options){const key=`lit${dummyUvs.map((dummy,index)=>{return options.usedUvs[index]?"1":"0"}).join("")}${options.shaderChunk}${LitOptionsUtils.generateKey(options.litOptions)}`;return key}createShaderDefinition(device,options){const litShader=new LitShader(device,options.litOptions);const decl=new ChunkBuilder;const code=new ChunkBuilder;const func=new ChunkBuilder;decl.append("uniform float textureBias;");decl.append(litShader.chunks.litShaderArgsPS);code.append(options.shaderChunk);func.code="evaluateFrontend();";func.code=`
${func.code.split("\n").map(l=>`    ${l}`).join("\n")}

`;const usedUvSets=options.usedUvs||[true];const mapTransforms=[];litShader.generateVertexShader(usedUvSets,usedUvSets,mapTransforms);litShader.generateFragmentShader(decl.code,code.code,func.code,"vUv0");return litShader.getDefinition()}}const lit=new ShaderGeneratorLit;const options=new LitMaterialOptions;class LitMaterial extends Material{getShaderVariant(device,scene,objDefs,unused,pass,sortedLights,viewUniformFormat,viewBindGroupFormat,vertexFormat){options.usedUvs=this.usedUvs.slice();options.shaderChunk=this.shaderChunk;LitMaterialOptionsBuilder.update(options.litOptions,this,scene,objDefs,pass,sortedLights);const processingOptions=new ShaderProcessorOptions(viewUniformFormat,viewBindGroupFormat,vertexFormat);const library=getProgramLibrary(device);library.register("lit",lit);const shader=library.getProgram("lit",options,processingOptions,this.userId);return shader}constructor(...args){super(...args);this.usedUvs=[true];this.shaderChunk="void evaluateFrontend() {}\n";this.chunks=null;this.useLighting=true;this.useFog=true;this.useGammaTonemap=true;this.useSkybox=true;this.shadingModel=SPECULAR_BLINN;this.ambientSH=null;this.pixelSnap=false;this.nineSlicedMode=null;this.fastTbn=false;this.twoSidedLighting=false;this.occludeDirect=false;this.occludeSpecular=SPECOCC_AO;this.occludeSpecularIntensity=1;this.opacityFadesSpecular=true;this.opacityDither=DITHER_NONE;this.opacityShadowDither=DITHER_NONE;this.conserveEnergy=true;this.ggxSpecular=false;this.fresnelModel=FRESNEL_SCHLICK;this.dynamicRefraction=false;this.hasAo=false;this.hasSpecular=false;this.hasSpecularityFactor=false;this.hasLighting=false;this.hasHeights=false;this.hasNormals=false;this.hasSheen=false;this.hasRefraction=false;this.hasIrridescence=false;this.hasMetalness=false;this.hasClearCoat=false;this.hasClearCoatNormals=false;}}const tempVec3=new Vec3;const tempMin3=new Vec3;const tempMax3=new Vec3;const tempBox=new BoundingBox;const epsilon=1e-6;class ClusterLight{constructor(){this.light=null;this.min=new Vec3;this.max=new Vec3;}}class WorldClusters{set maxCellLightCount(count){if(count!==this._maxCellLightCount){this._maxCellLightCount=count;this._cellsDirty=true;}}get maxCellLightCount(){return this._maxCellLightCount}set cells(value){tempVec3.copy(value).floor();if(!this._cells.equals(tempVec3)){this._cells.copy(tempVec3);this._cellsLimit.copy(tempVec3).sub(Vec3.ONE);this._cellsDirty=true;}}get cells(){return this._cells}destroy(){this.lightsBuffer.destroy();this.releaseClusterTexture();}releaseClusterTexture(){if(this.clusterTexture){this.clusterTexture.destroy();this.clusterTexture=null;}}registerUniforms(device){this._clusterSkipId=device.scope.resolve("clusterSkip");this._clusterMaxCellsId=device.scope.resolve("clusterMaxCells");this._clusterWorldTextureId=device.scope.resolve("clusterWorldTexture");this._clusterTextureSizeId=device.scope.resolve("clusterTextureSize");this._clusterTextureSizeData=new Float32Array(3);this._clusterBoundsMinId=device.scope.resolve("clusterBoundsMin");this._clusterBoundsMinData=new Float32Array(3);this._clusterBoundsDeltaId=device.scope.resolve("clusterBoundsDelta");this._clusterBoundsDeltaData=new Float32Array(3);this._clusterCellsCountByBoundsSizeId=device.scope.resolve("clusterCellsCountByBoundsSize");this._clusterCellsCountByBoundsSizeData=new Float32Array(3);this._clusterCellsDotId=device.scope.resolve("clusterCellsDot");this._clusterCellsDotData=new Float32Array(3);this._clusterCellsMaxId=device.scope.resolve("clusterCellsMax");this._clusterCellsMaxData=new Float32Array(3);this._clusterCompressionLimit0Id=device.scope.resolve("clusterCompressionLimit0");this._clusterCompressionLimit0Data=new Float32Array(2);}updateParams(lightingParams){if(lightingParams){this.cells=lightingParams.cells;this.maxCellLightCount=lightingParams.maxLightsPerCell;this.lightsBuffer.cookiesEnabled=lightingParams.cookiesEnabled;this.lightsBuffer.shadowsEnabled=lightingParams.shadowsEnabled;this.lightsBuffer.areaLightsEnabled=lightingParams.areaLightsEnabled;}}updateCells(){if(this._cellsDirty){this._cellsDirty=false;const cx=this._cells.x;const cy=this._cells.y;const cz=this._cells.z;const numCells=cx*cy*cz;const totalPixels=this.maxCellLightCount*numCells;let width=Math.ceil(Math.sqrt(totalPixels));width=math.roundUp(width,this.maxCellLightCount);const height=Math.ceil(totalPixels/width);this._clusterCellsMaxData[0]=cx;this._clusterCellsMaxData[1]=cy;this._clusterCellsMaxData[2]=cz;this._clusterCellsDotData[0]=this.maxCellLightCount;this._clusterCellsDotData[1]=cx*cz*this.maxCellLightCount;this._clusterCellsDotData[2]=cx*this.maxCellLightCount;this.clusters=new Uint8ClampedArray(totalPixels);this.counts=new Int32Array(numCells);this._clusterTextureSizeData[0]=width;this._clusterTextureSizeData[1]=1/width;this._clusterTextureSizeData[2]=1/height;this.releaseClusterTexture();this.clusterTexture=this.lightsBuffer.createTexture(this.device,width,height,PIXELFORMAT_L8,"ClusterTexture");}}uploadTextures(){this.clusterTexture.lock().set(this.clusters);this.clusterTexture.unlock();this.lightsBuffer.uploadTextures();}updateUniforms(){this._clusterSkipId.setValue(this._usedLights.length>1?0:1);this.lightsBuffer.updateUniforms();this._clusterWorldTextureId.setValue(this.clusterTexture);this._clusterMaxCellsId.setValue(this.maxCellLightCount);const boundsDelta=this.boundsDelta;this._clusterCellsCountByBoundsSizeData[0]=this._cells.x/boundsDelta.x;this._clusterCellsCountByBoundsSizeData[1]=this._cells.y/boundsDelta.y;this._clusterCellsCountByBoundsSizeData[2]=this._cells.z/boundsDelta.z;this._clusterCellsCountByBoundsSizeId.setValue(this._clusterCellsCountByBoundsSizeData);this._clusterBoundsMinData[0]=this.boundsMin.x;this._clusterBoundsMinData[1]=this.boundsMin.y;this._clusterBoundsMinData[2]=this.boundsMin.z;this._clusterBoundsDeltaData[0]=boundsDelta.x;this._clusterBoundsDeltaData[1]=boundsDelta.y;this._clusterBoundsDeltaData[2]=boundsDelta.z;this._clusterCompressionLimit0Data[0]=this._maxAttenuation;this._clusterCompressionLimit0Data[1]=this._maxColorValue;this._clusterTextureSizeId.setValue(this._clusterTextureSizeData);this._clusterBoundsMinId.setValue(this._clusterBoundsMinData);this._clusterBoundsDeltaId.setValue(this._clusterBoundsDeltaData);this._clusterCellsDotId.setValue(this._clusterCellsDotData);this._clusterCellsMaxId.setValue(this._clusterCellsMaxData);this._clusterCompressionLimit0Id.setValue(this._clusterCompressionLimit0Data);}evalLightCellMinMax(clusteredLight,min,max){min.copy(clusteredLight.min);min.sub(this.boundsMin);min.div(this.boundsDelta);min.mul2(min,this.cells);min.floor();max.copy(clusteredLight.max);max.sub(this.boundsMin);max.div(this.boundsDelta);max.mul2(max,this.cells);max.ceil();min.max(Vec3.ZERO);max.min(this._cellsLimit);}collectLights(lights){const maxLights=this.lightsBuffer.maxLights;const usedLights=this._usedLights;let lightIndex=1;lights.forEach(light=>{const runtimeLight=!!(light.mask&(MASK_AFFECT_DYNAMIC|MASK_AFFECT_LIGHTMAPPED));const zeroAngleSpotlight=light.type===LIGHTTYPE_SPOT&&light._outerConeAngle===0;if(light.enabled&&light.type!==LIGHTTYPE_DIRECTIONAL&&light.visibleThisFrame&&light.intensity>0&&runtimeLight&&!zeroAngleSpotlight){if(lightIndex<maxLights){let clusteredLight;if(lightIndex<usedLights.length){clusteredLight=usedLights[lightIndex];}else {clusteredLight=new ClusterLight;usedLights.push(clusteredLight);}clusteredLight.light=light;light.getBoundingBox(tempBox);clusteredLight.min.copy(tempBox.getMin());clusteredLight.max.copy(tempBox.getMax());lightIndex++;}}});usedLights.length=lightIndex;}evaluateBounds(){const usedLights=this._usedLights;const min=this.boundsMin;const max=this.boundsMax;if(usedLights.length>1){min.copy(usedLights[1].min);max.copy(usedLights[1].max);for(let i=2;i<usedLights.length;i++){min.min(usedLights[i].min);max.max(usedLights[i].max);}}else {min.set(0,0,0);max.set(1,1,1);}this.boundsDelta.sub2(max,min);this.lightsBuffer.setBounds(min,this.boundsDelta);}evaluateCompressionLimits(gammaCorrection){let maxAttenuation=0;let maxColorValue=0;const usedLights=this._usedLights;for(let i=1;i<usedLights.length;i++){const light=usedLights[i].light;maxAttenuation=Math.max(light.attenuationEnd,maxAttenuation);const color=gammaCorrection?light._linearFinalColor:light._finalColor;maxColorValue=Math.max(color[0],maxColorValue);maxColorValue=Math.max(color[1],maxColorValue);maxColorValue=Math.max(color[2],maxColorValue);}this._maxAttenuation=maxAttenuation+epsilon;this._maxColorValue=maxColorValue+epsilon;this.lightsBuffer.setCompressionRanges(this._maxAttenuation,this._maxColorValue);}updateClusters(gammaCorrection){this.counts.fill(0);this.clusters.fill(0);const divX=this._cells.x;const divZ=this._cells.z;const counts=this.counts;const limit=this._maxCellLightCount;const clusters=this.clusters;const pixelsPerCellCount=this.maxCellLightCount;const usedLights=this._usedLights;for(let i=1;i<usedLights.length;i++){const clusteredLight=usedLights[i];const light=clusteredLight.light;this.lightsBuffer.addLightData(light,i,gammaCorrection);this.evalLightCellMinMax(clusteredLight,tempMin3,tempMax3);const xStart=tempMin3.x;const xEnd=tempMax3.x;const yStart=tempMin3.y;const yEnd=tempMax3.y;const zStart=tempMin3.z;const zEnd=tempMax3.z;for(let x=xStart;x<=xEnd;x++){for(let z=zStart;z<=zEnd;z++){for(let y=yStart;y<=yEnd;y++){const clusterIndex=x+divX*(z+y*divZ);const count=counts[clusterIndex];if(count<limit){clusters[pixelsPerCellCount*clusterIndex+count]=i;counts[clusterIndex]=count+1;}}}}}}update(lights,gammaCorrection,lightingParams){this.updateParams(lightingParams);this.updateCells();this.collectLights(lights);this.evaluateBounds();this.evaluateCompressionLimits(gammaCorrection);this.updateClusters(gammaCorrection);this.uploadTextures();}activate(){this.updateUniforms();}constructor(device){this.clusterTexture=void 0;this.device=device;this.name="Untitled";this.reportCount=0;this.boundsMin=new Vec3;this.boundsMax=new Vec3;this.boundsDelta=new Vec3;this._cells=new Vec3(1,1,1);this._cellsLimit=new Vec3;this.cells=this._cells;this.maxCellLightCount=4;this._maxAttenuation=0;this._maxColorValue=0;this._usedLights=[];this._usedLights.push(new ClusterLight);this.lightsBuffer=new LightsBuffer(device);this.registerUniforms(device);}}class ShadowMap{destroy(){if(this.texture){this.texture.destroy();this.texture=null;}const targets=this.renderTargets;for(let i=0;i<targets.length;i++){targets[i].destroy();}this.renderTargets.length=0;}static getShadowFormat(device,shadowType){if(shadowType===SHADOW_VSM32){return PIXELFORMAT_RGBA32F}else if(shadowType===SHADOW_VSM16){return PIXELFORMAT_RGBA16F}else if(shadowType===SHADOW_PCF5){return PIXELFORMAT_DEPTH}else if((shadowType===SHADOW_PCF1||shadowType===SHADOW_PCF3)&&device.supportsDepthShadow){return PIXELFORMAT_DEPTH}else if(shadowType===SHADOW_PCSS&&!device.isWebGL1){return PIXELFORMAT_R32F}return PIXELFORMAT_RGBA8}static getShadowFiltering(device,shadowType){if((shadowType===SHADOW_PCF1||shadowType===SHADOW_PCF3||shadowType===SHADOW_PCSS)&&!device.supportsDepthShadow){return FILTER_NEAREST}else if(shadowType===SHADOW_VSM32){return device.extTextureFloatLinear?FILTER_LINEAR:FILTER_NEAREST}else if(shadowType===SHADOW_VSM16){return device.extTextureHalfFloatLinear?FILTER_LINEAR:FILTER_NEAREST}return FILTER_LINEAR}static create(device,light){let shadowMap=null;if(light._type===LIGHTTYPE_OMNI){shadowMap=this.createCubemap(device,light._shadowResolution,light._shadowType);}else {shadowMap=this.create2dMap(device,light._shadowResolution,light._shadowType);}return shadowMap}static createAtlas(device,resolution,shadowType){const shadowMap=this.create2dMap(device,resolution,shadowType);const targets=shadowMap.renderTargets;const rt=targets[0];for(let i=0;i<5;i++){targets.push(rt);}return shadowMap}static create2dMap(device,size,shadowType){const format=this.getShadowFormat(device,shadowType);const filter=this.getShadowFiltering(device,shadowType);const texture=new Texture(device,{format:format,width:size,height:size,mipmaps:false,minFilter:filter,magFilter:filter,addressU:ADDRESS_CLAMP_TO_EDGE,addressV:ADDRESS_CLAMP_TO_EDGE,name:"ShadowMap2D"});let target=null;if(shadowType===SHADOW_PCF5||(shadowType===SHADOW_PCF1||shadowType===SHADOW_PCF3)&&device.supportsDepthShadow){texture.compareOnRead=true;texture.compareFunc=FUNC_LESS;target=new RenderTarget({depthBuffer:texture});}else {target=new RenderTarget({colorBuffer:texture,depth:true});}if(device.isWebGPU){target.flipY=true;}return new ShadowMap(texture,[target])}static createCubemap(device,size,shadowType){const format=shadowType===SHADOW_PCSS&&!device.isWebGL1?PIXELFORMAT_R32F:PIXELFORMAT_RGBA8;const cubemap=new Texture(device,{format:format,width:size,height:size,cubemap:true,mipmaps:false,minFilter:FILTER_NEAREST,magFilter:FILTER_NEAREST,addressU:ADDRESS_CLAMP_TO_EDGE,addressV:ADDRESS_CLAMP_TO_EDGE,name:"ShadowMapCube"});const targets=[];for(let i=0;i<6;i++){const target=new RenderTarget({colorBuffer:cubemap,face:i,depth:true});targets.push(target);}return new ShadowMap(cubemap,targets)}constructor(texture,targets){this.texture=texture;this.cached=false;this.renderTargets=targets;}}const _tempArray=[];const _tempArray2=[];const _viewport$3=new Vec4;const _scissor=new Vec4;class Slot{constructor(rect){this.size=Math.floor(rect.w*1024);this.used=false;this.lightId=-1;this.rect=rect;}}class LightTextureAtlas{destroy(){this.destroyShadowAtlas();this.destroyCookieAtlas();}destroyShadowAtlas(){var _this$shadowAtlas;(_this$shadowAtlas=this.shadowAtlas)==null||_this$shadowAtlas.destroy();this.shadowAtlas=null;}destroyCookieAtlas(){var _this$cookieAtlas,_this$cookieRenderTar;(_this$cookieAtlas=this.cookieAtlas)==null||_this$cookieAtlas.destroy();this.cookieAtlas=null;(_this$cookieRenderTar=this.cookieRenderTarget)==null||_this$cookieRenderTar.destroy();this.cookieRenderTarget=null;}allocateShadowAtlas(resolution){if(!this.shadowAtlas||this.shadowAtlas.texture.width!==resolution){this.version++;this.destroyShadowAtlas();this.shadowAtlas=ShadowMap.createAtlas(this.device,resolution,SHADOW_PCF3);this.shadowAtlas.cached=true;const scissorOffset=4/this.shadowAtlasResolution;this.scissorVec.set(scissorOffset,scissorOffset,-2*scissorOffset,-2*scissorOffset);}}allocateCookieAtlas(resolution){if(this.cookieAtlas.width!==resolution){this.cookieRenderTarget.resize(resolution,resolution);this.version++;}}allocateUniforms(){this._shadowAtlasTextureId=this.device.scope.resolve("shadowAtlasTexture");this._shadowAtlasParamsId=this.device.scope.resolve("shadowAtlasParams");this._shadowAtlasParams=new Float32Array(2);this._cookieAtlasTextureId=this.device.scope.resolve("cookieAtlasTexture");}updateUniforms(){const isShadowFilterPcf=true;const rt=this.shadowAtlas.renderTargets[0];const isDepthShadow=!this.device.isWebGL1&&isShadowFilterPcf;const shadowBuffer=isDepthShadow?rt.depthBuffer:rt.colorBuffer;this._shadowAtlasTextureId.setValue(shadowBuffer);this._shadowAtlasParams[0]=this.shadowAtlasResolution;this._shadowAtlasParams[1]=this.shadowEdgePixels;this._shadowAtlasParamsId.setValue(this._shadowAtlasParams);this._cookieAtlasTextureId.setValue(this.cookieAtlas);}subdivide(numLights,lightingParams){let atlasSplit=lightingParams.atlasSplit;if(!atlasSplit){const gridSize=Math.ceil(Math.sqrt(numLights));atlasSplit=_tempArray2;atlasSplit[0]=gridSize;atlasSplit.length=1;}const arraysEqual=(a,b)=>a.length===b.length&&a.every((v,i)=>v===b[i]);if(!arraysEqual(atlasSplit,this.atlasSplit)){this.version++;this.slots.length=0;this.atlasSplit.length=0;this.atlasSplit.push(...atlasSplit);const splitCount=this.atlasSplit[0];if(splitCount>1){const invSize=1/splitCount;for(let i=0;i<splitCount;i++){for(let j=0;j<splitCount;j++){const rect=new Vec4(i*invSize,j*invSize,invSize,invSize);const nextLevelSplit=this.atlasSplit[1+i*splitCount+j];if(nextLevelSplit>1){for(let x=0;x<nextLevelSplit;x++){for(let y=0;y<nextLevelSplit;y++){const invSizeNext=invSize/nextLevelSplit;const rectNext=new Vec4(rect.x+x*invSizeNext,rect.y+y*invSizeNext,invSizeNext,invSizeNext);this.slots.push(new Slot(rectNext));}}}else {this.slots.push(new Slot(rect));}}}}else {this.slots.push(new Slot(new Vec4(0,0,1,1)));}this.slots.sort((a,b)=>{return b.size-a.size});}}collectLights(localLights,lightingParams){const cookiesEnabled=lightingParams.cookiesEnabled;const shadowsEnabled=lightingParams.shadowsEnabled;let needsShadowAtlas=false;let needsCookieAtlas=false;const lights=_tempArray;lights.length=0;const processLights=list=>{for(let i=0;i<list.length;i++){const light=list[i];if(light.visibleThisFrame){const lightShadow=shadowsEnabled&&light.castShadows;const lightCookie=cookiesEnabled&&!!light.cookie;needsShadowAtlas||(needsShadowAtlas=lightShadow);needsCookieAtlas||(needsCookieAtlas=lightCookie);if(lightShadow||lightCookie){lights.push(light);}}}};if(cookiesEnabled||shadowsEnabled){processLights(localLights);}lights.sort((a,b)=>{return b.maxScreenSize-a.maxScreenSize});if(needsShadowAtlas){this.allocateShadowAtlas(this.shadowAtlasResolution);}if(needsCookieAtlas){this.allocateCookieAtlas(this.cookieAtlasResolution);}if(needsShadowAtlas||needsCookieAtlas){this.subdivide(lights.length,lightingParams);}return lights}setupSlot(light,rect){light.atlasViewport.copy(rect);const faceCount=light.numShadowFaces;for(let face=0;face<faceCount;face++){if(light.castShadows||light._cookie){_viewport$3.copy(rect);_scissor.copy(rect);if(light._type===LIGHTTYPE_SPOT){_viewport$3.add(this.scissorVec);}if(light._type===LIGHTTYPE_OMNI){const smallSize=_viewport$3.z/3;const offset=this.cubeSlotsOffsets[face];_viewport$3.x+=smallSize*offset.x;_viewport$3.y+=smallSize*offset.y;_viewport$3.z=smallSize;_viewport$3.w=smallSize;_scissor.copy(_viewport$3);}if(light.castShadows){const lightRenderData=light.getRenderData(null,face);lightRenderData.shadowViewport.copy(_viewport$3);lightRenderData.shadowScissor.copy(_scissor);}}}}assignSlot(light,slotIndex,slotReassigned){light.atlasViewportAllocated=true;const slot=this.slots[slotIndex];slot.lightId=light.id;slot.used=true;if(slotReassigned){light.atlasSlotUpdated=true;light.atlasVersion=this.version;light.atlasSlotIndex=slotIndex;}}update(localLights,lightingParams){this.shadowAtlasResolution=lightingParams.shadowAtlasResolution;this.cookieAtlasResolution=lightingParams.cookieAtlasResolution;const lights=this.collectLights(localLights,lightingParams);if(lights.length>0){const slots=this.slots;for(let i=0;i<slots.length;i++){slots[i].used=false;}const assignCount=Math.min(lights.length,slots.length);for(let i=0;i<assignCount;i++){const light=lights[i];if(light.castShadows){light._shadowMap=this.shadowAtlas;}const previousSlot=slots[light.atlasSlotIndex];if(light.atlasVersion===this.version&&light.id===(previousSlot==null?void 0:previousSlot.lightId)){const _previousSlot=slots[light.atlasSlotIndex];if(_previousSlot.size===slots[i].size&&!_previousSlot.used){this.assignSlot(light,light.atlasSlotIndex,false);}}}let usedCount=0;for(let i=0;i<assignCount;i++){while(usedCount<slots.length&&slots[usedCount].used){usedCount++;}const light=lights[i];if(!light.atlasViewportAllocated){this.assignSlot(light,usedCount,true);}const slot=slots[light.atlasSlotIndex];this.setupSlot(light,slot.rect);}}this.updateUniforms();}constructor(device){this.device=device;this.version=1;this.shadowAtlasResolution=2048;this.shadowAtlas=null;this.shadowEdgePixels=3;this.cookieAtlasResolution=4;this.cookieAtlas=new Texture(this.device,{name:"CookieAtlas",width:this.cookieAtlasResolution,height:this.cookieAtlasResolution,format:PIXELFORMAT_RGBA8,cubemap:false,mipmaps:false,minFilter:FILTER_NEAREST,magFilter:FILTER_NEAREST,addressU:ADDRESS_CLAMP_TO_EDGE,addressV:ADDRESS_CLAMP_TO_EDGE});this.cookieRenderTarget=new RenderTarget({colorBuffer:this.cookieAtlas,depth:false,flipY:true});this.slots=[];this.atlasSplit=[];this.cubeSlotsOffsets=[new Vec2(0,0),new Vec2(0,1),new Vec2(1,0),new Vec2(1,1),new Vec2(2,0),new Vec2(2,1)];this.scissorVec=new Vec4;this.allocateShadowAtlas(1);this.allocateCookieAtlas(1);this.allocateUniforms();}}const lightCubeDir=[new Vec3(-1,0,0),new Vec3(1,0,0),new Vec3(0,-1,0),new Vec3(0,1,0),new Vec3(0,0,-1),new Vec3(0,0,1)];class LightCube{update(ambientLight,lights){const colors=this.colors;const{r,g,b}=ambientLight;for(let j=0;j<6;j++){colors[j*3]=r;colors[j*3+1]=g;colors[j*3+2]=b;}for(let j=0;j<lights.length;j++){const light=lights[j];if(light._type===LIGHTTYPE_DIRECTIONAL){for(let c=0;c<6;c++){const weight=Math.max(lightCubeDir[c].dot(light._direction),0)*light._intensity;const lightColor=light._color;colors[c*3]+=lightColor.r*weight;colors[c*3+1]+=lightColor.g*weight;colors[c*3+2]+=lightColor.b*weight;}}}}constructor(){this.colors=new Float32Array(6*3);}}class ShadowMapCache{destroy(){this.clear();this.cache=null;}clear(){this.cache.forEach(shadowMaps=>{shadowMaps.forEach(shadowMap=>{shadowMap.destroy();});});this.cache.clear();}getKey(light){const isCubeMap=light._type===LIGHTTYPE_OMNI;const shadowType=light._shadowType;const resolution=light._shadowResolution;return `${isCubeMap}-${shadowType}-${resolution}`}get(device,light){const key=this.getKey(light);const shadowMaps=this.cache.get(key);if(shadowMaps&&shadowMaps.length){return shadowMaps.pop()}const shadowMap=ShadowMap.create(device,light);shadowMap.cached=true;return shadowMap}add(light,shadowMap){const key=this.getKey(light);const shadowMaps=this.cache.get(key);if(shadowMaps){shadowMaps.push(shadowMap);}else {this.cache.set(key,[shadowMap]);}}constructor(){this.cache=new Map;}}class RenderPassShadowLocalNonClustered extends RenderPass{execute(){this.shadowRenderer.renderFace(this.light,null,this.face,false);}after(){if(this.applyVsm){this.shadowRenderer.renderVsm(this.light,this.shadowCamera);}}constructor(device,shadowRenderer,light,face,applyVsm){super(device);this.requiresCubemaps=false;this.shadowRenderer=shadowRenderer;this.light=light;this.face=face;this.applyVsm=applyVsm;this.shadowCamera=shadowRenderer.prepareFace(light,null,face);shadowRenderer.setupRenderPass(this,this.shadowCamera,true);}}class ShadowRendererLocal{cull(light,comp,casters=null){const isClustered=this.renderer.scene.clusteredLightingEnabled;light.visibleThisFrame=true;if(!isClustered){if(!light._shadowMap){light._shadowMap=ShadowMap.create(this.device,light);}}const type=light._type;const faceCount=type===LIGHTTYPE_SPOT?1:6;for(let face=0;face<faceCount;face++){const lightRenderData=light.getRenderData(null,face);const shadowCam=lightRenderData.shadowCamera;shadowCam.nearClip=light.attenuationEnd/1e3;shadowCam.farClip=light.attenuationEnd;lightRenderData.depthRangeCompensation=shadowCam.farClip-shadowCam.nearClip;const shadowCamNode=shadowCam._node;const lightNode=light._node;shadowCamNode.setPosition(lightNode.getPosition());if(type===LIGHTTYPE_SPOT){shadowCam.fov=light._outerConeAngle*2;shadowCamNode.setRotation(lightNode.getRotation());shadowCamNode.rotateLocal(-90,0,0);}else if(type===LIGHTTYPE_OMNI){if(isClustered){const tileSize=this.shadowRenderer.lightTextureAtlas.shadowAtlasResolution*light.atlasViewport.z/3;const texelSize=2/tileSize;const filterSize=texelSize*this.shadowRenderer.lightTextureAtlas.shadowEdgePixels;shadowCam.fov=Math.atan(1+filterSize)*math.RAD_TO_DEG*2;}else {shadowCam.fov=90;}}this.renderer.updateCameraFrustum(shadowCam);this.shadowRenderer.cullShadowCasters(comp,light,lightRenderData.visibleCasters,shadowCam,casters);}}prepareLights(shadowLights,lights){let shadowCamera;for(let i=0;i<lights.length;i++){const light=lights[i];if(this.shadowRenderer.needsShadowRendering(light)&&light.atlasViewportAllocated){shadowLights.push(light);for(let face=0;face<light.numShadowFaces;face++){shadowCamera=this.shadowRenderer.prepareFace(light,null,face);}}}return shadowCamera}buildNonClusteredRenderPasses(frameGraph,localLights){for(let i=0;i<localLights.length;i++){const light=localLights[i];if(this.shadowRenderer.needsShadowRendering(light)){const applyVsm=light._type===LIGHTTYPE_SPOT;const faceCount=light.numShadowFaces;for(let face=0;face<faceCount;face++){const renderPass=new RenderPassShadowLocalNonClustered(this.device,this.shadowRenderer,light,face,applyVsm);frameGraph.addRenderPass(renderPass);}}}}constructor(renderer,shadowRenderer){this.shadowLights=[];this.renderer=void 0;this.shadowRenderer=void 0;this.device=void 0;this.renderer=renderer;this.shadowRenderer=shadowRenderer;this.device=renderer.device;}}class RenderPassShadowDirectional extends RenderPass{execute(){const{light,camera,shadowRenderer,allCascadesRendering}=this;const faceCount=light.numShadowFaces;const shadowUpdateOverrides=light.shadowUpdateOverrides;for(let face=0;face<faceCount;face++){if((shadowUpdateOverrides==null?void 0:shadowUpdateOverrides[face])!==SHADOWUPDATE_NONE){shadowRenderer.renderFace(light,camera,face,!allCascadesRendering);}if((shadowUpdateOverrides==null?void 0:shadowUpdateOverrides[face])===SHADOWUPDATE_THISFRAME){shadowUpdateOverrides[face]=SHADOWUPDATE_NONE;}}}after(){this.shadowRenderer.renderVsm(this.light,this.camera);}constructor(device,shadowRenderer,light,camera,allCascadesRendering){super(device);this.shadowRenderer=shadowRenderer;this.light=light;this.camera=camera;this.allCascadesRendering=allCascadesRendering;}}const visibleSceneAabb=new BoundingBox;const center=new Vec3;const shadowCamView$1=new Mat4;const aabbPoints=[new Vec3,new Vec3,new Vec3,new Vec3,new Vec3,new Vec3,new Vec3,new Vec3];const _depthRange={min:0,max:0};function getDepthRange(cameraViewMatrix,aabbMin,aabbMax){aabbPoints[0].x=aabbPoints[1].x=aabbPoints[2].x=aabbPoints[3].x=aabbMin.x;aabbPoints[1].y=aabbPoints[3].y=aabbPoints[7].y=aabbPoints[5].y=aabbMin.y;aabbPoints[2].z=aabbPoints[3].z=aabbPoints[6].z=aabbPoints[7].z=aabbMin.z;aabbPoints[4].x=aabbPoints[5].x=aabbPoints[6].x=aabbPoints[7].x=aabbMax.x;aabbPoints[0].y=aabbPoints[2].y=aabbPoints[4].y=aabbPoints[6].y=aabbMax.y;aabbPoints[0].z=aabbPoints[1].z=aabbPoints[4].z=aabbPoints[5].z=aabbMax.z;let minz=9999999999;let maxz=-9999999999;for(let i=0;i<8;++i){cameraViewMatrix.transformPoint(aabbPoints[i],aabbPoints[i]);const z=aabbPoints[i].z;if(z<minz)minz=z;if(z>maxz)maxz=z;}_depthRange.min=minz;_depthRange.max=maxz;return _depthRange}class ShadowRendererDirectional{cull(light,comp,camera,casters=null){light.visibleThisFrame=true;if(!light._shadowMap){light._shadowMap=ShadowMap.create(this.device,light);}const nearDist=camera._nearClip;this.generateSplitDistances(light,nearDist,Math.min(camera._farClip,light.shadowDistance));const shadowUpdateOverrides=light.shadowUpdateOverrides;for(let cascade=0;cascade<light.numCascades;cascade++){if((shadowUpdateOverrides==null?void 0:shadowUpdateOverrides[cascade])===SHADOWUPDATE_NONE){break}const lightRenderData=light.getRenderData(camera,cascade);const shadowCam=lightRenderData.shadowCamera;shadowCam.renderTarget=light._shadowMap.renderTargets[0];lightRenderData.shadowViewport.copy(light.cascades[cascade]);lightRenderData.shadowScissor.copy(light.cascades[cascade]);const shadowCamNode=shadowCam._node;const lightNode=light._node;shadowCamNode.setPosition(lightNode.getPosition());shadowCamNode.setRotation(lightNode.getRotation());shadowCamNode.rotateLocal(-90,0,0);const frustumNearDist=cascade===0?nearDist:light._shadowCascadeDistances[cascade-1];const frustumFarDist=light._shadowCascadeDistances[cascade];const frustumPoints=camera.getFrustumCorners(frustumNearDist,frustumFarDist);center.set(0,0,0);const cameraWorldMat=camera.node.getWorldTransform();for(let i=0;i<8;i++){cameraWorldMat.transformPoint(frustumPoints[i],frustumPoints[i]);center.add(frustumPoints[i]);}center.mulScalar(1/8);let radius=0;for(let i=0;i<8;i++){const dist=frustumPoints[i].sub(center).length();if(dist>radius){radius=dist;}}const right=shadowCamNode.right;const up=shadowCamNode.up;const lightDir=shadowCamNode.forward;const sizeRatio=.25*light._shadowResolution/radius;const x=Math.ceil(center.dot(up)*sizeRatio)/sizeRatio;const y=Math.ceil(center.dot(right)*sizeRatio)/sizeRatio;const scaledUp=up.mulScalar(x);const scaledRight=right.mulScalar(y);const dot=center.dot(lightDir);const scaledDir=lightDir.mulScalar(dot);center.add2(scaledUp,scaledRight).add(scaledDir);shadowCamNode.setPosition(center);shadowCamNode.translateLocal(0,0,1e6);shadowCam.nearClip=.01;shadowCam.farClip=2e6;shadowCam.orthoHeight=radius;this.renderer.updateCameraFrustum(shadowCam);this.shadowRenderer.cullShadowCasters(comp,light,lightRenderData.visibleCasters,shadowCam,casters);let emptyAabb=true;const visibleCasters=lightRenderData.visibleCasters;for(let i=0;i<visibleCasters.length;i++){const meshInstance=visibleCasters[i];if(emptyAabb){emptyAabb=false;visibleSceneAabb.copy(meshInstance.aabb);}else {visibleSceneAabb.add(meshInstance.aabb);}}shadowCamView$1.copy(shadowCamNode.getWorldTransform()).invert();const depthRange=getDepthRange(shadowCamView$1,visibleSceneAabb.getMin(),visibleSceneAabb.getMax());shadowCamNode.translateLocal(0,0,depthRange.max+.1);shadowCam.farClip=depthRange.max-depthRange.min+.2;lightRenderData.depthRangeCompensation=shadowCam.farClip;lightRenderData.projectionCompensation=radius;}}generateSplitDistances(light,nearDist,farDist){light._shadowCascadeDistances.fill(farDist);for(let i=1;i<light.numCascades;i++){const fraction=i/light.numCascades;const linearDist=nearDist+(farDist-nearDist)*fraction;const logDist=nearDist*(farDist/nearDist)**fraction;const dist=math.lerp(linearDist,logDist,light.cascadeDistribution);light._shadowCascadeDistances[i-1]=dist;}}getLightRenderPass(light,camera){let renderPass=null;if(this.shadowRenderer.needsShadowRendering(light)){const faceCount=light.numShadowFaces;const shadowUpdateOverrides=light.shadowUpdateOverrides;let allCascadesRendering=true;let shadowCamera;for(let face=0;face<faceCount;face++){if((shadowUpdateOverrides==null?void 0:shadowUpdateOverrides[face])===SHADOWUPDATE_NONE){allCascadesRendering=false;}shadowCamera=this.shadowRenderer.prepareFace(light,camera,face);}renderPass=new RenderPassShadowDirectional(this.device,this.shadowRenderer,light,camera,allCascadesRendering);this.shadowRenderer.setupRenderPass(renderPass,shadowCamera,allCascadesRendering);}return renderPass}constructor(renderer,shadowRenderer){this.renderer=void 0;this.shadowRenderer=void 0;this.device=void 0;this.renderer=renderer;this.shadowRenderer=shadowRenderer;this.device=renderer.device;}}function gauss(x,sigma){return Math.exp(-(x*x)/(2*sigma*sigma))}function gaussWeights(kernelSize){const sigma=(kernelSize-1)/(2*3);const halfWidth=(kernelSize-1)*.5;const values=new Array(kernelSize);let sum=0;for(let i=0;i<kernelSize;++i){values[i]=gauss(i-halfWidth,sigma);sum+=values[i];}for(let i=0;i<kernelSize;++i){values[i]/=sum;}return values}const tempSet$1=new Set;const shadowCamView=new Mat4;const shadowCamViewProj=new Mat4;const pixelOffset=new Float32Array(2);const blurScissorRect=new Vec4(1,1,0,0);const viewportMatrix=new Mat4;class ShadowRenderer{static createShadowCamera(device,shadowType,type,face){const shadowCam=LightCamera.create("ShadowCamera",type,face);if(shadowType>=SHADOW_VSM8&&shadowType<=SHADOW_VSM32){shadowCam.clearColor=new Color(0,0,0,0);}else {shadowCam.clearColor=new Color(1,1,1,1);}shadowCam.clearDepthBuffer=true;shadowCam.clearStencilBuffer=false;return shadowCam}static setShadowCameraSettings(shadowCam,device,shadowType,type,isClustered){let hwPcf=shadowType===SHADOW_PCF5||(shadowType===SHADOW_PCF1||shadowType===SHADOW_PCF3)&&device.supportsDepthShadow;if(type===LIGHTTYPE_OMNI&&!isClustered){hwPcf=false;}shadowCam.clearColorBuffer=!hwPcf;}_cullShadowCastersInternal(meshInstances,visible,camera){const numInstances=meshInstances.length;for(let i=0;i<numInstances;i++){const meshInstance=meshInstances[i];if(meshInstance.castShadow){if(!meshInstance.cull||meshInstance._isVisible(camera)){meshInstance.visibleThisFrame=true;visible.push(meshInstance);}}}}cullShadowCasters(comp,light,visible,camera,casters){visible.length=0;if(casters){this._cullShadowCastersInternal(casters,visible,camera);}else {const layers=comp.layerList;const len=layers.length;for(let i=0;i<len;i++){const layer=layers[i];if(layer._lightsSet.has(light)){if(!tempSet$1.has(layer)){tempSet$1.add(layer);this._cullShadowCastersInternal(layer.shadowCasters,visible,camera);}}}tempSet$1.clear();}visible.sort(this.renderer.sortCompareDepth);}setupRenderState(device,light){if(device.isWebGL1&&device.extStandardDerivatives){if(light._type===LIGHTTYPE_OMNI){this.polygonOffset[0]=0;this.polygonOffset[1]=0;this.polygonOffsetId.setValue(this.polygonOffset);}else {this.polygonOffset[0]=light.shadowBias*-1e3;this.polygonOffset[1]=light.shadowBias*-1e3;this.polygonOffsetId.setValue(this.polygonOffset);}}const isClustered=this.renderer.scene.clusteredLightingEnabled;const gpuOrGl2=device.isWebGL2||device.isWebGPU;const useShadowSampler=isClustered?light._isPcf&&gpuOrGl2:light._isPcf&&gpuOrGl2&&light._type!==LIGHTTYPE_OMNI;device.setBlendState(useShadowSampler?this.blendStateNoWrite:this.blendStateWrite);device.setDepthState(light.shadowDepthState);device.setStencilState(null,null);}dispatchUniforms(light,shadowCam,lightRenderData,face){const shadowCamNode=shadowCam._node;if(light._type!==LIGHTTYPE_DIRECTIONAL){this.renderer.dispatchViewPos(shadowCamNode.getPosition());this.shadowMapLightRadiusId.setValue(light.attenuationEnd);}shadowCamView.setTRS(shadowCamNode.getPosition(),shadowCamNode.getRotation(),Vec3.ONE).invert();shadowCamViewProj.mul2(shadowCam.projectionMatrix,shadowCamView);const rectViewport=lightRenderData.shadowViewport;shadowCam.rect=rectViewport;shadowCam.scissorRect=lightRenderData.shadowScissor;viewportMatrix.setViewport(rectViewport.x,rectViewport.y,rectViewport.z,rectViewport.w);lightRenderData.shadowMatrix.mul2(viewportMatrix,shadowCamViewProj);if(light._type===LIGHTTYPE_DIRECTIONAL){light._shadowMatrixPalette.set(lightRenderData.shadowMatrix.data,face*16);}}getShadowPass(light){var _this$shadowPassCache;const lightType=light._type;const shadowType=light._shadowType;let shadowPassInfo=(_this$shadowPassCache=this.shadowPassCache[lightType])==null?void 0:_this$shadowPassCache[shadowType];if(!shadowPassInfo){const shadowPassName=`ShadowPass_${lightType}_${shadowType}`;shadowPassInfo=ShaderPass.get(this.device).allocate(shadowPassName,{isShadow:true,lightType:lightType,shadowType:shadowType});if(!this.shadowPassCache[lightType]){this.shadowPassCache[lightType]=[];}this.shadowPassCache[lightType][shadowType]=shadowPassInfo;}return shadowPassInfo.index}submitCasters(visibleCasters,light){const device=this.device;const renderer=this.renderer;const scene=renderer.scene;const passFlags=1<<SHADER_SHADOW;const shadowPass=this.getShadowPass(light);const count=visibleCasters.length;for(let i=0;i<count;i++){const meshInstance=visibleCasters[i];const mesh=meshInstance.mesh;meshInstance.ensureMaterial(device);const material=meshInstance.material;renderer.setBaseConstants(device,material);renderer.setSkinning(device,meshInstance);if(material.dirty){material.updateUniforms(device,scene);material.dirty=false;}if(material.chunks){renderer.setupCullMode(true,1,meshInstance);material.setParameters(device);meshInstance.setParameters(device,passFlags);}const shaderInstance=meshInstance.getShaderInstance(shadowPass,0,scene,this.viewUniformFormat,this.viewBindGroupFormat);const shadowShader=shaderInstance.shader;meshInstance._key[SORTKEY_DEPTH]=shadowShader.id;device.setShader(shadowShader);renderer.setVertexBuffers(device,mesh);renderer.setMorphing(device,meshInstance.morphInstance);this.renderer.setupMeshUniformBuffers(shaderInstance,meshInstance);const style=meshInstance.renderStyle;device.setIndexBuffer(mesh.indexBuffer[style]);renderer.drawInstance(device,meshInstance,mesh,style);renderer._shadowDrawCalls++;}}needsShadowRendering(light){const needs=light.enabled&&light.castShadows&&light.shadowUpdateMode!==SHADOWUPDATE_NONE&&light.visibleThisFrame;if(light.shadowUpdateMode===SHADOWUPDATE_THISFRAME){light.shadowUpdateMode=SHADOWUPDATE_NONE;}if(needs){this.renderer._shadowMapUpdates+=light.numShadowFaces;}return needs}getLightRenderData(light,camera,face){return light.getRenderData(light._type===LIGHTTYPE_DIRECTIONAL?camera:null,face)}setupRenderPass(renderPass,shadowCamera,clearRenderTarget){const rt=shadowCamera.renderTarget;renderPass.init(rt);renderPass.depthStencilOps.clearDepthValue=1;renderPass.depthStencilOps.clearDepth=clearRenderTarget;if(rt.depthBuffer){renderPass.depthStencilOps.storeDepth=true;}else {renderPass.colorOps.clearValue.copy(shadowCamera.clearColor);renderPass.colorOps.clear=clearRenderTarget;renderPass.depthStencilOps.storeDepth=false;}renderPass.requiresCubemaps=false;}prepareFace(light,camera,face){const type=light._type;const shadowType=light._shadowType;const isClustered=this.renderer.scene.clusteredLightingEnabled;const lightRenderData=this.getLightRenderData(light,camera,face);const shadowCam=lightRenderData.shadowCamera;ShadowRenderer.setShadowCameraSettings(shadowCam,this.device,shadowType,type,isClustered);const renderTargetIndex=type===LIGHTTYPE_DIRECTIONAL?0:face;shadowCam.renderTarget=light._shadowMap.renderTargets[renderTargetIndex];return shadowCam}renderFace(light,camera,face,clear,insideRenderPass=true){const device=this.device;const lightRenderData=this.getLightRenderData(light,camera,face);const shadowCam=lightRenderData.shadowCamera;this.dispatchUniforms(light,shadowCam,lightRenderData,face);const rt=shadowCam.renderTarget;const renderer=this.renderer;renderer.setCameraUniforms(shadowCam,rt);if(device.supportsUniformBuffers){renderer.setupViewUniformBuffers(lightRenderData.viewBindGroups,this.viewUniformFormat,this.viewBindGroupFormat,1);}if(insideRenderPass){renderer.setupViewport(shadowCam,rt);if(clear){renderer.clear(shadowCam);}}else {renderer.clearView(shadowCam,rt,true,false);}this.setupRenderState(device,light);this.submitCasters(lightRenderData.visibleCasters,light);}render(light,camera,insideRenderPass=true){if(this.needsShadowRendering(light)){const faceCount=light.numShadowFaces;for(let face=0;face<faceCount;face++){this.prepareFace(light,camera,face);this.renderFace(light,camera,face,true,insideRenderPass);}this.renderVsm(light,camera);}}renderVsm(light,camera){if(light._isVsm&&light._vsmBlurSize>1){const isClustered=this.renderer.scene.clusteredLightingEnabled;if(!isClustered||light._type===LIGHTTYPE_DIRECTIONAL){this.applyVsmBlur(light,camera);}}}getVsmBlurShader(isVsm8,blurMode,filterSize){let blurShader=(isVsm8?this.blurPackedVsmShader:this.blurVsmShader)[blurMode][filterSize];if(!blurShader){this.blurVsmWeights[filterSize]=gaussWeights(filterSize);const blurVS=shaderChunks.fullscreenQuadVS;let blurFS=`#define SAMPLES ${filterSize}
`;if(isVsm8){blurFS+=this.blurPackedVsmShaderCode[blurMode];}else {blurFS+=this.blurVsmShaderCode[blurMode];}const blurShaderName=`blurVsm${blurMode}${filterSize}${isVsm8}`;blurShader=createShaderFromCode(this.device,blurVS,blurFS,blurShaderName);if(isVsm8){this.blurPackedVsmShader[blurMode][filterSize]=blurShader;}else {this.blurVsmShader[blurMode][filterSize]=blurShader;}}return blurShader}applyVsmBlur(light,camera){const device=this.device;device.setBlendState(BlendState.NOBLEND);const lightRenderData=light.getRenderData(light._type===LIGHTTYPE_DIRECTIONAL?camera:null,0);const shadowCam=lightRenderData.shadowCamera;const origShadowMap=shadowCam.renderTarget;const tempShadowMap=this.renderer.shadowMapCache.get(device,light);const tempRt=tempShadowMap.renderTargets[0];const isVsm8=light._shadowType===SHADOW_VSM8;const blurMode=light.vsmBlurMode;const filterSize=light._vsmBlurSize;const blurShader=this.getVsmBlurShader(isVsm8,blurMode,filterSize);blurScissorRect.z=light._shadowResolution-2;blurScissorRect.w=blurScissorRect.z;this.sourceId.setValue(origShadowMap.colorBuffer);pixelOffset[0]=1/light._shadowResolution;pixelOffset[1]=0;this.pixelOffsetId.setValue(pixelOffset);if(blurMode===BLUR_GAUSSIAN)this.weightId.setValue(this.blurVsmWeights[filterSize]);drawQuadWithShader(device,tempRt,blurShader,null,blurScissorRect);this.sourceId.setValue(tempRt.colorBuffer);pixelOffset[1]=pixelOffset[0];pixelOffset[0]=0;this.pixelOffsetId.setValue(pixelOffset);drawQuadWithShader(device,origShadowMap,blurShader,null,blurScissorRect);this.renderer.shadowMapCache.add(light,tempShadowMap);}initViewBindGroupFormat(){if(this.device.supportsUniformBuffers&&!this.viewUniformFormat){this.viewUniformFormat=new UniformBufferFormat(this.device,[new UniformFormat("matrix_viewProjection",UNIFORMTYPE_MAT4)]);this.viewBindGroupFormat=new BindGroupFormat(this.device,[new BindUniformBufferFormat(UNIFORM_BUFFER_DEFAULT_SLOT_NAME,SHADERSTAGE_VERTEX|SHADERSTAGE_FRAGMENT)]);}}frameUpdate(){this.initViewBindGroupFormat();}constructor(renderer,lightTextureAtlas){this.shadowPassCache=[];this.device=renderer.device;this.renderer=renderer;this.lightTextureAtlas=lightTextureAtlas;const scope=this.device.scope;this.polygonOffsetId=scope.resolve("polygonOffset");this.polygonOffset=new Float32Array(2);this.sourceId=scope.resolve("source");this.pixelOffsetId=scope.resolve("pixelOffset");this.weightId=scope.resolve("weight[0]");this.blurVsmShaderCode=[shaderChunks.blurVSMPS,`#define GAUSS
${shaderChunks.blurVSMPS}`];const packed="#define PACKED\n";this.blurPackedVsmShaderCode=[packed+this.blurVsmShaderCode[0],packed+this.blurVsmShaderCode[1]];this.blurVsmShader=[{},{}];this.blurPackedVsmShader=[{},{}];this.blurVsmWeights={};this.shadowMapLightRadiusId=scope.resolve("light_radius");this.viewUniformFormat=null;this.viewBindGroupFormat=null;this.blendStateWrite=new BlendState;this.blendStateNoWrite=new BlendState;this.blendStateNoWrite.setColorWrite(false,false,false,false);}}const tempClusterArray=[];class WorldClustersAllocator{destroy(){if(this._empty){this._empty.destroy();this._empty=null;}this._allocated.forEach(cluster=>{cluster.destroy();});this._allocated.length=0;}get count(){return this._allocated.length}get empty(){if(!this._empty){const empty=new WorldClusters(this.device);empty.name="ClusterEmpty";empty.update([],false,null);this._empty=empty;}return this._empty}assign(renderPasses){const empty=this.empty;tempClusterArray.push(...this._allocated);this._allocated.length=0;this._clusters.clear();const passCount=renderPasses.length;for(let p=0;p<passCount;p++){const renderPass=renderPasses[p];const renderActions=renderPass.renderActions;if(renderActions){const count=renderActions.length;for(let i=0;i<count;i++){const ra=renderActions[i];ra.lightClusters=null;const layer=ra.layer;if(layer.hasClusteredLights&&layer.meshInstances.length){const hash=layer.getLightIdHash();const existingRenderAction=this._clusters.get(hash);let clusters=existingRenderAction==null?void 0:existingRenderAction.lightClusters;if(!clusters){var _tempClusterArray$pop;clusters=(_tempClusterArray$pop=tempClusterArray.pop())!=null?_tempClusterArray$pop:new WorldClusters(this.device);this._allocated.push(clusters);this._clusters.set(hash,ra);}ra.lightClusters=clusters;}if(!ra.lightClusters){ra.lightClusters=empty;}}}}tempClusterArray.forEach(item=>item.destroy());tempClusterArray.length=0;}update(renderPasses,gammaCorrection,lighting){this.assign(renderPasses);this._clusters.forEach(renderAction=>{const layer=renderAction.layer;const cluster=renderAction.lightClusters;cluster.update(layer.clusteredLightsSet,gammaCorrection,lighting);});}constructor(graphicsDevice){this._empty=null;this._allocated=[];this._clusters=new Map;this.device=graphicsDevice;}}const textureBlitVertexShader$1=`
	attribute vec2 vertex_position;
	varying vec2 uv0;
	void main(void) {
		gl_Position = vec4(vertex_position, 0.5, 1.0);
		uv0 = vertex_position.xy * 0.5 + 0.5;
		#ifndef WEBGPU
			uv0.y = 1.0 - uv0.y;
		#endif
	}`;const textureBlitFragmentShader$1=`
	varying vec2 uv0;
	uniform sampler2D blitTexture;
	void main(void) {
		gl_FragColor = texture2D(blitTexture, uv0);
	}`;const textureCubeBlitFragmentShader=`
	varying vec2 uv0;
	uniform samplerCube blitTexture;
	uniform mat4 invViewProj;
	void main(void) {
		vec4 projPos = vec4(uv0 * 2.0 - 1.0, 0.5, 1.0);
		vec4 worldPos = invViewProj * projPos;
		gl_FragColor = textureCube(blitTexture, worldPos.xyz);
	}`;const _viewport$2=new Vec4;const _invViewProjMatrices=[];class RenderPassCookieRenderer extends RenderPass{destroy(){var _this$_quadRenderer2D,_this$_quadRendererCu;(_this$_quadRenderer2D=this._quadRenderer2D)==null||_this$_quadRenderer2D.destroy();this._quadRenderer2D=null;(_this$_quadRendererCu=this._quadRendererCube)==null||_this$_quadRendererCu.destroy();this._quadRendererCube=null;}static create(renderTarget,cubeSlotsOffsets){const renderPass=new RenderPassCookieRenderer(renderTarget.device,cubeSlotsOffsets);renderPass.init(renderTarget);renderPass.colorOps.clear=false;renderPass.depthStencilOps.clearDepth=false;return renderPass}update(lights){const filteredLights=this._filteredLights;this.filter(lights,filteredLights);this.executeEnabled=filteredLights.length>0;}filter(lights,filteredLights){for(let i=0;i<lights.length;i++){const light=lights[i];if(light._type===LIGHTTYPE_DIRECTIONAL){continue}if(!light.atlasViewportAllocated){continue}if(!light.atlasSlotUpdated){continue}if(light.enabled&&light.cookie&&light.visibleThisFrame){filteredLights.push(light);}}}initInvViewProjMatrices(){if(!_invViewProjMatrices.length){for(let face=0;face<6;face++){const camera=LightCamera.create(null,LIGHTTYPE_OMNI,face);const projMat=camera.projectionMatrix;const viewMat=camera.node.getLocalTransform().clone().invert();_invViewProjMatrices[face]=new Mat4().mul2(projMat,viewMat).invert();}}}get quadRenderer2D(){if(!this._quadRenderer2D){const shader=createShaderFromCode(this.device,textureBlitVertexShader$1,textureBlitFragmentShader$1,"cookieRenderer2d");this._quadRenderer2D=new QuadRender(shader);}return this._quadRenderer2D}get quadRendererCube(){if(!this._quadRendererCube){const shader=createShaderFromCode(this.device,textureBlitVertexShader$1,textureCubeBlitFragmentShader,"cookieRendererCube");this._quadRendererCube=new QuadRender(shader);}return this._quadRendererCube}execute(){const device=this.device;device.setBlendState(BlendState.NOBLEND);device.setCullMode(CULLFACE_NONE);device.setDepthState(DepthState.NODEPTH);device.setStencilState();const renderTargetWidth=this.renderTarget.colorBuffer.width;const cubeSlotsOffsets=this._cubeSlotsOffsets;const filteredLights=this._filteredLights;for(let i=0;i<filteredLights.length;i++){const light=filteredLights[i];const faceCount=light.numShadowFaces;const quad=faceCount>1?this.quadRendererCube:this.quadRenderer2D;if(faceCount>1){this.initInvViewProjMatrices();}this.blitTextureId.setValue(light.cookie);for(let face=0;face<faceCount;face++){_viewport$2.copy(light.atlasViewport);if(faceCount>1){const smallSize=_viewport$2.z/3;const offset=cubeSlotsOffsets[face];_viewport$2.x+=smallSize*offset.x;_viewport$2.y+=smallSize*offset.y;_viewport$2.z=smallSize;_viewport$2.w=smallSize;this.invViewProjId.setValue(_invViewProjMatrices[face].data);}_viewport$2.mulScalar(renderTargetWidth);quad.render(_viewport$2);}}filteredLights.length=0;}constructor(device,cubeSlotsOffsets){super(device);this._quadRenderer2D=null;this._quadRendererCube=null;this._filteredLights=[];this._cubeSlotsOffsets=cubeSlotsOffsets;this.requiresCubemaps=false;this.blitTextureId=device.scope.resolve("blitTexture");this.invViewProjId=device.scope.resolve("invViewProj");}}class RenderPassShadowLocalClustered extends RenderPass{update(localLights){const shadowLights=this.shadowRendererLocal.shadowLights;const shadowCamera=this.shadowRendererLocal.prepareLights(shadowLights,localLights);const count=shadowLights.length;this.enabled=count>0;if(count){this.shadowRenderer.setupRenderPass(this,shadowCamera,false);}}execute(){const shadowLights=this.shadowRendererLocal.shadowLights;const count=shadowLights.length;for(let i=0;i<count;i++){const light=shadowLights[i];for(let face=0;face<light.numShadowFaces;face++){this.shadowRenderer.renderFace(light,null,face,true);}}shadowLights.length=0;}constructor(device,shadowRenderer,shadowRendererLocal){super(device);this.requiresCubemaps=false;this.shadowRenderer=shadowRenderer;this.shadowRendererLocal=shadowRendererLocal;}}class RenderPassUpdateClustered extends RenderPass{update(frameGraph,shadowsEnabled,cookiesEnabled,lights,localLights){this.frameGraph=frameGraph;this.cookiesRenderPass.enabled=cookiesEnabled;if(cookiesEnabled){this.cookiesRenderPass.update(lights);}this.shadowRenderPass.enabled=shadowsEnabled;if(shadowsEnabled){this.shadowRenderPass.update(localLights);}}destroy(){this.cookiesRenderPass.destroy();this.cookiesRenderPass=null;}execute(){const{renderer}=this;const{scene}=renderer;renderer.worldClustersAllocator.update(this.frameGraph.renderPasses,scene.gammaCorrection,scene.lighting);}constructor(device,renderer,shadowRenderer,shadowRendererLocal,lightTextureAtlas){super(device);this.renderer=renderer;this.frameGraph=null;this.cookiesRenderPass=RenderPassCookieRenderer.create(lightTextureAtlas.cookieRenderTarget,lightTextureAtlas.cubeSlotsOffsets);this.beforePasses.push(this.cookiesRenderPass);this.shadowRenderPass=new RenderPassShadowLocalClustered(device,shadowRenderer,shadowRendererLocal);this.beforePasses.push(this.shadowRenderPass);}}const base64String="muPIHORMLNDCz4DxVR/ZvYfAUVEFR47KRIC4nwAAAAAP7WxlhD6Ci+2HCe7BF8jRAPZwdH2UPpI5PdLCJdkvG4UTaNDJ/0crAzne71GCrb4kbdMjjCEGzdX6fNxDMLJq5xkeoIVTdfiZkodEeArmZmp/FQzFjD4x8iOW7Dg64n+3mWqyEwLxXT8zoJXfbw8QJKDCaarUYyTlMzNFHbgUe9IQV7g4YOgtSKpIFZJ0qERm7u4PpmiF89ktHWCywaGmD6h+hfh2/Zd8KYlKqqo4Cem4T42bT/Z9FpCQF1hhSjfBzZ5XFn/y3jegWC6u86KuELRundQS/1Rp+XuKKGIgRv3CvP5y749yqLlFO495JOT3+f2CXgd71npU0/KjjpkZucbJ5m78IVyuSrSozc9jgBUhDrz0hFsyb7LFUH9//wJbBgLdNWJZObfKxrNt8TliLA9w9sXFv6g26iXpf6r/BqcAusj/QzGBZuoUGeEtw8BCXCZ3jUiw4hvM18ZVqlUD3C40LAFXW6FRjuAZGRNstb0/qVk4skwyT+MHrvRorI4rKHVMWZmKyAkzL/78u/9pMQuX14pZN50b2PHn6fRxeaCQLsfT4dpvIkWWFuFVENZIh+8xgR6lU+85W0PPdAu1j99kcCG40JBQa4JMyRzq6qriOBLtqF87vpCJan0WEduVr/mOYkS00urVA0mA6M3031+GmGmW48PaJDYOEIb3bIXWPaLoAOEinX1TN3+/vwhG6nqJu0TdHpedS7QsGZIoxH3nQYYjQP1jmbahlbNngw5ogsGk1y50XZyUmQBY+/JBJ3Unu4dApm+WmPwHPU9gLb+4mHh4BiY6M86pq+WeTyWdI3s0CXPEtHGXZ8zMZgUoyRomBi1VdazzuN+WOmQ9Pa0Z0tlNopUi8AJ4x2Xn4mmOKEbXLxlbVsWu8XhuDGYFOGCRVdSqDPXrHU5SDdUlti3k5///SBwzTMwK3L4a1H7w4lnpEas6////AfX8asyIBfeFXVJ3tgvxQ/blZuUKyIODIfr/UzdWNu7pciLBpdZRZ4pIfZ1R6szq+XNxkGG///8EZFpu7VHAhFWqHEOrB9unw+YQa5o8/9IR/V5/zq+986rJSyfgJKt2u9hxU1wzyQWPjJGvzG9+eWWxGFOHVKqI4jBQALwZZswesnvZ2UmmkEXdiRpz8B+oWE7PY70ZTMndisYSXg2TqoI+3y9BxbnY2Y4EfbdcRhAvG59NqDENNYbxKvK5HJfPG5M+Wi2AcpLVJrD6caiEOzgSoVNSgQK8fm2M3zGcF4xtClv/8Hs9oD7C3jitTATYNQxmKqKf1LhIxzf1bmfiNn7UKFmcJu4sLqVLwxGSue3taBEyknkw5hXTsUCvqmmL/f8n/w0giR7Hu/9EHvpkz3yuu64TioMkzdTJ30i0+hFnQqW1+v9mMwq+z9qGX0UFu9MomvVG2xod6vc12AAAAACq7sGa5qptFR0jF3nQt/D+7PibKYahaxP3hEixPbGi9nwNf2LAa7LkEZRKxzXeCD64Xpii5n+8Kpg8eHIv7AWXZltgMoGltmoJ0XGdOCL8WkzphvR9N2o3ARSZ42l5e5Pe4B58MCRlP3EKv+mcloknH+fto5BWsmEutW6KvjOVsznFCktkSczVk4aGvj9VXlRcLeDoKG8RkBgdcNG2bf8HUL4MT2DM+ar7NImJhKpxakX4Vk0CnP+/XNhl5UsP0lXgeZXPoDBMSW5An+DXlTCO5FQGwSPYwHLKYVIimEdAoVe49rQLaaNcye5LxU2/c5TijTgJtD5eQQIe1snxauj5jZsxJBUJdoP/zqpjqv8qBruoPsVsP8N44PCUW5Dd0DzqjSS/Dl5mI9cn1w2ndN/0KAEm1QAAAACwu6KM/083IBbH5bPa/9oHUwcU8I9v3j6/v18QYammrf+P6VL///8BrpuM3fOLCxaLNOFNF1zPbPYTP65ni6njft4eVcyrVXRQFrs52tr35StiSp55edVDCBC0H5rIfac6nzUwxQSt7y15QoKb+5zebEQUmVbrPjXuUa19Ey7sqXMiSUKHaw72PJKDdrutJoQr3u6lEYJ8K0MakWKj9zjTFi4X94TsKYco0GrLeB60M6D8M/80rhXUW8iMequg8y5F838WI0+gp3GBN5Kj/xIOxTWQuUaPV/LwvARr1VH93BFgGZR1MFW0Ua30GbYmdnAgo9VWy8SQtpDUgGE2r2zq2eTEMCL7sMKmE1hchVhuF/TCq9iXKEm86kzOf3Rp9ZnCxbpDUj+FKNxVyXe6pVZkRXv/m95SnB/EB8aME29N85MtAcDoXWlor8De2Q5Dg1tar+8wgiZufbMam81j//ASUohoR/zSh2KG4bvT6mkIPz6C5/98DC3LaWlaEZ1zA5JORZRu6J/a0GY285sEYzw71YqOT1ihAG0z5SDt1xNiDQWZdFpndArp6xWhqSDkRb4kSJEHb9liPvw7uLV/6i5MVf//A9Qjr8xkAEUh+KDI+zdtJ68d6MBOktg1iyp/SCq8O9f5pbamn1VVVQPRTWqNBvhQKa07s6P0lc9Luu/3gw4HeyOUfz8MxMwV4UQhua+t9cr4bz/nIB2wnDSK1K7I94M+s6C84htaX/CNlMQUSs2KJO+yaebfTbkNX5yWcqEJevo0vbKUiETuFXiL019A3E+lmsyZMwXrXLLiQAZ5t9+jI3JobhJTMiDH5ZOQ+8Jau5555NMjHSscP9qCVaa40doh+1a3Ukf6jqBmLddgh79/fwTfCyqiuldNkUoy+nUp+4nerwg0OjtGv2x485PJOJvUEokNhYIdWjpx7BWk0VZGWOp3jSFTJ2bnu6KCduZtG/UcBC9RZ3W/jMSfSMw4Etr/DoD/XYP2V5Ovw+YoM3F5g2dGLdvuG6ZkVGLE6Dk5Zr+sdSyGliJP1y2OFf/KFO0RWO+3gsGhesTnfZVpTd8/HwgO216gwaqo+vY3TljfJWowY+i0p0Os4SLn/1wLqDHMlszggmT/D8MRFzs+pLv6LNJSsNZ/r41mWi/rF6ZcKp/yzJdK0VU44hskq3RGpgO6mIpJDsf/mZkFrz0yYOMLbuaj/wp1v7JMFM5eqvBhmTd7U8frQAtHtys4zgpjZmzUhOVTfNNLifElGXADlqHGKrkBT/nYwX8ZRm3RjvyPvjKyEqEGKUpVnvOGx+NKPHiWM//ZDpDVGvvrjmk8RPF/wiYZD3+Us8YCXjrVOfjdd1UPAfjLp8jgSn4me7DPTpz1Ggy9XL80guFO7ECT10AvILKfD18Qx+KY/f8aRqu0oOO8hfKRFZa9PUJwCsp6VdZz6LFkm2b9Pl2LIifCwzRy7TpdG2uAtOxP2OemY26bJMa9ZGSLIRlMsgpDpnDJwd0oa5pQ13x1hrHf52HpulUWonGWsfXZbSQYKu9bnEN76ciQih0opN3deDVrbrxorfVlnCmL1R9zq3ePGWIv21c7pW8kEiFTM5JX8dAw867s/60cf79/BH+MDFCZBHlz1L+qGOJf/1txhhmrf3//As+RIJwevDb+fgNXVeHw67QptZegayhrEwr5Gy+EPo1RLaMtPbqOZYoVzXzwzjMFWZxyUG9YUIf6////AQWy84iAygLk9COtXt92+0mT/xg0zMzMBeLkb8y9SL2TDXgSX422hDgpGNLJyuPioA+YJ91G8znrpNqHkwYyscaJDEc9Vc+j4cXle3hvcd2JqDQH2lBZxDn6mUTs0b75raMvbs727codX01Anj8f3wir9P2xQaQ22v/TxCMglKDFoTjaP01XTLgxnTvPv02JgEUrW6UDgOnobFpLdvKdlypgIzPcq14fgXU5tvVW0FEs7VRlsG1IyA69fN4n+awHhT34cE+xUvdj86C8LgAsFheTjI9Ht9EyYAAAAAAVBVKRx2wLgUTI0/2QfyJo2riRw3JDqzEShmx/Lifo6mRkQVbS7X53t+EvKxcXogtdts31e9MRHdcHgsA8rt4/mt2unlzQ/wsU8Gu7+W6Oj7eD8EQdDp5XlCsVaS/AV/t5ZpPOHR3rGpyAJe9IPV+xMrBL1Oz/8MQhFs31h0N1cVnq371uqIJYHyafKH1jteAK3VpMXBcuC+yt0ZeKyRUY4QhdrJJ4tJ1wg3Hu6kDsbovxupTMkGdRrm8oZSoYPbJ+PwH/xotgTdkA1205vUEfnqkI04T/fnnd1fiZW5AwNcggd7fi4j5zasmcntZexIxqFZQMzMJpfndmI5jn17cgn5EV5t9XN0C///8Q9wlJpMGXdoiaMTG2sVyHQsn8mWRISCLNG777S0OuDRP2GlLcJ2UeOg7Fo8hTNPeJ//iTJhyqxhKRUntdXOihq2wfKfH///8B0GGrwT+fSOQRdctKxjjGCSS11d6BlQ9BDfE0J6Z25FaNTKGpFKNCMr2G/041KpWwBLVe1k08vncseQbKZdXi8x1t9XA45U/Wd43D9wAh3Tal0aiLVzGPusOZ1F+W3TWoqlX/A95+dNef11TsuGful+ctGssldk3fqpfqh+43XTxL42+leSHoF/dWHYGX6maqUEuLX7UB+r/6Llr4LKocbVIeu+hB9QTPfz9fCP8RyWmX4SmbhMFsNtCijV7lVcwejLKlvl0GfCndnWV7/39VBrtTRuUx92oke3GBgKkC5fdGK0YvNK+xenKaDmsHDjNFUM3NMz3ZiXXFuLgojosPVCDEl2W5BjX3Ms+j0GSqACHmh0+RPWyuNm/Qe8vFf9AW7N1uRaxWirrUytqEJnJ4/Flm8hSoiZ2NQBsS6w/yQlC4gCaFo8q4nyY6AFdo4hiwhBXzbNKKvZvktCjSCukRR/BbYVbNwZi2Yh3hGodEacLW8qijiWJODf0P2bhfaiPspPT4lYJBgi/KfcFwCfvyUIgkJOv///8CG/JEepRBLaMFE+2TgrqsJXOVOWHt6g/bFwVLLMVBsMR50dis/39/AlBX+/rMTJkUQrnlxpR2iu0Tp8tATkRYGmDIrcAiRP8PjoWIlb7/0ecTdSCE9Y58+a+n/FovJQTVF4F2jAxMZhTgrM/KVS5BQu6bVbkWY5HXnxRshks3urDdW4RkWp4M4TeLmFK5KF/uHkkiO5Kv96RioH984v/CSDBnG+BwlnU9B+o7Y+0X0Nob+0pLsStxjvPXMy2eCpzhOWV4XbObBHN4UE2sLQ/DIqXhOzxVf38GlTi6aG7EnePO7TRJm9yOfUUcqq1I2iQHrVDqn3TUNRi/lMw8KbMW/3/nqCz/Ef8PoW5Qxcz2yHR/f78EPB2Stbd+ZFmfNTUYILzsb9YNhpaHcaymYrBiNHmFE3Y4ccYJ25Prqm7zHobGHED8/93ZNlWro9vcKivGZs31UiK1k5zjUhexUgbqJb+fUTjxce/7Zly8a5KMC1fX5nfjPgibdvzbXV1jRT2asXvmSAusaLdq1TSIJ8fXINk5AtT34EWPAsfP9IFQqM5K11O6saoHJA==";let data=null;const initData=()=>{if(!data){const binaryString=atob(base64String);data=Uint8Array.from(binaryString,char=>char.charCodeAt(0));}};const blueNoiseData=()=>{initData();return data};class BlueNoise{_next(){this.seed=(this.seed+4)%data.length;}value(){this._next();return data[this.seed]/255}vec4(dest=new Vec4){this._next();return dest.set(data[this.seed],data[this.seed+1],data[this.seed+2],data[this.seed+3]).mulScalar(1/255)}constructor(seed=0){this.seed=0;this.seed=seed*4;initData();}}const createTexture=(device,namePrefix,size,data)=>{const texture=new Texture(device,{name:`${namePrefix}${size}`,width:size,height:size,format:PIXELFORMAT_RGBA8,addressU:ADDRESS_REPEAT,addressV:ADDRESS_REPEAT,type:TEXTURETYPE_DEFAULT,magFilter:FILTER_NEAREST,minFilter:FILTER_NEAREST,anisotropy:1,mipmaps:false});texture.lock().set(data);texture.unlock();return texture};const deviceCacheBlueNoise=new DeviceCache;const getBlueNoiseTexture=device=>{return deviceCacheBlueNoise.get(device,()=>{const data=blueNoiseData();const size=Math.sqrt(data.length/4);return createTexture(device,"BlueNoise",size,data)})};let _skinUpdateIndex=0;const viewProjMat=new Mat4;const viewInvMat=new Mat4;const viewMat=new Mat4;const viewMat3=new Mat3;const tempSphere$1=new BoundingSphere;const _flipYMat=new Mat4().setScale(1,-1,1);const _tempLightSet=new Set;const _tempLayerSet=new Set;const _fixProjRangeMat=new Mat4().set([1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1]);const _haltonSequence=[new Vec2(.5,.333333),new Vec2(.25,.666667),new Vec2(.75,.111111),new Vec2(.125,.444444),new Vec2(.625,.777778),new Vec2(.375,.222222),new Vec2(.875,.555556),new Vec2(.0625,.888889),new Vec2(.5625,.037037),new Vec2(.3125,.37037),new Vec2(.8125,.703704),new Vec2(.1875,.148148),new Vec2(.6875,.481481),new Vec2(.4375,.814815),new Vec2(.9375,.259259),new Vec2(.03125,.592593)];const _tempProjMat0=new Mat4;const _tempProjMat1=new Mat4;const _tempProjMat2=new Mat4;const _tempProjMat3=new Mat4;const _tempProjMat4=new Mat4;const _tempProjMat5=new Mat4;const _tempSet=new Set;const _tempMeshInstances=[];const _tempMeshInstancesSkinned=[];class Renderer{destroy(){this.shadowRenderer=null;this._shadowRendererLocal=null;this._shadowRendererDirectional=null;this.shadowMapCache.destroy();this.shadowMapCache=null;this._renderPassUpdateClustered.destroy();this._renderPassUpdateClustered=null;this.lightTextureAtlas.destroy();this.lightTextureAtlas=null;}sortCompare(drawCallA,drawCallB){if(drawCallA.layer===drawCallB.layer){if(drawCallA.drawOrder&&drawCallB.drawOrder){return drawCallA.drawOrder-drawCallB.drawOrder}else if(drawCallA.zdist&&drawCallB.zdist){return drawCallB.zdist-drawCallA.zdist}else if(drawCallA.zdist2&&drawCallB.zdist2){return drawCallA.zdist2-drawCallB.zdist2}}return drawCallB._key[SORTKEY_FORWARD]-drawCallA._key[SORTKEY_FORWARD]}sortCompareMesh(drawCallA,drawCallB){if(drawCallA.layer===drawCallB.layer){if(drawCallA.drawOrder&&drawCallB.drawOrder){return drawCallA.drawOrder-drawCallB.drawOrder}else if(drawCallA.zdist&&drawCallB.zdist){return drawCallB.zdist-drawCallA.zdist}}const keyA=drawCallA._key[SORTKEY_FORWARD];const keyB=drawCallB._key[SORTKEY_FORWARD];if(keyA===keyB&&drawCallA.mesh&&drawCallB.mesh){return drawCallB.mesh.id-drawCallA.mesh.id}return keyB-keyA}sortCompareDepth(drawCallA,drawCallB){const keyA=drawCallA._key[SORTKEY_DEPTH];const keyB=drawCallB._key[SORTKEY_DEPTH];if(keyA===keyB&&drawCallA.mesh&&drawCallB.mesh){return drawCallB.mesh.id-drawCallA.mesh.id}return keyB-keyA}setupViewport(camera,renderTarget){const device=this.device;const pixelWidth=renderTarget?renderTarget.width:device.width;const pixelHeight=renderTarget?renderTarget.height:device.height;const rect=camera.rect;let x=Math.floor(rect.x*pixelWidth);let y=Math.floor(rect.y*pixelHeight);let w=Math.floor(rect.z*pixelWidth);let h=Math.floor(rect.w*pixelHeight);device.setViewport(x,y,w,h);if(camera._scissorRectClear){const scissorRect=camera.scissorRect;x=Math.floor(scissorRect.x*pixelWidth);y=Math.floor(scissorRect.y*pixelHeight);w=Math.floor(scissorRect.z*pixelWidth);h=Math.floor(scissorRect.w*pixelHeight);}device.setScissor(x,y,w,h);}setCameraUniforms(camera,target){const flipY=target==null?void 0:target.flipY;let viewCount=1;if(camera.xr&&camera.xr.session){var _camera$_node;const transform=((_camera$_node=camera._node)==null||(_camera$_node=_camera$_node.parent)==null?void 0:_camera$_node.getWorldTransform())||null;const views=camera.xr.views;viewCount=views.list.length;for(let v=0;v<viewCount;v++){const view=views.list[v];view.updateTransforms(transform);camera.frustum.setFromMat4(view.projViewOffMat);}}else {let projMat=camera.projectionMatrix;if(camera.calculateProjection){camera.calculateProjection(projMat,VIEW_CENTER);}let projMatSkybox=camera.getProjectionMatrixSkybox();if(flipY){projMat=_tempProjMat0.mul2(_flipYMat,projMat);projMatSkybox=_tempProjMat1.mul2(_flipYMat,projMatSkybox);}if(this.device.isWebGPU){projMat=_tempProjMat2.mul2(_fixProjRangeMat,projMat);projMatSkybox=_tempProjMat3.mul2(_fixProjRangeMat,projMatSkybox);}const{jitter}=camera;let jitterX=0;let jitterY=0;if(jitter>0){const targetWidth=target?target.width:this.device.width;const targetHeight=target?target.height:this.device.height;const offset=_haltonSequence[this.device.renderVersion%_haltonSequence.length];jitterX=jitter*(offset.x*2-1)/targetWidth;jitterY=jitter*(offset.y*2-1)/targetHeight;projMat=_tempProjMat4.copy(projMat);projMat.data[8]=jitterX;projMat.data[9]=jitterY;projMatSkybox=_tempProjMat5.copy(projMatSkybox);projMatSkybox.data[8]=jitterX;projMatSkybox.data[9]=jitterY;if(this.blueNoiseJitterVersion!==this.device.renderVersion){this.blueNoiseJitterVersion=this.device.renderVersion;this.blueNoise.vec4(this.blueNoiseJitterVec);}}const jitterVec=jitter>0?this.blueNoiseJitterVec:Vec4.ZERO;this.blueNoiseJitterData[0]=jitterVec.x;this.blueNoiseJitterData[1]=jitterVec.y;this.blueNoiseJitterData[2]=jitterVec.z;this.blueNoiseJitterData[3]=jitterVec.w;this.blueNoiseJitterId.setValue(this.blueNoiseJitterData);this.projId.setValue(projMat.data);this.projSkyboxId.setValue(projMatSkybox.data);if(camera.calculateTransform){camera.calculateTransform(viewInvMat,VIEW_CENTER);}else {const pos=camera._node.getPosition();const rot=camera._node.getRotation();viewInvMat.setTRS(pos,rot,Vec3.ONE);}this.viewInvId.setValue(viewInvMat.data);viewMat.copy(viewInvMat).invert();this.viewId.setValue(viewMat.data);viewMat3.setFromMat4(viewMat);this.viewId3.setValue(viewMat3.data);viewProjMat.mul2(projMat,viewMat);this.viewProjId.setValue(viewProjMat.data);camera._storeShaderMatrices(viewProjMat,jitterX,jitterY,this.device.renderVersion);this.flipYId.setValue(flipY?-1:1);this.dispatchViewPos(camera._node.getPosition());camera.frustum.setFromMat4(viewProjMat);}this.tbnBasis.setValue(flipY?-1:1);const n=camera._nearClip;const f=camera._farClip;this.nearClipId.setValue(n);this.farClipId.setValue(f);this.cameraParams[0]=1/f;this.cameraParams[1]=f;this.cameraParams[2]=n;this.cameraParams[3]=camera.projection===PROJECTION_ORTHOGRAPHIC?1:0;this.cameraParamsId.setValue(this.cameraParams);this.exposureId.setValue(this.scene.physicalUnits?camera.getExposure():this.scene.exposure);return viewCount}clear(camera,clearColor,clearDepth,clearStencil){const flags=((clearColor!=null?clearColor:camera._clearColorBuffer)?CLEARFLAG_COLOR:0)|((clearDepth!=null?clearDepth:camera._clearDepthBuffer)?CLEARFLAG_DEPTH:0)|((clearStencil!=null?clearStencil:camera._clearStencilBuffer)?CLEARFLAG_STENCIL:0);if(flags){const device=this.device;device.clear({color:[camera._clearColor.r,camera._clearColor.g,camera._clearColor.b,camera._clearColor.a],depth:camera._clearDepth,stencil:camera._clearStencil,flags:flags});}}setCamera(camera,target,clear,renderAction=null){this.setCameraUniforms(camera,target);this.clearView(camera,target,clear,false);}clearView(camera,target,clear,forceWrite){const device=this.device;device.setRenderTarget(target);device.updateBegin();if(forceWrite){device.setColorWrite(true,true,true,true);device.setDepthWrite(true);}this.setupViewport(camera,target);if(clear){const options=camera._clearOptions;device.clear(options?options:{color:[camera._clearColor.r,camera._clearColor.g,camera._clearColor.b,camera._clearColor.a],depth:camera._clearDepth,flags:(camera._clearColorBuffer?CLEARFLAG_COLOR:0)|(camera._clearDepthBuffer?CLEARFLAG_DEPTH:0)|(camera._clearStencilBuffer?CLEARFLAG_STENCIL:0),stencil:camera._clearStencil});}}setupCullMode(cullFaces,flipFactor,drawCall){const material=drawCall.material;let mode=CULLFACE_NONE;if(cullFaces){let flipFaces=1;if(material.cull===CULLFACE_FRONT||material.cull===CULLFACE_BACK){flipFaces=flipFactor*drawCall.flipFacesFactor*drawCall.node.worldScaleSign;}if(flipFaces<0){mode=material.cull===CULLFACE_FRONT?CULLFACE_BACK:CULLFACE_FRONT;}else {mode=material.cull;}}this.device.setCullMode(mode);if(mode===CULLFACE_NONE&&material.cull===CULLFACE_NONE){this.twoSidedLightingNegScaleFactorId.setValue(drawCall.node.worldScaleSign);}}updateCameraFrustum(camera){if(camera.xr&&camera.xr.views.list.length){const view=camera.xr.views.list[0];viewProjMat.mul2(view.projMat,view.viewOffMat);camera.frustum.setFromMat4(viewProjMat);return}const projMat=camera.projectionMatrix;if(camera.calculateProjection){camera.calculateProjection(projMat,VIEW_CENTER);}if(camera.calculateTransform){camera.calculateTransform(viewInvMat,VIEW_CENTER);}else {const pos=camera._node.getPosition();const rot=camera._node.getRotation();viewInvMat.setTRS(pos,rot,Vec3.ONE);this.viewInvId.setValue(viewInvMat.data);}viewMat.copy(viewInvMat).invert();viewProjMat.mul2(projMat,viewMat);camera.frustum.setFromMat4(viewProjMat);}setBaseConstants(device,material){device.setCullMode(material.cull);if(material.opacityMap){this.opacityMapId.setValue(material.opacityMap);}if(material.opacityMap||material.alphaTest>0){this.alphaTestId.setValue(material.alphaTest);}}updateCpuSkinMatrices(drawCalls){_skinUpdateIndex++;const drawCallsCount=drawCalls.length;if(drawCallsCount===0)return;for(let i=0;i<drawCallsCount;i++){const si=drawCalls[i].skinInstance;if(si){si.updateMatrices(drawCalls[i].node,_skinUpdateIndex);si._dirty=true;}}}updateGpuSkinMatrices(drawCalls){for(const drawCall of drawCalls){const skin=drawCall.skinInstance;if(skin&&skin._dirty){skin.updateMatrixPalette(drawCall.node,_skinUpdateIndex);skin._dirty=false;}}}updateMorphing(drawCalls){for(const drawCall of drawCalls){const morphInst=drawCall.morphInstance;if(morphInst&&morphInst._dirty){morphInst.update();}}}updateGSplats(drawCalls){for(const drawCall of drawCalls){var _drawCall$gsplatInsta;(_drawCall$gsplatInsta=drawCall.gsplatInstance)==null||_drawCall$gsplatInsta.update();}}gpuUpdate(drawCalls){this.updateGpuSkinMatrices(drawCalls);this.updateMorphing(drawCalls);this.updateGSplats(drawCalls);}setVertexBuffers(device,mesh){device.setVertexBuffer(mesh.vertexBuffer);}setMorphing(device,morphInstance){if(morphInstance){if(morphInstance.morph.useTextureMorph){device.setVertexBuffer(morphInstance.morph.vertexBufferIds);this.morphPositionTex.setValue(morphInstance.texturePositions);this.morphNormalTex.setValue(morphInstance.textureNormals);this.morphTexParams.setValue(morphInstance._textureParams);}else {for(let t=0;t<morphInstance._activeVertexBuffers.length;t++){const vb=morphInstance._activeVertexBuffers[t];if(vb){const semantic=SEMANTIC_ATTR+(t+8);vb.format.elements[0].name=semantic;vb.format.elements[0].scopeId=device.scope.resolve(semantic);vb.format.update();device.setVertexBuffer(vb);}}this.morphWeightsA.setValue(morphInstance._shaderMorphWeightsA);this.morphWeightsB.setValue(morphInstance._shaderMorphWeightsB);}}}setSkinning(device,meshInstance){const skinInstance=meshInstance.skinInstance;if(skinInstance){this._skinDrawCalls++;if(device.supportsBoneTextures){const boneTexture=skinInstance.boneTexture;this.boneTextureId.setValue(boneTexture);this.boneTextureSizeId.setValue(skinInstance.boneTextureSize);}else {this.poseMatrixId.setValue(skinInstance.matrixPalette);}}}dispatchViewPos(position){const vp=this.viewPos;vp[0]=position.x;vp[1]=position.y;vp[2]=position.z;this.viewPosId.setValue(vp);}initViewBindGroupFormat(isClustered){if(this.device.supportsUniformBuffers&&!this.viewUniformFormat){const uniforms=[new UniformFormat("matrix_viewProjection",UNIFORMTYPE_MAT4),new UniformFormat("cubeMapRotationMatrix",UNIFORMTYPE_MAT3),new UniformFormat("view_position",UNIFORMTYPE_VEC3),new UniformFormat("skyboxIntensity",UNIFORMTYPE_FLOAT),new UniformFormat("exposure",UNIFORMTYPE_FLOAT),new UniformFormat("textureBias",UNIFORMTYPE_FLOAT)];if(isClustered){uniforms.push(...[new UniformFormat("clusterCellsCountByBoundsSize",UNIFORMTYPE_VEC3),new UniformFormat("clusterTextureSize",UNIFORMTYPE_VEC3),new UniformFormat("clusterBoundsMin",UNIFORMTYPE_VEC3),new UniformFormat("clusterBoundsDelta",UNIFORMTYPE_VEC3),new UniformFormat("clusterCellsDot",UNIFORMTYPE_VEC3),new UniformFormat("clusterCellsMax",UNIFORMTYPE_VEC3),new UniformFormat("clusterCompressionLimit0",UNIFORMTYPE_VEC2),new UniformFormat("shadowAtlasParams",UNIFORMTYPE_VEC2),new UniformFormat("clusterMaxCells",UNIFORMTYPE_INT),new UniformFormat("clusterSkip",UNIFORMTYPE_FLOAT)]);}this.viewUniformFormat=new UniformBufferFormat(this.device,uniforms);const formats=[new BindUniformBufferFormat(UNIFORM_BUFFER_DEFAULT_SLOT_NAME,SHADERSTAGE_VERTEX|SHADERSTAGE_FRAGMENT),new BindTextureFormat("lightsTextureFloat",SHADERSTAGE_FRAGMENT,TEXTUREDIMENSION_2D,SAMPLETYPE_UNFILTERABLE_FLOAT),new BindTextureFormat("lightsTexture8",SHADERSTAGE_FRAGMENT,TEXTUREDIMENSION_2D,SAMPLETYPE_UNFILTERABLE_FLOAT),new BindTextureFormat("shadowAtlasTexture",SHADERSTAGE_FRAGMENT,TEXTUREDIMENSION_2D,SAMPLETYPE_DEPTH),new BindTextureFormat("cookieAtlasTexture",SHADERSTAGE_FRAGMENT,TEXTUREDIMENSION_2D,SAMPLETYPE_FLOAT),new BindTextureFormat("areaLightsLutTex1",SHADERSTAGE_FRAGMENT,TEXTUREDIMENSION_2D,SAMPLETYPE_FLOAT),new BindTextureFormat("areaLightsLutTex2",SHADERSTAGE_FRAGMENT,TEXTUREDIMENSION_2D,SAMPLETYPE_FLOAT)];if(isClustered){formats.push(...[new BindTextureFormat("clusterWorldTexture",SHADERSTAGE_FRAGMENT,TEXTUREDIMENSION_2D,SAMPLETYPE_UNFILTERABLE_FLOAT)]);}this.viewBindGroupFormat=new BindGroupFormat(this.device,formats);}}setupViewUniformBuffers(viewBindGroups,viewUniformFormat,viewBindGroupFormat,viewCount){const device=this.device;while(viewBindGroups.length<viewCount){const ub=new UniformBuffer(device,viewUniformFormat,false);const bg=new BindGroup(device,viewBindGroupFormat,ub);viewBindGroups.push(bg);}const viewBindGroup=viewBindGroups[0];viewBindGroup.defaultUniformBuffer.update();viewBindGroup.update();device.setBindGroup(BINDGROUP_VIEW,viewBindGroup);}setupMeshUniformBuffers(shaderInstance,meshInstance){const device=this.device;if(device.supportsUniformBuffers){this.modelMatrixId.setValue(meshInstance.node.worldTransform.data);this.normalMatrixId.setValue(meshInstance.node.normalMatrix.data);const meshBindGroup=shaderInstance.getBindGroup(device);meshBindGroup.defaultUniformBuffer.update();meshBindGroup.update();device.setBindGroup(BINDGROUP_MESH,meshBindGroup);}}drawInstance(device,meshInstance,mesh,style,normal){const modelMatrix=meshInstance.node.worldTransform;this.modelMatrixId.setValue(modelMatrix.data);if(normal){this.normalMatrixId.setValue(meshInstance.node.normalMatrix.data);}const instancingData=meshInstance.instancingData;if(instancingData){if(instancingData.count>0){this._instancedDrawCalls++;device.setVertexBuffer(instancingData.vertexBuffer);device.draw(mesh.primitive[style],instancingData.count);}else {device.clearVertexBuffer();}}else {device.draw(mesh.primitive[style]);}}drawInstance2(device,meshInstance,mesh,style){const instancingData=meshInstance.instancingData;if(instancingData){if(instancingData.count>0){this._instancedDrawCalls++;device.draw(mesh.primitive[style],instancingData.count,true);}else {device.clearVertexBuffer();}}else {device.draw(mesh.primitive[style],undefined,true);}}cull(camera,drawCalls,culledInstances){const opaque=culledInstances.opaque;opaque.length=0;const transparent=culledInstances.transparent;transparent.length=0;const doCull=camera.frustumCulling;const count=drawCalls.length;for(let i=0;i<count;i++){const drawCall=drawCalls[i];if(drawCall.visible){const visible=!doCull||!drawCall.cull||drawCall._isVisible(camera);if(visible){drawCall.visibleThisFrame=true;const bucket=drawCall.transparent?transparent:opaque;bucket.push(drawCall);if(drawCall.skinInstance||drawCall.morphInstance||drawCall.gsplatInstance){this.processingMeshInstances.add(drawCall);if(drawCall.gsplatInstance){drawCall.gsplatInstance.cameras.push(camera);}}}}}}collectLights(comp){this.lights.length=0;this.localLights.length=0;const stats=this.scene._stats;const count=comp.layerList.length;for(let i=0;i<count;i++){const layer=comp.layerList[i];if(!_tempLayerSet.has(layer)){_tempLayerSet.add(layer);const lights=layer._lights;for(let j=0;j<lights.length;j++){const light=lights[j];if(!_tempLightSet.has(light)){_tempLightSet.add(light);this.lights.push(light);if(light._type!==LIGHTTYPE_DIRECTIONAL){this.localLights.push(light);}}}}}stats.lights=this.lights.length;_tempLightSet.clear();_tempLayerSet.clear();}cullLights(camera,lights){const clusteredLightingEnabled=this.scene.clusteredLightingEnabled;const physicalUnits=this.scene.physicalUnits;for(let i=0;i<lights.length;i++){const light=lights[i];if(light.enabled){if(light._type!==LIGHTTYPE_DIRECTIONAL){light.getBoundingSphere(tempSphere$1);if(camera.frustum.containsSphere(tempSphere$1)){light.visibleThisFrame=true;light.usePhysicalUnits=physicalUnits;const screenSize=camera.getScreenSize(tempSphere$1);light.maxScreenSize=Math.max(light.maxScreenSize,screenSize);}else {if(!clusteredLightingEnabled){if(light.castShadows&&!light.shadowMap){light.visibleThisFrame=true;}}}}else {light.usePhysicalUnits=this.scene.physicalUnits;}}}}cullShadowmaps(comp){const isClustered=this.scene.clusteredLightingEnabled;for(let i=0;i<this.localLights.length;i++){const light=this.localLights[i];if(light._type!==LIGHTTYPE_DIRECTIONAL){if(isClustered){if(light.atlasSlotUpdated&&light.shadowUpdateMode===SHADOWUPDATE_NONE){light.shadowUpdateMode=SHADOWUPDATE_THISFRAME;}}else {if(light.shadowUpdateMode===SHADOWUPDATE_NONE&&light.castShadows){if(!light.getRenderData(null,0).shadowCamera.renderTarget){light.shadowUpdateMode=SHADOWUPDATE_THISFRAME;}}}if(light.visibleThisFrame&&light.castShadows&&light.shadowUpdateMode!==SHADOWUPDATE_NONE){this._shadowRendererLocal.cull(light,comp);}}}this.cameraDirShadowLights.clear();const cameras=comp.cameras;for(let i=0;i<cameras.length;i++){const cameraComponent=cameras[i];if(cameraComponent.enabled){const camera=cameraComponent.camera;let lightList;const cameraLayers=camera.layers;for(let l=0;l<cameraLayers.length;l++){const cameraLayer=comp.getLayerById(cameraLayers[l]);if(cameraLayer){const layerDirLights=cameraLayer.splitLights[LIGHTTYPE_DIRECTIONAL];for(let j=0;j<layerDirLights.length;j++){const light=layerDirLights[j];if(light.castShadows&&!_tempSet.has(light)){var _lightList;_tempSet.add(light);lightList=(_lightList=lightList)!=null?_lightList:[];lightList.push(light);this._shadowRendererDirectional.cull(light,comp,camera);}}}}if(lightList){this.cameraDirShadowLights.set(camera,lightList);}_tempSet.clear();}}}cullComposition(comp){this.processingMeshInstances.clear();const numCameras=comp.cameras.length;for(let i=0;i<numCameras;i++){const camera=comp.cameras[i];let currentRenderTarget;let cameraChanged=true;this._camerasRendered++;const layerIds=camera.layers;for(let j=0;j<layerIds.length;j++){const layer=comp.getLayerById(layerIds[j]);if(layer&&layer.enabled){var _camera$renderTarget;const renderTarget=(_camera$renderTarget=camera.renderTarget)!=null?_camera$renderTarget:layer.renderTarget;if(cameraChanged||renderTarget!==currentRenderTarget){cameraChanged=false;currentRenderTarget=renderTarget;camera.frameUpdate(renderTarget);this.updateCameraFrustum(camera.camera);}this.cullLights(camera.camera,layer._lights);layer.onPreCull==null||layer.onPreCull(comp.camerasMap.get(camera));const culledInstances=layer.getCulledInstances(camera.camera);this.cull(camera.camera,layer.meshInstances,culledInstances);layer.onPostCull==null||layer.onPostCull(comp.camerasMap.get(camera));}}}if(this.scene.clusteredLightingEnabled){this.updateLightTextureAtlas();}this.cullShadowmaps(comp);}updateShaders(drawCalls,onlyLitShaders){const count=drawCalls.length;for(let i=0;i<count;i++){const mat=drawCalls[i].material;if(mat){if(!_tempSet.has(mat)){_tempSet.add(mat);if(mat.getShaderVariant!==Material.prototype.getShaderVariant){if(onlyLitShaders){if(!mat.useLighting||mat.emitter&&!mat.emitter.lighting){continue}}mat.clearVariants();}}}}_tempSet.clear();}updateFrameUniforms(){this.blueNoiseTextureId.setValue(getBlueNoiseTexture(this.device));}beginFrame(comp){const scene=this.scene;const updateShaders=scene.updateShaders;const layers=comp.layerList;const layerCount=layers.length;for(let i=0;i<layerCount;i++){const layer=layers[i];const meshInstances=layer.meshInstances;const count=meshInstances.length;for(let j=0;j<count;j++){const meshInst=meshInstances[j];meshInst.visibleThisFrame=false;if(updateShaders){_tempMeshInstances.push(meshInst);}if(meshInst.skinInstance){_tempMeshInstancesSkinned.push(meshInst);}}}if(updateShaders){const onlyLitShaders=!scene.updateShaders;this.updateShaders(_tempMeshInstances,onlyLitShaders);scene.updateShaders=false;scene._shaderVersion++;}this.updateFrameUniforms();this.updateCpuSkinMatrices(_tempMeshInstancesSkinned);_tempMeshInstances.length=0;_tempMeshInstancesSkinned.length=0;const lights=this.lights;const lightCount=lights.length;for(let i=0;i<lightCount;i++){lights[i].beginFrame();}}updateLightTextureAtlas(){this.lightTextureAtlas.update(this.localLights,this.scene.lighting);}updateLayerComposition(comp){const len=comp.layerList.length;for(let i=0;i<len;i++){comp.layerList[i]._postRenderCounter=0;}const scene=this.scene;const shaderVersion=scene._shaderVersion;for(let i=0;i<len;i++){const layer=comp.layerList[i];layer._shaderVersion=shaderVersion;layer._preRenderCalledForCameras=0;layer._postRenderCalledForCameras=0;const transparent=comp.subLayerList[i];if(transparent){layer._postRenderCounter|=2;}else {layer._postRenderCounter|=1;}layer._postRenderCounterMax=layer._postRenderCounter;}comp._update();}frameUpdate(){this.clustersDebugRendered=false;this.initViewBindGroupFormat(this.scene.clusteredLightingEnabled);this.dirLightShadows.clear();}constructor(graphicsDevice){this.clustersDebugRendered=false;this.processingMeshInstances=new Set;this.worldClustersAllocator=void 0;this.lights=[];this.localLights=[];this.cameraDirShadowLights=new Map;this.dirLightShadows=new Map;this.blueNoise=new BlueNoise(123);this.device=graphicsDevice;this.scene=null;this.worldClustersAllocator=new WorldClustersAllocator(graphicsDevice);this.lightTextureAtlas=new LightTextureAtlas(graphicsDevice);this.shadowMapCache=new ShadowMapCache;this.shadowRenderer=new ShadowRenderer(this,this.lightTextureAtlas);this._shadowRendererLocal=new ShadowRendererLocal(this,this.shadowRenderer);this._shadowRendererDirectional=new ShadowRendererDirectional(this,this.shadowRenderer);this._renderPassUpdateClustered=new RenderPassUpdateClustered(this.device,this,this.shadowRenderer,this._shadowRendererLocal,this.lightTextureAtlas);this.viewUniformFormat=null;this.viewBindGroupFormat=null;this._skinTime=0;this._morphTime=0;this._cullTime=0;this._shadowMapTime=0;this._lightClustersTime=0;this._layerCompositionUpdateTime=0;this._shadowDrawCalls=0;this._skinDrawCalls=0;this._instancedDrawCalls=0;this._shadowMapUpdates=0;this._numDrawCallsCulled=0;this._camerasRendered=0;this._lightClusters=0;const scope=graphicsDevice.scope;this.boneTextureId=scope.resolve("texture_poseMap");this.boneTextureSizeId=scope.resolve("texture_poseMapSize");this.poseMatrixId=scope.resolve("matrix_pose[0]");this.modelMatrixId=scope.resolve("matrix_model");this.normalMatrixId=scope.resolve("matrix_normal");this.viewInvId=scope.resolve("matrix_viewInverse");this.viewPos=new Float32Array(3);this.viewPosId=scope.resolve("view_position");this.projId=scope.resolve("matrix_projection");this.projSkyboxId=scope.resolve("matrix_projectionSkybox");this.viewId=scope.resolve("matrix_view");this.viewId3=scope.resolve("matrix_view3");this.viewProjId=scope.resolve("matrix_viewProjection");this.flipYId=scope.resolve("projectionFlipY");this.tbnBasis=scope.resolve("tbnBasis");this.nearClipId=scope.resolve("camera_near");this.farClipId=scope.resolve("camera_far");this.cameraParams=new Float32Array(4);this.cameraParamsId=scope.resolve("camera_params");this.viewIndexId=scope.resolve("view_index");this.blueNoiseJitterVersion=0;this.blueNoiseJitterVec=new Vec4;this.blueNoiseJitterData=new Float32Array(4);this.blueNoiseJitterId=scope.resolve("blueNoiseJitter");this.blueNoiseTextureId=scope.resolve("blueNoiseTex32");this.alphaTestId=scope.resolve("alpha_ref");this.opacityMapId=scope.resolve("texture_opacityMap");this.exposureId=scope.resolve("exposure");this.twoSidedLightingNegScaleFactorId=scope.resolve("twoSidedLightingNegScaleFactor");this.twoSidedLightingNegScaleFactorId.setValue(0);this.morphWeightsA=scope.resolve("morph_weights_a");this.morphWeightsB=scope.resolve("morph_weights_b");this.morphPositionTex=scope.resolve("morphPositionTex");this.morphNormalTex=scope.resolve("morphNormalTex");this.morphTexParams=scope.resolve("morph_tex_params");this.lightCube=new LightCube;this.constantLightCube=scope.resolve("lightCube[0]");}}class RenderAction{destroy(){this.viewBindGroups.forEach(bg=>{bg.defaultUniformBuffer.destroy();bg.destroy();});this.viewBindGroups.length=0;}setupClears(camera,layer){this.clearColor=(camera==null?void 0:camera.clearColorBuffer)||layer.clearColorBuffer;this.clearDepth=(camera==null?void 0:camera.clearDepthBuffer)||layer.clearDepthBuffer;this.clearStencil=(camera==null?void 0:camera.clearStencilBuffer)||layer.clearStencilBuffer;}constructor(){this.layer=null;this.transparent=false;this.camera=null;this.renderTarget=null;this.lightClusters=null;this.clearColor=false;this.clearDepth=false;this.clearStencil=false;this.triggerPostprocess=false;this.firstCameraUse=false;this.lastCameraUse=false;this.viewBindGroups=[];this.useCameraPasses=false;}}class RenderPassForward extends RenderPass{addRenderAction(renderAction){this.renderActions.push(renderAction);}addLayer(cameraComponent,layer,transparent,autoClears=true){const ra=new RenderAction;ra.renderTarget=this.renderTarget;ra.camera=cameraComponent;ra.layer=layer;ra.transparent=transparent;if(autoClears){const firstRa=this.renderActions.length===0;ra.setupClears(firstRa?cameraComponent:undefined,layer);}this.addRenderAction(ra);}addLayers(composition,cameraComponent,startIndex,firstLayerClears,lastLayerId,lastLayerIsTransparent=true){const{layerList,subLayerEnabled,subLayerList}=composition;let clearRenderTarget=firstLayerClears;let index=startIndex;while(index<layerList.length){const layer=layerList[index];const isTransparent=subLayerList[index];const enabled=layer.enabled&&subLayerEnabled[index];const renderedbyCamera=cameraComponent.camera.layersSet.has(layer.id);if(enabled&&renderedbyCamera){this.addLayer(cameraComponent,layer,isTransparent,clearRenderTarget);clearRenderTarget=false;}index++;if(layer.id===lastLayerId&&isTransparent===lastLayerIsTransparent){break}}return index}updateDirectionalShadows(){const{renderer,renderActions}=this;for(let i=0;i<renderActions.length;i++){const renderAction=renderActions[i];const cameraComp=renderAction.camera;const camera=cameraComp.camera;const shadowDirLights=this.renderer.cameraDirShadowLights.get(camera);if(shadowDirLights){for(let l=0;l<shadowDirLights.length;l++){const light=shadowDirLights[l];if(renderer.dirLightShadows.get(light)!==camera){renderer.dirLightShadows.set(light,camera);const shadowPass=renderer._shadowRendererDirectional.getLightRenderPass(light,camera);if(shadowPass){this.beforePasses.push(shadowPass);}}}}}}updateClears(){const renderAction=this.renderActions[0];if(renderAction){const cameraComponent=renderAction.camera;const camera=cameraComponent.camera;const fullSizeClearRect=camera.fullSizeClearRect;this.setClearColor(fullSizeClearRect&&renderAction.clearColor?camera.clearColor:undefined);this.setClearDepth(fullSizeClearRect&&renderAction.clearDepth&&!this.noDepthClear?camera.clearDepth:undefined);this.setClearStencil(fullSizeClearRect&&renderAction.clearStencil?camera.clearStencil:undefined);}}frameUpdate(){super.frameUpdate();this.updateDirectionalShadows();this.updateClears();}before(){const{renderActions}=this;if(renderActions.length){const ra=renderActions[0];if(ra.camera.onPreRender&&ra.firstCameraUse){ra.camera.onPreRender();}}}execute(){const{layerComposition,renderActions}=this;for(let i=0;i<renderActions.length;i++){const ra=renderActions[i];if(layerComposition.isEnabled(ra.layer,ra.transparent)){this.renderRenderAction(ra,i===0);}}}after(){const{renderActions}=this;if(renderActions.length){const ra=renderActions[renderActions.length-1];if(ra.camera.onPostRender&&ra.lastCameraUse){ra.camera.onPostRender();}}this.beforePasses.length=0;}renderRenderAction(renderAction,firstRenderAction){const{renderer,layerComposition}=this;const device=renderer.device;const{layer,transparent,camera}=renderAction;const cameraPass=layerComposition.camerasMap.get(camera);if(!transparent&&layer.onPreRenderOpaque){layer.onPreRenderOpaque(cameraPass);}else if(transparent&&layer.onPreRenderTransparent){layer.onPreRenderTransparent(cameraPass);}if(!(layer._preRenderCalledForCameras&1<<cameraPass)){if(layer.onPreRender){layer.onPreRender(cameraPass);}layer._preRenderCalledForCameras|=1<<cameraPass;}if(camera){var _camera$camera$shader,_camera$camera$shader2;const options={lightClusters:renderAction.lightClusters};const shaderPass=(_camera$camera$shader=(_camera$camera$shader2=camera.camera.shaderPassInfo)==null?void 0:_camera$camera$shader2.index)!=null?_camera$camera$shader:layer.shaderPass;if(!firstRenderAction||!camera.camera.fullSizeClearRect){options.clearColor=renderAction.clearColor;options.clearDepth=renderAction.clearDepth;options.clearStencil=renderAction.clearStencil;}renderer.renderForwardLayer(camera.camera,renderAction.renderTarget,layer,transparent,shaderPass,renderAction.viewBindGroups,options);device.setBlendState(BlendState.NOBLEND);device.setStencilState(null,null);device.setAlphaToCoverage(false);}if(!transparent&&layer.onPostRenderOpaque){layer.onPostRenderOpaque(cameraPass);}else if(transparent&&layer.onPostRenderTransparent){layer.onPostRenderTransparent(cameraPass);}if(layer.onPostRender&&!(layer._postRenderCalledForCameras&1<<cameraPass)){layer._postRenderCounter&=~(transparent?2:1);if(layer._postRenderCounter===0){layer.onPostRender(cameraPass);layer._postRenderCalledForCameras|=1<<cameraPass;layer._postRenderCounter=layer._postRenderCounterMax;}}}constructor(device,layerComposition,scene,renderer){super(device);this.layerComposition=void 0;this.scene=void 0;this.renderer=void 0;this.renderActions=[];this.noDepthClear=false;this.layerComposition=layerComposition;this.scene=scene;this.renderer=renderer;}}class RenderPassPostprocessing extends RenderPass{execute(){const renderAction=this.renderAction;const camera=renderAction.camera;camera.onPostprocessing();}constructor(device,renderer,renderAction){super(device);this.renderer=renderer;this.renderAction=renderAction;this.requiresCubemaps=false;}}const _noLights=[[],[],[]];const _drawCallList={drawCalls:[],shaderInstances:[],isNewMaterial:[],lightMaskChanged:[],clear:function(){this.drawCalls.length=0;this.shaderInstances.length=0;this.isNewMaterial.length=0;this.lightMaskChanged.length=0;}};function vogelDiskPrecalculationSamples(numSamples){const samples=[];for(let i=0;i<numSamples;++i){const r=Math.sqrt(i+.5)/Math.sqrt(numSamples);samples.push(r);}return samples}function vogelSpherePrecalculationSamples(numSamples){const samples=[];for(let i=0;i<numSamples;i++){const weight=i/numSamples;const radius=Math.sqrt(1-weight*weight);samples.push(radius);}return samples}class ForwardRenderer extends Renderer{destroy(){super.destroy();}dispatchGlobalLights(scene){this.ambientColor[0]=scene.ambientLight.r;this.ambientColor[1]=scene.ambientLight.g;this.ambientColor[2]=scene.ambientLight.b;if(scene.gammaCorrection){for(let i=0;i<3;i++){this.ambientColor[i]=Math.pow(this.ambientColor[i],2.2);}}if(scene.physicalUnits){for(let i=0;i<3;i++){this.ambientColor[i]*=scene.ambientLuminance;}}this.ambientId.setValue(this.ambientColor);this.skyboxIntensityId.setValue(scene.physicalUnits?scene.skyboxLuminance:scene.skyboxIntensity);this.cubeMapRotationMatrixId.setValue(scene._skyboxRotationMat3.data);}_resolveLight(scope,i){const light=`light${i}`;this.lightColorId[i]=scope.resolve(`${light}_color`);this.lightDir[i]=new Float32Array(3);this.lightDirId[i]=scope.resolve(`${light}_direction`);this.lightShadowMapId[i]=scope.resolve(`${light}_shadowMap`);this.lightShadowMatrixId[i]=scope.resolve(`${light}_shadowMatrix`);this.lightShadowParamsId[i]=scope.resolve(`${light}_shadowParams`);this.lightShadowIntensity[i]=scope.resolve(`${light}_shadowIntensity`);this.lightShadowSearchAreaId[i]=scope.resolve(`${light}_shadowSearchArea`);this.lightRadiusId[i]=scope.resolve(`${light}_radius`);this.lightPos[i]=new Float32Array(3);this.lightPosId[i]=scope.resolve(`${light}_position`);this.lightWidth[i]=new Float32Array(3);this.lightWidthId[i]=scope.resolve(`${light}_halfWidth`);this.lightHeight[i]=new Float32Array(3);this.lightHeightId[i]=scope.resolve(`${light}_halfHeight`);this.lightInAngleId[i]=scope.resolve(`${light}_innerConeAngle`);this.lightOutAngleId[i]=scope.resolve(`${light}_outerConeAngle`);this.lightCookieId[i]=scope.resolve(`${light}_cookie`);this.lightCookieIntId[i]=scope.resolve(`${light}_cookieIntensity`);this.lightCookieMatrixId[i]=scope.resolve(`${light}_cookieMatrix`);this.lightCookieOffsetId[i]=scope.resolve(`${light}_cookieOffset`);this.lightCameraParamsId[i]=scope.resolve(`${light}_cameraParams`);this.shadowMatrixPaletteId[i]=scope.resolve(`${light}_shadowMatrixPalette[0]`);this.shadowCascadeDistancesId[i]=scope.resolve(`${light}_shadowCascadeDistances[0]`);this.shadowCascadeCountId[i]=scope.resolve(`${light}_shadowCascadeCount`);}setLTCDirectionalLight(wtm,cnt,dir,campos,far){this.lightPos[cnt][0]=campos.x-dir.x*far;this.lightPos[cnt][1]=campos.y-dir.y*far;this.lightPos[cnt][2]=campos.z-dir.z*far;this.lightPosId[cnt].setValue(this.lightPos[cnt]);const hWidth=wtm.transformVector(new Vec3(-.5,0,0));this.lightWidth[cnt][0]=hWidth.x*far;this.lightWidth[cnt][1]=hWidth.y*far;this.lightWidth[cnt][2]=hWidth.z*far;this.lightWidthId[cnt].setValue(this.lightWidth[cnt]);const hHeight=wtm.transformVector(new Vec3(0,0,.5));this.lightHeight[cnt][0]=hHeight.x*far;this.lightHeight[cnt][1]=hHeight.y*far;this.lightHeight[cnt][2]=hHeight.z*far;this.lightHeightId[cnt].setValue(this.lightHeight[cnt]);}dispatchDirectLights(dirs,scene,mask,camera){let cnt=0;const scope=this.device.scope;for(let i=0;i<dirs.length;i++){if(!(dirs[i].mask&mask))continue;const directional=dirs[i];const wtm=directional._node.getWorldTransform();if(!this.lightColorId[cnt]){this._resolveLight(scope,cnt);}this.lightColorId[cnt].setValue(scene.gammaCorrection?directional._linearFinalColor:directional._finalColor);wtm.getY(directional._direction).mulScalar(-1);directional._direction.normalize();this.lightDir[cnt][0]=directional._direction.x;this.lightDir[cnt][1]=directional._direction.y;this.lightDir[cnt][2]=directional._direction.z;this.lightDirId[cnt].setValue(this.lightDir[cnt]);if(directional.shape!==LIGHTSHAPE_PUNCTUAL){this.setLTCDirectionalLight(wtm,cnt,directional._direction,camera._node.getPosition(),camera.farClip);}if(directional.castShadows){const lightRenderData=directional.getRenderData(camera,0);const biases=directional._getUniformBiasValues(lightRenderData);this.lightShadowMapId[cnt].setValue(lightRenderData.shadowBuffer);this.lightShadowMatrixId[cnt].setValue(lightRenderData.shadowMatrix.data);this.shadowMatrixPaletteId[cnt].setValue(directional._shadowMatrixPalette);this.shadowCascadeDistancesId[cnt].setValue(directional._shadowCascadeDistances);this.shadowCascadeCountId[cnt].setValue(directional.numCascades);this.lightShadowIntensity[cnt].setValue(directional.shadowIntensity);const projectionCompensation=50/lightRenderData.projectionCompensation;const shadowRT=lightRenderData.shadowCamera.renderTarget;if(shadowRT){const pixelsPerMeter=directional.penumbraSize/shadowRT.width;this.lightShadowSearchAreaId[cnt].setValue(pixelsPerMeter*projectionCompensation);}const cameraParams=directional._shadowCameraParams;cameraParams.length=4;cameraParams[0]=lightRenderData.depthRangeCompensation;cameraParams[1]=lightRenderData.shadowCamera._farClip;cameraParams[2]=lightRenderData.shadowCamera._nearClip;cameraParams[3]=1;this.lightCameraParamsId[cnt].setValue(cameraParams);const params=directional._shadowRenderParams;params.length=4;params[0]=directional._shadowResolution;params[1]=biases.normalBias;params[2]=biases.bias;params[3]=0;this.lightShadowParamsId[cnt].setValue(params);}cnt++;}return cnt}setLTCPositionalLight(wtm,cnt){const hWidth=wtm.transformVector(new Vec3(-.5,0,0));this.lightWidth[cnt][0]=hWidth.x;this.lightWidth[cnt][1]=hWidth.y;this.lightWidth[cnt][2]=hWidth.z;this.lightWidthId[cnt].setValue(this.lightWidth[cnt]);const hHeight=wtm.transformVector(new Vec3(0,0,.5));this.lightHeight[cnt][0]=hHeight.x;this.lightHeight[cnt][1]=hHeight.y;this.lightHeight[cnt][2]=hHeight.z;this.lightHeightId[cnt].setValue(this.lightHeight[cnt]);}dispatchOmniLight(scene,scope,omni,cnt){const wtm=omni._node.getWorldTransform();if(!this.lightColorId[cnt]){this._resolveLight(scope,cnt);}this.lightRadiusId[cnt].setValue(omni.attenuationEnd);this.lightColorId[cnt].setValue(scene.gammaCorrection?omni._linearFinalColor:omni._finalColor);wtm.getTranslation(omni._position);this.lightPos[cnt][0]=omni._position.x;this.lightPos[cnt][1]=omni._position.y;this.lightPos[cnt][2]=omni._position.z;this.lightPosId[cnt].setValue(this.lightPos[cnt]);if(omni.shape!==LIGHTSHAPE_PUNCTUAL){this.setLTCPositionalLight(wtm,cnt);}if(omni.castShadows){const lightRenderData=omni.getRenderData(null,0);this.lightShadowMapId[cnt].setValue(lightRenderData.shadowBuffer);const biases=omni._getUniformBiasValues(lightRenderData);const params=omni._shadowRenderParams;params.length=4;params[0]=omni._shadowResolution;params[1]=biases.normalBias;params[2]=biases.bias;params[3]=1/omni.attenuationEnd;this.lightShadowParamsId[cnt].setValue(params);this.lightShadowIntensity[cnt].setValue(omni.shadowIntensity);const pixelsPerMeter=omni.penumbraSize/lightRenderData.shadowCamera.renderTarget.width;this.lightShadowSearchAreaId[cnt].setValue(pixelsPerMeter);const cameraParams=omni._shadowCameraParams;cameraParams.length=4;cameraParams[0]=lightRenderData.depthRangeCompensation;cameraParams[1]=lightRenderData.shadowCamera._farClip;cameraParams[2]=lightRenderData.shadowCamera._nearClip;cameraParams[3]=0;this.lightCameraParamsId[cnt].setValue(cameraParams);}if(omni._cookie){this.lightCookieId[cnt].setValue(omni._cookie);this.lightShadowMatrixId[cnt].setValue(wtm.data);this.lightCookieIntId[cnt].setValue(omni.cookieIntensity);}}dispatchSpotLight(scene,scope,spot,cnt){const wtm=spot._node.getWorldTransform();if(!this.lightColorId[cnt]){this._resolveLight(scope,cnt);}this.lightInAngleId[cnt].setValue(spot._innerConeAngleCos);this.lightOutAngleId[cnt].setValue(spot._outerConeAngleCos);this.lightRadiusId[cnt].setValue(spot.attenuationEnd);this.lightColorId[cnt].setValue(scene.gammaCorrection?spot._linearFinalColor:spot._finalColor);wtm.getTranslation(spot._position);this.lightPos[cnt][0]=spot._position.x;this.lightPos[cnt][1]=spot._position.y;this.lightPos[cnt][2]=spot._position.z;this.lightPosId[cnt].setValue(this.lightPos[cnt]);if(spot.shape!==LIGHTSHAPE_PUNCTUAL){this.setLTCPositionalLight(wtm,cnt);}wtm.getY(spot._direction).mulScalar(-1);spot._direction.normalize();this.lightDir[cnt][0]=spot._direction.x;this.lightDir[cnt][1]=spot._direction.y;this.lightDir[cnt][2]=spot._direction.z;this.lightDirId[cnt].setValue(this.lightDir[cnt]);if(spot.castShadows){const lightRenderData=spot.getRenderData(null,0);this.lightShadowMapId[cnt].setValue(lightRenderData.shadowBuffer);this.lightShadowMatrixId[cnt].setValue(lightRenderData.shadowMatrix.data);const biases=spot._getUniformBiasValues(lightRenderData);const params=spot._shadowRenderParams;params.length=4;params[0]=spot._shadowResolution;params[1]=biases.normalBias;params[2]=biases.bias;params[3]=1/spot.attenuationEnd;this.lightShadowParamsId[cnt].setValue(params);this.lightShadowIntensity[cnt].setValue(spot.shadowIntensity);const pixelsPerMeter=spot.penumbraSize/lightRenderData.shadowCamera.renderTarget.width;const fov=lightRenderData.shadowCamera._fov*Math.PI/180;const fovRatio=1/Math.tan(fov/2);this.lightShadowSearchAreaId[cnt].setValue(pixelsPerMeter*fovRatio);const cameraParams=spot._shadowCameraParams;cameraParams.length=4;cameraParams[0]=lightRenderData.depthRangeCompensation;cameraParams[1]=lightRenderData.shadowCamera._farClip;cameraParams[2]=lightRenderData.shadowCamera._nearClip;cameraParams[3]=0;this.lightCameraParamsId[cnt].setValue(cameraParams);}if(spot._cookie){if(!spot.castShadows){const cookieMatrix=LightCamera.evalSpotCookieMatrix(spot);this.lightShadowMatrixId[cnt].setValue(cookieMatrix.data);}this.lightCookieId[cnt].setValue(spot._cookie);this.lightCookieIntId[cnt].setValue(spot.cookieIntensity);if(spot._cookieTransform){spot._cookieTransformUniform[0]=spot._cookieTransform.x;spot._cookieTransformUniform[1]=spot._cookieTransform.y;spot._cookieTransformUniform[2]=spot._cookieTransform.z;spot._cookieTransformUniform[3]=spot._cookieTransform.w;this.lightCookieMatrixId[cnt].setValue(spot._cookieTransformUniform);spot._cookieOffsetUniform[0]=spot._cookieOffset.x;spot._cookieOffsetUniform[1]=spot._cookieOffset.y;this.lightCookieOffsetId[cnt].setValue(spot._cookieOffsetUniform);}}}dispatchLocalLights(sortedLights,scene,mask,usedDirLights){let cnt=usedDirLights;const scope=this.device.scope;const omnis=sortedLights[LIGHTTYPE_OMNI];const numOmnis=omnis.length;for(let i=0;i<numOmnis;i++){const omni=omnis[i];if(!(omni.mask&mask))continue;this.dispatchOmniLight(scene,scope,omni,cnt);cnt++;}const spts=sortedLights[LIGHTTYPE_SPOT];const numSpts=spts.length;for(let i=0;i<numSpts;i++){const spot=spts[i];if(!(spot.mask&mask))continue;this.dispatchSpotLight(scene,scope,spot,cnt);cnt++;}}renderForwardPrepareMaterials(camera,drawCalls,sortedLights,layer,pass){var _layer$getLightHash;const addCall=(drawCall,shaderInstance,isNewMaterial,lightMaskChanged)=>{_drawCallList.drawCalls.push(drawCall);_drawCallList.shaderInstances.push(shaderInstance);_drawCallList.isNewMaterial.push(isNewMaterial);_drawCallList.lightMaskChanged.push(lightMaskChanged);};_drawCallList.clear();const device=this.device;const scene=this.scene;const clusteredLightingEnabled=scene.clusteredLightingEnabled;const lightHash=(_layer$getLightHash=layer==null?void 0:layer.getLightHash(clusteredLightingEnabled))!=null?_layer$getLightHash:0;let prevMaterial=null,prevObjDefs,prevLightMask;const drawCallsCount=drawCalls.length;for(let i=0;i<drawCallsCount;i++){const drawCall=drawCalls[i];drawCall.ensureMaterial(device);const material=drawCall.material;const objDefs=drawCall._shaderDefs;const lightMask=drawCall.mask;if(material&&material===prevMaterial&&objDefs!==prevObjDefs){prevMaterial=null;}if(material!==prevMaterial){this._materialSwitches++;material._scene=scene;if(material.dirty){material.updateUniforms(device,scene);material.dirty=false;}}const shaderInstance=drawCall.getShaderInstance(pass,lightHash,scene,this.viewUniformFormat,this.viewBindGroupFormat,sortedLights);addCall(drawCall,shaderInstance,material!==prevMaterial,!prevMaterial||lightMask!==prevLightMask);prevMaterial=material;prevObjDefs=objDefs;prevLightMask=lightMask;}return _drawCallList}renderForwardInternal(camera,preparedCalls,sortedLights,pass,drawCallback,flipFaces){const device=this.device;const scene=this.scene;const passFlag=1<<pass;const flipFactor=flipFaces?-1:1;const clusteredLightingEnabled=this.scene.clusteredLightingEnabled;const preparedCallsCount=preparedCalls.drawCalls.length;for(let i=0;i<preparedCallsCount;i++){var _drawCall$stencilFron,_drawCall$stencilBack;const drawCall=preparedCalls.drawCalls[i];const newMaterial=preparedCalls.isNewMaterial[i];const lightMaskChanged=preparedCalls.lightMaskChanged[i];const shaderInstance=preparedCalls.shaderInstances[i];const material=drawCall.material;const lightMask=drawCall.mask;if(newMaterial){const asyncCompile=false;device.setShader(shaderInstance.shader,asyncCompile);material.setParameters(device);if(lightMaskChanged){const usedDirLights=this.dispatchDirectLights(sortedLights[LIGHTTYPE_DIRECTIONAL],scene,lightMask,camera);if(!clusteredLightingEnabled){this.dispatchLocalLights(sortedLights,scene,lightMask,usedDirLights);}}this.alphaTestId.setValue(material.alphaTest);device.setBlendState(material.blendState);device.setDepthState(material.depthState);device.setAlphaToCoverage(material.alphaToCoverage);}this.setupCullMode(camera._cullFaces,flipFactor,drawCall);const stencilFront=(_drawCall$stencilFron=drawCall.stencilFront)!=null?_drawCall$stencilFron:material.stencilFront;const stencilBack=(_drawCall$stencilBack=drawCall.stencilBack)!=null?_drawCall$stencilBack:material.stencilBack;device.setStencilState(stencilFront,stencilBack);const mesh=drawCall.mesh;drawCall.setParameters(device,passFlag);this.setVertexBuffers(device,mesh);this.setMorphing(device,drawCall.morphInstance);this.setSkinning(device,drawCall);this.setupMeshUniformBuffers(shaderInstance,drawCall);const style=drawCall.renderStyle;device.setIndexBuffer(mesh.indexBuffer[style]);drawCallback==null||drawCallback(drawCall,i);if(camera.xr&&camera.xr.session&&camera.xr.views.list.length){const views=camera.xr.views;for(let v=0;v<views.list.length;v++){const view=views.list[v];device.setViewport(view.viewport.x,view.viewport.y,view.viewport.z,view.viewport.w);this.projId.setValue(view.projMat.data);this.projSkyboxId.setValue(view.projMat.data);this.viewId.setValue(view.viewOffMat.data);this.viewInvId.setValue(view.viewInvOffMat.data);this.viewId3.setValue(view.viewMat3.data);this.viewProjId.setValue(view.projViewOffMat.data);this.viewPosId.setValue(view.positionData);this.viewIndexId.setValue(v);if(v===0){this.drawInstance(device,drawCall,mesh,style,true);}else {this.drawInstance2(device,drawCall,mesh,style);}this._forwardDrawCalls++;}}else {this.drawInstance(device,drawCall,mesh,style,true);this._forwardDrawCalls++;}if(i<preparedCallsCount-1&&!preparedCalls.isNewMaterial[i+1]){material.setParameters(device,drawCall.parameters);}}}renderForward(camera,allDrawCalls,sortedLights,pass,drawCallback,layer,flipFaces){const preparedCalls=this.renderForwardPrepareMaterials(camera,allDrawCalls,sortedLights,layer,pass);this.renderForwardInternal(camera,preparedCalls,sortedLights,pass,drawCallback,flipFaces);_drawCallList.clear();}renderForwardLayer(camera,renderTarget,layer,transparent,shaderPass,viewBindGroups,options={}){var _options$clearColor,_options$clearDepth,_options$clearStencil;const{scene,device}=this;const clusteredLightingEnabled=scene.clusteredLightingEnabled;this.setupViewport(camera,renderTarget);const clearColor=(_options$clearColor=options.clearColor)!=null?_options$clearColor:false;const clearDepth=(_options$clearDepth=options.clearDepth)!=null?_options$clearDepth:false;const clearStencil=(_options$clearStencil=options.clearStencil)!=null?_options$clearStencil:false;if(clearColor||clearDepth||clearStencil){this.clear(camera,clearColor,clearDepth,clearStencil);}let visible,splitLights;if(layer){layer.sortVisible(camera,transparent);const culledInstances=layer.getCulledInstances(camera);visible=transparent?culledInstances.transparent:culledInstances.opaque;scene.immediate.onPreRenderLayer(layer,visible,transparent);if(layer.requiresLightCube){this.lightCube.update(scene.ambientLight,layer._lights);this.constantLightCube.setValue(this.lightCube.colors);}splitLights=layer.splitLights;}else {var _options$splitLights;visible=options.meshInstances;splitLights=(_options$splitLights=options.splitLights)!=null?_options$splitLights:_noLights;}if(clusteredLightingEnabled){var _options$lightCluster;const lightClusters=(_options$lightCluster=options.lightClusters)!=null?_options$lightCluster:this.worldClustersAllocator.empty;lightClusters.activate();if(layer){if(!this.clustersDebugRendered&&scene.lighting.debugLayer===layer.id){this.clustersDebugRendered=true;}}}scene._activeCamera=camera;const viewCount=this.setCameraUniforms(camera,renderTarget);if(device.supportsUniformBuffers){this.setupViewUniformBuffers(viewBindGroups,this.viewUniformFormat,this.viewBindGroupFormat,viewCount);}const flipFaces=!!(camera._flipFaces^(renderTarget==null?void 0:renderTarget.flipY));const forwardDrawCalls=this._forwardDrawCalls;this.renderForward(camera,visible,splitLights,shaderPass,layer==null?void 0:layer.onDrawCall,layer,flipFaces);if(layer){layer._forwardDrawCalls+=this._forwardDrawCalls-forwardDrawCalls;}}setSceneConstants(){const scene=this.scene;this.dispatchGlobalLights(scene);if(scene.fog!==FOG_NONE){this.fogColor[0]=scene.fogColor.r;this.fogColor[1]=scene.fogColor.g;this.fogColor[2]=scene.fogColor.b;if(scene.gammaCorrection){for(let i=0;i<3;i++){this.fogColor[i]=Math.pow(this.fogColor[i],2.2);}}this.fogColorId.setValue(this.fogColor);if(scene.fog===FOG_LINEAR){this.fogStartId.setValue(scene.fogStart);this.fogEndId.setValue(scene.fogEnd);}else {this.fogDensityId.setValue(scene.fogDensity);}}const device=this.device;this._screenSize[0]=device.width;this._screenSize[1]=device.height;this._screenSize[2]=1/device.width;this._screenSize[3]=1/device.height;this.screenSizeId.setValue(this._screenSize);this.pcssDiskSamplesId.setValue(this.pcssDiskSamples);this.pcssSphereSamplesId.setValue(this.pcssSphereSamples);}buildFrameGraph(frameGraph,layerComposition){const scene=this.scene;const webgl1=this.device.isWebGL1;frameGraph.reset();this.update(layerComposition);if(scene.clusteredLightingEnabled){const{shadowsEnabled,cookiesEnabled}=scene.lighting;this._renderPassUpdateClustered.update(frameGraph,shadowsEnabled,cookiesEnabled,this.lights,this.localLights);frameGraph.addRenderPass(this._renderPassUpdateClustered);}else {this._shadowRendererLocal.buildNonClusteredRenderPasses(frameGraph,this.localLights);}let startIndex=0;let newStart=true;let renderTarget=null;const renderActions=layerComposition._renderActions;for(let i=startIndex;i<renderActions.length;i++){const renderAction=renderActions[i];const{layer,camera}=renderAction;if(renderAction.useCameraPasses){camera.camera.renderPasses.forEach(renderPass=>{frameGraph.addRenderPass(renderPass);});}else {const depthPass=camera.camera.renderPassDepthGrab;if(depthPass&&webgl1&&renderAction.firstCameraUse){depthPass.options.resizeSource=camera.camera.renderTarget;depthPass.update(this.scene);frameGraph.addRenderPass(depthPass);}const isDepthLayer=layer.id===LAYERID_DEPTH;if(webgl1&&isDepthLayer&&!camera.renderSceneColorMap){continue}const isGrabPass=isDepthLayer&&(camera.renderSceneColorMap||camera.renderSceneDepthMap);if(newStart){newStart=false;startIndex=i;renderTarget=renderAction.renderTarget;}const nextRenderAction=renderActions[i+1];const isNextLayerDepth=nextRenderAction?nextRenderAction.layer.id===LAYERID_DEPTH:false;const isNextLayerGrabPass=isNextLayerDepth&&(camera.renderSceneColorMap||camera.renderSceneDepthMap)&&!webgl1;const nextNeedDirShadows=nextRenderAction?nextRenderAction.firstCameraUse&&this.cameraDirShadowLights.has(nextRenderAction.camera.camera):false;if(!nextRenderAction||nextRenderAction.renderTarget!==renderTarget||nextNeedDirShadows||isNextLayerGrabPass||isGrabPass){const isDepthOnly=isDepthLayer&&startIndex===i;if(!isDepthOnly){this.addMainRenderPass(frameGraph,layerComposition,renderTarget,startIndex,i);}if(isDepthLayer){if(camera.renderSceneColorMap){const colorGrabPass=camera.camera.renderPassColorGrab;colorGrabPass.source=camera.renderTarget;frameGraph.addRenderPass(colorGrabPass);}if(camera.renderSceneDepthMap&&!webgl1){frameGraph.addRenderPass(camera.camera.renderPassDepthGrab);}}if(renderAction.triggerPostprocess&&camera!=null&&camera.onPostprocessing){const renderPass=new RenderPassPostprocessing(this.device,this,renderAction);frameGraph.addRenderPass(renderPass);}newStart=true;}}}}addMainRenderPass(frameGraph,layerComposition,renderTarget,startIndex,endIndex){const renderPass=new RenderPassForward(this.device,layerComposition,this.scene,this);renderPass.init(renderTarget);const renderActions=layerComposition._renderActions;for(let i=startIndex;i<=endIndex;i++){renderPass.addRenderAction(renderActions[i]);}frameGraph.addRenderPass(renderPass);}update(comp){this.frameUpdate();this.shadowRenderer.frameUpdate();this.scene._updateSkyMesh();this.updateLayerComposition(comp);this.collectLights(comp);this.beginFrame(comp);this.setSceneConstants();this.cullComposition(comp);this.gpuUpdate(this.processingMeshInstances);}constructor(graphicsDevice){super(graphicsDevice);const device=this.device;this._forwardDrawCalls=0;this._materialSwitches=0;this._depthMapTime=0;this._forwardTime=0;this._sortTime=0;const scope=device.scope;this.fogColorId=scope.resolve("fog_color");this.fogStartId=scope.resolve("fog_start");this.fogEndId=scope.resolve("fog_end");this.fogDensityId=scope.resolve("fog_density");this.ambientId=scope.resolve("light_globalAmbient");this.skyboxIntensityId=scope.resolve("skyboxIntensity");this.cubeMapRotationMatrixId=scope.resolve("cubeMapRotationMatrix");this.pcssDiskSamplesId=scope.resolve("pcssDiskSamples[0]");this.pcssSphereSamplesId=scope.resolve("pcssSphereSamples[0]");this.lightColorId=[];this.lightDir=[];this.lightDirId=[];this.lightShadowMapId=[];this.lightShadowMatrixId=[];this.lightShadowParamsId=[];this.lightShadowIntensity=[];this.lightRadiusId=[];this.lightPos=[];this.lightPosId=[];this.lightWidth=[];this.lightWidthId=[];this.lightHeight=[];this.lightHeightId=[];this.lightInAngleId=[];this.lightOutAngleId=[];this.lightCookieId=[];this.lightCookieIntId=[];this.lightCookieMatrixId=[];this.lightCookieOffsetId=[];this.lightShadowSearchAreaId=[];this.lightCameraParamsId=[];this.shadowMatrixPaletteId=[];this.shadowCascadeDistancesId=[];this.shadowCascadeCountId=[];this.screenSizeId=scope.resolve("uScreenSize");this._screenSize=new Float32Array(4);this.fogColor=new Float32Array(3);this.ambientColor=new Float32Array(3);this.pcssDiskSamples=vogelDiskPrecalculationSamples(16);this.pcssSphereSamples=vogelSpherePrecalculationSamples(16);}}function sortManual(drawCallA,drawCallB){return drawCallA.drawOrder-drawCallB.drawOrder}function sortMaterialMesh(drawCallA,drawCallB){const keyA=drawCallA._key[SORTKEY_FORWARD];const keyB=drawCallB._key[SORTKEY_FORWARD];if(keyA===keyB&&drawCallA.mesh&&drawCallB.mesh){return drawCallB.mesh.id-drawCallA.mesh.id}return keyB-keyA}function sortBackToFront(drawCallA,drawCallB){return drawCallB.zdist-drawCallA.zdist}function sortFrontToBack(drawCallA,drawCallB){return drawCallA.zdist-drawCallB.zdist}const sortCallbacks=[null,sortManual,sortMaterialMesh,sortBackToFront,sortFrontToBack];let layerCounter=0;const lightKeys=[];const _tempMaterials=new Set;class CulledInstances{constructor(){this.opaque=[];this.transparent=[];}}class Layer{set enabled(val){if(val!==this._enabled){this._dirtyComposition=true;this._enabled=val;if(val){this.incrementCounter();if(this.onEnable)this.onEnable();}else {this.decrementCounter();if(this.onDisable)this.onDisable();}}}get enabled(){return this._enabled}set clearColorBuffer(val){this._clearColorBuffer=val;this._dirtyComposition=true;}get clearColorBuffer(){return this._clearColorBuffer}set clearDepthBuffer(val){this._clearDepthBuffer=val;this._dirtyComposition=true;}get clearDepthBuffer(){return this._clearDepthBuffer}set clearStencilBuffer(val){this._clearStencilBuffer=val;this._dirtyComposition=true;}get clearStencilBuffer(){return this._clearStencilBuffer}get hasClusteredLights(){return this._clusteredLightsSet.size>0}get clusteredLightsSet(){return this._clusteredLightsSet}incrementCounter(){if(this._refCounter===0){this._enabled=true;if(this.onEnable)this.onEnable();}this._refCounter++;}decrementCounter(){if(this._refCounter===1){this._enabled=false;if(this.onDisable)this.onDisable();}else if(this._refCounter===0){return}this._refCounter--;}addMeshInstances(meshInstances,skipShadowCasters){const destMeshInstances=this.meshInstances;const destMeshInstancesSet=this.meshInstancesSet;for(let i=0;i<meshInstances.length;i++){const mi=meshInstances[i];if(!destMeshInstancesSet.has(mi)){destMeshInstances.push(mi);destMeshInstancesSet.add(mi);_tempMaterials.add(mi.material);}}if(!skipShadowCasters){this.addShadowCasters(meshInstances);}if(_tempMaterials.size>0){const sceneShaderVer=this._shaderVersion;_tempMaterials.forEach(mat=>{if(sceneShaderVer>=0&&mat._shaderVersion!==sceneShaderVer){if(mat.getShaderVariant!==Material.prototype.getShaderVariant){mat.clearVariants();}mat._shaderVersion=sceneShaderVer;}});_tempMaterials.clear();}}removeMeshInstances(meshInstances,skipShadowCasters){const destMeshInstances=this.meshInstances;const destMeshInstancesSet=this.meshInstancesSet;for(let i=0;i<meshInstances.length;i++){const mi=meshInstances[i];if(destMeshInstancesSet.has(mi)){destMeshInstancesSet.delete(mi);const j=destMeshInstances.indexOf(mi);if(j>=0){destMeshInstances.splice(j,1);}}}if(!skipShadowCasters){this.removeShadowCasters(meshInstances);}}addShadowCasters(meshInstances){const shadowCasters=this.shadowCasters;const shadowCastersSet=this.shadowCastersSet;for(let i=0;i<meshInstances.length;i++){const mi=meshInstances[i];if(mi.castShadow&&!shadowCastersSet.has(mi)){shadowCastersSet.add(mi);shadowCasters.push(mi);}}}removeShadowCasters(meshInstances){const shadowCasters=this.shadowCasters;const shadowCastersSet=this.shadowCastersSet;for(let i=0;i<meshInstances.length;i++){const mi=meshInstances[i];if(shadowCastersSet.has(mi)){shadowCastersSet.delete(mi);const j=shadowCasters.indexOf(mi);if(j>=0){shadowCasters.splice(j,1);}}}}clearMeshInstances(skipShadowCasters=false){this.meshInstances.length=0;this.meshInstancesSet.clear();if(!skipShadowCasters){this.shadowCasters.length=0;this.shadowCastersSet.clear();}}markLightsDirty(){this._lightHashDirty=true;this._lightIdHashDirty=true;this._splitLightsDirty=true;}addLight(light){const l=light.light;if(!this._lightsSet.has(l)){this._lightsSet.add(l);this._lights.push(l);this.markLightsDirty();}if(l.type!==LIGHTTYPE_DIRECTIONAL){this._clusteredLightsSet.add(l);}}removeLight(light){const l=light.light;if(this._lightsSet.has(l)){this._lightsSet.delete(l);this._lights.splice(this._lights.indexOf(l),1);this.markLightsDirty();}if(l.type!==LIGHTTYPE_DIRECTIONAL){this._clusteredLightsSet.delete(l);}}clearLights(){this._lightsSet.forEach(light=>light.removeLayer(this));this._lightsSet.clear();this._clusteredLightsSet.clear();this._lights.length=0;this.markLightsDirty();}get splitLights(){if(this._splitLightsDirty){this._splitLightsDirty=false;const splitLights=this._splitLights;for(let i=0;i<splitLights.length;i++){splitLights[i].length=0;}const lights=this._lights;for(let i=0;i<lights.length;i++){const light=lights[i];if(light.enabled){splitLights[light._type].push(light);}}for(let i=0;i<splitLights.length;i++){splitLights[i].sort((a,b)=>a.key-b.key);}}return this._splitLights}evaluateLightHash(localLights,directionalLights,useIds){let hash=0;const lights=this._lights;for(let i=0;i<lights.length;i++){const isLocalLight=lights[i].type!==LIGHTTYPE_DIRECTIONAL;if(localLights&&isLocalLight||directionalLights&&!isLocalLight){lightKeys.push(useIds?lights[i].id:lights[i].key);}}if(lightKeys.length>0){lightKeys.sort();hash=hash32Fnv1a(lightKeys);lightKeys.length=0;}return hash}getLightHash(isClustered){if(this._lightHashDirty){this._lightHashDirty=false;this._lightHash=this.evaluateLightHash(!isClustered,true,false);}return this._lightHash}getLightIdHash(){if(this._lightIdHashDirty){this._lightIdHashDirty=false;this._lightIdHash=this.evaluateLightHash(true,false,true);}return this._lightIdHash}addCamera(camera){if(!this.camerasSet.has(camera.camera)){this.camerasSet.add(camera.camera);this.cameras.push(camera);this._dirtyComposition=true;}}removeCamera(camera){if(this.camerasSet.has(camera.camera)){this.camerasSet.delete(camera.camera);const index=this.cameras.indexOf(camera);this.cameras.splice(index,1);this._dirtyComposition=true;}}clearCameras(){this.cameras.length=0;this.camerasSet.clear();this._dirtyComposition=true;}_calculateSortDistances(drawCalls,drawCallsCount,camPos,camFwd){for(let i=0;i<drawCallsCount;i++){const drawCall=drawCalls[i];if(drawCall.layer<=LAYER_FX)continue;if(drawCall.calculateSortDistance){drawCall.zdist=drawCall.calculateSortDistance(drawCall,camPos,camFwd);continue}const meshPos=drawCall.aabb.center;const tempx=meshPos.x-camPos.x;const tempy=meshPos.y-camPos.y;const tempz=meshPos.z-camPos.z;drawCall.zdist=tempx*camFwd.x+tempy*camFwd.y+tempz*camFwd.z;}}getCulledInstances(camera){let instances=this._visibleInstances.get(camera);if(!instances){instances=new CulledInstances;this._visibleInstances.set(camera,instances);}return instances}sortVisible(camera,transparent){const sortMode=transparent?this.transparentSortMode:this.opaqueSortMode;if(sortMode===SORTMODE_NONE){return}const culledInstances=this.getCulledInstances(camera);const instances=transparent?culledInstances.transparent:culledInstances.opaque;const cameraNode=camera.node;if(sortMode===SORTMODE_CUSTOM){const sortPos=cameraNode.getPosition();const sortDir=cameraNode.forward;if(this.customCalculateSortValues){this.customCalculateSortValues(instances,instances.length,sortPos,sortDir);}if(this.customSortCallback){instances.sort(this.customSortCallback);}}else {if(sortMode===SORTMODE_BACK2FRONT||sortMode===SORTMODE_FRONT2BACK){const sortPos=cameraNode.getPosition();const sortDir=cameraNode.forward;this._calculateSortDistances(instances,instances.length,sortPos,sortDir);}instances.sort(sortCallbacks[sortMode]);}}constructor(options={}){var _options$enabled,_options$opaqueSortMo,_options$transparentS,_options$shaderPass;this.meshInstances=[];this.meshInstancesSet=new Set;this.shadowCasters=[];this.shadowCastersSet=new Set;this._visibleInstances=new WeakMap;this._lights=[];this._lightsSet=new Set;this._clusteredLightsSet=new Set;this._splitLights=[[],[],[]];this._splitLightsDirty=true;this.requiresLightCube=false;this.cameras=[];this.camerasSet=new Set;this._dirtyComposition=false;if(options.id!==undefined){this.id=options.id;layerCounter=Math.max(this.id+1,layerCounter);}else {this.id=layerCounter++;}this.name=options.name;this._enabled=(_options$enabled=options.enabled)!=null?_options$enabled:true;this._refCounter=this._enabled?1:0;this.opaqueSortMode=(_options$opaqueSortMo=options.opaqueSortMode)!=null?_options$opaqueSortMo:SORTMODE_MATERIALMESH;this.transparentSortMode=(_options$transparentS=options.transparentSortMode)!=null?_options$transparentS:SORTMODE_BACK2FRONT;if(options.renderTarget){this.renderTarget=options.renderTarget;}this.shaderPass=(_options$shaderPass=options.shaderPass)!=null?_options$shaderPass:SHADER_FORWARD;this._clearColorBuffer=!!options.clearColorBuffer;this._clearDepthBuffer=!!options.clearDepthBuffer;this._clearStencilBuffer=!!options.clearStencilBuffer;this.onPreCull=options.onPreCull;this.onPreRender=options.onPreRender;this.onPreRenderOpaque=options.onPreRenderOpaque;this.onPreRenderTransparent=options.onPreRenderTransparent;this.onPostCull=options.onPostCull;this.onPostRender=options.onPostRender;this.onPostRenderOpaque=options.onPostRenderOpaque;this.onPostRenderTransparent=options.onPostRenderTransparent;this.onDrawCall=options.onDrawCall;this.onEnable=options.onEnable;this.onDisable=options.onDisable;if(this._enabled&&this.onEnable){this.onEnable();}this.layerReference=options.layerReference;this.customSortCallback=null;this.customCalculateSortValues=null;this._lightHash=0;this._lightHashDirty=false;this._lightIdHash=0;this._lightIdHashDirty=false;this._shaderVersion=-1;}}const cmpPriority=(a,b)=>a.priority-b.priority;const sortPriority=arr=>arr.sort(cmpPriority);class LayerComposition extends EventHandler{destroy(){this.destroyRenderActions();}destroyRenderActions(){this._renderActions.forEach(ra=>ra.destroy());this._renderActions.length=0;}_update(){const len=this.layerList.length;if(!this._dirty){for(let i=0;i<len;i++){if(this.layerList[i]._dirtyComposition){this._dirty=true;break}}}if(this._dirty){this._dirty=false;this.cameras.length=0;for(let i=0;i<len;i++){const layer=this.layerList[i];layer._dirtyComposition=false;for(let j=0;j<layer.cameras.length;j++){const camera=layer.cameras[j];const index=this.cameras.indexOf(camera);if(index<0){this.cameras.push(camera);}}}if(this.cameras.length>1){sortPriority(this.cameras);}this.camerasMap.clear();for(let i=0;i<this.cameras.length;i++){this.camerasMap.set(this.cameras[i],i);}let renderActionCount=0;this.destroyRenderActions();for(let i=0;i<this.cameras.length;i++){const camera=this.cameras[i];if(camera.camera.renderPasses.length>0){this.addDummyRenderAction(renderActionCount,camera);renderActionCount++;continue}let cameraFirstRenderAction=true;const cameraFirstRenderActionIndex=renderActionCount;let lastRenderAction=null;let postProcessMarked=false;for(let j=0;j<len;j++){const layer=this.layerList[j];const isLayerEnabled=layer.enabled&&this.subLayerEnabled[j];if(isLayerEnabled){if(layer.cameras.length>0){if(camera.layers.indexOf(layer.id)>=0){if(!postProcessMarked&&layer.id===camera.disablePostEffectsLayer){postProcessMarked=true;if(lastRenderAction){lastRenderAction.triggerPostprocess=true;}}const isTransparent=this.subLayerList[j];lastRenderAction=this.addRenderAction(renderActionCount,layer,isTransparent,camera,cameraFirstRenderAction,postProcessMarked);renderActionCount++;cameraFirstRenderAction=false;}}}}if(cameraFirstRenderActionIndex<renderActionCount){lastRenderAction.lastCameraUse=true;}if(!postProcessMarked&&lastRenderAction){lastRenderAction.triggerPostprocess=true;}if(camera.renderTarget&&camera.postEffectsEnabled){this.propagateRenderTarget(cameraFirstRenderActionIndex-1,camera);}}this._logRenderActions();}}getNextRenderAction(renderActionIndex){const renderAction=new RenderAction;this._renderActions.push(renderAction);return renderAction}addDummyRenderAction(renderActionIndex,camera){const renderAction=this.getNextRenderAction(renderActionIndex);renderAction.camera=camera;renderAction.useCameraPasses=true;}addRenderAction(renderActionIndex,layer,isTransparent,camera,cameraFirstRenderAction,postProcessMarked){let rt=layer.renderTarget;if(camera&&camera.renderTarget){if(layer.id!==LAYERID_DEPTH){rt=camera.renderTarget;}}let used=false;const renderActions=this._renderActions;for(let i=renderActionIndex-1;i>=0;i--){if(renderActions[i].camera===camera&&renderActions[i].renderTarget===rt){used=true;break}}if(postProcessMarked&&camera.postEffectsEnabled){rt=null;}const renderAction=this.getNextRenderAction(renderActionIndex);renderAction.triggerPostprocess=false;renderAction.layer=layer;renderAction.transparent=isTransparent;renderAction.camera=camera;renderAction.renderTarget=rt;renderAction.firstCameraUse=cameraFirstRenderAction;renderAction.lastCameraUse=false;const needsCameraClear=cameraFirstRenderAction||!used;const needsLayerClear=layer.clearColorBuffer||layer.clearDepthBuffer||layer.clearStencilBuffer;if(needsCameraClear||needsLayerClear){renderAction.setupClears(needsCameraClear?camera:undefined,layer);}return renderAction}propagateRenderTarget(startIndex,fromCamera){for(let a=startIndex;a>=0;a--){const ra=this._renderActions[a];const layer=ra.layer;if(ra.renderTarget&&layer.id!==LAYERID_DEPTH){break}if(layer.id===LAYERID_DEPTH){continue}if(ra.useCameraPasses){break}const thisCamera=ra==null?void 0:ra.camera.camera;if(thisCamera){if(!fromCamera.camera.rect.equals(thisCamera.rect)||!fromCamera.camera.scissorRect.equals(thisCamera.scissorRect)){break}}ra.renderTarget=fromCamera.renderTarget;}}_logRenderActions(){}_isLayerAdded(layer){const found=this.layerIdMap.get(layer.id)===layer;return found}_isSublayerAdded(layer,transparent){const map=transparent?this.layerTransparentIndexMap:this.layerOpaqueIndexMap;if(map.get(layer)!==undefined){return true}return false}push(layer){if(this._isLayerAdded(layer))return;this.layerList.push(layer);this.layerList.push(layer);this._opaqueOrder[layer.id]=this.subLayerList.push(false)-1;this._transparentOrder[layer.id]=this.subLayerList.push(true)-1;this.subLayerEnabled.push(true);this.subLayerEnabled.push(true);this._updateLayerMaps();this._dirty=true;this.fire("add",layer);}insert(layer,index){if(this._isLayerAdded(layer))return;this.layerList.splice(index,0,layer,layer);this.subLayerList.splice(index,0,false,true);const count=this.layerList.length;this._updateOpaqueOrder(index,count-1);this._updateTransparentOrder(index,count-1);this.subLayerEnabled.splice(index,0,true,true);this._updateLayerMaps();this._dirty=true;this.fire("add",layer);}remove(layer){let id=this.layerList.indexOf(layer);delete this._opaqueOrder[id];delete this._transparentOrder[id];while(id>=0){this.layerList.splice(id,1);this.subLayerList.splice(id,1);this.subLayerEnabled.splice(id,1);id=this.layerList.indexOf(layer);this._dirty=true;this.fire("remove",layer);}const count=this.layerList.length;this._updateOpaqueOrder(0,count-1);this._updateTransparentOrder(0,count-1);this._updateLayerMaps();}pushOpaque(layer){if(this._isSublayerAdded(layer,false))return;this.layerList.push(layer);this._opaqueOrder[layer.id]=this.subLayerList.push(false)-1;this.subLayerEnabled.push(true);this._updateLayerMaps();this._dirty=true;this.fire("add",layer);}insertOpaque(layer,index){if(this._isSublayerAdded(layer,false))return;this.layerList.splice(index,0,layer);this.subLayerList.splice(index,0,false);const count=this.subLayerList.length;this._updateOpaqueOrder(index,count-1);this.subLayerEnabled.splice(index,0,true);this._updateLayerMaps();this._dirty=true;this.fire("add",layer);}removeOpaque(layer){for(let i=0,len=this.layerList.length;i<len;i++){if(this.layerList[i]===layer&&!this.subLayerList[i]){this.layerList.splice(i,1);this.subLayerList.splice(i,1);len--;this._updateOpaqueOrder(i,len-1);this.subLayerEnabled.splice(i,1);this._dirty=true;if(this.layerList.indexOf(layer)<0){this.fire("remove",layer);}break}}this._updateLayerMaps();}pushTransparent(layer){if(this._isSublayerAdded(layer,true))return;this.layerList.push(layer);this._transparentOrder[layer.id]=this.subLayerList.push(true)-1;this.subLayerEnabled.push(true);this._updateLayerMaps();this._dirty=true;this.fire("add",layer);}insertTransparent(layer,index){if(this._isSublayerAdded(layer,true))return;this.layerList.splice(index,0,layer);this.subLayerList.splice(index,0,true);const count=this.subLayerList.length;this._updateTransparentOrder(index,count-1);this.subLayerEnabled.splice(index,0,true);this._updateLayerMaps();this._dirty=true;this.fire("add",layer);}removeTransparent(layer){for(let i=0,len=this.layerList.length;i<len;i++){if(this.layerList[i]===layer&&this.subLayerList[i]){this.layerList.splice(i,1);this.subLayerList.splice(i,1);len--;this._updateTransparentOrder(i,len-1);this.subLayerEnabled.splice(i,1);this._dirty=true;if(this.layerList.indexOf(layer)<0){this.fire("remove",layer);}break}}this._updateLayerMaps();}getOpaqueIndex(layer){var _this$layerOpaqueInde;return (_this$layerOpaqueInde=this.layerOpaqueIndexMap.get(layer))!=null?_this$layerOpaqueInde:-1}getTransparentIndex(layer){var _this$layerTransparen;return (_this$layerTransparen=this.layerTransparentIndexMap.get(layer))!=null?_this$layerTransparen:-1}isEnabled(layer,transparent){const index=transparent?this.getTransparentIndex(layer):this.getOpaqueIndex(layer);return this.subLayerEnabled[index]}_updateLayerMaps(){this.layerIdMap.clear();this.layerNameMap.clear();this.layerOpaqueIndexMap.clear();this.layerTransparentIndexMap.clear();for(let i=0;i<this.layerList.length;i++){const layer=this.layerList[i];this.layerIdMap.set(layer.id,layer);this.layerNameMap.set(layer.name,layer);const subLayerIndexMap=this.subLayerList[i]?this.layerTransparentIndexMap:this.layerOpaqueIndexMap;subLayerIndexMap.set(layer,i);}}getLayerById(id){var _this$layerIdMap$get;return (_this$layerIdMap$get=this.layerIdMap.get(id))!=null?_this$layerIdMap$get:null}getLayerByName(name){var _this$layerNameMap$ge;return (_this$layerNameMap$ge=this.layerNameMap.get(name))!=null?_this$layerNameMap$ge:null}_updateOpaqueOrder(startIndex,endIndex){for(let i=startIndex;i<=endIndex;i++){if(this.subLayerList[i]===false){this._opaqueOrder[this.layerList[i].id]=i;}}}_updateTransparentOrder(startIndex,endIndex){for(let i=startIndex;i<=endIndex;i++){if(this.subLayerList[i]===true){this._transparentOrder[this.layerList[i].id]=i;}}}_sortLayersDescending(layersA,layersB,order){let topLayerA=-1;let topLayerB=-1;for(let i=0,len=layersA.length;i<len;i++){const id=layersA[i];if(order.hasOwnProperty(id)){topLayerA=Math.max(topLayerA,order[id]);}}for(let i=0,len=layersB.length;i<len;i++){const id=layersB[i];if(order.hasOwnProperty(id)){topLayerB=Math.max(topLayerB,order[id]);}}if(topLayerA===-1&&topLayerB!==-1){return 1}else if(topLayerB===-1&&topLayerA!==-1){return -1}return topLayerB-topLayerA}sortTransparentLayers(layersA,layersB){return this._sortLayersDescending(layersA,layersB,this._transparentOrder)}sortOpaqueLayers(layersA,layersB){return this._sortLayersDescending(layersA,layersB,this._opaqueOrder)}constructor(name="Untitled"){super();this.layerList=[];this.layerIdMap=new Map;this.layerNameMap=new Map;this.layerOpaqueIndexMap=new Map;this.layerTransparentIndexMap=new Map;this.subLayerList=[];this.subLayerEnabled=[];this.cameras=[];this.camerasMap=new Map;this._renderActions=[];this._dirty=false;this.name=name;this._opaqueOrder={};this._transparentOrder={};}}const tmpVec=new Vec3;const tmpBiases={bias:0,normalBias:0};const chanId={r:0,g:1,b:2,a:3};const lightTypes={"directional":LIGHTTYPE_DIRECTIONAL,"omni":LIGHTTYPE_OMNI,"point":LIGHTTYPE_OMNI,"spot":LIGHTTYPE_SPOT};const directionalCascades=[[new Vec4(0,0,1,1)],[new Vec4(0,0,.5,.5),new Vec4(0,.5,.5,.5)],[new Vec4(0,0,.5,.5),new Vec4(0,.5,.5,.5),new Vec4(.5,0,.5,.5)],[new Vec4(0,0,.5,.5),new Vec4(0,.5,.5,.5),new Vec4(.5,0,.5,.5),new Vec4(.5,.5,.5,.5)]];let id=0;class LightRenderData{destroy(){this.viewBindGroups.forEach(bg=>{bg.defaultUniformBuffer.destroy();bg.destroy();});this.viewBindGroups.length=0;}get shadowBuffer(){const rt=this.shadowCamera.renderTarget;if(rt){const light=this.light;if(light._type===LIGHTTYPE_OMNI){return rt.colorBuffer}return light._isPcf&&light.device.supportsDepthShadow?rt.depthBuffer:rt.colorBuffer}return null}constructor(device,camera,face,light){this.light=light;this.camera=camera;this.shadowCamera=ShadowRenderer.createShadowCamera(device,light._shadowType,light._type,face);this.shadowMatrix=new Mat4;this.shadowViewport=new Vec4(0,0,1,1);this.shadowScissor=new Vec4(0,0,1,1);this.depthRangeCompensation=0;this.projectionCompensation=0;this.face=face;this.visibleCasters=[];this.viewBindGroups=[];}}class Light{destroy(){this._destroyShadowMap();this.releaseRenderData();this._renderData=null;}releaseRenderData(){if(this._renderData){for(let i=0;i<this._renderData.length;i++){this._renderData[i].destroy();}this._renderData.length=0;}}addLayer(layer){this.layers.add(layer);}removeLayer(layer){this.layers.delete(layer);}set shadowBias(value){if(this._shadowBias!==value){this._shadowBias=value;this._updateShadowBias();}}get shadowBias(){return this._shadowBias}set numCascades(value){if(!this.cascades||this.numCascades!==value){this.cascades=directionalCascades[value-1];this._shadowMatrixPalette=new Float32Array(4*16);this._shadowCascadeDistances=new Float32Array(4);this._destroyShadowMap();this.updateKey();}}get numCascades(){return this.cascades.length}set shadowMap(shadowMap){if(this._shadowMap!==shadowMap){this._destroyShadowMap();this._shadowMap=shadowMap;}}get shadowMap(){return this._shadowMap}set mask(value){if(this._mask!==value){this._mask=value;this.updateKey();}}get mask(){return this._mask}get numShadowFaces(){const type=this._type;if(type===LIGHTTYPE_DIRECTIONAL){return this.numCascades}else if(type===LIGHTTYPE_OMNI){return 6}return 1}set type(value){if(this._type===value){return}this._type=value;this._destroyShadowMap();this._updateShadowBias();this.updateKey();const stype=this._shadowType;this._shadowType=null;this.shadowUpdateOverrides=null;this.shadowType=stype;}get type(){return this._type}set shape(value){if(this._shape===value){return}this._shape=value;this._destroyShadowMap();this.updateKey();const stype=this._shadowType;this._shadowType=null;this.shadowType=stype;}get shape(){return this._shape}set usePhysicalUnits(value){if(this._usePhysicalUnits!==value){this._usePhysicalUnits=value;this._updateFinalColor();}}get usePhysicalUnits(){return this._usePhysicalUnits}set shadowType(value){if(this._shadowType===value){return}const device=this.device;if(this._type===LIGHTTYPE_OMNI&&value!==SHADOW_PCF3&&value!==SHADOW_PCSS){value=SHADOW_PCF3;}const supportsDepthShadow=device.supportsDepthShadow;if(value===SHADOW_PCF5&&!supportsDepthShadow){value=SHADOW_PCF3;}if(value===SHADOW_VSM32&&(!device.textureFloatRenderable||!device.textureFloatFilterable)){value=SHADOW_VSM16;}if(value===SHADOW_VSM16&&!device.textureHalfFloatRenderable){value=SHADOW_VSM8;}this._isVsm=value>=SHADOW_VSM8&&value<=SHADOW_VSM32;this._isPcf=value===SHADOW_PCF1||value===SHADOW_PCF3||value===SHADOW_PCF5;this._shadowType=value;this._destroyShadowMap();this.updateKey();}get shadowType(){return this._shadowType}set enabled(value){if(this._enabled!==value){this._enabled=value;this.layersDirty();}}get enabled(){return this._enabled}set castShadows(value){if(this._castShadows!==value){this._castShadows=value;this._destroyShadowMap();this.layersDirty();this.updateKey();}}get castShadows(){return this._castShadows&&this._mask!==MASK_BAKE&&this._mask!==0}get bakeShadows(){return this._castShadows&&this._mask===MASK_BAKE}set shadowResolution(value){if(this._shadowResolution!==value){if(this._type===LIGHTTYPE_OMNI){value=Math.min(value,this.device.maxCubeMapSize);}else {value=Math.min(value,this.device.maxTextureSize);}this._shadowResolution=value;this._destroyShadowMap();}}get shadowResolution(){return this._shadowResolution}set vsmBlurSize(value){if(this._vsmBlurSize===value){return}if(value%2===0)value++;this._vsmBlurSize=value;}get vsmBlurSize(){return this._vsmBlurSize}set normalOffsetBias(value){if(this._normalOffsetBias===value){return}if(!this._normalOffsetBias&&value||this._normalOffsetBias&&!value){this.updateKey();}this._normalOffsetBias=value;}get normalOffsetBias(){return this._normalOffsetBias}set falloffMode(value){if(this._falloffMode===value){return}this._falloffMode=value;this.updateKey();}get falloffMode(){return this._falloffMode}set innerConeAngle(value){if(this._innerConeAngle===value){return}this._innerConeAngle=value;this._innerConeAngleCos=Math.cos(value*Math.PI/180);if(this._usePhysicalUnits){this._updateFinalColor();}}get innerConeAngle(){return this._innerConeAngle}set outerConeAngle(value){if(this._outerConeAngle===value){return}this._outerConeAngle=value;this._updateOuterAngle(value);if(this._usePhysicalUnits){this._updateFinalColor();}}get outerConeAngle(){return this._outerConeAngle}set penumbraSize(value){this._penumbraSize=value;}get penumbraSize(){return this._penumbraSize}_updateOuterAngle(angle){const radAngle=angle*Math.PI/180;this._outerConeAngleCos=Math.cos(radAngle);this._outerConeAngleSin=Math.sin(radAngle);}set intensity(value){if(this._intensity!==value){this._intensity=value;this._updateFinalColor();}}get intensity(){return this._intensity}set affectSpecularity(value){if(this._type===LIGHTTYPE_DIRECTIONAL){this._affectSpecularity=value;this.updateKey();}}get affectSpecularity(){return this._affectSpecularity}set luminance(value){if(this._luminance!==value){this._luminance=value;this._updateFinalColor();}}get luminance(){return this._luminance}get cookieMatrix(){if(!this._cookieMatrix){this._cookieMatrix=new Mat4;}return this._cookieMatrix}get atlasViewport(){if(!this._atlasViewport){this._atlasViewport=new Vec4(0,0,1,1);}return this._atlasViewport}set cookie(value){if(this._cookie===value){return}this._cookie=value;this.updateKey();}get cookie(){return this._cookie}set cookieFalloff(value){if(this._cookieFalloff===value){return}this._cookieFalloff=value;this.updateKey();}get cookieFalloff(){return this._cookieFalloff}set cookieChannel(value){if(this._cookieChannel===value){return}if(value.length<3){const chr=value.charAt(value.length-1);const addLen=3-value.length;for(let i=0;i<addLen;i++){value+=chr;}}this._cookieChannel=value;this.updateKey();}get cookieChannel(){return this._cookieChannel}set cookieTransform(value){if(this._cookieTransform===value){return}this._cookieTransform=value;this._cookieTransformSet=!!value;if(value&&!this._cookieOffset){this.cookieOffset=new Vec2;this._cookieOffsetSet=false;}this.updateKey();}get cookieTransform(){return this._cookieTransform}set cookieOffset(value){if(this._cookieOffset===value){return}const xformNew=!!(this._cookieTransformSet||value);if(xformNew&&!value&&this._cookieOffset){this._cookieOffset.set(0,0);}else {this._cookieOffset=value;}this._cookieOffsetSet=!!value;if(value&&!this._cookieTransform){this.cookieTransform=new Vec4(1,1,0,0);this._cookieTransformSet=false;}this.updateKey();}get cookieOffset(){return this._cookieOffset}beginFrame(){this.visibleThisFrame=this._type===LIGHTTYPE_DIRECTIONAL&&this._enabled;this.maxScreenSize=0;this.atlasViewportAllocated=false;this.atlasSlotUpdated=false;}_destroyShadowMap(){this.releaseRenderData();if(this._shadowMap){if(!this._shadowMap.cached){this._shadowMap.destroy();}this._shadowMap=null;}if(this.shadowUpdateMode===SHADOWUPDATE_NONE){this.shadowUpdateMode=SHADOWUPDATE_THISFRAME;}if(this.shadowUpdateOverrides){for(let i=0;i<this.shadowUpdateOverrides.length;i++){if(this.shadowUpdateOverrides[i]===SHADOWUPDATE_NONE){this.shadowUpdateOverrides[i]=SHADOWUPDATE_THISFRAME;}}}}getRenderData(camera,face){for(let i=0;i<this._renderData.length;i++){const current=this._renderData[i];if(current.camera===camera&&current.face===face){return current}}const rd=new LightRenderData(this.device,camera,face,this);this._renderData.push(rd);return rd}clone(){const clone=new Light(this.device,this.clusteredLighting);clone.type=this._type;clone.setColor(this._color);clone.intensity=this._intensity;clone.affectSpecularity=this._affectSpecularity;clone.luminance=this._luminance;clone.castShadows=this.castShadows;clone._enabled=this._enabled;clone.attenuationStart=this.attenuationStart;clone.attenuationEnd=this.attenuationEnd;clone.falloffMode=this._falloffMode;clone.shadowType=this._shadowType;clone.vsmBlurSize=this._vsmBlurSize;clone.vsmBlurMode=this.vsmBlurMode;clone.vsmBias=this.vsmBias;clone.penumbraSize=this.penumbraSize;clone.shadowUpdateMode=this.shadowUpdateMode;clone.mask=this.mask;if(this.shadowUpdateOverrides){clone.shadowUpdateOverrides=this.shadowUpdateOverrides.slice();}clone.innerConeAngle=this._innerConeAngle;clone.outerConeAngle=this._outerConeAngle;clone.numCascades=this.numCascades;clone.cascadeDistribution=this.cascadeDistribution;clone.shape=this._shape;clone.shadowDepthState.copy(this.shadowDepthState);clone.shadowBias=this.shadowBias;clone.normalOffsetBias=this._normalOffsetBias;clone.shadowResolution=this._shadowResolution;clone.shadowDistance=this.shadowDistance;clone.shadowIntensity=this.shadowIntensity;return clone}static getLightUnitConversion(type,outerAngle=Math.PI/4,innerAngle=0){switch(type){case LIGHTTYPE_SPOT:{const falloffEnd=Math.cos(outerAngle);const falloffStart=Math.cos(innerAngle);return 2*Math.PI*(1-falloffStart+(falloffStart-falloffEnd)/2)}case LIGHTTYPE_OMNI:return 4*Math.PI;case LIGHTTYPE_DIRECTIONAL:return 1}}_getUniformBiasValues(lightRenderData){const farClip=lightRenderData.shadowCamera._farClip;switch(this._type){case LIGHTTYPE_OMNI:tmpBiases.bias=this.shadowBias;tmpBiases.normalBias=this._normalOffsetBias;break;case LIGHTTYPE_SPOT:if(this._isVsm){tmpBiases.bias=-1e-5*20;}else {tmpBiases.bias=this.shadowBias*20;if(this.device.isWebGL1&&this.device.extStandardDerivatives)tmpBiases.bias*=-100;}tmpBiases.normalBias=this._isVsm?this.vsmBias/(this.attenuationEnd/7):this._normalOffsetBias;break;case LIGHTTYPE_DIRECTIONAL:if(this._isVsm){tmpBiases.bias=-1e-5*20;}else {tmpBiases.bias=this.shadowBias/farClip*100;if(this.device.isWebGL1&&this.device.extStandardDerivatives)tmpBiases.bias*=-100;}tmpBiases.normalBias=this._isVsm?this.vsmBias/(farClip/7):this._normalOffsetBias;break}return tmpBiases}getColor(){return this._color}getBoundingSphere(sphere){if(this._type===LIGHTTYPE_SPOT){const size=this.attenuationEnd;const angle=this._outerConeAngle;const cosAngle=this._outerConeAngleCos;const node=this._node;tmpVec.copy(node.up);if(angle>45){sphere.radius=size*this._outerConeAngleSin;tmpVec.mulScalar(-size*cosAngle);}else {sphere.radius=size/(2*cosAngle);tmpVec.mulScalar(-sphere.radius);}sphere.center.add2(node.getPosition(),tmpVec);}else if(this._type===LIGHTTYPE_OMNI){sphere.center=this._node.getPosition();sphere.radius=this.attenuationEnd;}}getBoundingBox(box){if(this._type===LIGHTTYPE_SPOT){const range=this.attenuationEnd;const angle=this._outerConeAngle;const node=this._node;const scl=Math.abs(Math.sin(angle*math.DEG_TO_RAD)*range);box.center.set(0,-range*.5,0);box.halfExtents.set(scl,range*.5,scl);box.setFromTransformedAabb(box,node.getWorldTransform(),true);}else if(this._type===LIGHTTYPE_OMNI){box.center.copy(this._node.getPosition());box.halfExtents.set(this.attenuationEnd,this.attenuationEnd,this.attenuationEnd);}}_updateShadowBias(){const device=this.device;if(device.isWebGL2||device.isWebGPU){if(this._type===LIGHTTYPE_OMNI&&!this.clusteredLighting){this.shadowDepthState.depthBias=0;this.shadowDepthState.depthBiasSlope=0;}else {const bias=this.shadowBias*-1e3;this.shadowDepthState.depthBias=bias;this.shadowDepthState.depthBiasSlope=bias;}}}_updateFinalColor(){const color=this._color;const r=color.r;const g=color.g;const b=color.b;let i=this._intensity;if(this._usePhysicalUnits){i=this._luminance/Light.getLightUnitConversion(this._type,this._outerConeAngle*math.DEG_TO_RAD,this._innerConeAngle*math.DEG_TO_RAD);}const finalColor=this._finalColor;const linearFinalColor=this._linearFinalColor;finalColor[0]=r*i;finalColor[1]=g*i;finalColor[2]=b*i;if(i>=1){linearFinalColor[0]=Math.pow(r,2.2)*i;linearFinalColor[1]=Math.pow(g,2.2)*i;linearFinalColor[2]=Math.pow(b,2.2)*i;}else {linearFinalColor[0]=Math.pow(finalColor[0],2.2);linearFinalColor[1]=Math.pow(finalColor[1],2.2);linearFinalColor[2]=Math.pow(finalColor[2],2.2);}}setColor(){if(arguments.length===1){this._color.set(arguments[0].r,arguments[0].g,arguments[0].b);}else if(arguments.length===3){this._color.set(arguments[0],arguments[1],arguments[2]);}this._updateFinalColor();}layersDirty(){this.layers.forEach(layer=>{layer.markLightsDirty();});}updateKey(){let key=this._type<<29|(this._castShadows?1:0)<<28|this._shadowType<<25|this._falloffMode<<23|(this._normalOffsetBias!==0?1:0)<<22|(this._cookie?1:0)<<21|(this._cookieFalloff?1:0)<<20|chanId[this._cookieChannel.charAt(0)]<<18|(this._cookieTransform?1:0)<<12|this._shape<<10|this.numCascades-1<<8|(this.affectSpecularity?1:0)<<7|this.mask<<6;if(this._cookieChannel.length===3){key|=chanId[this._cookieChannel.charAt(1)]<<16;key|=chanId[this._cookieChannel.charAt(2)]<<14;}if(key!==this.key){this.layersDirty();}this.key=key;}constructor(graphicsDevice,clusteredLighting){this.layers=new Set;this.clusteredLighting=void 0;this.shadowDepthState=DepthState.DEFAULT.clone();this.device=graphicsDevice;this.clusteredLighting=clusteredLighting;this.id=id++;this._type=LIGHTTYPE_DIRECTIONAL;this._color=new Color(.8,.8,.8);this._intensity=1;this._affectSpecularity=true;this._luminance=0;this._castShadows=false;this._enabled=false;this._mask=MASK_AFFECT_DYNAMIC;this.isStatic=false;this.key=0;this.bakeDir=true;this.bakeNumSamples=1;this.bakeArea=0;this.attenuationStart=10;this.attenuationEnd=10;this._falloffMode=LIGHTFALLOFF_LINEAR;this._shadowType=SHADOW_PCF3;this._vsmBlurSize=11;this.vsmBlurMode=BLUR_GAUSSIAN;this.vsmBias=.01*.25;this._cookie=null;this.cookieIntensity=1;this._cookieFalloff=true;this._cookieChannel="rgb";this._cookieTransform=null;this._cookieTransformUniform=new Float32Array(4);this._cookieOffset=null;this._cookieOffsetUniform=new Float32Array(2);this._cookieTransformSet=false;this._cookieOffsetSet=false;this._innerConeAngle=40;this._outerConeAngle=45;this.cascades=null;this._shadowMatrixPalette=null;this._shadowCascadeDistances=null;this.numCascades=1;this.cascadeDistribution=.5;this._shape=LIGHTSHAPE_PUNCTUAL;this._finalColor=new Float32Array([.8,.8,.8]);const c=Math.pow(this._finalColor[0],2.2);this._linearFinalColor=new Float32Array([c,c,c]);this._position=new Vec3(0,0,0);this._direction=new Vec3(0,0,0);this._innerConeAngleCos=Math.cos(this._innerConeAngle*Math.PI/180);this._updateOuterAngle(this._outerConeAngle);this._usePhysicalUnits=undefined;this._shadowMap=null;this._shadowRenderParams=[];this._shadowCameraParams=[];this.shadowDistance=40;this._shadowResolution=1024;this._shadowBias=-5e-4;this.shadowIntensity=1;this._normalOffsetBias=0;this.shadowUpdateMode=SHADOWUPDATE_REALTIME;this.shadowUpdateOverrides=null;this._penumbraSize=1;this._isVsm=false;this._isPcf=true;this._cookieMatrix=null;this._atlasViewport=null;this.atlasViewportAllocated=false;this.atlasVersion=0;this.atlasSlotIndex=0;this.atlasSlotUpdated=false;this._node=null;this._renderData=[];this.visibleThisFrame=false;this.maxScreenSize=0;this._updateShadowBias();}}class LightingParams{applySettings(render){var _render$lightingShado,_render$lightingCooki,_render$lightingAreaL,_render$lightingShado2,_render$lightingCooki2,_render$lightingMaxLi,_render$lightingShado3;this.shadowsEnabled=(_render$lightingShado=render.lightingShadowsEnabled)!=null?_render$lightingShado:this.shadowsEnabled;this.cookiesEnabled=(_render$lightingCooki=render.lightingCookiesEnabled)!=null?_render$lightingCooki:this.cookiesEnabled;this.areaLightsEnabled=(_render$lightingAreaL=render.lightingAreaLightsEnabled)!=null?_render$lightingAreaL:this.areaLightsEnabled;this.shadowAtlasResolution=(_render$lightingShado2=render.lightingShadowAtlasResolution)!=null?_render$lightingShado2:this.shadowAtlasResolution;this.cookieAtlasResolution=(_render$lightingCooki2=render.lightingCookieAtlasResolution)!=null?_render$lightingCooki2:this.cookieAtlasResolution;this.maxLightsPerCell=(_render$lightingMaxLi=render.lightingMaxLightsPerCell)!=null?_render$lightingMaxLi:this.maxLightsPerCell;this.shadowType=(_render$lightingShado3=render.lightingShadowType)!=null?_render$lightingShado3:this.shadowType;if(render.lightingCells){this.cell=new Vec3(render.lightingCells);}}set cells(value){this._cells.copy(value);}get cells(){return this._cells}set maxLightsPerCell(value){this._maxLightsPerCell=math.clamp(value,1,255);}get maxLightsPerCell(){return this._maxLightsPerCell}set cookieAtlasResolution(value){this._cookieAtlasResolution=math.clamp(value,32,this._maxTextureSize);}get cookieAtlasResolution(){return this._cookieAtlasResolution}set shadowAtlasResolution(value){this._shadowAtlasResolution=math.clamp(value,32,this._maxTextureSize);}get shadowAtlasResolution(){return this._shadowAtlasResolution}set shadowType(value){if(this._shadowType!==value){this._shadowType=value;this._dirtyLightsFnc();}}get shadowType(){return this._shadowType}set cookiesEnabled(value){if(this._cookiesEnabled!==value){this._cookiesEnabled=value;this._dirtyLightsFnc();}}get cookiesEnabled(){return this._cookiesEnabled}set areaLightsEnabled(value){if(this._supportsAreaLights){if(this._areaLightsEnabled!==value){this._areaLightsEnabled=value;this._dirtyLightsFnc();}}}get areaLightsEnabled(){return this._areaLightsEnabled}set shadowsEnabled(value){if(this._shadowsEnabled!==value){this._shadowsEnabled=value;this._dirtyLightsFnc();}}get shadowsEnabled(){return this._shadowsEnabled}constructor(supportsAreaLights,maxTextureSize,dirtyLightsFnc){this._areaLightsEnabled=false;this._cells=new Vec3(10,3,10);this._maxLightsPerCell=255;this._shadowsEnabled=true;this._shadowType=SHADOW_PCF3;this._shadowAtlasResolution=2048;this._cookiesEnabled=false;this._cookieAtlasResolution=2048;this.debugLayer=void 0;this.atlasSplit=null;this._supportsAreaLights=supportsAreaLights;this._maxTextureSize=maxTextureSize;this._dirtyLightsFnc=dirtyLightsFnc;}}const textureMorphVertexShader=`
	attribute vec2 vertex_position;
	varying vec2 uv0;
	void main(void) {
		gl_Position = vec4(vertex_position, 0.5, 1.0);
		uv0 = vertex_position.xy * 0.5 + 0.5;
	}
	`;const blendStateAdditive=new BlendState(true,BLENDEQUATION_ADD,BLENDMODE_ONE,BLENDMODE_ONE);class MorphInstance{destroy(){this.shader=null;const morph=this.morph;if(morph){this.morph=null;morph.decRefCount();if(morph.refCount<1){morph.destroy();}}if(this.rtPositions){this.rtPositions.destroy();this.rtPositions=null;}if(this.texturePositions){this.texturePositions.destroy();this.texturePositions=null;}if(this.rtNormals){this.rtNormals.destroy();this.rtNormals=null;}if(this.textureNormals){this.textureNormals.destroy();this.textureNormals=null;}}clone(){return new MorphInstance(this.morph)}_getWeightIndex(key){if(typeof key==="string"){const index=this._weightMap.get(key);return index}return key}getWeight(key){const index=this._getWeightIndex(key);return this._weights[index]}setWeight(key,weight){const index=this._getWeightIndex(key);this._weights[index]=weight;this._dirty=true;}_getFragmentShader(numTextures){let fragmentShader="";if(numTextures>0){fragmentShader+="varying vec2 uv0;\n"+`uniform highp float morphFactor[${numTextures}];
`;}for(let i=0;i<numTextures;i++){fragmentShader+=`uniform highp sampler2D morphBlendTex${i};
`;}fragmentShader+="void main (void) {\n"+"    highp vec4 color = vec4(0, 0, 0, 1);\n";for(let i=0;i<numTextures;i++){fragmentShader+=`    color.xyz += morphFactor[${i}] * texture2D(morphBlendTex${i}, uv0).xyz;
`;}fragmentShader+="    gl_FragColor = color;\n"+"}\n";return fragmentShader}_getShader(count){let shader=this.shaderCache[count];if(!shader){const fs=this._getFragmentShader(count);shader=createShaderFromCode(this.device,textureMorphVertexShader,fs,`textureMorph${count}`);this.shaderCache[count]=shader;}return shader}_updateTextureRenderTarget(renderTarget,srcTextureName){const device=this.device;const submitBatch=(usedCount,blending)=>{this.morphFactor.setValue(this._shaderMorphWeights);device.setBlendState(blending?blendStateAdditive:BlendState.NOBLEND);const shader=this._getShader(usedCount);drawQuadWithShader(device,renderTarget,shader);};let usedCount=0;let blending=false;const count=this._activeTargets.length;for(let i=0;i<count;i++){const activeTarget=this._activeTargets[i];const tex=activeTarget.target[srcTextureName];if(tex){this[`morphBlendTex${usedCount}`].setValue(tex);this._shaderMorphWeights[usedCount]=activeTarget.weight;usedCount++;if(usedCount>=this.maxSubmitCount){submitBatch(usedCount,blending);usedCount=0;blending=true;}}}if(usedCount>0||count===0&&!this.zeroTextures){submitBatch(usedCount,blending);}}_updateTextureMorph(){this.device;if(this._activeTargets.length>0||!this.zeroTextures){if(this.rtPositions){this._updateTextureRenderTarget(this.rtPositions,"texturePositions");}if(this.rtNormals){this._updateTextureRenderTarget(this.rtNormals,"textureNormals");}this.zeroTextures=this._activeTargets.length===0;}}_updateVertexMorph(){const count=this.maxSubmitCount;for(let i=0;i<count;i++){this._shaderMorphWeights[i]=0;this._activeVertexBuffers[i]=null;}let posIndex=0;let nrmIndex=this.morph.morphPositions?4:0;for(let i=0;i<this._activeTargets.length;i++){const target=this._activeTargets[i].target;if(target._vertexBufferPositions){this._activeVertexBuffers[posIndex]=target._vertexBufferPositions;this._shaderMorphWeights[posIndex]=this._activeTargets[i].weight;posIndex++;}if(target._vertexBufferNormals){this._activeVertexBuffers[nrmIndex]=target._vertexBufferNormals;this._shaderMorphWeights[nrmIndex]=this._activeTargets[i].weight;nrmIndex++;}}}update(){this._dirty=false;const targets=this.morph._targets;let activeCount=0;const epsilon=1e-5;for(let i=0;i<targets.length;i++){const absWeight=Math.abs(this.getWeight(i));if(absWeight>epsilon){if(this._activeTargets.length<=activeCount){this._activeTargets[activeCount]={};}const activeTarget=this._activeTargets[activeCount++];activeTarget.absWeight=absWeight;activeTarget.weight=this.getWeight(i);activeTarget.target=targets[i];}}this._activeTargets.length=activeCount;const maxActiveTargets=this.morph.maxActiveTargets;if(this._activeTargets.length>maxActiveTargets){this._activeTargets.sort((l,r)=>{return l.absWeight<r.absWeight?1:r.absWeight<l.absWeight?-1:0});this._activeTargets.length=maxActiveTargets;}if(this.morph.useTextureMorph){this._updateTextureMorph();}else {this._updateVertexMorph();}}constructor(morph){this.morph=morph;morph.incRefCount();this.device=morph.device;this._weights=[];this._weightMap=new Map;for(let v=0;v<morph._targets.length;v++){const target=morph._targets[v];if(target.name){this._weightMap.set(target.name,v);}this.setWeight(v,target.defaultWeight);}this._activeTargets=[];if(morph.useTextureMorph){this.shaderCache={};this.maxSubmitCount=this.device.maxTextures;this._shaderMorphWeights=new Float32Array(this.maxSubmitCount);const createRT=(name,textureVar)=>{this[textureVar]=morph._createTexture(name,morph._renderTextureFormat);return new RenderTarget({colorBuffer:this[textureVar],depth:false})};if(morph.morphPositions){this.rtPositions=createRT("MorphRTPos","texturePositions");}if(morph.morphNormals){this.rtNormals=createRT("MorphRTNrm","textureNormals");}this._textureParams=new Float32Array([morph.morphTextureWidth,morph.morphTextureHeight,1/morph.morphTextureWidth,1/morph.morphTextureHeight]);for(let i=0;i<this.maxSubmitCount;i++){this[`morphBlendTex${i}`]=this.device.scope.resolve(`morphBlendTex${i}`);}this.morphFactor=this.device.scope.resolve("morphFactor[0]");this.zeroTextures=false;}else {this.maxSubmitCount=8;this._shaderMorphWeights=new Float32Array(this.maxSubmitCount);this._shaderMorphWeightsA=new Float32Array(this._shaderMorphWeights.buffer,0,4);this._shaderMorphWeightsB=new Float32Array(this._shaderMorphWeights.buffer,4*4,4);this._activeVertexBuffers=new Array(this.maxSubmitCount);}}}class Model{getGraph(){return this.graph}setGraph(graph){this.graph=graph;}getCameras(){return this.cameras}setCameras(cameras){this.cameras=cameras;}getLights(){return this.lights}setLights(lights){this.lights=lights;}getMaterials(){const materials=[];for(let i=0;i<this.meshInstances.length;i++){const meshInstance=this.meshInstances[i];if(materials.indexOf(meshInstance.material)===-1){materials.push(meshInstance.material);}}return materials}clone(){const srcNodes=[];const cloneNodes=[];const _duplicate=function _duplicate(node){const newNode=node.clone();srcNodes.push(node);cloneNodes.push(newNode);for(let idx=0;idx<node._children.length;idx++){newNode.addChild(_duplicate(node._children[idx]));}return newNode};const cloneGraph=_duplicate(this.graph);const cloneMeshInstances=[];const cloneSkinInstances=[];const cloneMorphInstances=[];for(let i=0;i<this.skinInstances.length;i++){const skin=this.skinInstances[i].skin;const cloneSkinInstance=new SkinInstance(skin);const bones=[];for(let j=0;j<skin.boneNames.length;j++){const boneName=skin.boneNames[j];const bone=cloneGraph.findByName(boneName);bones.push(bone);}cloneSkinInstance.bones=bones;cloneSkinInstances.push(cloneSkinInstance);}for(let i=0;i<this.morphInstances.length;i++){const morph=this.morphInstances[i].morph;const cloneMorphInstance=new MorphInstance(morph);cloneMorphInstances.push(cloneMorphInstance);}for(let i=0;i<this.meshInstances.length;i++){const meshInstance=this.meshInstances[i];const nodeIndex=srcNodes.indexOf(meshInstance.node);const cloneMeshInstance=new MeshInstance(meshInstance.mesh,meshInstance.material,cloneNodes[nodeIndex]);if(meshInstance.skinInstance){const skinInstanceIndex=this.skinInstances.indexOf(meshInstance.skinInstance);cloneMeshInstance.skinInstance=cloneSkinInstances[skinInstanceIndex];}if(meshInstance.morphInstance){const morphInstanceIndex=this.morphInstances.indexOf(meshInstance.morphInstance);cloneMeshInstance.morphInstance=cloneMorphInstances[morphInstanceIndex];}cloneMeshInstances.push(cloneMeshInstance);}const clone=new Model;clone.graph=cloneGraph;clone.meshInstances=cloneMeshInstances;clone.skinInstances=cloneSkinInstances;clone.morphInstances=cloneMorphInstances;clone.getGraph().syncHierarchy();return clone}destroy(){const meshInstances=this.meshInstances;for(let i=0;i<meshInstances.length;i++){meshInstances[i].destroy();}this.meshInstances.length=0;}generateWireframe(){MeshInstance._prepareRenderStyleForArray(this.meshInstances,RENDERSTYLE_WIREFRAME);}constructor(){this.graph=null;this.meshInstances=[];this.skinInstances=[];this.morphInstances=[];this.cameras=[];this.lights=[];this._shadersVersion=0;this._immutable=false;}}class Morph extends RefCountedObject{get aabb(){if(!this._aabb){const min=new Vec3;const max=new Vec3;for(let i=0;i<this._targets.length;i++){const targetAabb=this._targets[i].aabb;min.min(targetAabb.getMin());max.max(targetAabb.getMax());}this._aabb=new BoundingBox;this._aabb.setMinMax(min,max);}return this._aabb}get morphPositions(){return this._morphPositions}get morphNormals(){return this._morphNormals}get maxActiveTargets(){if(this._useTextureMorph){return this._targets.length}return this._morphPositions&&this._morphNormals?4:8}get useTextureMorph(){return this._useTextureMorph}_init(){if(this._useTextureMorph){this._useTextureMorph=this._initTextureBased();}if(!this._useTextureMorph){for(let i=0;i<this._targets.length;i++){this._targets[i]._initVertexBuffers(this.device);}}for(let i=0;i<this._targets.length;i++){this._targets[i]._postInit();}}_findSparseSet(deltaArrays,ids,usedDataIndices,floatRounding){let freeIndex=1;const dataCount=deltaArrays[0].length;for(let v=0;v<dataCount;v+=3){let vertexUsed=false;for(let i=0;i<deltaArrays.length;i++){const data=deltaArrays[i];if(data[v]!==0||data[v+1]!==0||data[v+2]!==0){vertexUsed=true;break}}if(vertexUsed){ids.push(freeIndex+floatRounding);usedDataIndices.push(v/3);freeIndex++;}else {ids.push(0+floatRounding);}}return freeIndex}_initTextureBased(){const useUintIds=this.device.isWebGPU;const floatRounding=useUintIds?0:.2;const deltaArrays=[],deltaInfos=[];for(let i=0;i<this._targets.length;i++){const target=this._targets[i];if(target.options.deltaPositions){deltaArrays.push(target.options.deltaPositions);deltaInfos.push({target:target,name:"texturePositions"});}if(target.options.deltaNormals){deltaArrays.push(target.options.deltaNormals);deltaInfos.push({target:target,name:"textureNormals"});}}const ids=[],usedDataIndices=[];const freeIndex=this._findSparseSet(deltaArrays,ids,usedDataIndices,floatRounding);const maxTextureSize=Math.min(this.device.maxTextureSize,4096);let morphTextureWidth=Math.ceil(Math.sqrt(freeIndex));morphTextureWidth=Math.min(morphTextureWidth,maxTextureSize);const morphTextureHeight=Math.ceil(freeIndex/morphTextureWidth);if(morphTextureHeight>maxTextureSize){return false}this.morphTextureWidth=morphTextureWidth;this.morphTextureHeight=morphTextureHeight;let halfFloat=false;let numComponents=3;const float2Half=FloatPacking.float2Half;if(this._textureFormat===PIXELFORMAT_RGBA16F){halfFloat=true;numComponents=4;}const textures=[];for(let i=0;i<deltaArrays.length;i++){textures.push(this._createTexture("MorphTarget",this._textureFormat));}for(let i=0;i<deltaArrays.length;i++){const data=deltaArrays[i];const texture=textures[i];const textureData=texture.lock();if(halfFloat){for(let v=0;v<usedDataIndices.length;v++){const index=usedDataIndices[v]*3;const dstIndex=v*numComponents+numComponents;textureData[dstIndex]=float2Half(data[index]);textureData[dstIndex+1]=float2Half(data[index+1]);textureData[dstIndex+2]=float2Half(data[index+2]);}}else {for(let v=0;v<usedDataIndices.length;v++){const index=usedDataIndices[v]*3;const dstIndex=v*numComponents+numComponents;textureData[dstIndex]=data[index];textureData[dstIndex+1]=data[index+1];textureData[dstIndex+2]=data[index+2];}}texture.unlock();const target=deltaInfos[i].target;target._setTexture(deltaInfos[i].name,texture);}const formatDesc=[{semantic:SEMANTIC_ATTR15,components:1,type:useUintIds?TYPE_UINT32:TYPE_FLOAT32}];this.vertexBufferIds=new VertexBuffer(this.device,new VertexFormat(this.device,formatDesc,ids.length),ids.length,{data:useUintIds?new Uint32Array(ids):new Float32Array(ids)});return true}destroy(){var _this$vertexBufferIds;(_this$vertexBufferIds=this.vertexBufferIds)==null||_this$vertexBufferIds.destroy();this.vertexBufferIds=null;for(let i=0;i<this._targets.length;i++){this._targets[i].destroy();}this._targets.length=0;}get targets(){return this._targets}_updateMorphFlags(){this._morphPositions=false;this._morphNormals=false;for(let i=0;i<this._targets.length;i++){const target=this._targets[i];if(target.morphPositions){this._morphPositions=true;}if(target.morphNormals){this._morphNormals=true;}}}_createTexture(name,format){return new Texture(this.device,{width:this.morphTextureWidth,height:this.morphTextureHeight,format:format,cubemap:false,mipmaps:false,minFilter:FILTER_NEAREST,magFilter:FILTER_NEAREST,addressU:ADDRESS_CLAMP_TO_EDGE,addressV:ADDRESS_CLAMP_TO_EDGE,name:name})}constructor(targets,graphicsDevice,{preferHighPrecision=false}={}){super();this._aabb=void 0;this.preferHighPrecision=void 0;this.device=graphicsDevice;this.preferHighPrecision=preferHighPrecision;this._targets=targets.slice();const device=this.device;if(device.supportsMorphTargetTexturesCore){const renderableHalf=device.extTextureHalfFloat&&device.textureHalfFloatRenderable?PIXELFORMAT_RGBA16F:undefined;const renderableFloat=device.extTextureFloat&&device.textureFloatRenderable?PIXELFORMAT_RGBA32F:undefined;this._renderTextureFormat=this.preferHighPrecision?renderableFloat!=null?renderableFloat:renderableHalf:renderableHalf!=null?renderableHalf:renderableFloat;const textureHalf=device.extTextureHalfFloat&&device.textureHalfFloatUpdatable?PIXELFORMAT_RGBA16F:undefined;const textureFloat=device.extTextureFloat?PIXELFORMAT_RGB32F:undefined;this._textureFormat=this.preferHighPrecision?textureFloat!=null?textureFloat:textureHalf:textureHalf!=null?textureHalf:textureFloat;if(this._renderTextureFormat!==undefined&&this._textureFormat!==undefined){this._useTextureMorph=true;}}this._init();this._updateMorphFlags();}}class MorphTarget{destroy(){var _this$_vertexBufferPo,_this$_vertexBufferNo,_this$texturePosition,_this$textureNormals;(_this$_vertexBufferPo=this._vertexBufferPositions)==null||_this$_vertexBufferPo.destroy();this._vertexBufferPositions=null;(_this$_vertexBufferNo=this._vertexBufferNormals)==null||_this$_vertexBufferNo.destroy();this._vertexBufferNormals=null;(_this$texturePosition=this.texturePositions)==null||_this$texturePosition.destroy();this.texturePositions=null;(_this$textureNormals=this.textureNormals)==null||_this$textureNormals.destroy();this.textureNormals=null;}get name(){return this._name}get defaultWeight(){return this._defaultWeight}get aabb(){if(!this._aabb){this._aabb=new BoundingBox;if(this.deltaPositions){this._aabb.compute(this.deltaPositions);}}return this._aabb}get morphPositions(){return !!this._vertexBufferPositions||!!this.texturePositions}get morphNormals(){return !!this._vertexBufferNormals||!!this.textureNormals}clone(){return new MorphTarget(this.options)}_postInit(){if(!this.options.preserveData){this.options=null;}this.used=true;}_initVertexBuffers(graphicsDevice){const options=this.options;this._vertexBufferPositions=this._createVertexBuffer(graphicsDevice,options.deltaPositions,options.deltaPositionsType);this._vertexBufferNormals=this._createVertexBuffer(graphicsDevice,options.deltaNormals,options.deltaNormalsType);if(this._vertexBufferPositions){this.deltaPositions=this._vertexBufferPositions.lock();}}_createVertexBuffer(device,data,dataType=TYPE_FLOAT32){if(data){const formatDesc=[{semantic:SEMANTIC_ATTR0,components:3,type:dataType}];return new VertexBuffer(device,new VertexFormat(device,formatDesc),data.length/3,{data:data})}return null}_setTexture(name,texture){this[name]=texture;}constructor(options){this.used=false;if(arguments.length===2){options=arguments[1];}this.options=options;this._name=options.name;this._defaultWeight=options.defaultWeight||0;this._aabb=options.aabb;this.deltaPositions=options.deltaPositions;}}class ShaderGeneratorParticle extends ShaderGenerator{generateKey(options){let key="particle";for(const prop in options){if(options.hasOwnProperty(prop)){key+=options[prop];}}return key}_animTex(options){let vshader="";vshader+=options.animTexLoop?shaderChunks.particleAnimFrameLoopVS:shaderChunks.particleAnimFrameClampVS;vshader+=shaderChunks.particleAnimTexVS;return vshader}createShaderDefinition(device,options){const executionDefine=`#define PARTICLE_${options.useCpu?"CPU":"GPU"}
`;let fshader=`#define PARTICLE
${executionDefine}`;let vshader=`#define VERTEXSHADER
${executionDefine}`;if(options.mesh)vshader+="#define USE_MESH\n";if(options.localSpace)vshader+="#define LOCAL_SPACE\n";if(options.screenSpace)vshader+="#define SCREEN_SPACE\n";if(options.animTex)vshader+="\nuniform vec2 animTexTilesParams;\n";if(options.animTex)vshader+="\nuniform vec4 animTexParams;\n";if(options.animTex)vshader+="\nuniform vec2 animTexIndexParams;\n";if(options.normal===2)vshader+="\nvarying mat3 ParticleMat;\n";if(options.normal===1)vshader+="\nvarying vec3 Normal;\n";if(options.soft)vshader+="\nvarying float vDepth;\n";const faceVS=options.customFace?shaderChunks.particle_customFaceVS:shaderChunks.particle_billboardVS;if(!options.useCpu){vshader+=shaderChunks.particle_initVS;vshader+=options.pack8?shaderChunks.particleInputRgba8PS:shaderChunks.particleInputFloatPS;if(options.soft>0)vshader+=shaderChunks.screenDepthPS;vshader+=shaderChunks.particleVS;if(options.localSpace)vshader+=shaderChunks.particle_localShiftVS;if(options.animTex)vshader+=this._animTex(options);if(options.wrap)vshader+=shaderChunks.particle_wrapVS;if(options.alignToMotion)vshader+=shaderChunks.particle_pointAlongVS;vshader+=options.mesh?shaderChunks.particle_meshVS:faceVS;if(options.normal===1)vshader+=shaderChunks.particle_normalVS;if(options.normal===2)vshader+=shaderChunks.particle_TBNVS;if(options.stretch>0)vshader+=shaderChunks.particle_stretchVS;vshader+=shaderChunks.particle_endVS;if(options.soft>0)vshader+=shaderChunks.particle_softVS;}else {if(options.soft>0)vshader+=shaderChunks.screenDepthPS;vshader+=shaderChunks.particle_cpuVS;if(options.localSpace)vshader+=shaderChunks.particle_localShiftVS;if(options.animTex)vshader+=this._animTex(options);if(options.alignToMotion)vshader+=shaderChunks.particle_pointAlongVS;vshader+=options.mesh?shaderChunks.particle_meshVS:faceVS;if(options.normal===1)vshader+=shaderChunks.particle_normalVS;if(options.normal===2)vshader+=shaderChunks.particle_TBNVS;if(options.stretch>0)vshader+=shaderChunks.particle_stretchVS;vshader+=shaderChunks.particle_cpu_endVS;if(options.soft>0)vshader+=shaderChunks.particle_softVS;}vshader+="}\n";if(options.normal>0){if(options.normal===1){fshader+="\nvarying vec3 Normal;\n";}else if(options.normal===2){fshader+="\nvarying mat3 ParticleMat;\n";}fshader+="\nuniform vec3 lightCube[6];\n";}if(options.soft)fshader+="\nvarying float vDepth;\n";if(options.normal===0&&options.fog==="none")options.srgb=false;fshader+=shaderChunks.decodePS;fshader+=ShaderGenerator.gammaCode(options.gamma);fshader+=ShaderGenerator.tonemapCode(options.toneMap);if(options.fog==="linear"){fshader+=shaderChunks.fogLinearPS;}else if(options.fog==="exp"){fshader+=shaderChunks.fogExpPS;}else if(options.fog==="exp2"){fshader+=shaderChunks.fogExp2PS;}else {fshader+=shaderChunks.fogNonePS;}if(options.normal===2)fshader+="\nuniform sampler2D normalMap;\n";if(options.soft>0)fshader+=shaderChunks.screenDepthPS;fshader+=shaderChunks.particlePS;if(options.soft>0)fshader+=shaderChunks.particle_softPS;if(options.normal===1)fshader+="\nvec3 normal = Normal;\n";if(options.normal===2)fshader+=shaderChunks.particle_normalMapPS;if(options.normal>0)fshader+=options.halflambert?shaderChunks.particle_halflambertPS:shaderChunks.particle_lambertPS;if(options.normal>0)fshader+=shaderChunks.particle_lightingPS;if(options.blend===BLEND_NORMAL){fshader+=shaderChunks.particle_blendNormalPS;}else if(options.blend===BLEND_ADDITIVE){fshader+=shaderChunks.particle_blendAddPS;}else if(options.blend===BLEND_MULTIPLICATIVE){fshader+=shaderChunks.particle_blendMultiplyPS;}fshader+=shaderChunks.particle_endPS;return ShaderUtils.createDefinition(device,{name:"ParticleShader",vertexCode:vshader,fragmentCode:fshader})}}const particle=new ShaderGeneratorParticle;let nonUniformScale;let uniformScale=1;const particleTexChannels$1=4;const rotMat=new Mat4;const rotMatInv=new Mat4;const randomPosTformed=new Vec3;const randomPos=new Vec3;const rndFactor3Vec=new Vec3;const particlePosPrev=new Vec3;const velocityVec=new Vec3;const localVelocityVec=new Vec3;const velocityVec2=new Vec3;const localVelocityVec2=new Vec3;const radialVelocityVec=new Vec3;const particlePos=new Vec3;const particleFinalPos=new Vec3;const moveDirVec=new Vec3;const tmpVec3$1=new Vec3;function frac(f){return f-Math.floor(f)}function saturate$1(x){return Math.max(Math.min(x,1),0)}function glMod(x,y){return x-y*Math.floor(x/y)}function encodeFloatRGBA(v){let encX=frac(v);let encY=frac(255*v);let encZ=frac(65025*v);let encW=frac(160581375*v);encX-=encY/255;encY-=encZ/255;encZ-=encW/255;encW-=encW/255;return [encX,encY,encZ,encW]}function encodeFloatRG(v){let encX=frac(v);let encY=frac(255*v);encX-=encY/255;encY-=encY/255;return [encX,encY]}class ParticleCPUUpdater{calcSpawnPosition(particleTex,spawnMatrix,extentsInnerRatioUniform,emitterPos,i){const emitter=this._emitter;const rX=Math.random();const rY=Math.random();const rZ=Math.random();const rW=Math.random();if(emitter.useCpu){particleTex[i*particleTexChannels$1+0+emitter.numParticlesPot*2*particleTexChannels$1]=rX;particleTex[i*particleTexChannels$1+1+emitter.numParticlesPot*2*particleTexChannels$1]=rY;particleTex[i*particleTexChannels$1+2+emitter.numParticlesPot*2*particleTexChannels$1]=rZ;}randomPos.x=rX-.5;randomPos.y=rY-.5;randomPos.z=rZ-.5;if(emitter.emitterShape===EMITTERSHAPE_BOX){const max=Math.max(Math.abs(randomPos.x),Math.max(Math.abs(randomPos.y),Math.abs(randomPos.z)));const edgeX=max+(.5-max)*extentsInnerRatioUniform[0];const edgeY=max+(.5-max)*extentsInnerRatioUniform[1];const edgeZ=max+(.5-max)*extentsInnerRatioUniform[2];randomPos.x=edgeX*(max===Math.abs(randomPos.x)?Math.sign(randomPos.x):2*randomPos.x);randomPos.y=edgeY*(max===Math.abs(randomPos.y)?Math.sign(randomPos.y):2*randomPos.y);randomPos.z=edgeZ*(max===Math.abs(randomPos.z)?Math.sign(randomPos.z):2*randomPos.z);if(!emitter.localSpace){randomPosTformed.copy(emitterPos).add(spawnMatrix.transformPoint(randomPos));}else {randomPosTformed.copy(spawnMatrix.transformPoint(randomPos));}}else {randomPos.normalize();const spawnBoundsSphereInnerRatio=emitter.emitterRadius===0?0:emitter.emitterRadiusInner/emitter.emitterRadius;const r=rW*(1-spawnBoundsSphereInnerRatio)+spawnBoundsSphereInnerRatio;if(!emitter.localSpace){randomPosTformed.copy(emitterPos).add(randomPos.mulScalar(r*emitter.emitterRadius));}else {randomPosTformed.copy(randomPos.mulScalar(r*emitter.emitterRadius));}}const particleRate=math.lerp(emitter.rate,emitter.rate2,rX);let startSpawnTime=-particleRate*i;if(emitter.pack8){const packX=(randomPosTformed.x-emitter.worldBounds.center.x)/emitter.worldBoundsSize.x+.5;const packY=(randomPosTformed.y-emitter.worldBounds.center.y)/emitter.worldBoundsSize.y+.5;const packZ=(randomPosTformed.z-emitter.worldBounds.center.z)/emitter.worldBoundsSize.z+.5;let packA=math.lerp(emitter.startAngle*math.DEG_TO_RAD,emitter.startAngle2*math.DEG_TO_RAD,rX);packA=packA%(Math.PI*2)/(Math.PI*2);const rg0=encodeFloatRG(packX);particleTex[i*particleTexChannels$1]=rg0[0];particleTex[i*particleTexChannels$1+1]=rg0[1];const ba0=encodeFloatRG(packY);particleTex[i*particleTexChannels$1+2]=ba0[0];particleTex[i*particleTexChannels$1+3]=ba0[1];const rg1=encodeFloatRG(packZ);particleTex[i*particleTexChannels$1+0+emitter.numParticlesPot*particleTexChannels$1]=rg1[0];particleTex[i*particleTexChannels$1+1+emitter.numParticlesPot*particleTexChannels$1]=rg1[1];const ba1=encodeFloatRG(packA);particleTex[i*particleTexChannels$1+2+emitter.numParticlesPot*particleTexChannels$1]=ba1[0];particleTex[i*particleTexChannels$1+3+emitter.numParticlesPot*particleTexChannels$1]=ba1[1];const a2=1;particleTex[i*particleTexChannels$1+3+emitter.numParticlesPot*particleTexChannels$1*2]=a2;const maxNegLife=Math.max(emitter.lifetime,(emitter.numParticles-1)*Math.max(emitter.rate,emitter.rate2));const maxPosLife=emitter.lifetime+1;startSpawnTime=(startSpawnTime+maxNegLife)/(maxNegLife+maxPosLife);const rgba3=encodeFloatRGBA(startSpawnTime);particleTex[i*particleTexChannels$1+0+emitter.numParticlesPot*particleTexChannels$1*3]=rgba3[0];particleTex[i*particleTexChannels$1+1+emitter.numParticlesPot*particleTexChannels$1*3]=rgba3[1];particleTex[i*particleTexChannels$1+2+emitter.numParticlesPot*particleTexChannels$1*3]=rgba3[2];particleTex[i*particleTexChannels$1+3+emitter.numParticlesPot*particleTexChannels$1*3]=rgba3[3];}else {particleTex[i*particleTexChannels$1]=randomPosTformed.x;particleTex[i*particleTexChannels$1+1]=randomPosTformed.y;particleTex[i*particleTexChannels$1+2]=randomPosTformed.z;particleTex[i*particleTexChannels$1+3]=math.lerp(emitter.startAngle*math.DEG_TO_RAD,emitter.startAngle2*math.DEG_TO_RAD,rX);particleTex[i*particleTexChannels$1+3+emitter.numParticlesPot*particleTexChannels$1]=startSpawnTime;}}update(data,vbToSort,particleTex,spawnMatrix,extentsInnerRatioUniform,emitterPos,delta,isOnStop){let a,b,c;const emitter=this._emitter;if(emitter.meshInstance.node){const fullMat=emitter.meshInstance.node.worldTransform;for(let j=0;j<12;j++){rotMat.data[j]=fullMat.data[j];}rotMatInv.copy(rotMat);rotMatInv.invert();nonUniformScale=emitter.meshInstance.node.localScale;uniformScale=Math.max(Math.max(nonUniformScale.x,nonUniformScale.y),nonUniformScale.z);}emitterPos=emitter.meshInstance.node===null||emitter.localSpace?Vec3.ZERO:emitter.meshInstance.node.getPosition();const posCam=emitter.camera?emitter.camera._node.getPosition():Vec3.ZERO;const vertSize=!emitter.useMesh?15:17;let cf,cc;let rotSpeed,rotSpeed2,scale2,alpha,alpha2,radialSpeed,radialSpeed2;const precision1=emitter.precision-1;for(let i=0;i<emitter.numParticles;i++){const id=Math.floor(emitter.vbCPU[i*emitter.numParticleVerts*(emitter.useMesh?6:4)+3]);const rndFactor=particleTex[id*particleTexChannels$1+0+emitter.numParticlesPot*2*particleTexChannels$1];rndFactor3Vec.x=rndFactor;rndFactor3Vec.y=particleTex[id*particleTexChannels$1+1+emitter.numParticlesPot*2*particleTexChannels$1];rndFactor3Vec.z=particleTex[id*particleTexChannels$1+2+emitter.numParticlesPot*2*particleTexChannels$1];const particleRate=emitter.rate+(emitter.rate2-emitter.rate)*rndFactor;const particleLifetime=emitter.lifetime;let life=particleTex[id*particleTexChannels$1+3+emitter.numParticlesPot*particleTexChannels$1]+delta;const nlife=saturate$1(life/particleLifetime);let scale=0;let alphaDiv=0;const angle=0;const respawn=life-delta<=0||life>=particleLifetime;if(respawn){this.calcSpawnPosition(particleTex,spawnMatrix,extentsInnerRatioUniform,emitterPos,id);}let particleEnabled=life>0&&life<particleLifetime;if(particleEnabled){c=nlife*precision1;cf=Math.floor(c);cc=Math.ceil(c);c%=1;a=emitter.qRotSpeed[cf];b=emitter.qRotSpeed[cc];rotSpeed=a+(b-a)*c;a=emitter.qRotSpeed2[cf];b=emitter.qRotSpeed2[cc];rotSpeed2=a+(b-a)*c;a=emitter.qScale[cf];b=emitter.qScale[cc];scale=a+(b-a)*c;a=emitter.qScale2[cf];b=emitter.qScale2[cc];scale2=a+(b-a)*c;a=emitter.qAlpha[cf];b=emitter.qAlpha[cc];alpha=a+(b-a)*c;a=emitter.qAlpha2[cf];b=emitter.qAlpha2[cc];alpha2=a+(b-a)*c;a=emitter.qRadialSpeed[cf];b=emitter.qRadialSpeed[cc];radialSpeed=a+(b-a)*c;a=emitter.qRadialSpeed2[cf];b=emitter.qRadialSpeed2[cc];radialSpeed2=a+(b-a)*c;radialSpeed+=(radialSpeed2-radialSpeed)*(rndFactor*100%1);particlePosPrev.x=particleTex[id*particleTexChannels$1];particlePosPrev.y=particleTex[id*particleTexChannels$1+1];particlePosPrev.z=particleTex[id*particleTexChannels$1+2];if(!emitter.localSpace){radialVelocityVec.copy(particlePosPrev).sub(emitterPos);}else {radialVelocityVec.copy(particlePosPrev);}radialVelocityVec.normalize().mulScalar(radialSpeed);cf*=3;cc*=3;a=emitter.qLocalVelocity[cf];b=emitter.qLocalVelocity[cc];localVelocityVec.x=a+(b-a)*c;a=emitter.qLocalVelocity[cf+1];b=emitter.qLocalVelocity[cc+1];localVelocityVec.y=a+(b-a)*c;a=emitter.qLocalVelocity[cf+2];b=emitter.qLocalVelocity[cc+2];localVelocityVec.z=a+(b-a)*c;a=emitter.qLocalVelocity2[cf];b=emitter.qLocalVelocity2[cc];localVelocityVec2.x=a+(b-a)*c;a=emitter.qLocalVelocity2[cf+1];b=emitter.qLocalVelocity2[cc+1];localVelocityVec2.y=a+(b-a)*c;a=emitter.qLocalVelocity2[cf+2];b=emitter.qLocalVelocity2[cc+2];localVelocityVec2.z=a+(b-a)*c;a=emitter.qVelocity[cf];b=emitter.qVelocity[cc];velocityVec.x=a+(b-a)*c;a=emitter.qVelocity[cf+1];b=emitter.qVelocity[cc+1];velocityVec.y=a+(b-a)*c;a=emitter.qVelocity[cf+2];b=emitter.qVelocity[cc+2];velocityVec.z=a+(b-a)*c;a=emitter.qVelocity2[cf];b=emitter.qVelocity2[cc];velocityVec2.x=a+(b-a)*c;a=emitter.qVelocity2[cf+1];b=emitter.qVelocity2[cc+1];velocityVec2.y=a+(b-a)*c;a=emitter.qVelocity2[cf+2];b=emitter.qVelocity2[cc+2];velocityVec2.z=a+(b-a)*c;localVelocityVec.x+=(localVelocityVec2.x-localVelocityVec.x)*rndFactor3Vec.x;localVelocityVec.y+=(localVelocityVec2.y-localVelocityVec.y)*rndFactor3Vec.y;localVelocityVec.z+=(localVelocityVec2.z-localVelocityVec.z)*rndFactor3Vec.z;if(emitter.initialVelocity>0){if(emitter.emitterShape===EMITTERSHAPE_SPHERE){randomPos.copy(rndFactor3Vec).mulScalar(2).sub(Vec3.ONE).normalize();localVelocityVec.add(randomPos.mulScalar(emitter.initialVelocity));}else {localVelocityVec.add(Vec3.FORWARD.mulScalar(emitter.initialVelocity));}}velocityVec.x+=(velocityVec2.x-velocityVec.x)*rndFactor3Vec.x;velocityVec.y+=(velocityVec2.y-velocityVec.y)*rndFactor3Vec.y;velocityVec.z+=(velocityVec2.z-velocityVec.z)*rndFactor3Vec.z;rotSpeed+=(rotSpeed2-rotSpeed)*rndFactor3Vec.y;scale=(scale+(scale2-scale)*(rndFactor*1e4%1))*uniformScale;alphaDiv=(alpha2-alpha)*(rndFactor*1e3%1);if(emitter.meshInstance.node){if(!emitter.localSpace){rotMat.transformPoint(localVelocityVec,localVelocityVec);}else {localVelocityVec.x/=nonUniformScale.x;localVelocityVec.y/=nonUniformScale.y;localVelocityVec.z/=nonUniformScale.z;}}if(!emitter.localSpace){localVelocityVec.add(velocityVec.mul(nonUniformScale));localVelocityVec.add(radialVelocityVec.mul(nonUniformScale));}else {rotMatInv.transformPoint(velocityVec,velocityVec);localVelocityVec.add(velocityVec).add(radialVelocityVec);}moveDirVec.copy(localVelocityVec);particlePos.copy(particlePosPrev).add(localVelocityVec.mulScalar(delta));particleFinalPos.copy(particlePos);particleTex[id*particleTexChannels$1]=particleFinalPos.x;particleTex[id*particleTexChannels$1+1]=particleFinalPos.y;particleTex[id*particleTexChannels$1+2]=particleFinalPos.z;particleTex[id*particleTexChannels$1+3]+=rotSpeed*delta;if(emitter.wrap&&emitter.wrapBounds){if(!emitter.localSpace){particleFinalPos.sub(emitterPos);}particleFinalPos.x=glMod(particleFinalPos.x,emitter.wrapBounds.x)-emitter.wrapBounds.x*.5;particleFinalPos.y=glMod(particleFinalPos.y,emitter.wrapBounds.y)-emitter.wrapBounds.y*.5;particleFinalPos.z=glMod(particleFinalPos.z,emitter.wrapBounds.z)-emitter.wrapBounds.z*.5;if(!emitter.localSpace){particleFinalPos.add(emitterPos);}}if(emitter.sort>0){if(emitter.sort===1){tmpVec3$1.copy(particleFinalPos).sub(posCam);emitter.particleDistance[id]=-(tmpVec3$1.x*tmpVec3$1.x+tmpVec3$1.y*tmpVec3$1.y+tmpVec3$1.z*tmpVec3$1.z);}else if(emitter.sort===2){emitter.particleDistance[id]=life;}else if(emitter.sort===3){emitter.particleDistance[id]=-life;}}}if(isOnStop){if(life<0){particleTex[id*particleTexChannels$1+3+emitter.numParticlesPot*2*particleTexChannels$1]=-1;}}else {if(life>=particleLifetime){life-=Math.max(particleLifetime,(emitter.numParticles-1)*particleRate);particleTex[id*particleTexChannels$1+3+emitter.numParticlesPot*2*particleTexChannels$1]=emitter.loop?1:-1;}if(life<0&&emitter.loop){particleTex[id*particleTexChannels$1+3+emitter.numParticlesPot*2*particleTexChannels$1]=1;}}if(particleTex[id*particleTexChannels$1+3+emitter.numParticlesPot*2*particleTexChannels$1]<0){particleEnabled=false;}particleTex[id*particleTexChannels$1+3+emitter.numParticlesPot*particleTexChannels$1]=life;for(let v=0;v<emitter.numParticleVerts;v++){const vbOffset=(i*emitter.numParticleVerts+v)*(emitter.useMesh?6:4);let quadX=emitter.vbCPU[vbOffset];let quadY=emitter.vbCPU[vbOffset+1];let quadZ=emitter.vbCPU[vbOffset+2];if(!particleEnabled){quadX=quadY=quadZ=0;}const w=i*emitter.numParticleVerts*vertSize+v*vertSize;data[w]=particleFinalPos.x;data[w+1]=particleFinalPos.y;data[w+2]=particleFinalPos.z;data[w+3]=nlife;data[w+4]=emitter.alignToMotion?angle:particleTex[id*particleTexChannels$1+3];data[w+5]=scale;data[w+6]=alphaDiv;data[w+7]=moveDirVec.x;data[w+8]=quadX;data[w+9]=quadY;data[w+10]=quadZ;data[w+11]=moveDirVec.y;data[w+12]=id;data[w+13]=moveDirVec.z;data[w+14]=emitter.vbCPU[vbOffset+3];if(emitter.useMesh){data[w+15]=emitter.vbCPU[vbOffset+4];data[w+16]=emitter.vbCPU[vbOffset+5];}}}if(emitter.sort>PARTICLESORT_NONE&&emitter.camera){const vbStride=emitter.useMesh?6:4;const particleDistance=emitter.particleDistance;for(let i=0;i<emitter.numParticles;i++){vbToSort[i][0]=i;vbToSort[i][1]=particleDistance[Math.floor(emitter.vbCPU[i*emitter.numParticleVerts*vbStride+3])];}emitter.vbOld.set(emitter.vbCPU);vbToSort.sort((p1,p2)=>{return p1[1]-p2[1]});for(let i=0;i<emitter.numParticles;i++){const src=vbToSort[i][0]*emitter.numParticleVerts*vbStride;const dest=i*emitter.numParticleVerts*vbStride;for(let j=0;j<emitter.numParticleVerts*vbStride;j++){emitter.vbCPU[dest+j]=emitter.vbOld[src+j];}}}}constructor(emitter){this._emitter=emitter;}}const spawnMatrix3=new Mat3;const emitterMatrix3=new Mat3;const emitterMatrix3Inv=new Mat3;class ParticleGPUUpdater{_setInputBounds(){this.inBoundsSizeUniform[0]=this._emitter.prevWorldBoundsSize.x;this.inBoundsSizeUniform[1]=this._emitter.prevWorldBoundsSize.y;this.inBoundsSizeUniform[2]=this._emitter.prevWorldBoundsSize.z;this.constantInBoundsSize.setValue(this.inBoundsSizeUniform);this.inBoundsCenterUniform[0]=this._emitter.prevWorldBoundsCenter.x;this.inBoundsCenterUniform[1]=this._emitter.prevWorldBoundsCenter.y;this.inBoundsCenterUniform[2]=this._emitter.prevWorldBoundsCenter.z;this.constantInBoundsCenter.setValue(this.inBoundsCenterUniform);}randomize(){this.frameRandomUniform[0]=Math.random();this.frameRandomUniform[1]=Math.random();this.frameRandomUniform[2]=Math.random();}update(device,spawnMatrix,extentsInnerRatioUniform,delta,isOnStop){const emitter=this._emitter;device.setBlendState(BlendState.NOBLEND);device.setDepthState(DepthState.NODEPTH);device.setCullMode(CULLFACE_NONE);this.randomize();this.constantGraphSampleSize.setValue(1/emitter.precision);this.constantGraphNumSamples.setValue(emitter.precision);this.constantNumParticles.setValue(emitter.numParticles);this.constantNumParticlesPot.setValue(emitter.numParticlesPot);this.constantInternalTex0.setValue(emitter.internalTex0);this.constantInternalTex1.setValue(emitter.internalTex1);this.constantInternalTex2.setValue(emitter.internalTex2);this.constantInternalTex3.setValue(emitter.internalTex3);const node=emitter.meshInstance.node;const emitterScale=node===null?Vec3.ONE:node.localScale;if(emitter.pack8){this.worldBoundsMulUniform[0]=emitter.worldBoundsMul.x;this.worldBoundsMulUniform[1]=emitter.worldBoundsMul.y;this.worldBoundsMulUniform[2]=emitter.worldBoundsMul.z;this.constantOutBoundsMul.setValue(this.worldBoundsMulUniform);this.worldBoundsAddUniform[0]=emitter.worldBoundsAdd.x;this.worldBoundsAddUniform[1]=emitter.worldBoundsAdd.y;this.worldBoundsAddUniform[2]=emitter.worldBoundsAdd.z;this.constantOutBoundsAdd.setValue(this.worldBoundsAddUniform);this._setInputBounds();let maxVel=emitter.maxVel*Math.max(Math.max(emitterScale.x,emitterScale.y),emitterScale.z);maxVel=Math.max(maxVel,1);this.constantMaxVel.setValue(maxVel);}const emitterPos=node===null||emitter.localSpace?Vec3.ZERO:node.getPosition();const emitterMatrix=node===null?Mat4.IDENTITY:node.getWorldTransform();if(emitter.emitterShape===EMITTERSHAPE_BOX){spawnMatrix3.setFromMat4(spawnMatrix);this.constantSpawnBounds.setValue(spawnMatrix3.data);this.constantSpawnPosInnerRatio.setValue(extentsInnerRatioUniform);}else {this.constantSpawnBoundsSphere.setValue(emitter.emitterRadius);this.constantSpawnBoundsSphereInnerRatio.setValue(emitter.emitterRadius===0?0:emitter.emitterRadiusInner/emitter.emitterRadius);}this.constantInitialVelocity.setValue(emitter.initialVelocity);emitterMatrix3.setFromMat4(emitterMatrix);emitterMatrix3Inv.invertMat4(emitterMatrix);this.emitterPosUniform[0]=emitterPos.x;this.emitterPosUniform[1]=emitterPos.y;this.emitterPosUniform[2]=emitterPos.z;this.constantEmitterPos.setValue(this.emitterPosUniform);this.constantFrameRandom.setValue(this.frameRandomUniform);this.constantDelta.setValue(delta);this.constantRate.setValue(emitter.rate);this.constantRateDiv.setValue(emitter.rate2-emitter.rate);this.constantStartAngle.setValue(emitter.startAngle*math.DEG_TO_RAD);this.constantStartAngle2.setValue(emitter.startAngle2*math.DEG_TO_RAD);this.constantSeed.setValue(emitter.seed);this.constantLifetime.setValue(emitter.lifetime);this.emitterScaleUniform[0]=emitterScale.x;this.emitterScaleUniform[1]=emitterScale.y;this.emitterScaleUniform[2]=emitterScale.z;this.constantEmitterScale.setValue(this.emitterScaleUniform);this.constantEmitterMatrix.setValue(emitterMatrix3.data);this.constantEmitterMatrixInv.setValue(emitterMatrix3Inv.data);this.constantLocalVelocityDivMult.setValue(emitter.localVelocityUMax);this.constantVelocityDivMult.setValue(emitter.velocityUMax);this.constantRotSpeedDivMult.setValue(emitter.rotSpeedUMax[0]);let texIN=emitter.swapTex?emitter.particleTexOUT:emitter.particleTexIN;texIN=emitter.beenReset?emitter.particleTexStart:texIN;const texOUT=emitter.swapTex?emitter.particleTexIN:emitter.particleTexOUT;this.constantParticleTexIN.setValue(texIN);drawQuadWithShader(device,emitter.swapTex?emitter.rtParticleTexIN:emitter.rtParticleTexOUT,!isOnStop?emitter.loop?emitter.shaderParticleUpdateRespawn:emitter.shaderParticleUpdateNoRespawn:emitter.shaderParticleUpdateOnStop);emitter.material.setParameter("particleTexOUT",texIN);emitter.material.setParameter("particleTexIN",texOUT);emitter.beenReset=false;emitter.swapTex=!emitter.swapTex;emitter.prevWorldBoundsSize.copy(emitter.worldBoundsSize);emitter.prevWorldBoundsCenter.copy(emitter.worldBounds.center);if(emitter.pack8){this._setInputBounds();}}constructor(emitter,gd){this._emitter=emitter;this.frameRandomUniform=new Float32Array(3);this.emitterPosUniform=new Float32Array(3);this.emitterScaleUniform=new Float32Array([1,1,1]);this.worldBoundsMulUniform=new Float32Array(3);this.worldBoundsAddUniform=new Float32Array(3);this.inBoundsSizeUniform=new Float32Array(3);this.inBoundsCenterUniform=new Float32Array(3);this.constantParticleTexIN=gd.scope.resolve("particleTexIN");this.constantParticleTexOUT=gd.scope.resolve("particleTexOUT");this.constantEmitterPos=gd.scope.resolve("emitterPos");this.constantEmitterScale=gd.scope.resolve("emitterScale");this.constantSpawnBounds=gd.scope.resolve("spawnBounds");this.constantSpawnPosInnerRatio=gd.scope.resolve("spawnPosInnerRatio");this.constantSpawnBoundsSphere=gd.scope.resolve("spawnBoundsSphere");this.constantSpawnBoundsSphereInnerRatio=gd.scope.resolve("spawnBoundsSphereInnerRatio");this.constantInitialVelocity=gd.scope.resolve("initialVelocity");this.constantFrameRandom=gd.scope.resolve("frameRandom");this.constantDelta=gd.scope.resolve("delta");this.constantRate=gd.scope.resolve("rate");this.constantRateDiv=gd.scope.resolve("rateDiv");this.constantLifetime=gd.scope.resolve("lifetime");this.constantGraphSampleSize=gd.scope.resolve("graphSampleSize");this.constantGraphNumSamples=gd.scope.resolve("graphNumSamples");this.constantInternalTex0=gd.scope.resolve("internalTex0");this.constantInternalTex1=gd.scope.resolve("internalTex1");this.constantInternalTex2=gd.scope.resolve("internalTex2");this.constantInternalTex3=gd.scope.resolve("internalTex3");this.constantEmitterMatrix=gd.scope.resolve("emitterMatrix");this.constantEmitterMatrixInv=gd.scope.resolve("emitterMatrixInv");this.constantNumParticles=gd.scope.resolve("numParticles");this.constantNumParticlesPot=gd.scope.resolve("numParticlesPot");this.constantLocalVelocityDivMult=gd.scope.resolve("localVelocityDivMult");this.constantVelocityDivMult=gd.scope.resolve("velocityDivMult");this.constantRotSpeedDivMult=gd.scope.resolve("rotSpeedDivMult");this.constantSeed=gd.scope.resolve("seed");this.constantStartAngle=gd.scope.resolve("startAngle");this.constantStartAngle2=gd.scope.resolve("startAngle2");this.constantOutBoundsMul=gd.scope.resolve("outBoundsMul");this.constantOutBoundsAdd=gd.scope.resolve("outBoundsAdd");this.constantInBoundsSize=gd.scope.resolve("inBoundsSize");this.constantInBoundsCenter=gd.scope.resolve("inBoundsCenter");this.constantMaxVel=gd.scope.resolve("maxVel");this.constantFaceTangent=gd.scope.resolve("faceTangent");this.constantFaceBinorm=gd.scope.resolve("faceBinorm");}}const particleVerts=[[-1,-1],[1,-1],[1,1],[-1,1]];function _createTexture(device,width,height,pixelData,format=PIXELFORMAT_RGBA32F,mult8Bit,filter){let mipFilter=FILTER_NEAREST;if(filter&&format===PIXELFORMAT_RGBA8){mipFilter=FILTER_LINEAR;}const texture=new Texture(device,{width:width,height:height,format:format,cubemap:false,mipmaps:false,minFilter:mipFilter,magFilter:mipFilter,addressU:ADDRESS_CLAMP_TO_EDGE,addressV:ADDRESS_CLAMP_TO_EDGE,name:"ParticleSystemTexture"});const pixels=texture.lock();if(format===PIXELFORMAT_RGBA8){const temp=new Uint8Array(pixelData.length);for(let i=0;i<pixelData.length;i++){temp[i]=pixelData[i]*mult8Bit*255;}pixelData=temp;}pixels.set(pixelData);texture.unlock();return texture}function saturate(x){return Math.max(Math.min(x,1),0)}const default0Curve=new Curve([0,0,1,0]);const default1Curve=new Curve([0,1,1,1]);const default0Curve3=new CurveSet([0,0,1,0],[0,0,1,0],[0,0,1,0]);const default1Curve3=new CurveSet([0,1,1,1],[0,1,1,1],[0,1,1,1]);let particleTexHeight=2;const particleTexChannels=4;const extentsInnerRatioUniform=new Float32Array(3);const spawnMatrix=new Mat4;const tmpVec3=new Vec3;const bMin=new Vec3;const bMax=new Vec3;let setPropertyTarget;let setPropertyOptions;function setProperty(pName,defaultVal){if(setPropertyOptions[pName]!==undefined&&setPropertyOptions[pName]!==null){setPropertyTarget[pName]=setPropertyOptions[pName];}else {setPropertyTarget[pName]=defaultVal;}}function pack3NFloats(a,b,c){const packed=a*255<<16|b*255<<8|c*255;return packed/(1<<24)}function packTextureXYZ_NXYZ(qXYZ,qXYZ2){const num=qXYZ.length/3;const colors=new Array(num*4);for(let i=0;i<num;i++){colors[i*4]=qXYZ[i*3];colors[i*4+1]=qXYZ[i*3+1];colors[i*4+2]=qXYZ[i*3+2];colors[i*4+3]=pack3NFloats(qXYZ2[i*3],qXYZ2[i*3+1],qXYZ2[i*3+2]);}return colors}function packTextureRGBA(qRGB,qA){const colors=new Array(qA.length*4);for(let i=0;i<qA.length;i++){colors[i*4]=qRGB[i*3];colors[i*4+1]=qRGB[i*3+1];colors[i*4+2]=qRGB[i*3+2];colors[i*4+3]=qA[i];}return colors}function packTexture5Floats(qA,qB,qC,qD,qE){const colors=new Array(qA.length*4);for(let i=0;i<qA.length;i++){colors[i*4]=qA[i];colors[i*4+1]=qB[i];colors[i*4+2]=0;colors[i*4+3]=pack3NFloats(qC[i],qD[i],qE[i]);}return colors}function packTexture2Floats(qA,qB){const colors=new Array(qA.length*4);for(let i=0;i<qA.length;i++){colors[i*4]=qA[i];colors[i*4+1]=qB[i];colors[i*4+2]=0;colors[i*4+3]=0;}return colors}function calcEndTime(emitter){const interval=Math.max(emitter.rate,emitter.rate2)*emitter.numParticles+emitter.lifetime;return Date.now()+interval*1e3}function subGraph(A,B){const r=new Float32Array(A.length);for(let i=0;i<A.length;i++){r[i]=A[i]-B[i];}return r}function maxUnsignedGraphValue(A,outUMax){const chans=outUMax.length;const values=A.length/chans;for(let i=0;i<values;i++){for(let j=0;j<chans;j++){const a=Math.abs(A[i*chans+j]);outUMax[j]=Math.max(outUMax[j],a);}}}function normalizeGraph(A,uMax){const chans=uMax.length;const values=A.length/chans;for(let i=0;i<values;i++){for(let j=0;j<chans;j++){A[i*chans+j]/=uMax[j]===0?1:uMax[j];A[i*chans+j]*=.5;A[i*chans+j]+=.5;}}}function divGraphFrom2Curves(curve1,curve2,outUMax){const sub=subGraph(curve2,curve1);maxUnsignedGraphValue(sub,outUMax);normalizeGraph(sub,outUMax);return sub}const particleEmitterDeviceCache=new DeviceCache;class ParticleEmitter{get defaultParamTexture(){return particleEmitterDeviceCache.get(this.graphicsDevice,()=>{const resolution=16;const centerPoint=resolution*.5+.5;const dtex=new Float32Array(resolution*resolution*4);for(let y=0;y<resolution;y++){for(let x=0;x<resolution;x++){const xgrad=x+1-centerPoint;const ygrad=y+1-centerPoint;const c=saturate(1-saturate(Math.sqrt(xgrad*xgrad+ygrad*ygrad)/resolution)-.5);const p=y*resolution+x;dtex[p*4]=1;dtex[p*4+1]=1;dtex[p*4+2]=1;dtex[p*4+3]=c;}}const texture=_createTexture(this.graphicsDevice,resolution,resolution,dtex,PIXELFORMAT_RGBA8,1,true);texture.minFilter=FILTER_LINEAR;texture.magFilter=FILTER_LINEAR;return texture})}onChangeCamera(){this.regenShader();this.resetMaterial();}calculateBoundsMad(){this.worldBoundsMul.x=1/this.worldBoundsSize.x;this.worldBoundsMul.y=1/this.worldBoundsSize.y;this.worldBoundsMul.z=1/this.worldBoundsSize.z;this.worldBoundsAdd.copy(this.worldBounds.center).mul(this.worldBoundsMul).mulScalar(-1);this.worldBoundsAdd.x+=.5;this.worldBoundsAdd.y+=.5;this.worldBoundsAdd.z+=.5;}calculateWorldBounds(){if(!this.node)return;this.prevWorldBoundsSize.copy(this.worldBoundsSize);this.prevWorldBoundsCenter.copy(this.worldBounds.center);if(!this.useCpu){let recalculateLocalBounds=false;if(this.emitterShape===EMITTERSHAPE_BOX){recalculateLocalBounds=!this.emitterExtents.equals(this.prevEmitterExtents);}else {recalculateLocalBounds=!(this.emitterRadius===this.prevEmitterRadius);}if(recalculateLocalBounds){this.calculateLocalBounds();}}const nodeWT=this.node.getWorldTransform();if(this.localSpace){this.worldBoundsNoTrail.copy(this.localBounds);}else {this.worldBoundsNoTrail.setFromTransformedAabb(this.localBounds,nodeWT);}this.worldBoundsTrail[0].add(this.worldBoundsNoTrail);this.worldBoundsTrail[1].add(this.worldBoundsNoTrail);const now=this.simTimeTotal;if(now>=this.timeToSwitchBounds){this.worldBoundsTrail[0].copy(this.worldBoundsTrail[1]);this.worldBoundsTrail[1].copy(this.worldBoundsNoTrail);this.timeToSwitchBounds=now+this.lifetime;}this.worldBounds.copy(this.worldBoundsTrail[0]);this.worldBoundsSize.copy(this.worldBounds.halfExtents).mulScalar(2);if(this.localSpace){this.meshInstance.aabb.setFromTransformedAabb(this.worldBounds,nodeWT);this.meshInstance.mesh.aabb.setFromTransformedAabb(this.worldBounds,nodeWT);}else {this.meshInstance.aabb.copy(this.worldBounds);this.meshInstance.mesh.aabb.copy(this.worldBounds);}this.meshInstance._aabbVer=1-this.meshInstance._aabbVer;if(this.pack8)this.calculateBoundsMad();}resetWorldBounds(){if(!this.node)return;this.worldBoundsNoTrail.setFromTransformedAabb(this.localBounds,this.localSpace?Mat4.IDENTITY:this.node.getWorldTransform());this.worldBoundsTrail[0].copy(this.worldBoundsNoTrail);this.worldBoundsTrail[1].copy(this.worldBoundsNoTrail);this.worldBounds.copy(this.worldBoundsTrail[0]);this.worldBoundsSize.copy(this.worldBounds.halfExtents).mulScalar(2);this.prevWorldBoundsSize.copy(this.worldBoundsSize);this.prevWorldBoundsCenter.copy(this.worldBounds.center);this.simTimeTotal=0;this.timeToSwitchBounds=0;}calculateLocalBounds(){let minx=Number.MAX_VALUE;let miny=Number.MAX_VALUE;let minz=Number.MAX_VALUE;let maxx=-Number.MAX_VALUE;let maxy=-Number.MAX_VALUE;let maxz=-Number.MAX_VALUE;let maxR=0;let maxScale=0;const stepWeight=this.lifetime/this.precision;const wVels=[this.qVelocity,this.qVelocity2];const lVels=[this.qLocalVelocity,this.qLocalVelocity2];const accumX=[0,0];const accumY=[0,0];const accumZ=[0,0];const accumR=[0,0];const accumW=[0,0];let x,y,z;for(let i=0;i<this.precision+1;i++){const index=Math.min(i,this.precision-1);for(let j=0;j<2;j++){x=lVels[j][index*3+0]*stepWeight+accumX[j];y=lVels[j][index*3+1]*stepWeight+accumY[j];z=lVels[j][index*3+2]*stepWeight+accumZ[j];minx=Math.min(x,minx);miny=Math.min(y,miny);minz=Math.min(z,minz);maxx=Math.max(x,maxx);maxy=Math.max(y,maxy);maxz=Math.max(z,maxz);accumX[j]=x;accumY[j]=y;accumZ[j]=z;}for(let j=0;j<2;j++){accumW[j]+=stepWeight*Math.sqrt(wVels[j][index*3+0]*wVels[j][index*3+0]+wVels[j][index*3+1]*wVels[j][index*3+1]+wVels[j][index*3+2]*wVels[j][index*3+2]);}accumR[0]+=this.qRadialSpeed[index]*stepWeight;accumR[1]+=this.qRadialSpeed2[index]*stepWeight;maxR=Math.max(maxR,Math.max(Math.abs(accumR[0]),Math.abs(accumR[1])));maxScale=Math.max(maxScale,this.qScale[index]);}if(this.emitterShape===EMITTERSHAPE_BOX){x=this.emitterExtents.x*.5;y=this.emitterExtents.y*.5;z=this.emitterExtents.z*.5;}else {x=this.emitterRadius;y=this.emitterRadius;z=this.emitterRadius;}const w=Math.max(accumW[0],accumW[1]);bMin.x=minx-maxScale-x-maxR-w;bMin.y=miny-maxScale-y-maxR-w;bMin.z=minz-maxScale-z-maxR-w;bMax.x=maxx+maxScale+x+maxR+w;bMax.y=maxy+maxScale+y+maxR+w;bMax.z=maxz+maxScale+z+maxR+w;this.localBounds.setMinMax(bMin,bMax);}rebuild(){const gd=this.graphicsDevice;if(this.colorMap===null)this.colorMap=this.defaultParamTexture;this.spawnBounds=this.emitterShape===EMITTERSHAPE_BOX?this.emitterExtents:this.emitterRadius;this.useCpu=this.useCpu||this.sort>PARTICLESORT_NONE||gd.maxVertexTextures<=1||gd.fragmentUniformsCount<64||gd.forceCpuParticles||!gd.extTextureFloat;this._destroyResources();this.pack8=(this.pack8||!gd.textureFloatRenderable)&&!this.useCpu;particleTexHeight=this.useCpu||this.pack8?4:2;this.useMesh=false;if(this.mesh){const totalVertCount=this.numParticles*this.mesh.vertexBuffer.numVertices;if(totalVertCount>65535);else {this.useMesh=true;}}this.numParticlesPot=math.nextPowerOfTwo(this.numParticles);this.rebuildGraphs();this.calculateLocalBounds();this.resetWorldBounds();if(this.node){this.worldBounds.setFromTransformedAabb(this.localBounds,this.localSpace?Mat4.IDENTITY:this.node.getWorldTransform());this.worldBoundsTrail[0].copy(this.worldBounds);this.worldBoundsTrail[1].copy(this.worldBounds);this.worldBoundsSize.copy(this.worldBounds.halfExtents).mulScalar(2);this.prevWorldBoundsSize.copy(this.worldBoundsSize);this.prevWorldBoundsCenter.copy(this.worldBounds.center);if(this.pack8)this.calculateBoundsMad();}this.vbToSort=new Array(this.numParticles);for(let iSort=0;iSort<this.numParticles;iSort++)this.vbToSort[iSort]=[0,0];this.particleDistance=new Float32Array(this.numParticles);this._gpuUpdater.randomize();this.particleTex=new Float32Array(this.numParticlesPot*particleTexHeight*particleTexChannels);const emitterPos=this.node===null||this.localSpace?Vec3.ZERO:this.node.getPosition();if(this.emitterShape===EMITTERSHAPE_BOX){if(this.node===null||this.localSpace){spawnMatrix.setTRS(Vec3.ZERO,Quat.IDENTITY,this.spawnBounds);}else {spawnMatrix.setTRS(Vec3.ZERO,this.node.getRotation(),tmpVec3.copy(this.spawnBounds).mul(this.node.localScale));}extentsInnerRatioUniform[0]=this.emitterExtents.x!==0?this.emitterExtentsInner.x/this.emitterExtents.x:0;extentsInnerRatioUniform[1]=this.emitterExtents.y!==0?this.emitterExtentsInner.y/this.emitterExtents.y:0;extentsInnerRatioUniform[2]=this.emitterExtents.z!==0?this.emitterExtentsInner.z/this.emitterExtents.z:0;}for(let i=0;i<this.numParticles;i++){this._cpuUpdater.calcSpawnPosition(this.particleTex,spawnMatrix,extentsInnerRatioUniform,emitterPos,i);if(this.useCpu)this.particleTex[i*particleTexChannels+3+this.numParticlesPot*2*particleTexChannels]=1;}this.particleTexStart=new Float32Array(this.numParticlesPot*particleTexHeight*particleTexChannels);for(let i=0;i<this.particleTexStart.length;i++){this.particleTexStart[i]=this.particleTex[i];}if(!this.useCpu){if(this.pack8){this.particleTexIN=_createTexture(gd,this.numParticlesPot,particleTexHeight,this.particleTex,PIXELFORMAT_RGBA8,1,false);this.particleTexOUT=_createTexture(gd,this.numParticlesPot,particleTexHeight,this.particleTex,PIXELFORMAT_RGBA8,1,false);this.particleTexStart=_createTexture(gd,this.numParticlesPot,particleTexHeight,this.particleTexStart,PIXELFORMAT_RGBA8,1,false);}else {this.particleTexIN=_createTexture(gd,this.numParticlesPot,particleTexHeight,this.particleTex);this.particleTexOUT=_createTexture(gd,this.numParticlesPot,particleTexHeight,this.particleTex);this.particleTexStart=_createTexture(gd,this.numParticlesPot,particleTexHeight,this.particleTexStart);}this.rtParticleTexIN=new RenderTarget({colorBuffer:this.particleTexIN,depth:false});this.rtParticleTexOUT=new RenderTarget({colorBuffer:this.particleTexOUT,depth:false});this.swapTex=false;}const shaderCodeStart=(this.localSpace?"#define LOCAL_SPACE\n":"")+shaderChunks.particleUpdaterInitPS+(this.pack8?shaderChunks.particleInputRgba8PS+shaderChunks.particleOutputRgba8PS:shaderChunks.particleInputFloatPS+shaderChunks.particleOutputFloatPS)+(this.emitterShape===EMITTERSHAPE_BOX?shaderChunks.particleUpdaterAABBPS:shaderChunks.particleUpdaterSpherePS)+shaderChunks.particleUpdaterStartPS;const shaderCodeRespawn=shaderCodeStart+shaderChunks.particleUpdaterRespawnPS+shaderChunks.particleUpdaterEndPS;const shaderCodeNoRespawn=shaderCodeStart+shaderChunks.particleUpdaterNoRespawnPS+shaderChunks.particleUpdaterEndPS;const shaderCodeOnStop=shaderCodeStart+shaderChunks.particleUpdaterOnStopPS+shaderChunks.particleUpdaterEndPS;const params=`${this.emitterShape}${this.pack8}${this.localSpace}`;this.shaderParticleUpdateRespawn=createShaderFromCode(gd,shaderChunks.fullscreenQuadVS,shaderCodeRespawn,`fsQuad0${params}`);this.shaderParticleUpdateNoRespawn=createShaderFromCode(gd,shaderChunks.fullscreenQuadVS,shaderCodeNoRespawn,`fsQuad1${params}`);this.shaderParticleUpdateOnStop=createShaderFromCode(gd,shaderChunks.fullscreenQuadVS,shaderCodeOnStop,`fsQuad2${params}`);this.numParticleVerts=this.useMesh?this.mesh.vertexBuffer.numVertices:4;this.numParticleIndices=this.useMesh?this.mesh.indexBuffer[0].numIndices:6;this._allocate(this.numParticles);const mesh=new Mesh(gd);mesh.vertexBuffer=this.vertexBuffer;mesh.indexBuffer[0]=this.indexBuffer;mesh.primitive[0].type=PRIMITIVE_TRIANGLES;mesh.primitive[0].base=0;mesh.primitive[0].count=this.numParticles*this.numParticleIndices;mesh.primitive[0].indexed=true;this.material=new Material;this.material.name=this.node.name;this.material.cull=CULLFACE_NONE;this.material.alphaWrite=false;this.material.blendType=this.blendType;this.material.depthWrite=this.depthWrite;this.material.emitter=this;this.regenShader();this.resetMaterial();const wasVisible=this.meshInstance?this.meshInstance.visible:true;this.meshInstance=new MeshInstance(mesh,this.material,this.node);this.meshInstance.pick=false;this.meshInstance.updateKey();this.meshInstance.cull=true;if(this.localSpace){this.meshInstance.aabb.setFromTransformedAabb(this.worldBounds,this.node.getWorldTransform());}else {this.meshInstance.aabb.copy(this.worldBounds);}this.meshInstance._updateAabb=false;this.meshInstance.visible=wasVisible;this._initializeTextures();this.resetTime();this.addTime(0,false);if(this.preWarm)this.prewarm(this.lifetime);}_isAnimated(){return this.animNumFrames>=1&&(this.animTilesX>1||this.animTilesY>1)&&(this.colorMap&&this.colorMap!==this.defaultParamTexture||this.normalMap)}rebuildGraphs(){const precision=this.precision;const gd=this.graphicsDevice;this.qLocalVelocity=this.localVelocityGraph.quantize(precision);this.qVelocity=this.velocityGraph.quantize(precision);this.qColor=this.colorGraph.quantizeClamped(precision,0,1);this.qRotSpeed=this.rotationSpeedGraph.quantize(precision);this.qScale=this.scaleGraph.quantize(precision);this.qAlpha=this.alphaGraph.quantize(precision);this.qRadialSpeed=this.radialSpeedGraph.quantize(precision);this.qLocalVelocity2=this.localVelocityGraph2.quantize(precision);this.qVelocity2=this.velocityGraph2.quantize(precision);this.qColor2=this.colorGraph2.quantizeClamped(precision,0,1);this.qRotSpeed2=this.rotationSpeedGraph2.quantize(precision);this.qScale2=this.scaleGraph2.quantize(precision);this.qAlpha2=this.alphaGraph2.quantize(precision);this.qRadialSpeed2=this.radialSpeedGraph2.quantize(precision);for(let i=0;i<precision;i++){this.qRotSpeed[i]*=math.DEG_TO_RAD;this.qRotSpeed2[i]*=math.DEG_TO_RAD;}this.localVelocityUMax=new Float32Array(3);this.velocityUMax=new Float32Array(3);this.colorUMax=new Float32Array(3);this.rotSpeedUMax=[0];this.scaleUMax=[0];this.alphaUMax=[0];this.radialSpeedUMax=[0];this.qLocalVelocityDiv=divGraphFrom2Curves(this.qLocalVelocity,this.qLocalVelocity2,this.localVelocityUMax);this.qVelocityDiv=divGraphFrom2Curves(this.qVelocity,this.qVelocity2,this.velocityUMax);this.qColorDiv=divGraphFrom2Curves(this.qColor,this.qColor2,this.colorUMax);this.qRotSpeedDiv=divGraphFrom2Curves(this.qRotSpeed,this.qRotSpeed2,this.rotSpeedUMax);this.qScaleDiv=divGraphFrom2Curves(this.qScale,this.qScale2,this.scaleUMax);this.qAlphaDiv=divGraphFrom2Curves(this.qAlpha,this.qAlpha2,this.alphaUMax);this.qRadialSpeedDiv=divGraphFrom2Curves(this.qRadialSpeed,this.qRadialSpeed2,this.radialSpeedUMax);if(this.pack8){const umax=[0,0,0];maxUnsignedGraphValue(this.qVelocity,umax);const umax2=[0,0,0];maxUnsignedGraphValue(this.qVelocity2,umax2);const lumax=[0,0,0];maxUnsignedGraphValue(this.qLocalVelocity,lumax);const lumax2=[0,0,0];maxUnsignedGraphValue(this.qLocalVelocity2,lumax2);const rumax=[0];maxUnsignedGraphValue(this.qRadialSpeed,rumax);const rumax2=[0];maxUnsignedGraphValue(this.qRadialSpeed2,rumax2);let maxVel=Math.max(umax[0],umax2[0]);maxVel=Math.max(maxVel,umax[1]);maxVel=Math.max(maxVel,umax2[1]);maxVel=Math.max(maxVel,umax[2]);maxVel=Math.max(maxVel,umax2[2]);let lmaxVel=Math.max(lumax[0],lumax2[0]);lmaxVel=Math.max(lmaxVel,lumax[1]);lmaxVel=Math.max(lmaxVel,lumax2[1]);lmaxVel=Math.max(lmaxVel,lumax[2]);lmaxVel=Math.max(lmaxVel,lumax2[2]);const maxRad=Math.max(rumax[0],rumax2[0]);this.maxVel=maxVel+lmaxVel+maxRad;}if(!this.useCpu){this.internalTex0=_createTexture(gd,precision,1,packTextureXYZ_NXYZ(this.qLocalVelocity,this.qLocalVelocityDiv));this.internalTex1=_createTexture(gd,precision,1,packTextureXYZ_NXYZ(this.qVelocity,this.qVelocityDiv));this.internalTex2=_createTexture(gd,precision,1,packTexture5Floats(this.qRotSpeed,this.qScale,this.qScaleDiv,this.qRotSpeedDiv,this.qAlphaDiv));this.internalTex3=_createTexture(gd,precision,1,packTexture2Floats(this.qRadialSpeed,this.qRadialSpeedDiv));}this.colorParam=_createTexture(gd,precision,1,packTextureRGBA(this.qColor,this.qAlpha),PIXELFORMAT_RGBA8,1,true);}_initializeTextures(){if(this.colorMap){this.material.setParameter("colorMap",this.colorMap);if(this.lighting&&this.normalMap){this.material.setParameter("normalMap",this.normalMap);}}}regenShader(){const programLib=getProgramLibrary(this.graphicsDevice);programLib.register("particle",particle);const hasNormal=this.normalMap!==null;this.normalOption=0;if(this.lighting){this.normalOption=hasNormal?2:1;}this.material.getShaderVariant=function(dev,sc,defs,unused,pass,sortedLights,viewUniformFormat,viewBindGroupFormat){if(this.emitter.scene){if(this.emitter.camera!==this.emitter.scene._activeCamera){this.emitter.camera=this.emitter.scene._activeCamera;this.emitter.onChangeCamera();}}const inTools=this.emitter.inTools;const processingOptions=new ShaderProcessorOptions(viewUniformFormat,viewBindGroupFormat);const shader=programLib.getProgram("particle",{pass:SHADER_FORWARD,useCpu:this.emitter.useCpu,normal:this.emitter.normalOption,halflambert:this.emitter.halfLambert,stretch:this.emitter.stretch,alignToMotion:this.emitter.alignToMotion,soft:this.emitter.depthSoftening,mesh:this.emitter.useMesh,gamma:this.emitter.scene?this.emitter.scene.gammaCorrection:0,toneMap:this.emitter.scene?this.emitter.scene.toneMapping:0,fog:this.emitter.scene&&!this.emitter.noFog?this.emitter.scene.fog:"none",wrap:this.emitter.wrap&&this.emitter.wrapBounds,localSpace:this.emitter.localSpace,screenSpace:inTools?false:this.emitter.screenSpace,blend:this.blendType,animTex:this.emitter._isAnimated(),animTexLoop:this.emitter.animLoop,pack8:this.emitter.pack8,customFace:this.emitter.orientation!==PARTICLEORIENTATION_SCREEN},processingOptions);return shader};this.material.shader=this.material.getShaderVariant();}resetMaterial(){const material=this.material;material.setParameter("stretch",this.stretch);if(this._isAnimated()){material.setParameter("animTexTilesParams",this.animTilesParams);material.setParameter("animTexParams",this.animParams);material.setParameter("animTexIndexParams",this.animIndexParams);}material.setParameter("colorMult",this.intensity);if(!this.useCpu){material.setParameter("internalTex0",this.internalTex0);material.setParameter("internalTex1",this.internalTex1);material.setParameter("internalTex2",this.internalTex2);material.setParameter("internalTex3",this.internalTex3);}material.setParameter("colorParam",this.colorParam);material.setParameter("numParticles",this.numParticles);material.setParameter("numParticlesPot",this.numParticlesPot);material.setParameter("lifetime",this.lifetime);material.setParameter("rate",this.rate);material.setParameter("rateDiv",this.rate2-this.rate);material.setParameter("seed",this.seed);material.setParameter("scaleDivMult",this.scaleUMax[0]);material.setParameter("alphaDivMult",this.alphaUMax[0]);material.setParameter("radialSpeedDivMult",this.radialSpeedUMax[0]);material.setParameter("graphNumSamples",this.precision);material.setParameter("graphSampleSize",1/this.precision);material.setParameter("emitterScale",new Float32Array([1,1,1]));if(this.pack8){this._gpuUpdater._setInputBounds();material.setParameter("inBoundsSize",this._gpuUpdater.inBoundsSizeUniform);material.setParameter("inBoundsCenter",this._gpuUpdater.inBoundsCenterUniform);material.setParameter("maxVel",this.maxVel);}if(this.wrap&&this.wrapBounds){this.wrapBoundsUniform[0]=this.wrapBounds.x;this.wrapBoundsUniform[1]=this.wrapBounds.y;this.wrapBoundsUniform[2]=this.wrapBounds.z;material.setParameter("wrapBounds",this.wrapBoundsUniform);}if(this.colorMap){material.setParameter("colorMap",this.colorMap);}if(this.lighting){if(this.normalMap){material.setParameter("normalMap",this.normalMap);}}if(this.depthSoftening>0){material.setParameter("softening",1/(this.depthSoftening*this.depthSoftening*100));}if(this.stretch>0)material.cull=CULLFACE_NONE;this._compParticleFaceParams();}_compParticleFaceParams(){let tangent,binormal;if(this.orientation===PARTICLEORIENTATION_SCREEN){tangent=new Float32Array([1,0,0]);binormal=new Float32Array([0,0,1]);}else {let n;if(this.orientation===PARTICLEORIENTATION_WORLD){n=this.particleNormal.normalize();}else {const emitterMat=this.node===null?Mat4.IDENTITY:this.node.getWorldTransform();n=emitterMat.transformVector(this.particleNormal).normalize();}const t=new Vec3(1,0,0);if(Math.abs(t.dot(n))===1){t.set(0,0,1);}const b=new Vec3().cross(n,t).normalize();t.cross(b,n).normalize();tangent=new Float32Array([t.x,t.y,t.z]);binormal=new Float32Array([b.x,b.y,b.z]);}this.material.setParameter("faceTangent",tangent);this.material.setParameter("faceBinorm",binormal);}_allocate(numParticles){const psysVertCount=numParticles*this.numParticleVerts;const psysIndexCount=numParticles*this.numParticleIndices;if(this.vertexBuffer===undefined||this.vertexBuffer.getNumVertices()!==psysVertCount){if(!this.useCpu){const elements=[{semantic:SEMANTIC_ATTR0,components:4,type:TYPE_FLOAT32}];if(this.useMesh){elements.push({semantic:SEMANTIC_ATTR1,components:2,type:TYPE_FLOAT32});}const particleFormat=new VertexFormat(this.graphicsDevice,elements);this.vertexBuffer=new VertexBuffer(this.graphicsDevice,particleFormat,psysVertCount,{usage:BUFFER_DYNAMIC});this.indexBuffer=new IndexBuffer(this.graphicsDevice,INDEXFORMAT_UINT16,psysIndexCount);}else {const elements=[{semantic:SEMANTIC_ATTR0,components:4,type:TYPE_FLOAT32},{semantic:SEMANTIC_ATTR1,components:4,type:TYPE_FLOAT32},{semantic:SEMANTIC_ATTR2,components:4,type:TYPE_FLOAT32},{semantic:SEMANTIC_ATTR3,components:1,type:TYPE_FLOAT32},{semantic:SEMANTIC_ATTR4,components:this.useMesh?4:2,type:TYPE_FLOAT32}];const particleFormat=new VertexFormat(this.graphicsDevice,elements);this.vertexBuffer=new VertexBuffer(this.graphicsDevice,particleFormat,psysVertCount,{usage:BUFFER_DYNAMIC});this.indexBuffer=new IndexBuffer(this.graphicsDevice,INDEXFORMAT_UINT16,psysIndexCount);}const data=new Float32Array(this.vertexBuffer.lock());let meshData,stride,texCoordOffset;if(this.useMesh){meshData=new Float32Array(this.mesh.vertexBuffer.lock());stride=meshData.length/this.mesh.vertexBuffer.numVertices;for(let elem=0;elem<this.mesh.vertexBuffer.format.elements.length;elem++){if(this.mesh.vertexBuffer.format.elements[elem].name===SEMANTIC_TEXCOORD0){texCoordOffset=this.mesh.vertexBuffer.format.elements[elem].offset/4;break}}}for(let i=0;i<psysVertCount;i++){const id=Math.floor(i/this.numParticleVerts);if(!this.useMesh){const vertID=i%4;data[i*4]=particleVerts[vertID][0];data[i*4+1]=particleVerts[vertID][1];data[i*4+2]=0;data[i*4+3]=id;}else {const vert=i%this.numParticleVerts;data[i*6]=meshData[vert*stride];data[i*6+1]=meshData[vert*stride+1];data[i*6+2]=meshData[vert*stride+2];data[i*6+3]=id;data[i*6+4]=meshData[vert*stride+texCoordOffset+0];data[i*6+5]=1-meshData[vert*stride+texCoordOffset+1];}}if(this.useCpu){this.vbCPU=new Float32Array(data);this.vbOld=new Float32Array(this.vbCPU.length);}this.vertexBuffer.unlock();if(this.useMesh){this.mesh.vertexBuffer.unlock();}let dst=0;const indices=new Uint16Array(this.indexBuffer.lock());if(this.useMesh)meshData=new Uint16Array(this.mesh.indexBuffer[0].lock());for(let i=0;i<numParticles;i++){if(!this.useMesh){const baseIndex=i*4;indices[dst++]=baseIndex;indices[dst++]=baseIndex+1;indices[dst++]=baseIndex+2;indices[dst++]=baseIndex;indices[dst++]=baseIndex+2;indices[dst++]=baseIndex+3;}else {for(let j=0;j<this.numParticleIndices;j++){indices[i*this.numParticleIndices+j]=meshData[j]+i*this.numParticleVerts;}}}this.indexBuffer.unlock();if(this.useMesh)this.mesh.indexBuffer[0].unlock();}}reset(){this.beenReset=true;this.seed=Math.random();this.material.setParameter("seed",this.seed);if(this.useCpu){for(let i=0;i<this.particleTexStart.length;i++){this.particleTex[i]=this.particleTexStart[i];}}else {this._initializeTextures();}this.resetWorldBounds();this.resetTime();const origLoop=this.loop;this.loop=true;this.addTime(0,false);this.loop=origLoop;if(this.preWarm){this.prewarm(this.lifetime);}}prewarm(time){const lifetimeFraction=time/this.lifetime;const iterations=Math.min(Math.floor(lifetimeFraction*this.precision),this.precision);const stepDelta=time/iterations;for(let i=0;i<iterations;i++){this.addTime(stepDelta,false);}}resetTime(){this.endTime=calcEndTime(this);}finishFrame(){if(this.useCpu)this.vertexBuffer.unlock();}addTime(delta,isOnStop){const device=this.graphicsDevice;this.simTimeTotal+=delta;this.calculateWorldBounds();if(this._isAnimated()){const tilesParams=this.animTilesParams;tilesParams[0]=1/this.animTilesX;tilesParams[1]=1/this.animTilesY;const params=this.animParams;params[0]=this.animStartFrame;params[1]=this.animNumFrames*this.animSpeed;params[2]=this.animNumFrames-1;params[3]=this.animNumAnimations-1;const animIndexParams=this.animIndexParams;animIndexParams[0]=this.animIndex;animIndexParams[1]=this.randomizeAnimIndex;}if(this.scene){if(this.camera!==this.scene._activeCamera){this.camera=this.scene._activeCamera;this.onChangeCamera();}}if(this.emitterShape===EMITTERSHAPE_BOX){extentsInnerRatioUniform[0]=this.emitterExtents.x!==0?this.emitterExtentsInner.x/this.emitterExtents.x:0;extentsInnerRatioUniform[1]=this.emitterExtents.y!==0?this.emitterExtentsInner.y/this.emitterExtents.y:0;extentsInnerRatioUniform[2]=this.emitterExtents.z!==0?this.emitterExtentsInner.z/this.emitterExtents.z:0;if(this.meshInstance.node===null){spawnMatrix.setTRS(Vec3.ZERO,Quat.IDENTITY,this.emitterExtents);}else {spawnMatrix.setTRS(Vec3.ZERO,this.meshInstance.node.getRotation(),tmpVec3.copy(this.emitterExtents).mul(this.meshInstance.node.localScale));}}let emitterPos;const emitterScale=this.meshInstance.node===null?Vec3.ONE:this.meshInstance.node.localScale;this.emitterScaleUniform[0]=emitterScale.x;this.emitterScaleUniform[1]=emitterScale.y;this.emitterScaleUniform[2]=emitterScale.z;this.material.setParameter("emitterScale",this.emitterScaleUniform);if(this.localSpace&&this.meshInstance.node){emitterPos=this.meshInstance.node.getPosition();this.emitterPosUniform[0]=emitterPos.x;this.emitterPosUniform[1]=emitterPos.y;this.emitterPosUniform[2]=emitterPos.z;this.material.setParameter("emitterPos",this.emitterPosUniform);}this._compParticleFaceParams();if(!this.useCpu){this._gpuUpdater.update(device,spawnMatrix,extentsInnerRatioUniform,delta,isOnStop);}else {const data=new Float32Array(this.vertexBuffer.lock());this._cpuUpdater.update(data,this.vbToSort,this.particleTex,spawnMatrix,extentsInnerRatioUniform,emitterPos,delta,isOnStop);}if(!this.loop){if(Date.now()>this.endTime){if(this.onFinished)this.onFinished();this.meshInstance.visible=false;}}if(this.meshInstance){this.meshInstance.drawOrder=this.drawOrder;}}_destroyResources(){if(this.particleTexIN){this.particleTexIN.destroy();this.particleTexIN=null;}if(this.particleTexOUT){this.particleTexOUT.destroy();this.particleTexOUT=null;}if(this.particleTexStart&&this.particleTexStart.destroy){this.particleTexStart.destroy();this.particleTexStart=null;}if(this.rtParticleTexIN){this.rtParticleTexIN.destroy();this.rtParticleTexIN=null;}if(this.rtParticleTexOUT){this.rtParticleTexOUT.destroy();this.rtParticleTexOUT=null;}if(this.internalTex0){this.internalTex0.destroy();this.internalTex0=null;}if(this.internalTex1){this.internalTex1.destroy();this.internalTex1=null;}if(this.internalTex2){this.internalTex2.destroy();this.internalTex2=null;}if(this.internalTex3){this.internalTex3.destroy();this.internalTex3=null;}if(this.colorParam){this.colorParam.destroy();this.colorParam=null;}if(this.vertexBuffer){this.vertexBuffer.destroy();this.vertexBuffer=undefined;}if(this.indexBuffer){this.indexBuffer.destroy();this.indexBuffer=undefined;}if(this.material){this.material.destroy();this.material=null;}}destroy(){this.camera=null;this._destroyResources();}constructor(graphicsDevice,options){this.graphicsDevice=graphicsDevice;const gd=graphicsDevice;const precision=32;this.precision=precision;this._addTimeTime=0;setPropertyTarget=this;setPropertyOptions=options;setProperty("numParticles",1);if(this.numParticles>graphicsDevice.maxTextureSize){this.numParticles=graphicsDevice.maxTextureSize;}setProperty("rate",1);setProperty("rate2",this.rate);setProperty("lifetime",50);setProperty("emitterExtents",new Vec3(0,0,0));setProperty("emitterExtentsInner",new Vec3(0,0,0));setProperty("emitterRadius",0);setProperty("emitterRadiusInner",0);setProperty("emitterShape",EMITTERSHAPE_BOX);setProperty("initialVelocity",1);setProperty("wrap",false);setProperty("localSpace",false);setProperty("screenSpace",false);setProperty("wrapBounds",null);setProperty("colorMap",this.defaultParamTexture);setProperty("normalMap",null);setProperty("loop",true);setProperty("preWarm",false);setProperty("sort",PARTICLESORT_NONE);setProperty("mode",PARTICLEMODE_GPU);setProperty("scene",null);setProperty("lighting",false);setProperty("halfLambert",false);setProperty("intensity",1);setProperty("stretch",0);setProperty("alignToMotion",false);setProperty("depthSoftening",0);setProperty("mesh",null);setProperty("particleNormal",new Vec3(0,1,0));setProperty("orientation",PARTICLEORIENTATION_SCREEN);setProperty("depthWrite",false);setProperty("noFog",false);setProperty("blendType",BLEND_NORMAL);setProperty("node",null);setProperty("startAngle",0);setProperty("startAngle2",this.startAngle);setProperty("animTilesX",1);setProperty("animTilesY",1);setProperty("animStartFrame",0);setProperty("animNumFrames",1);setProperty("animNumAnimations",1);setProperty("animIndex",0);setProperty("randomizeAnimIndex",false);setProperty("animSpeed",1);setProperty("animLoop",true);this._gpuUpdater=new ParticleGPUUpdater(this,gd);this._cpuUpdater=new ParticleCPUUpdater(this);this.emitterPosUniform=new Float32Array(3);this.wrapBoundsUniform=new Float32Array(3);this.emitterScaleUniform=new Float32Array([1,1,1]);setProperty("colorGraph",default1Curve3);setProperty("colorGraph2",this.colorGraph);setProperty("scaleGraph",default1Curve);setProperty("scaleGraph2",this.scaleGraph);setProperty("alphaGraph",default1Curve);setProperty("alphaGraph2",this.alphaGraph);setProperty("localVelocityGraph",default0Curve3);setProperty("localVelocityGraph2",this.localVelocityGraph);setProperty("velocityGraph",default0Curve3);setProperty("velocityGraph2",this.velocityGraph);setProperty("rotationSpeedGraph",default0Curve);setProperty("rotationSpeedGraph2",this.rotationSpeedGraph);setProperty("radialSpeedGraph",default0Curve);setProperty("radialSpeedGraph2",this.radialSpeedGraph);this.animTilesParams=new Float32Array(2);this.animParams=new Float32Array(4);this.animIndexParams=new Float32Array(2);this.internalTex0=null;this.internalTex1=null;this.internalTex2=null;this.colorParam=null;this.vbToSort=null;this.vbOld=null;this.particleDistance=null;this.camera=null;this.swapTex=false;this.useMesh=true;this.useCpu=!graphicsDevice.supportsGpuParticles;this.pack8=true;this.localBounds=new BoundingBox;this.worldBoundsNoTrail=new BoundingBox;this.worldBoundsTrail=[new BoundingBox,new BoundingBox];this.worldBounds=new BoundingBox;this.worldBoundsSize=new Vec3;this.prevWorldBoundsSize=new Vec3;this.prevWorldBoundsCenter=new Vec3;this.prevEmitterExtents=this.emitterExtents;this.prevEmitterRadius=this.emitterRadius;this.worldBoundsMul=new Vec3;this.worldBoundsAdd=new Vec3;this.timeToSwitchBounds=0;this.shaderParticleUpdateRespawn=null;this.shaderParticleUpdateNoRespawn=null;this.shaderParticleUpdateOnStop=null;this.numParticleVerts=0;this.numParticleIndices=0;this.material=null;this.meshInstance=null;this.drawOrder=0;this.seed=Math.random();this.fixedTimeStep=1/60;this.maxSubSteps=10;this.simTime=0;this.simTimeTotal=0;this.beenReset=false;this._layer=null;this.rebuild();}}const mip2size=[128,64,16,8,4,2];const fShader=`
		#include "decodePS"
		#include "gamma"
		#include "tonemapping"
		#include "envMultiplyPS"

		#ifdef SKY_CUBEMAP
				#include "cubemapSeams"
				#include "skyboxHDRPS"
		#else
				#include "sphericalPS"
				#include "envAtlasPS"
				#include "skyboxEnvPS"
		#endif
`;class ShaderGeneratorSkybox extends ShaderGenerator{generateKey(options){const sharedKey=`skybox-${options.type}-${options.encoding}-${options.gamma}-${options.toneMapping}-${options.skymesh}`;return sharedKey+(options.type==="cubemap"?`-${options.mip}`:"")}createShaderDefinition(device,options){const defines=new Map;defines.set("SKYBOX_DECODE_FNC",ChunkUtils.decodeFunc(options.encoding));if(options.skymesh!==SKYTYPE_INFINITE)defines.set("SKYMESH","");if(options.type==="cubemap"){defines.set("SKY_CUBEMAP","");defines.set("SKYBOX_MIP",(1-1/mip2size[options.mip]).toString());}const includes=new Map;includes.set("decodePS",shaderChunks.decodePS);includes.set("gamma",ShaderGenerator.gammaCode(options.gamma));includes.set("tonemapping",ShaderGenerator.tonemapCode(options.toneMapping));includes.set("envMultiplyPS",shaderChunks.envMultiplyPS);if(options.type==="cubemap"){includes.set("cubemapSeams",options.mip?shaderChunks.fixCubemapSeamsStretchPS:shaderChunks.fixCubemapSeamsNonePS);includes.set("skyboxHDRPS",shaderChunks.skyboxHDRPS);}else {includes.set("sphericalPS",shaderChunks.sphericalPS);includes.set("envAtlasPS",shaderChunks.envAtlasPS);includes.set("skyboxEnvPS",shaderChunks.skyboxEnvPS);}return ShaderUtils.createDefinition(device,{name:"SkyboxShader",attributes:{aPosition:SEMANTIC_POSITION},vertexCode:shaderChunks.skyboxVS,vertexDefines:defines,fragmentCode:fShader,fragmentDefines:defines,fragmentIncludes:includes})}}const skybox=new ShaderGeneratorSkybox;const calculateNormals=(positions,indices)=>{const triangleCount=indices.length/3;const vertexCount=positions.length/3;const p1=new Vec3;const p2=new Vec3;const p3=new Vec3;const p1p2=new Vec3;const p1p3=new Vec3;const faceNormal=new Vec3;const normals=[];for(let i=0;i<positions.length;i++){normals[i]=0;}for(let i=0;i<triangleCount;i++){const i1=indices[i*3];const i2=indices[i*3+1];const i3=indices[i*3+2];p1.set(positions[i1*3],positions[i1*3+1],positions[i1*3+2]);p2.set(positions[i2*3],positions[i2*3+1],positions[i2*3+2]);p3.set(positions[i3*3],positions[i3*3+1],positions[i3*3+2]);p1p2.sub2(p2,p1);p1p3.sub2(p3,p1);faceNormal.cross(p1p2,p1p3).normalize();normals[i1*3]+=faceNormal.x;normals[i1*3+1]+=faceNormal.y;normals[i1*3+2]+=faceNormal.z;normals[i2*3]+=faceNormal.x;normals[i2*3+1]+=faceNormal.y;normals[i2*3+2]+=faceNormal.z;normals[i3*3]+=faceNormal.x;normals[i3*3+1]+=faceNormal.y;normals[i3*3+2]+=faceNormal.z;}for(let i=0;i<vertexCount;i++){const nx=normals[i*3];const ny=normals[i*3+1];const nz=normals[i*3+2];const invLen=1/Math.sqrt(nx*nx+ny*ny+nz*nz);normals[i*3]*=invLen;normals[i*3+1]*=invLen;normals[i*3+2]*=invLen;}return normals};const calculateTangents=(positions,normals,uvs,indices)=>{const triangleCount=indices.length/3;const vertexCount=positions.length/3;const v1=new Vec3;const v2=new Vec3;const v3=new Vec3;const w1=new Vec2;const w2=new Vec2;const w3=new Vec2;const sdir=new Vec3;const tdir=new Vec3;const tan1=new Float32Array(vertexCount*3);const tan2=new Float32Array(vertexCount*3);const tangents=[];for(let i=0;i<triangleCount;i++){const i1=indices[i*3];const i2=indices[i*3+1];const i3=indices[i*3+2];v1.set(positions[i1*3],positions[i1*3+1],positions[i1*3+2]);v2.set(positions[i2*3],positions[i2*3+1],positions[i2*3+2]);v3.set(positions[i3*3],positions[i3*3+1],positions[i3*3+2]);w1.set(uvs[i1*2],uvs[i1*2+1]);w2.set(uvs[i2*2],uvs[i2*2+1]);w3.set(uvs[i3*2],uvs[i3*2+1]);const x1=v2.x-v1.x;const x2=v3.x-v1.x;const y1=v2.y-v1.y;const y2=v3.y-v1.y;const z1=v2.z-v1.z;const z2=v3.z-v1.z;const s1=w2.x-w1.x;const s2=w3.x-w1.x;const _t=w2.y-w1.y;const _t2=w3.y-w1.y;const area=s1*_t2-s2*_t;if(area===0){sdir.set(0,1,0);tdir.set(1,0,0);}else {const r=1/area;sdir.set((_t2*x1-_t*x2)*r,(_t2*y1-_t*y2)*r,(_t2*z1-_t*z2)*r);tdir.set((s1*x2-s2*x1)*r,(s1*y2-s2*y1)*r,(s1*z2-s2*z1)*r);}tan1[i1*3+0]+=sdir.x;tan1[i1*3+1]+=sdir.y;tan1[i1*3+2]+=sdir.z;tan1[i2*3+0]+=sdir.x;tan1[i2*3+1]+=sdir.y;tan1[i2*3+2]+=sdir.z;tan1[i3*3+0]+=sdir.x;tan1[i3*3+1]+=sdir.y;tan1[i3*3+2]+=sdir.z;tan2[i1*3+0]+=tdir.x;tan2[i1*3+1]+=tdir.y;tan2[i1*3+2]+=tdir.z;tan2[i2*3+0]+=tdir.x;tan2[i2*3+1]+=tdir.y;tan2[i2*3+2]+=tdir.z;tan2[i3*3+0]+=tdir.x;tan2[i3*3+1]+=tdir.y;tan2[i3*3+2]+=tdir.z;}const t1=new Vec3;const t2=new Vec3;const n=new Vec3;const temp=new Vec3;for(let i=0;i<vertexCount;i++){n.set(normals[i*3],normals[i*3+1],normals[i*3+2]);t1.set(tan1[i*3],tan1[i*3+1],tan1[i*3+2]);t2.set(tan2[i*3],tan2[i*3+1],tan2[i*3+2]);const ndott=n.dot(t1);temp.copy(n).mulScalar(ndott);temp.sub2(t1,temp).normalize();tangents[i*4]=temp.x;tangents[i*4+1]=temp.y;tangents[i*4+2]=temp.z;temp.cross(n,t1);tangents[i*4+3]=temp.dot(t2)<0?-1:1;}return tangents};class Geometry{calculateNormals(){this.normals=calculateNormals(this.positions,this.indices);}calculateTangents(){this.tangents=calculateTangents(this.positions,this.normals,this.uvs,this.indices);}constructor(){this.positions=void 0;this.normals=void 0;this.colors=void 0;this.uvs=void 0;this.uvs1=void 0;this.blendIndices=void 0;this.blendWeights=void 0;this.tangents=void 0;this.indices=void 0;}}const primitiveUv1Padding$1=4/64;const primitiveUv1PaddingScale$1=1-primitiveUv1Padding$1*2;class BoxGeometry extends Geometry{constructor(opts={}){var _opts$halfExtents,_opts$widthSegments,_opts$lengthSegments,_opts$heightSegments,_opts$yOffset;super();const he=(_opts$halfExtents=opts.halfExtents)!=null?_opts$halfExtents:new Vec3(.5,.5,.5);const ws=(_opts$widthSegments=opts.widthSegments)!=null?_opts$widthSegments:1;const ls=(_opts$lengthSegments=opts.lengthSegments)!=null?_opts$lengthSegments:1;const hs=(_opts$heightSegments=opts.heightSegments)!=null?_opts$heightSegments:1;const yOffset=(_opts$yOffset=opts.yOffset)!=null?_opts$yOffset:0;const minY=-he.y+yOffset;const maxY=he.y+yOffset;const corners=[new Vec3(-he.x,minY,he.z),new Vec3(he.x,minY,he.z),new Vec3(he.x,maxY,he.z),new Vec3(-he.x,maxY,he.z),new Vec3(he.x,minY,-he.z),new Vec3(-he.x,minY,-he.z),new Vec3(-he.x,maxY,-he.z),new Vec3(he.x,maxY,-he.z)];const faceAxes=[[0,1,3],[4,5,7],[3,2,6],[1,0,4],[1,4,2],[5,0,6]];const faceNormals=[[0,0,1],[0,0,-1],[0,1,0],[0,-1,0],[1,0,0],[-1,0,0]];const sides={FRONT:0,BACK:1,TOP:2,BOTTOM:3,RIGHT:4,LEFT:5};const positions=[];const normals=[];const uvs=[];const indices=[];let vcounter=0;const generateFace=(side,uSegments,vSegments)=>{const temp1=new Vec3;const temp2=new Vec3;const temp3=new Vec3;const r=new Vec3;for(let i=0;i<=uSegments;i++){for(let j=0;j<=vSegments;j++){temp1.lerp(corners[faceAxes[side][0]],corners[faceAxes[side][1]],i/uSegments);temp2.lerp(corners[faceAxes[side][0]],corners[faceAxes[side][2]],j/vSegments);temp3.sub2(temp2,corners[faceAxes[side][0]]);r.add2(temp1,temp3);let u=i/uSegments;let v=j/vSegments;positions.push(r.x,r.y,r.z);normals.push(faceNormals[side][0],faceNormals[side][1],faceNormals[side][2]);uvs.push(u,1-v);u=u*primitiveUv1PaddingScale$1+primitiveUv1Padding$1;v=v*primitiveUv1PaddingScale$1+primitiveUv1Padding$1;u/=3;v/=3;u+=side%3/3;v+=Math.floor(side/3)/3;if(i<uSegments&&j<vSegments){indices.push(vcounter+vSegments+1,vcounter+1,vcounter);indices.push(vcounter+vSegments+1,vcounter+vSegments+2,vcounter+1);}vcounter++;}}};generateFace(sides.FRONT,ws,hs);generateFace(sides.BACK,ws,hs);generateFace(sides.TOP,ws,ls);generateFace(sides.BOTTOM,ws,ls);generateFace(sides.RIGHT,ls,hs);generateFace(sides.LEFT,ls,hs);this.positions=positions;this.normals=normals;this.uvs=uvs;this.uvs1=uvs;this.indices=indices;if(opts.calculateTangents){this.tangents=calculateTangents(positions,normals,uvs,indices);}}}class SphereGeometry extends Geometry{constructor(opts={}){var _opts$radius,_opts$latitudeBands,_opts$longitudeBands;super();const radius=(_opts$radius=opts.radius)!=null?_opts$radius:.5;const latitudeBands=(_opts$latitudeBands=opts.latitudeBands)!=null?_opts$latitudeBands:16;const longitudeBands=(_opts$longitudeBands=opts.longitudeBands)!=null?_opts$longitudeBands:16;const positions=[];const normals=[];const uvs=[];const indices=[];for(let lat=0;lat<=latitudeBands;lat++){const theta=lat*Math.PI/latitudeBands;const sinTheta=Math.sin(theta);const cosTheta=Math.cos(theta);for(let lon=0;lon<=longitudeBands;lon++){const phi=lon*2*Math.PI/longitudeBands-Math.PI/2;const sinPhi=Math.sin(phi);const cosPhi=Math.cos(phi);const x=cosPhi*sinTheta;const y=cosTheta;const z=sinPhi*sinTheta;const u=1-lon/longitudeBands;const v=1-lat/latitudeBands;positions.push(x*radius,y*radius,z*radius);normals.push(x,y,z);uvs.push(u,1-v);}}for(let lat=0;lat<latitudeBands;++lat){for(let lon=0;lon<longitudeBands;++lon){const first=lat*(longitudeBands+1)+lon;const second=first+longitudeBands+1;indices.push(first+1,second,first);indices.push(first+1,second+1,second);}}this.positions=positions;this.normals=normals;this.uvs=uvs;this.uvs1=uvs;this.indices=indices;if(opts.calculateTangents){this.tangents=calculateTangents(positions,normals,uvs,indices);}}}class DomeGeometry extends SphereGeometry{constructor(opts={}){var _opts$latitudeBands,_opts$longitudeBands;const radius=.5;const latitudeBands=(_opts$latitudeBands=opts.latitudeBands)!=null?_opts$latitudeBands:16;const longitudeBands=(_opts$longitudeBands=opts.longitudeBands)!=null?_opts$longitudeBands:16;super({radius,latitudeBands,longitudeBands});const bottomLimit=.1;const curvatureRadius=.95;const curvatureRadiusSq=curvatureRadius*curvatureRadius;const positions=this.positions;for(let i=0;i<positions.length;i+=3){const x=positions[i]/radius;let y=positions[i+1]/radius;const z=positions[i+2]/radius;if(y<0){y*=.3;if(x*x+z*z<curvatureRadiusSq){y=-bottomLimit;}}y+=bottomLimit;y*=radius;positions[i+1]=y;}}}class SkyGeometry{static create(device,type){switch(type){case SKYTYPE_BOX:return SkyGeometry.box(device);case SKYTYPE_DOME:return SkyGeometry.dome(device)}return SkyGeometry.infinite(device)}static infinite(device){return Mesh.fromGeometry(device,new BoxGeometry(device))}static box(device){return Mesh.fromGeometry(device,new BoxGeometry({yOffset:.5}))}static dome(device){const geom=new DomeGeometry({latitudeBands:50,longitudeBands:50});geom.normals=undefined;geom.uvs=undefined;return Mesh.fromGeometry(device,geom)}}class SkyMesh{destroy(){if(this.meshInstance){if(this.skyLayer){this.skyLayer.removeMeshInstances([this.meshInstance]);}this.meshInstance.destroy();this.meshInstance=null;}}constructor(device,scene,node,texture,type){this.meshInstance=null;const material=new Material;material.name="SkyMaterial";material.getShaderVariant=function(dev,sc,defs,unused,pass,sortedLights,viewUniformFormat,viewBindGroupFormat){const options={pass:pass,encoding:texture.encoding,gamma:pass===SHADER_FORWARDHDR?scene.gammaCorrection?GAMMA_SRGBHDR:GAMMA_NONE:scene.gammaCorrection,toneMapping:pass===SHADER_FORWARDHDR?TONEMAP_LINEAR:scene.toneMapping,skymesh:type};if(texture.cubemap){options.type="cubemap";options.mip=texture.fixCubemapSeams?scene.skyboxMip:0;options.fixSeams=texture.fixCubemapSeams;}else {options.type="envAtlas";}const processingOptions=new ShaderProcessorOptions(viewUniformFormat,viewBindGroupFormat);const library=getProgramLibrary(device);library.register("skybox",skybox);return library.getProgram("skybox",options,processingOptions)};if(texture.cubemap){material.setParameter("texture_cubeMap",texture);}else {material.setParameter("texture_envAtlas",texture);material.setParameter("mipLevel",scene._skyboxMip);}material.cull=CULLFACE_FRONT;material.depthWrite=false;const skyLayer=scene.layers.getLayerById(LAYERID_SKYBOX);if(skyLayer){const mesh=SkyGeometry.create(device,type);const meshInstance=new MeshInstance(mesh,material,node);this.meshInstance=meshInstance;meshInstance.cull=false;meshInstance.pick=false;skyLayer.addMeshInstances([meshInstance]);this.skyLayer=skyLayer;}}}class Sky{applySettings(render){var _render$skyType,_render$skyMeshPositi,_render$skyMeshRotati,_render$skyMeshScale;this.type=(_render$skyType=render.skyType)!=null?_render$skyType:SKYTYPE_INFINITE;this.node.setLocalPosition(new Vec3((_render$skyMeshPositi=render.skyMeshPosition)!=null?_render$skyMeshPositi:[0,0,0]));this.node.setLocalEulerAngles(new Vec3((_render$skyMeshRotati=render.skyMeshRotation)!=null?_render$skyMeshRotati:[0,0,0]));this.node.setLocalScale(new Vec3((_render$skyMeshScale=render.skyMeshScale)!=null?_render$skyMeshScale:[1,1,1]));if(render.skyCenter){this._center=new Vec3(render.skyCenter);}}set type(value){if(this._type!==value){this._type=value;this.scene.updateShaders=true;this.updateSkyMesh();}}get type(){return this._type}set center(value){this._center.copy(value);}get center(){return this._center}updateSkyMesh(){const texture=this.scene._getSkyboxTex();if(texture){this.resetSkyMesh();this.skyMesh=new SkyMesh(this.device,this.scene,this.node,texture,this.type);this.scene.fire("set:skybox",texture);}}resetSkyMesh(){var _this$skyMesh;(_this$skyMesh=this.skyMesh)==null||_this$skyMesh.destroy();this.skyMesh=null;}update(){if(this.type!==SKYTYPE_INFINITE){const{center,centerArray}=this;const temp=new Vec3;this.node.getWorldTransform().transformPoint(center,temp);centerArray[0]=temp.x;centerArray[1]=temp.y;centerArray[2]=temp.z;this.projectedSkydomeCenterId.setValue(centerArray);}}constructor(scene){this._type=SKYTYPE_INFINITE;this._center=new Vec3(0,1,0);this.skyMesh=null;this.node=new GraphNode("SkyMeshNode");this.device=scene.device;this.scene=scene;this.center=new Vec3(0,1,0);this.centerArray=new Float32Array(3);this.projectedSkydomeCenterId=this.device.scope.resolve("projectedSkydomeCenter");}}const identityGraphNode=new GraphNode;identityGraphNode.worldTransform=Mat4.IDENTITY;identityGraphNode._dirtyWorld=identityGraphNode._dirtyNormal=false;class ImmediateBatch{addLines(positions,color){const destPos=this.positions;const count=positions.length;for(let i=0;i<count;i++){const pos=positions[i];destPos.push(pos.x,pos.y,pos.z);}const destCol=this.colors;if(color.length){for(let i=0;i<count;i++){const col=color[i];destCol.push(col.r,col.g,col.b,col.a);}}else {for(let i=0;i<count;i++){destCol.push(color.r,color.g,color.b,color.a);}}}addLinesArrays(positions,color){const destPos=this.positions;for(let i=0;i<positions.length;i+=3){destPos.push(positions[i],positions[i+1],positions[i+2]);}const destCol=this.colors;if(color.length){for(let i=0;i<color.length;i+=4){destCol.push(color[i],color[i+1],color[i+2],color[i+3]);}}else {const count=positions.length/3;for(let i=0;i<count;i++){destCol.push(color.r,color.g,color.b,color.a);}}}onPreRender(visibleList,transparent){if(this.positions.length>0&&this.material.transparent===transparent){this.mesh.setPositions(this.positions);this.mesh.setColors(this.colors);this.mesh.update(PRIMITIVE_LINES,false);if(!this.meshInstance){this.meshInstance=new MeshInstance(this.mesh,this.material,identityGraphNode);}visibleList.push(this.meshInstance);}}clear(){this.positions.length=0;this.colors.length=0;}constructor(device,material,layer){this.material=material;this.layer=layer;this.positions=[];this.colors=[];this.mesh=new Mesh(device);this.meshInstance=null;}}class ImmediateBatches{getBatch(material,layer){let batch=this.map.get(material);if(!batch){batch=new ImmediateBatch(this.device,material,layer);this.map.set(material,batch);}return batch}onPreRender(visibleList,transparent){this.map.forEach(batch=>{batch.onPreRender(visibleList,transparent);});}clear(){this.map.forEach(batch=>batch.clear());}constructor(device){this.device=device;this.map=new Map;}}const tempPoints=[];const vec=new Vec3;class Immediate{createMaterial(depthTest){const material=new BasicMaterial;material.vertexColors=true;material.blendType=BLEND_NORMAL;material.depthTest=depthTest;material.update();return material}get materialDepth(){if(!this._materialDepth){this._materialDepth=this.createMaterial(true);}return this._materialDepth}get materialNoDepth(){if(!this._materialNoDepth){this._materialNoDepth=this.createMaterial(false);}return this._materialNoDepth}getBatch(layer,depthTest){let batches=this.batchesMap.get(layer);if(!batches){batches=new ImmediateBatches(this.device);this.batchesMap.set(layer,batches);}this.allBatches.add(batches);const material=depthTest?this.materialDepth:this.materialNoDepth;return batches.getBatch(material,layer)}getShader(id,fragment){if(!this[id]){const vertex=`
				attribute vec2 vertex_position;
				uniform mat4 matrix_model;
				varying vec2 uv0;
				void main(void) {
					gl_Position = matrix_model * vec4(vertex_position, 0, 1);
					uv0 = vertex_position.xy + 0.5;
				}
			`;this[id]=createShaderFromCode(this.device,vertex,fragment,`DebugShader:${id}`);}return this[id]}getTextureShader(){return this.getShader("textureShader",`
			varying vec2 uv0;
			uniform sampler2D colorMap;
			void main (void) {
				gl_FragColor = vec4(texture2D(colorMap, uv0).xyz, 1);
			}
		`)}getUnfilterableTextureShader(){return this.getShader("textureShaderUnfilterable",`
			varying vec2 uv0;
			uniform highp sampler2D colorMap;
			void main (void) {
				ivec2 uv = ivec2(uv0 * textureSize(colorMap, 0));
				gl_FragColor = vec4(texelFetch(colorMap, uv, 0).xyz, 1);
			}
		`)}getDepthTextureShader(){return this.getShader("depthTextureShader",`
			${shaderChunks.screenDepthPS}
			varying vec2 uv0;
			void main() {
				float depth = getLinearScreenDepth(getImageEffectUV(uv0)) * camera_params.x;
				gl_FragColor = vec4(vec3(depth), 1.0);
			}
		`)}getQuadMesh(){if(!this.quadMesh){this.quadMesh=new Mesh(this.device);this.quadMesh.setPositions([-.5,-.5,0,.5,-.5,0,-.5,.5,0,.5,.5,0]);this.quadMesh.update(PRIMITIVE_TRISTRIP);}return this.quadMesh}drawMesh(material,matrix,mesh,meshInstance,layer){if(!meshInstance){const graphNode=this.getGraphNode(matrix);meshInstance=new MeshInstance(mesh,material,graphNode);}let layerMeshInstances=this.layerMeshInstances.get(layer);if(!layerMeshInstances){layerMeshInstances=[];this.layerMeshInstances.set(layer,layerMeshInstances);}layerMeshInstances.push(meshInstance);}drawWireAlignedBox(min,max,color,depthTest,layer,mat){if(mat){const mulPoint=(x,y,z)=>{vec.set(x,y,z);mat.transformPoint(vec,vec);tempPoints.push(vec.x,vec.y,vec.z);};mulPoint(min.x,min.y,min.z);mulPoint(min.x,max.y,min.z);mulPoint(min.x,max.y,min.z);mulPoint(max.x,max.y,min.z);mulPoint(max.x,max.y,min.z);mulPoint(max.x,min.y,min.z);mulPoint(max.x,min.y,min.z);mulPoint(min.x,min.y,min.z);mulPoint(min.x,min.y,max.z);mulPoint(min.x,max.y,max.z);mulPoint(min.x,max.y,max.z);mulPoint(max.x,max.y,max.z);mulPoint(max.x,max.y,max.z);mulPoint(max.x,min.y,max.z);mulPoint(max.x,min.y,max.z);mulPoint(min.x,min.y,max.z);mulPoint(min.x,min.y,min.z);mulPoint(min.x,min.y,max.z);mulPoint(min.x,max.y,min.z);mulPoint(min.x,max.y,max.z);mulPoint(max.x,max.y,min.z);mulPoint(max.x,max.y,max.z);mulPoint(max.x,min.y,min.z);mulPoint(max.x,min.y,max.z);}else {tempPoints.push(min.x,min.y,min.z,min.x,max.y,min.z,min.x,max.y,min.z,max.x,max.y,min.z,max.x,max.y,min.z,max.x,min.y,min.z,max.x,min.y,min.z,min.x,min.y,min.z,min.x,min.y,max.z,min.x,max.y,max.z,min.x,max.y,max.z,max.x,max.y,max.z,max.x,max.y,max.z,max.x,min.y,max.z,max.x,min.y,max.z,min.x,min.y,max.z,min.x,min.y,min.z,min.x,min.y,max.z,min.x,max.y,min.z,min.x,max.y,max.z,max.x,max.y,min.z,max.x,max.y,max.z,max.x,min.y,min.z,max.x,min.y,max.z);}const batch=this.getBatch(layer,depthTest);batch.addLinesArrays(tempPoints,color);tempPoints.length=0;}drawWireSphere(center,radius,color,numSegments,depthTest,layer){const step=2*Math.PI/numSegments;let angle=0;for(let i=0;i<numSegments;i++){const sin0=Math.sin(angle);const cos0=Math.cos(angle);angle+=step;const sin1=Math.sin(angle);const cos1=Math.cos(angle);tempPoints.push(center.x+radius*sin0,center.y,center.z+radius*cos0);tempPoints.push(center.x+radius*sin1,center.y,center.z+radius*cos1);tempPoints.push(center.x+radius*sin0,center.y+radius*cos0,center.z);tempPoints.push(center.x+radius*sin1,center.y+radius*cos1,center.z);tempPoints.push(center.x,center.y+radius*sin0,center.z+radius*cos0);tempPoints.push(center.x,center.y+radius*sin1,center.z+radius*cos1);}const batch=this.getBatch(layer,depthTest);batch.addLinesArrays(tempPoints,color);tempPoints.length=0;}getGraphNode(matrix){const graphNode=new GraphNode("ImmediateDebug");graphNode.worldTransform=matrix;graphNode._dirtyWorld=graphNode._dirtyNormal=false;return graphNode}onPreRenderLayer(layer,visibleList,transparent){this.batchesMap.forEach((batches,batchLayer)=>{if(batchLayer===layer){batches.onPreRender(visibleList,transparent);}});if(!this.updatedLayers.has(layer)){this.updatedLayers.add(layer);const meshInstances=this.layerMeshInstances.get(layer);if(meshInstances){for(let i=0;i<meshInstances.length;i++){visibleList.push(meshInstances[i]);}meshInstances.length=0;}}}onPostRender(){this.allBatches.forEach(batch=>batch.clear());this.allBatches.clear();this.updatedLayers.clear();}constructor(device){this.device=device;this.quadMesh=null;this.textureShader=null;this.depthTextureShader=null;this.cubeLocalPos=null;this.cubeWorldPos=null;this.batchesMap=new Map;this.allBatches=new Set;this.updatedLayers=new Set;this._materialDepth=null;this._materialNoDepth=null;this.layerMeshInstances=new Map;}}const _goldenAngle=2.399963229728653;const random={circlePoint(point){const r=Math.sqrt(Math.random());const theta=Math.random()*2*Math.PI;point.x=r*Math.cos(theta);point.y=r*Math.sin(theta);},circlePointDeterministic(point,index,numPoints){const theta=index*_goldenAngle;const r=Math.sqrt(index)/Math.sqrt(numPoints);point.x=r*Math.cos(theta);point.y=r*Math.sin(theta);},spherePointDeterministic(point,index,numPoints,start=0,end=1){start=1-2*start;end=1-2*end;const y=math.lerp(start,end,index/numPoints);const radius=Math.sqrt(1-y*y);const theta=_goldenAngle*index;point.x=Math.cos(theta)*radius;point.y=y;point.z=Math.sin(theta)*radius;},radicalInverse(i){let bits=(i<<16|i>>>16)>>>0;bits=((bits&1431655765)<<1|(bits&2863311530)>>>1)>>>0;bits=((bits&858993459)<<2|(bits&3435973836)>>>2)>>>0;bits=((bits&252645135)<<4|(bits&4042322160)>>>4)>>>0;bits=((bits&16711935)<<8|(bits&4278255360)>>>8)>>>0;return bits*23283064365386963e-26}};const getProjectionName=projection=>{switch(projection){case TEXTUREPROJECTION_CUBE:return "Cubemap";case TEXTUREPROJECTION_OCTAHEDRAL:return "Octahedral";default:return "Equirect"}};const packFloat32ToRGBA8=(value,array,offset)=>{if(value<=0){array[offset+0]=0;array[offset+1]=0;array[offset+2]=0;array[offset+3]=0;}else if(value>=1){array[offset+0]=255;array[offset+1]=0;array[offset+2]=0;array[offset+3]=0;}else {let encX=1*value%1;let encY=255*value%1;let encZ=65025*value%1;const encW=16581375*value%1;encX-=encY/255;encY-=encZ/255;encZ-=encW/255;array[offset+0]=Math.min(255,Math.floor(encX*256));array[offset+1]=Math.min(255,Math.floor(encY*256));array[offset+2]=Math.min(255,Math.floor(encZ*256));array[offset+3]=Math.min(255,Math.floor(encW*256));}};const packSamples=samples=>{const numSamples=samples.length;const w=Math.min(numSamples,512);const h=Math.ceil(numSamples/w);const data=new Uint8Array(w*h*4);let off=0;for(let i=0;i<numSamples;i+=4){packFloat32ToRGBA8(samples[i+0]*.5+.5,data,off+0);packFloat32ToRGBA8(samples[i+1]*.5+.5,data,off+4);packFloat32ToRGBA8(samples[i+2]*.5+.5,data,off+8);packFloat32ToRGBA8(samples[i+3]/8,data,off+12);off+=16;}return {width:w,height:h,data:data}};const hemisphereSamplePhong=(dstVec,x,y,specularPower)=>{const phi=y*2*Math.PI;const cosTheta=Math.pow(1-x,1/(specularPower+1));const sinTheta=Math.sqrt(1-cosTheta*cosTheta);dstVec.set(Math.cos(phi)*sinTheta,Math.sin(phi)*sinTheta,cosTheta).normalize();};const hemisphereSampleLambert=(dstVec,x,y)=>{const phi=y*2*Math.PI;const cosTheta=Math.sqrt(1-x);const sinTheta=Math.sqrt(x);dstVec.set(Math.cos(phi)*sinTheta,Math.sin(phi)*sinTheta,cosTheta).normalize();};const hemisphereSampleGGX=(dstVec,x,y,a)=>{const phi=y*2*Math.PI;const cosTheta=Math.sqrt((1-x)/(1+(a*a-1)*x));const sinTheta=Math.sqrt(1-cosTheta*cosTheta);dstVec.set(Math.cos(phi)*sinTheta,Math.sin(phi)*sinTheta,cosTheta).normalize();};const D_GGX=(NoH,linearRoughness)=>{const a=NoH*linearRoughness;const k=linearRoughness/(1-NoH*NoH+a*a);return k*k*(1/Math.PI)};const generatePhongSamples=(numSamples,specularPower)=>{const H=new Vec3;const result=[];for(let i=0;i<numSamples;++i){hemisphereSamplePhong(H,i/numSamples,random.radicalInverse(i),specularPower);result.push(H.x,H.y,H.z,0);}return result};const generateLambertSamples=(numSamples,sourceTotalPixels)=>{const pixelsPerSample=sourceTotalPixels/numSamples;const H=new Vec3;const result=[];for(let i=0;i<numSamples;++i){hemisphereSampleLambert(H,i/numSamples,random.radicalInverse(i));const pdf=H.z/Math.PI;const mipLevel=.5*Math.log2(pixelsPerSample/pdf);result.push(H.x,H.y,H.z,mipLevel);}return result};const requiredSamplesGGX={"16":{"2":26,"8":20,"32":17,"128":16,"512":16},"32":{"2":53,"8":40,"32":34,"128":32,"512":32},"128":{"2":214,"8":163,"32":139,"128":130,"512":128},"1024":{"2":1722,"8":1310,"32":1114,"128":1041,"512":1025}};const getRequiredSamplesGGX=(numSamples,specularPower)=>{const table=requiredSamplesGGX[numSamples];return table&&table[specularPower]||numSamples};const generateGGXSamples=(numSamples,specularPower,sourceTotalPixels)=>{const pixelsPerSample=sourceTotalPixels/numSamples;const roughness=1-Math.log2(specularPower)/11;const a=roughness*roughness;const H=new Vec3;const L=new Vec3;const N=new Vec3(0,0,1);const result=[];const requiredSamples=getRequiredSamplesGGX(numSamples,specularPower);for(let i=0;i<requiredSamples;++i){hemisphereSampleGGX(H,i/requiredSamples,random.radicalInverse(i),a);const NoH=H.z;L.set(H.x,H.y,H.z).mulScalar(2*NoH).sub(N);if(L.z>0){const pdf=D_GGX(Math.min(1,NoH),a)/4+.001;const mipLevel=.5*Math.log2(pixelsPerSample/pdf);result.push(L.x,L.y,L.z,mipLevel);}}while(result.length<numSamples*4){result.push(0,0,0,0);}return result};const createSamplesTex=(device,name,samples)=>{const packedSamples=packSamples(samples);return new Texture(device,{name:name,width:packedSamples.width,height:packedSamples.height,mipmaps:false,minFilter:FILTER_NEAREST,magFilter:FILTER_NEAREST,levels:[packedSamples.data]})};class SimpleCache{destroy(){if(this.destroyContent){this.map.forEach((value,key)=>{value.destroy();});}}get(key,missFunc){if(!this.map.has(key)){const result=missFunc();this.map.set(key,result);return result}return this.map.get(key)}constructor(destroyContent=true){this.map=new Map;this.destroyContent=destroyContent;}}const samplesCache=new SimpleCache(false);const deviceCache$1=new DeviceCache;const getCachedTexture=(device,key,getSamplesFnc)=>{const cache=deviceCache$1.get(device,()=>{return new SimpleCache});return cache.get(key,()=>{return createSamplesTex(device,key,samplesCache.get(key,getSamplesFnc))})};const generateLambertSamplesTex=(device,numSamples,sourceTotalPixels)=>{const key=`lambert-samples-${numSamples}-${sourceTotalPixels}`;return getCachedTexture(device,key,()=>{return generateLambertSamples(numSamples,sourceTotalPixels)})};const generatePhongSamplesTex=(device,numSamples,specularPower)=>{const key=`phong-samples-${numSamples}-${specularPower}`;return getCachedTexture(device,key,()=>{return generatePhongSamples(numSamples,specularPower)})};const generateGGXSamplesTex=(device,numSamples,specularPower,sourceTotalPixels)=>{const key=`ggx-samples-${numSamples}-${specularPower}-${sourceTotalPixels}`;return getCachedTexture(device,key,()=>{return generateGGXSamples(numSamples,specularPower,sourceTotalPixels)})};const vsCode=`
attribute vec2 vertex_position;

uniform vec4 uvMod;

varying vec2 vUv0;

void main(void) {
		gl_Position = vec4(vertex_position, 0.5, 1.0);
		vUv0 = getImageEffectUV((vertex_position.xy * 0.5 + 0.5) * uvMod.xy + uvMod.zw);
}
`;function reprojectTexture(source,target,options={}){var _options$seamPixels,_options$rect$z,_options$rect,_options$rect$w,_options$rect2;if(source instanceof GraphicsDevice){source=arguments[1];target=arguments[2];options={};if(arguments[3]!==undefined){options.specularPower=arguments[3];}if(arguments[4]!==undefined){options.numSamples=arguments[4];}}const seamPixels=(_options$seamPixels=options.seamPixels)!=null?_options$seamPixels:0;const innerWidth=((_options$rect$z=(_options$rect=options.rect)==null?void 0:_options$rect.z)!=null?_options$rect$z:target.width)-seamPixels*2;const innerHeight=((_options$rect$w=(_options$rect2=options.rect)==null?void 0:_options$rect2.w)!=null?_options$rect$w:target.height)-seamPixels*2;if(innerWidth<1||innerHeight<1){return false}const funcNames={"none":"reproject","lambert":"prefilterSamplesUnweighted","phong":"prefilterSamplesUnweighted","ggx":"prefilterSamples"};const specularPower=options.hasOwnProperty("specularPower")?options.specularPower:1;const face=options.hasOwnProperty("face")?options.face:null;const distribution=options.hasOwnProperty("distribution")?options.distribution:specularPower===1?"none":"phong";const processFunc=funcNames[distribution]||"reproject";const prefilterSamples=processFunc.startsWith("prefilterSamples");const decodeFunc=ChunkUtils.decodeFunc(source.encoding);const encodeFunc=ChunkUtils.encodeFunc(target.encoding);const sourceFunc=`sample${getProjectionName(source.projection)}`;const targetFunc=`getDirection${getProjectionName(target.projection)}`;const numSamples=options.hasOwnProperty("numSamples")?options.numSamples:1024;const shaderKey=`${processFunc}_${decodeFunc}_${encodeFunc}_${sourceFunc}_${targetFunc}_${numSamples}`;const device=source.device;let shader=getProgramLibrary(device).getCachedShader(shaderKey);if(!shader){const defines=`#define PROCESS_FUNC ${processFunc}
${prefilterSamples?"#define USE_SAMPLES_TEX\n":""}${source.cubemap?"#define CUBEMAP_SOURCE\n":""}#define DECODE_FUNC ${decodeFunc}
`+`#define ENCODE_FUNC ${encodeFunc}
`+`#define SOURCE_FUNC ${sourceFunc}
`+`#define TARGET_FUNC ${targetFunc}
`+`#define NUM_SAMPLES ${numSamples}
`+`#define NUM_SAMPLES_SQRT ${Math.round(Math.sqrt(numSamples)).toFixed(1)}
`;shader=createShaderFromCode(device,vsCode,`${defines}
${shaderChunks.reprojectPS}`,shaderKey);}device.setBlendState(BlendState.NOBLEND);const constantSource=device.scope.resolve(source.cubemap?"sourceCube":"sourceTex");constantSource.setValue(source);const constantParams=device.scope.resolve("params");device.scope.resolve("params2");const uvModParam=device.scope.resolve("uvMod");if(seamPixels>0){uvModParam.setValue([(innerWidth+seamPixels*2)/innerWidth,(innerHeight+seamPixels*2)/innerHeight,-seamPixels/innerWidth,-seamPixels/innerHeight]);}else {uvModParam.setValue([1,1,0,0]);}const params=[0,source.fixCubemapSeams?1/source.width:0,target.fixCubemapSeams?1/target.width:0];if(prefilterSamples){const sourceTotalPixels=source.width*source.height*(source.cubemap?6:1);const samplesTex=distribution==="ggx"?generateGGXSamplesTex(device,numSamples,specularPower,sourceTotalPixels):distribution==="lambert"?generateLambertSamplesTex(device,numSamples,sourceTotalPixels):generatePhongSamplesTex(device,numSamples,specularPower);device.scope.resolve("samplesTex").setValue(samplesTex);device.scope.resolve("samplesTexInverseSize").setValue([1/samplesTex.width,1/samplesTex.height]);}for(let f=0;f<(target.cubemap?6:1);f++){if(face===null||f===face){var _options;const renderTarget=new RenderTarget({colorBuffer:target,face:f,depth:false,flipY:device.isWebGPU});params[0]=f;constantParams.setValue(params);drawQuadWithShader(device,renderTarget,shader,(_options=options)==null?void 0:_options.rect);renderTarget.destroy();}}return true}const fixCubemapSeams=true;const calcLevels=(width,height=0)=>{return 1+Math.floor(Math.log2(Math.max(width,height)))};const supportsFloat16=device=>{return device.extTextureHalfFloat&&device.textureHalfFloatRenderable};const supportsFloat32=device=>{return device.extTextureFloat&&device.textureFloatRenderable};const lightingSourcePixelFormat=device=>{return supportsFloat16(device)?PIXELFORMAT_RGBA16F:supportsFloat32(device)?PIXELFORMAT_RGBA32F:PIXELFORMAT_RGBA8};const lightingPixelFormat=device=>{return PIXELFORMAT_RGBA8};const createCubemap=(device,size,format,mipmaps)=>{return new Texture(device,{name:`lighting-${size}`,cubemap:true,width:size,height:size,format:format,type:TEXTURETYPE_RGBP,addressU:ADDRESS_CLAMP_TO_EDGE,addressV:ADDRESS_CLAMP_TO_EDGE,fixCubemapSeams:fixCubemapSeams,mipmaps:!!mipmaps})};class EnvLighting{static generateSkyboxCubemap(source,size){const device=source.device;const result=createCubemap(device,size||(source.cubemap?source.width:source.width/4),PIXELFORMAT_RGBA8,false);reprojectTexture(source,result,{numSamples:1024});return result}static generateLightingSource(source,options){const device=source.device;const format=lightingSourcePixelFormat(device);const result=(options==null?void 0:options.target)||new Texture(device,{name:"lighting-source",cubemap:true,width:(options==null?void 0:options.size)||128,height:(options==null?void 0:options.size)||128,format:format,type:format===PIXELFORMAT_RGBA8?TEXTURETYPE_RGBP:TEXTURETYPE_DEFAULT,addressU:ADDRESS_CLAMP_TO_EDGE,addressV:ADDRESS_CLAMP_TO_EDGE,fixCubemapSeams:false,mipmaps:true});reprojectTexture(source,result,{numSamples:source.mipmaps?1:1024});return result}static generateAtlas(source,options){const device=source.device;const format=lightingPixelFormat();const result=(options==null?void 0:options.target)||new Texture(device,{name:"envAtlas",width:(options==null?void 0:options.size)||512,height:(options==null?void 0:options.size)||512,format:format,type:TEXTURETYPE_RGBP,projection:TEXTUREPROJECTION_EQUIRECT,addressU:ADDRESS_CLAMP_TO_EDGE,addressV:ADDRESS_CLAMP_TO_EDGE,mipmaps:false});const s=result.width/512;const rect=new Vec4(0,0,512*s,256*s);const levels=calcLevels(256)-calcLevels(4);for(let i=0;i<levels;++i){reprojectTexture(source,result,{numSamples:1,rect:rect,seamPixels:s});rect.x+=rect.w;rect.y+=rect.w;rect.z=Math.max(1,Math.floor(rect.z*.5));rect.w=Math.max(1,Math.floor(rect.w*.5));}rect.set(0,256*s,256*s,128*s);for(let i=1;i<7;++i){reprojectTexture(source,result,{numSamples:(options==null?void 0:options.numReflectionSamples)||1024,distribution:(options==null?void 0:options.distribution)||"ggx",specularPower:Math.max(1,2048>>i*2),rect:rect,seamPixels:s});rect.y+=rect.w;rect.z=Math.max(1,Math.floor(rect.z*.5));rect.w=Math.max(1,Math.floor(rect.w*.5));}rect.set(128*s,(256+128)*s,64*s,32*s);reprojectTexture(source,result,{numSamples:(options==null?void 0:options.numAmbientSamples)||2048,distribution:"lambert",rect:rect,seamPixels:s});return result}static generatePrefilteredAtlas(sources,options){const device=sources[0].device;const format=sources[0].format;const type=sources[0].type;const result=(options==null?void 0:options.target)||new Texture(device,{name:"envPrefilteredAtlas",width:(options==null?void 0:options.size)||512,height:(options==null?void 0:options.size)||512,format:format,type:type,projection:TEXTUREPROJECTION_EQUIRECT,addressU:ADDRESS_CLAMP_TO_EDGE,addressV:ADDRESS_CLAMP_TO_EDGE,mipmaps:false});const s=result.width/512;const rect=new Vec4(0,0,512*s,256*s);const levels=calcLevels(512);for(let i=0;i<levels;++i){reprojectTexture(sources[0],result,{numSamples:1,rect:rect,seamPixels:s});rect.x+=rect.w;rect.y+=rect.w;rect.z=Math.max(1,Math.floor(rect.z*.5));rect.w=Math.max(1,Math.floor(rect.w*.5));}rect.set(0,256*s,256*s,128*s);for(let i=1;i<sources.length;++i){reprojectTexture(sources[i],result,{numSamples:1,rect:rect,seamPixels:s});rect.y+=rect.w;rect.z=Math.max(1,Math.floor(rect.z*.5));rect.w=Math.max(1,Math.floor(rect.w*.5));}rect.set(128*s,(256+128)*s,64*s,32*s);if(options!=null&&options.legacyAmbient){reprojectTexture(sources[5],result,{numSamples:1,rect:rect,seamPixels:s});}else {reprojectTexture(sources[0],result,{numSamples:(options==null?void 0:options.numSamples)||2048,distribution:"lambert",rect:rect,seamPixels:s});}return result}}class Scene extends EventHandler{get defaultDrawLayer(){return this.layers.getLayerById(LAYERID_IMMEDIATE)}set ambientBakeNumSamples(value){this._ambientBakeNumSamples=math.clamp(Math.floor(value),1,255);}get ambientBakeNumSamples(){return this._ambientBakeNumSamples}set ambientBakeSpherePart(value){this._ambientBakeSpherePart=math.clamp(value,.001,1);}get ambientBakeSpherePart(){return this._ambientBakeSpherePart}set clusteredLightingEnabled(value){if(this.device.isWebGPU&&!value){return}if(!this._clusteredLightingEnabled&&value){console.error("Turning on disabled clustered lighting is not currently supported");return}this._clusteredLightingEnabled=value;}get clusteredLightingEnabled(){return this._clusteredLightingEnabled}set envAtlas(value){if(value!==this._envAtlas){this._envAtlas=value;if(value){value.addressU=ADDRESS_CLAMP_TO_EDGE;value.addressV=ADDRESS_CLAMP_TO_EDGE;value.minFilter=FILTER_LINEAR;value.magFilter=FILTER_LINEAR;value.mipmaps=false;}this._prefilteredCubemaps=[];if(this._internalEnvAtlas){this._internalEnvAtlas.destroy();this._internalEnvAtlas=null;}this._resetSkyMesh();}}get envAtlas(){return this._envAtlas}set fog(type){if(type!==this._fog){this._fog=type;this.updateShaders=true;}}get fog(){return this._fog}set gammaCorrection(value){if(value!==this._gammaCorrection){this._gammaCorrection=value;this.updateShaders=true;}}get gammaCorrection(){return this._gammaCorrection}set layers(layers){const prev=this._layers;this._layers=layers;this.fire("set:layers",prev,layers);}get layers(){return this._layers}get sky(){return this._sky}get lighting(){return this._lightingParams}set lightmapFilterRange(value){this._lightmapFilterRange=Math.max(value,.001);}get lightmapFilterRange(){return this._lightmapFilterRange}set lightmapFilterSmoothness(value){this._lightmapFilterSmoothness=Math.max(value,.001);}get lightmapFilterSmoothness(){return this._lightmapFilterSmoothness}set prefilteredCubemaps(value){value=value||[];const cubemaps=this._prefilteredCubemaps;const changed=cubemaps.length!==value.length||cubemaps.some((c,i)=>c!==value[i]);if(changed){const complete=value.length===6&&value.every(c=>!!c);if(complete){this._internalEnvAtlas=EnvLighting.generatePrefilteredAtlas(value,{target:this._internalEnvAtlas});this._envAtlas=this._internalEnvAtlas;}else {if(this._internalEnvAtlas){this._internalEnvAtlas.destroy();this._internalEnvAtlas=null;}this._envAtlas=null;}this._prefilteredCubemaps=value.slice();this._resetSkyMesh();}}get prefilteredCubemaps(){return this._prefilteredCubemaps}set skybox(value){if(value!==this._skyboxCubeMap){this._skyboxCubeMap=value;this._resetSkyMesh();}}get skybox(){return this._skyboxCubeMap}set skyboxIntensity(value){if(value!==this._skyboxIntensity){this._skyboxIntensity=value;this._resetSkyMesh();}}get skyboxIntensity(){return this._skyboxIntensity}set skyboxLuminance(value){if(value!==this._skyboxLuminance){this._skyboxLuminance=value;this._resetSkyMesh();}}get skyboxLuminance(){return this._skyboxLuminance}set skyboxMip(value){if(value!==this._skyboxMip){this._skyboxMip=value;this._resetSkyMesh();}}get skyboxMip(){return this._skyboxMip}set skyboxRotation(value){if(!this._skyboxRotation.equals(value)){const isIdentity=value.equals(Quat.IDENTITY);this._skyboxRotation.copy(value);if(isIdentity){this._skyboxRotationMat3.setIdentity();}else {this._skyboxRotationMat4.setTRS(Vec3.ZERO,value,Vec3.ONE);this._skyboxRotationMat3.invertMat4(this._skyboxRotationMat4);}if(!this._skyboxRotationShaderInclude&&!isIdentity){this._skyboxRotationShaderInclude=true;this._resetSkyMesh();}}}get skyboxRotation(){return this._skyboxRotation}set toneMapping(value){if(value!==this._toneMapping){this._toneMapping=value;this.updateShaders=true;}}get toneMapping(){return this._toneMapping}destroy(){this._resetSkyMesh();this.root=null;this.off();}drawLine(start,end,color=Color.WHITE,depthTest=true,layer=this.defaultDrawLayer){const batch=this.immediate.getBatch(layer,depthTest);batch.addLines([start,end],[color,color]);}drawLines(positions,colors,depthTest=true,layer=this.defaultDrawLayer){const batch=this.immediate.getBatch(layer,depthTest);batch.addLines(positions,colors);}drawLineArrays(positions,colors,depthTest=true,layer=this.defaultDrawLayer){const batch=this.immediate.getBatch(layer,depthTest);batch.addLinesArrays(positions,colors);}applySettings(settings){var _render$skyboxIntensi,_render$skyboxLuminan,_render$skyboxMip,_render$clusteredLigh;const physics=settings.physics;const render=settings.render;this._gravity.set(physics.gravity[0],physics.gravity[1],physics.gravity[2]);this.ambientLight.set(render.global_ambient[0],render.global_ambient[1],render.global_ambient[2]);this.ambientLuminance=render.ambientLuminance;this._fog=render.fog;this.fogColor.set(render.fog_color[0],render.fog_color[1],render.fog_color[2]);this.fogStart=render.fog_start;this.fogEnd=render.fog_end;this.fogDensity=render.fog_density;this._gammaCorrection=render.gamma_correction;this._toneMapping=render.tonemapping;this.lightmapSizeMultiplier=render.lightmapSizeMultiplier;this.lightmapMaxResolution=render.lightmapMaxResolution;this.lightmapMode=render.lightmapMode;this.exposure=render.exposure;this._skyboxIntensity=(_render$skyboxIntensi=render.skyboxIntensity)!=null?_render$skyboxIntensi:1;this._skyboxLuminance=(_render$skyboxLuminan=render.skyboxLuminance)!=null?_render$skyboxLuminan:2e4;this._skyboxMip=(_render$skyboxMip=render.skyboxMip)!=null?_render$skyboxMip:0;if(render.skyboxRotation){this.skyboxRotation=new Quat().setFromEulerAngles(render.skyboxRotation[0],render.skyboxRotation[1],render.skyboxRotation[2]);}this.sky.applySettings(render);this.clusteredLightingEnabled=(_render$clusteredLigh=render.clusteredLightingEnabled)!=null?_render$clusteredLigh:false;this.lighting.applySettings(render);["lightmapFilterEnabled","lightmapFilterRange","lightmapFilterSmoothness","ambientBake","ambientBakeNumSamples","ambientBakeSpherePart","ambientBakeOcclusionBrightness","ambientBakeOcclusionContrast"].forEach(setting=>{if(render.hasOwnProperty(setting)){this[setting]=render[setting];}});this._resetSkyMesh();}_getSkyboxTex(){const cubemaps=this._prefilteredCubemaps;if(this._skyboxMip){const skyboxMapping=[0,1,3,4,5,6];return cubemaps[skyboxMapping[this._skyboxMip]]||this._envAtlas||cubemaps[0]||this._skyboxCubeMap}return this._skyboxCubeMap||cubemaps[0]||this._envAtlas}_updateSkyMesh(){if(!this.sky.skyMesh){this.sky.updateSkyMesh();}this.sky.update();}_resetSkyMesh(){this.sky.resetSkyMesh();this.updateShaders=true;}setSkybox(cubemaps){if(!cubemaps){this.skybox=null;this.envAtlas=null;}else {this.skybox=cubemaps[0]||null;if(cubemaps[1]&&!cubemaps[1].cubemap){this.envAtlas=cubemaps[1];}else {this.prefilteredCubemaps=cubemaps.slice(1);}}}get lightmapPixelFormat(){return this.lightmapHDR&&this.device.getRenderableHdrFormat()||PIXELFORMAT_RGBA8}constructor(graphicsDevice){super();this.ambientBake=false;this.ambientBakeOcclusionBrightness=0;this.ambientBakeOcclusionContrast=0;this.ambientLight=new Color(0,0,0);this.ambientLuminance=0;this.exposure=1;this.fogColor=new Color(0,0,0);this.fogDensity=0;this.fogEnd=1e3;this.fogStart=1;this.lightmapSizeMultiplier=1;this.lightmapMaxResolution=2048;this.lightmapMode=BAKE_COLORDIR;this.lightmapFilterEnabled=false;this.lightmapHDR=false;this.root=null;this.physicalUnits=false;this._envAtlas=null;this._skyboxCubeMap=null;this.device=graphicsDevice;this._gravity=new Vec3(0,-9.8,0);this._layers=null;this._fog=FOG_NONE;this._gammaCorrection=GAMMA_SRGB;this._toneMapping=0;this._prefilteredCubemaps=[];this._internalEnvAtlas=null;this._skyboxIntensity=1;this._skyboxLuminance=0;this._skyboxMip=0;this._skyboxRotationShaderInclude=false;this._skyboxRotation=new Quat;this._skyboxRotationMat3=new Mat3;this._skyboxRotationMat4=new Mat4;this._ambientBakeNumSamples=1;this._ambientBakeSpherePart=.4;this._lightmapFilterRange=10;this._lightmapFilterSmoothness=.2;this._clusteredLightingEnabled=true;this._lightingParams=new LightingParams(this.device.supportsAreaLights,this.device.maxTextureSize,()=>{this.updateShaders=true;});this._sky=new Sky(this);this._stats={meshInstances:0,lights:0,dynamicLights:0,bakedLights:0,updateShadersTime:0};this.updateShaders=true;this._shaderVersion=0;this.immediate=new Immediate(this.device);}}Scene.EVENT_SETLAYERS="set:layers";Scene.EVENT_SETSKYBOX="set:skybox";class Skin{constructor(graphicsDevice,ibp,boneNames){this.device=graphicsDevice;this.inverseBindPose=ibp;this.boneNames=boneNames;}}const spriteNormals=[0,0,1,0,0,1,0,0,1,0,0,1];const spriteIndices=[0,1,3,2,3,1];class Sprite extends EventHandler{set frameKeys(value){this._frameKeys=value;if(this._atlas&&this._frameKeys){if(this._updatingProperties){this._meshesDirty=true;}else {this._createMeshes();}}this.fire("set:frameKeys",value);}get frameKeys(){return this._frameKeys}set atlas(value){if(value===this._atlas)return;if(this._atlas){this._atlas.off("set:frames",this._onSetFrames,this);this._atlas.off("set:frame",this._onFrameChanged,this);this._atlas.off("remove:frame",this._onFrameRemoved,this);}this._atlas=value;if(this._atlas&&this._frameKeys){this._atlas.on("set:frames",this._onSetFrames,this);this._atlas.on("set:frame",this._onFrameChanged,this);this._atlas.on("remove:frame",this._onFrameRemoved,this);if(this._updatingProperties){this._meshesDirty=true;}else {this._createMeshes();}}this.fire("set:atlas",value);}get atlas(){return this._atlas}set pixelsPerUnit(value){if(this._pixelsPerUnit===value)return;this._pixelsPerUnit=value;this.fire("set:pixelsPerUnit",value);if(this._atlas&&this._frameKeys&&this.renderMode===SPRITE_RENDERMODE_SIMPLE){if(this._updatingProperties){this._meshesDirty=true;}else {this._createMeshes();}}}get pixelsPerUnit(){return this._pixelsPerUnit}set renderMode(value){if(this._renderMode===value){return}const prev=this._renderMode;this._renderMode=value;this.fire("set:renderMode",value);if(prev===SPRITE_RENDERMODE_SIMPLE||value===SPRITE_RENDERMODE_SIMPLE){if(this._atlas&&this._frameKeys){if(this._updatingProperties){this._meshesDirty=true;}else {this._createMeshes();}}}}get renderMode(){return this._renderMode}get meshes(){return this._meshes}_createMeshes(){const len=this._meshes.length;for(let i=0;i<len;i++){const mesh=this._meshes[i];if(mesh){mesh.destroy();}}const count=this._frameKeys.length;this._meshes=new Array(count);const createMeshFunc=this.renderMode===SPRITE_RENDERMODE_SLICED||this._renderMode===SPRITE_RENDERMODE_TILED?this._create9SliceMesh:this._createSimpleMesh;for(let i=0;i<count;i++){const frame=this._atlas.frames[this._frameKeys[i]];this._meshes[i]=frame?createMeshFunc.call(this,frame):null;}this.fire("set:meshes");}_createSimpleMesh(frame){const rect=frame.rect;const texWidth=this._atlas.texture.width;const texHeight=this._atlas.texture.height;const w=rect.z/this._pixelsPerUnit;const h=rect.w/this._pixelsPerUnit;const hp=frame.pivot.x;const vp=frame.pivot.y;const positions=[-hp*w,-vp*h,0,(1-hp)*w,-vp*h,0,(1-hp)*w,(1-vp)*h,0,-hp*w,(1-vp)*h,0];const lu=rect.x/texWidth;const bv=1-rect.y/texHeight;const ru=(rect.x+rect.z)/texWidth;const tv=1-(rect.y+rect.w)/texHeight;const uvs=[lu,bv,ru,bv,ru,tv,lu,tv];const geom=new Geometry;geom.positions=positions;geom.normals=spriteNormals;geom.uvs=uvs;geom.indices=spriteIndices;return Mesh.fromGeometry(this._device,geom)}_create9SliceMesh(){const he=Vec2.ONE;const ws=3;const ls=3;const positions=[];const normals=[];const uvs=[];const indices=[];let vcounter=0;for(let i=0;i<=ws;i++){const u=i===0||i===ws?0:1;for(let j=0;j<=ls;j++){const x=-he.x+2*he.x*(i<=1?0:3)/ws;const y=0;const z=-(-he.y+2*he.y*(j<=1?0:3)/ls);const v=j===0||j===ls?0:1;positions.push(-x,y,z);normals.push(0,1,0);uvs.push(u,v);if(i<ws&&j<ls){indices.push(vcounter+ls+1,vcounter+1,vcounter);indices.push(vcounter+ls+1,vcounter+ls+2,vcounter+1);}vcounter++;}}const geom=new Geometry;geom.positions=positions;geom.normals=normals;geom.uvs=uvs;geom.indices=indices;return Mesh.fromGeometry(this._device,geom)}_onSetFrames(frames){if(this._updatingProperties){this._meshesDirty=true;}else {this._createMeshes();}}_onFrameChanged(frameKey,frame){const idx=this._frameKeys.indexOf(frameKey);if(idx<0)return;if(frame){if(this.renderMode===SPRITE_RENDERMODE_SIMPLE){this._meshes[idx]=this._createSimpleMesh(frame);}}else {this._meshes[idx]=null;}this.fire("set:meshes");}_onFrameRemoved(frameKey){const idx=this._frameKeys.indexOf(frameKey);if(idx<0)return;this._meshes[idx]=null;this.fire("set:meshes");}startUpdate(){this._updatingProperties=true;this._meshesDirty=false;}endUpdate(){this._updatingProperties=false;if(this._meshesDirty&&this._atlas&&this._frameKeys){this._createMeshes();}this._meshesDirty=false;}destroy(){for(const mesh of this._meshes){if(mesh){mesh.destroy();}}this._meshes.length=0;}constructor(device,options){super();this._device=device;this._pixelsPerUnit=options&&options.pixelsPerUnit!==undefined?options.pixelsPerUnit:1;this._renderMode=options&&options.renderMode!==undefined?options.renderMode:SPRITE_RENDERMODE_SIMPLE;this._atlas=options&&options.atlas!==undefined?options.atlas:null;this._frameKeys=options&&options.frameKeys!==undefined?options.frameKeys:null;this._meshes=[];this._updatingProperties=false;this._meshesDirty=false;if(this._atlas&&this._frameKeys){this._createMeshes();}}}class StandardMaterialOptions{get pass(){return this.litOptions.pass}constructor(){this.forceUv1=false;this.ambientTint=false;this.diffuseTint=false;this.specularTint=false;this.metalnessTint=false;this.glossTint=false;this.emissiveTint=false;this.opacityTint=false;this.emissiveEncoding="linear";this.lightMapEncoding="linear";this.packedNormal=false;this.glossInvert=false;this.sheenGlossInvert=false;this.clearCoatGlossInvert=false;this.litOptions=new LitShaderOptions;}}const _matTex2D=[];const buildPropertiesList=options=>{return Object.keys(options).filter(key=>key!=="litOptions").sort()};class ShaderGeneratorStandard extends ShaderGenerator{generateKey(options){let props;if(options===this.optionsContextMin){if(!this.propsMin)this.propsMin=buildPropertiesList(options);props=this.propsMin;}else if(options===this.optionsContext){if(!this.props)this.props=buildPropertiesList(options);props=this.props;}else {props=buildPropertiesList(options);}const key=`standard:
${props.map(prop=>prop+options[prop]).join("\n")}${LitOptionsUtils.generateKey(options.litOptions)}`;return key}_getUvSourceExpression(transformPropName,uVPropName,options){const transformId=options[transformPropName];const uvChannel=options[uVPropName];const isMainPass=options.litOptions.pass===SHADER_FORWARD||options.litOptions.pass===SHADER_FORWARDHDR;let expression;if(isMainPass&&options.litOptions.nineSlicedMode===SPRITE_RENDERMODE_SLICED){expression="nineSlicedUv";}else if(isMainPass&&options.litOptions.nineSlicedMode===SPRITE_RENDERMODE_TILED){expression="nineSlicedUv";}else {if(transformId===0){expression=`vUv${uvChannel}`;}else {expression=`vUV${uvChannel}_${transformId}`;}if(options.heightMap&&transformPropName!=="heightMapTransform"){expression+=" + dUvOffset";}}return expression}_addMapDef(name,enabled){return enabled?`#define ${name}
`:`#undef ${name}
`}_addMapDefs(float,color,vertex,map,invert){return this._addMapDef("MAPFLOAT",float)+this._addMapDef("MAPCOLOR",color)+this._addMapDef("MAPVERTEX",vertex)+this._addMapDef("MAPTEXTURE",map)+this._addMapDef("MAPINVERT",invert)}_addMap(propName,chunkName,options,chunks,mapping,encoding=null){const mapPropName=`${propName}Map`;const uVPropName=`${mapPropName}Uv`;const identifierPropName=`${mapPropName}Identifier`;const transformPropName=`${mapPropName}Transform`;const channelPropName=`${mapPropName}Channel`;const vertexColorChannelPropName=`${propName}VertexColorChannel`;const tintPropName=`${propName}Tint`;const vertexColorPropName=`${propName}VertexColor`;const detailModePropName=`${propName}Mode`;const invertName=`${propName}Invert`;const tintOption=options[tintPropName];const vertexColorOption=options[vertexColorPropName];const textureOption=options[mapPropName];const textureIdentifier=options[identifierPropName];const detailModeOption=options[detailModePropName];let subCode=chunks[chunkName];if(textureOption){const uv=this._getUvSourceExpression(transformPropName,uVPropName,options);subCode=subCode.replace(/\$UV/g,uv).replace(/\$CH/g,options[channelPropName]);if(mapping&&subCode.search(/\$SAMPLER/g)!==-1){let samplerName=`texture_${mapPropName}`;const alias=mapping[textureIdentifier];if(alias){samplerName=alias;}else {mapping[textureIdentifier]=samplerName;}subCode=subCode.replace(/\$SAMPLER/g,samplerName);}if(encoding){if(options[channelPropName]==="aaa"){subCode=subCode.replace(/\$DECODE/g,"passThrough");}else {subCode=subCode.replace(/\$DECODE/g,ChunkUtils.decodeFunc(!options.litOptions.gamma&&encoding==="srgb"?"linear":encoding));}if(subCode.indexOf("$texture2DSAMPLE")){const decodeTable={linear:"texture2D",srgb:"texture2DSRGB",rgbm:"texture2DRGBM",rgbe:"texture2DRGBE"};subCode=subCode.replace(/\$texture2DSAMPLE/g,decodeTable[encoding]||"texture2D");}}}if(vertexColorOption){subCode=subCode.replace(/\$VC/g,options[vertexColorChannelPropName]);}if(detailModeOption){subCode=subCode.replace(/\$DETAILMODE/g,detailModeOption);}const isFloatTint=!!(tintOption&1);const isVecTint=!!(tintOption&2);const invertOption=!!options[invertName];subCode=this._addMapDefs(isFloatTint,isVecTint,vertexColorOption,textureOption,invertOption)+subCode;return subCode.replace(/\$/g,"")}_correctChannel(p,chan,_matTex2D){if(_matTex2D[p]>0){if(_matTex2D[p]<chan.length){return chan.substring(0,_matTex2D[p])}else if(_matTex2D[p]>chan.length){let str=chan;const chr=str.charAt(str.length-1);const addLen=_matTex2D[p]-str.length;for(let i=0;i<addLen;i++)str+=chr;return str}return chan}}createShaderDefinition(device,options){const shaderPassInfo=ShaderPass.get(device).getByIndex(options.litOptions.pass);const isForwardPass=shaderPassInfo.isForward;const litShader=new LitShader(device,options.litOptions);const useUv=[];const useUnmodifiedUv=[];const mapTransforms=[];const maxUvSets=2;const textureMapping={};for(const p in _matTex2D){const mname=`${p}Map`;if(options[`${p}VertexColor`]){const cname=`${p}VertexColorChannel`;options[cname]=this._correctChannel(p,options[cname],_matTex2D);}if(options[mname]){const cname=`${mname}Channel`;const tname=`${mname}Transform`;const uname=`${mname}Uv`;options[uname]=Math.min(options[uname],maxUvSets-1);options[cname]=this._correctChannel(p,options[cname],_matTex2D);const uvSet=options[uname];useUv[uvSet]=true;useUnmodifiedUv[uvSet]=useUnmodifiedUv[uvSet]||options[mname]&&!options[tname];if(options[tname]){mapTransforms.push({name:p,id:options[tname],uv:options[uname]});}}}if(options.forceUv1){useUv[1]=true;useUnmodifiedUv[1]=useUnmodifiedUv[1]!==undefined?useUnmodifiedUv[1]:true;}litShader.generateVertexShader(useUv,useUnmodifiedUv,mapTransforms);if(options.litOptions.shadingModel===SPECULAR_PHONG){options.litOptions.fresnelModel=0;options.litOptions.ambientSH=false;}else {options.litOptions.fresnelModel=options.litOptions.fresnelModel===0?FRESNEL_SCHLICK:options.litOptions.fresnelModel;}const decl=new ChunkBuilder;const code=new ChunkBuilder;const func=new ChunkBuilder;const args=new ChunkBuilder;let lightingUv="";if(options.litOptions.nineSlicedMode===SPRITE_RENDERMODE_TILED){decl.append("const float textureBias = -1000.0;");}else {decl.append("uniform float textureBias;");}if(isForwardPass){if(options.heightMap){decl.append("vec2 dUvOffset;");code.append(this._addMap("height","parallaxPS",options,litShader.chunks,textureMapping));func.append("getParallax();");}if(options.litOptions.blendType!==BLEND_NONE||options.litOptions.alphaTest||options.litOptions.alphaToCoverage||options.litOptions.opacityDither!==DITHER_NONE){decl.append("float dAlpha;");code.append(this._addMap("opacity","opacityPS",options,litShader.chunks,textureMapping));func.append("getOpacity();");args.append("litArgs_opacity = dAlpha;");if(options.litOptions.alphaTest){code.append(litShader.chunks.alphaTestPS);func.append("alphaTest(dAlpha);");}const opacityDither=options.litOptions.opacityDither;if(opacityDither!==DITHER_NONE){if(opacityDither===DITHER_BAYER8){decl.append(litShader.chunks.bayerPS);}decl.append(`#define DITHER_${opacityDither.toUpperCase()}
`);decl.append(litShader.chunks.opacityDitherPS);func.append("opacityDither(dAlpha, 0.0);");}}else {decl.append("float dAlpha = 1.0;");}if(litShader.needsNormal){if(options.normalMap||options.clearCoatNormalMap){code.append(options.packedNormal?litShader.chunks.normalXYPS:litShader.chunks.normalXYZPS);if(!options.litOptions.hasTangents){const baseName=options.normalMap?"normalMap":"clearCoatNormalMap";lightingUv=this._getUvSourceExpression(`${baseName}Transform`,`${baseName}Uv`,options);}}decl.append("vec3 dNormalW;");code.append(this._addMap("normalDetail","normalDetailMapPS",options,litShader.chunks,textureMapping));code.append(this._addMap("normal","normalMapPS",options,litShader.chunks,textureMapping));func.append("getNormal();");args.append("litArgs_worldNormal = dNormalW;");}if(litShader.needsSceneColor){decl.append("uniform sampler2D uSceneColorMap;");}if(litShader.needsScreenSize){decl.append("uniform vec4 uScreenSize;");}if(litShader.needsTransforms){decl.append("uniform mat4 matrix_viewProjection;");decl.append("uniform mat4 matrix_model;");}if(options.diffuseDetail||options.aoDetail){code.append(litShader.chunks.detailModesPS);}decl.append("vec3 dAlbedo;");if(options.diffuseDetail){code.append(this._addMap("diffuseDetail","diffuseDetailMapPS",options,litShader.chunks,textureMapping,options.diffuseDetailEncoding));}code.append(this._addMap("diffuse","diffusePS",options,litShader.chunks,textureMapping,options.diffuseEncoding));func.append("getAlbedo();");args.append("litArgs_albedo = dAlbedo;");if(options.litOptions.useRefraction){decl.append("float dTransmission;");code.append(this._addMap("refraction","transmissionPS",options,litShader.chunks,textureMapping));func.append("getRefraction();");args.append("litArgs_transmission = dTransmission;");decl.append("float dThickness;");code.append(this._addMap("thickness","thicknessPS",options,litShader.chunks,textureMapping));func.append("getThickness();");args.append("litArgs_thickness = dThickness;");if(options.litOptions.dispersion){args.append("litArgs_dispersion = material_dispersion;");}}if(options.litOptions.useIridescence){decl.append("float dIridescence;");code.append(this._addMap("iridescence","iridescencePS",options,litShader.chunks,textureMapping));func.append("getIridescence();");args.append("litArgs_iridescence_intensity = dIridescence;");decl.append("float dIridescenceThickness;");code.append(this._addMap("iridescenceThickness","iridescenceThicknessPS",options,litShader.chunks,textureMapping));func.append("getIridescenceThickness();");args.append("litArgs_iridescence_thickness = dIridescenceThickness;");}if(litShader.lighting&&options.litOptions.useSpecular||litShader.reflections){decl.append("vec3 dSpecularity;");decl.append("float dGlossiness;");if(options.litOptions.useSheen){decl.append("vec3 sSpecularity;");code.append(this._addMap("sheen","sheenPS",options,litShader.chunks,textureMapping,options.sheenEncoding));func.append("getSheen();");args.append("litArgs_sheen_specularity = sSpecularity;");decl.append("float sGlossiness;");code.append(this._addMap("sheenGloss","sheenGlossPS",options,litShader.chunks,textureMapping));func.append("getSheenGlossiness();");args.append("litArgs_sheen_gloss = sGlossiness;");}if(options.litOptions.useMetalness){decl.append("float dMetalness;");code.append(this._addMap("metalness","metalnessPS",options,litShader.chunks,textureMapping));func.append("getMetalness();");args.append("litArgs_metalness = dMetalness;");decl.append("float dIor;");code.append(this._addMap("ior","iorPS",options,litShader.chunks,textureMapping));func.append("getIor();");args.append("litArgs_ior = dIor;");}if(options.litOptions.useSpecularityFactor){decl.append("float dSpecularityFactor;");code.append(this._addMap("specularityFactor","specularityFactorPS",options,litShader.chunks,textureMapping));func.append("getSpecularityFactor();");args.append("litArgs_specularityFactor = dSpecularityFactor;");}if(options.useSpecularColor){code.append(this._addMap("specular","specularPS",options,litShader.chunks,textureMapping,options.specularEncoding));}else {code.append("void getSpecularity() { dSpecularity = vec3(1); }");}code.append(this._addMap("gloss","glossPS",options,litShader.chunks,textureMapping));func.append("getGlossiness();");func.append("getSpecularity();");args.append("litArgs_specularity = dSpecularity;");args.append("litArgs_gloss = dGlossiness;");}else {decl.append("vec3 dSpecularity = vec3(0.0);");decl.append("float dGlossiness = 0.0;");}if(options.aoDetail){code.append(this._addMap("aoDetail","aoDetailMapPS",options,litShader.chunks,textureMapping));}if(options.aoMap||options.aoVertexColor){decl.append("float dAo;");code.append(this._addMap("ao","aoPS",options,litShader.chunks,textureMapping));func.append("getAO();");args.append("litArgs_ao = dAo;");}decl.append("vec3 dEmission;");code.append(this._addMap("emissive","emissivePS",options,litShader.chunks,textureMapping,options.emissiveEncoding));func.append("getEmission();");args.append("litArgs_emission = dEmission;");if(options.litOptions.useClearCoat){decl.append("float ccSpecularity;");decl.append("float ccGlossiness;");decl.append("vec3 ccNormalW;");code.append(this._addMap("clearCoat","clearCoatPS",options,litShader.chunks,textureMapping));code.append(this._addMap("clearCoatGloss","clearCoatGlossPS",options,litShader.chunks,textureMapping));code.append(this._addMap("clearCoatNormal","clearCoatNormalPS",options,litShader.chunks,textureMapping));func.append("getClearCoat();");func.append("getClearCoatGlossiness();");func.append("getClearCoatNormal();");args.append("litArgs_clearcoat_specularity = ccSpecularity;");args.append("litArgs_clearcoat_gloss = ccGlossiness;");args.append("litArgs_clearcoat_worldNormal = ccNormalW;");}if(options.lightMap||options.lightVertexColor){const lightmapDir=options.dirLightMap&&options.litOptions.useSpecular;const lightmapChunkPropName=lightmapDir?"lightmapDirPS":"lightmapSinglePS";decl.append("vec3 dLightmap;");if(lightmapDir){decl.append("vec3 dLightmapDir;");}code.append(this._addMap("light",lightmapChunkPropName,options,litShader.chunks,textureMapping,options.lightMapEncoding));func.append("getLightMap();");args.append("litArgs_lightmap = dLightmap;");if(lightmapDir){args.append("litArgs_lightmapDir = dLightmapDir;");}}if(code.code.indexOf("texture2DSRGB")!==-1||code.code.indexOf("texture2DRGBM")!==-1||code.code.indexOf("texture2DRGBE")!==-1){code.prepend(litShader.chunks.textureSamplePS);}}else {const opacityShadowDither=options.litOptions.opacityShadowDither;if(options.litOptions.alphaTest||opacityShadowDither){decl.append("float dAlpha;");code.append(this._addMap("opacity","opacityPS",options,litShader.chunks,textureMapping));func.append("getOpacity();");args.append("litArgs_opacity = dAlpha;");if(options.litOptions.alphaTest){code.append(litShader.chunks.alphaTestPS);func.append("alphaTest(dAlpha);");}if(opacityShadowDither!==DITHER_NONE){if(opacityShadowDither===DITHER_BAYER8){decl.append(litShader.chunks.bayerPS);}decl.append(`#define DITHER_${opacityShadowDither.toUpperCase()}
`);decl.append(litShader.chunks.opacityDitherPS);func.append("opacityDither(dAlpha, 0.0);");}}}decl.append(litShader.chunks.litShaderArgsPS);code.append(`void evaluateFrontend() { 
${func.code}
${args.code}
 }
`);func.code="evaluateFrontend();";for(const texture in textureMapping){decl.append(`uniform sampler2D ${textureMapping[texture]};`);}func.code=`
${func.code.split("\n").map(l=>`    ${l}`).join("\n")}

`;litShader.generateFragmentShader(decl.code,code.code,func.code,lightingUv);return litShader.getDefinition()}constructor(...args){super(...args);this.optionsContext=new StandardMaterialOptions;this.optionsContextMin=new StandardMaterialOptions;}}const standard=new ShaderGeneratorStandard;const arraysEqual=(a,b)=>{if(a.length!==b.length){return false}for(let i=0;i<a.length;++i){if(a[i]!==b[i]){return false}}return true};const notWhite=color=>{return color.r!==1||color.g!==1||color.b!==1};const notBlack=color=>{return color.r!==0||color.g!==0||color.b!==0};class StandardMaterialOptionsBuilder{updateMinRef(options,scene,stdMat,objDefs,pass,sortedLights){this._updateSharedOptions(options,scene,stdMat,objDefs,pass);this._updateMinOptions(options,stdMat,pass);this._updateUVOptions(options,stdMat,objDefs,true);}updateRef(options,scene,stdMat,objDefs,pass,sortedLights){this._updateSharedOptions(options,scene,stdMat,objDefs,pass);this._updateEnvOptions(options,stdMat,scene);this._updateMaterialOptions(options,stdMat);if(pass===SHADER_FORWARDHDR){if(options.litOptions.gamma)options.litOptions.gamma=GAMMA_SRGBHDR;options.litOptions.toneMap=TONEMAP_LINEAR;}options.litOptions.hasTangents=objDefs&&(objDefs&SHADERDEF_TANGENTS)!==0;this._updateLightOptions(options,scene,stdMat,objDefs,sortedLights);this._updateUVOptions(options,stdMat,objDefs,false);}_updateSharedOptions(options,scene,stdMat,objDefs,pass){options.forceUv1=stdMat.forceUv1;if(stdMat.userAttributes){options.litOptions.userAttributes=Object.fromEntries(stdMat.userAttributes.entries());}options.litOptions.chunks=stdMat.chunks||{};options.litOptions.pass=pass;options.litOptions.alphaTest=stdMat.alphaTest>0;options.litOptions.blendType=stdMat.blendType;options.litOptions.screenSpace=objDefs&&(objDefs&SHADERDEF_SCREENSPACE)!==0;options.litOptions.skin=objDefs&&(objDefs&SHADERDEF_SKIN)!==0;options.litOptions.useInstancing=objDefs&&(objDefs&SHADERDEF_INSTANCING)!==0;options.litOptions.useMorphPosition=objDefs&&(objDefs&SHADERDEF_MORPH_POSITION)!==0;options.litOptions.useMorphNormal=objDefs&&(objDefs&SHADERDEF_MORPH_NORMAL)!==0;options.litOptions.useMorphTextureBased=objDefs&&(objDefs&SHADERDEF_MORPH_TEXTURE_BASED)!==0;options.litOptions.nineSlicedMode=stdMat.nineSlicedMode||0;if(scene.clusteredLightingEnabled&&stdMat.useLighting){options.litOptions.clusteredLightingEnabled=true;options.litOptions.clusteredLightingCookiesEnabled=scene.lighting.cookiesEnabled;options.litOptions.clusteredLightingShadowsEnabled=scene.lighting.shadowsEnabled;options.litOptions.clusteredLightingShadowType=scene.lighting.shadowType;options.litOptions.clusteredLightingAreaLightsEnabled=scene.lighting.areaLightsEnabled;}else {options.litOptions.clusteredLightingEnabled=false;options.litOptions.clusteredLightingCookiesEnabled=false;options.litOptions.clusteredLightingShadowsEnabled=false;options.litOptions.clusteredLightingAreaLightsEnabled=false;}}_updateUVOptions(options,stdMat,objDefs,minimalOptions){let hasUv0=false;let hasUv1=false;let hasVcolor=false;if(objDefs){hasUv0=(objDefs&SHADERDEF_UV0)!==0;hasUv1=(objDefs&SHADERDEF_UV1)!==0;hasVcolor=(objDefs&SHADERDEF_VCOLOR)!==0;}options.litOptions.vertexColors=false;this._mapXForms=[];const uniqueTextureMap={};for(const p in _matTex2D){this._updateTexOptions(options,stdMat,p,hasUv0,hasUv1,hasVcolor,minimalOptions,uniqueTextureMap);}this._mapXForms=null;options.litOptions.lightMapEnabled=options.lightMap;options.litOptions.dirLightMapEnabled=options.dirLightMap;options.litOptions.useHeights=options.heightMap;options.litOptions.useNormals=options.normalMap;options.litOptions.useClearCoatNormals=options.clearCoatNormalMap;options.litOptions.useAo=options.aoMap||options.aoVertexColor;options.litOptions.diffuseMapEnabled=options.diffuseMap;}_updateTexOptions(options,stdMat,p,hasUv0,hasUv1,hasVcolor,minimalOptions,uniqueTextureMap){const isOpacity=p==="opacity";if(!minimalOptions||isOpacity){const mname=`${p}Map`;const vname=`${p}VertexColor`;const vcname=`${p}VertexColorChannel`;const cname=`${mname}Channel`;const tname=`${mname}Transform`;const uname=`${mname}Uv`;const iname=`${mname}Identifier`;if(p!=="light"){options[mname]=false;options[iname]=undefined;options[cname]="";options[tname]=0;options[uname]=0;}options[vname]=false;options[vcname]="";if(isOpacity&&stdMat.blendType===BLEND_NONE&&stdMat.alphaTest===0&&!stdMat.alphaToCoverage&&stdMat.opacityDither===DITHER_NONE){return}if(p!=="height"&&stdMat[vname]){if(hasVcolor){options[vname]=stdMat[vname];options[vcname]=stdMat[vcname];options.litOptions.vertexColors=true;}}if(stdMat[mname]){let allow=true;if(stdMat[uname]===0&&!hasUv0)allow=false;if(stdMat[uname]===1&&!hasUv1)allow=false;if(allow){const mapId=stdMat[mname].id;let identifier=uniqueTextureMap[mapId];if(identifier===undefined){uniqueTextureMap[mapId]=p;identifier=p;}options[mname]=!!stdMat[mname];options[iname]=identifier;options[tname]=this._getMapTransformID(stdMat.getUniform(tname),stdMat[uname]);options[cname]=stdMat[cname];options[uname]=stdMat[uname];}}}}_updateMinOptions(options,stdMat,pass){options.opacityTint=stdMat.blendType!==BLEND_NONE||stdMat.opacityShadowDither!==DITHER_NONE;const isPrepass=pass===SHADER_PREPASS_VELOCITY;options.litOptions.opacityShadowDither=isPrepass?stdMat.opacityDither:stdMat.opacityShadowDither;options.litOptions.lights=[];}_updateMaterialOptions(options,stdMat){var _stdMat$diffuseMap,_stdMat$diffuseDetail,_stdMat$emissiveMap,_stdMat$lightMap;const diffuseTint=stdMat.diffuseTint||!stdMat.diffuseMap&&!stdMat.diffuseVertexColor;const useSpecular=!!(stdMat.useMetalness||stdMat.specularMap||stdMat.sphereMap||stdMat.cubeMap||notBlack(stdMat.specular)||stdMat.specularityFactor>0&&stdMat.useMetalness||stdMat.enableGGXSpecular||stdMat.clearCoat>0);const useSpecularColor=!stdMat.useMetalness||stdMat.useMetalnessSpecularColor;const specularTint=useSpecular&&(stdMat.specularTint||!stdMat.specularMap&&!stdMat.specularVertexColor)&&notWhite(stdMat.specular);const specularityFactorTint=useSpecular&&stdMat.useMetalnessSpecularColor&&(stdMat.specularityFactorTint||stdMat.specularityFactor<1&&!stdMat.specularityFactorMap);const emissiveTintColor=!stdMat.emissiveMap||notWhite(stdMat.emissive)&&stdMat.emissiveTint;const emissiveTintIntensity=stdMat.emissiveIntensity!==1;const isPackedNormalMap=stdMat.normalMap?stdMat.normalMap.format===PIXELFORMAT_DXT5||stdMat.normalMap.type===TEXTURETYPE_SWIZZLEGGGR:false;options.opacityTint=stdMat.blendType!==BLEND_NONE||stdMat.alphaTest>0||stdMat.opacityDither!==DITHER_NONE?1:0;options.ambientTint=stdMat.ambientTint;options.diffuseTint=diffuseTint?2:0;options.specularTint=specularTint?2:0;options.specularityFactorTint=specularityFactorTint?1:0;options.metalnessTint=stdMat.useMetalness&&stdMat.metalness<1?1:0;options.glossTint=1;options.emissiveTint=(emissiveTintColor?2:0)+(emissiveTintIntensity?1:0);options.diffuseEncoding=(_stdMat$diffuseMap=stdMat.diffuseMap)==null?void 0:_stdMat$diffuseMap.encoding;options.diffuseDetailEncoding=(_stdMat$diffuseDetail=stdMat.diffuseDetailMap)==null?void 0:_stdMat$diffuseDetail.encoding;options.emissiveEncoding=(_stdMat$emissiveMap=stdMat.emissiveMap)==null?void 0:_stdMat$emissiveMap.encoding;options.lightMapEncoding=(_stdMat$lightMap=stdMat.lightMap)==null?void 0:_stdMat$lightMap.encoding;options.packedNormal=isPackedNormalMap;options.refractionTint=stdMat.refraction!==1?1:0;options.refractionIndexTint=stdMat.refractionIndex!==1/1.5?1:0;options.thicknessTint=stdMat.useDynamicRefraction&&stdMat.thickness!==1?1:0;options.specularEncoding=stdMat.specularEncoding||"linear";options.sheenEncoding=stdMat.sheenEncoding||"linear";options.aoMapUv=stdMat.aoUvSet;options.aoDetail=!!stdMat.aoMap;options.diffuseDetail=!!stdMat.diffuseMap;options.normalDetail=!!stdMat.normalMap;options.diffuseDetailMode=stdMat.diffuseDetailMode;options.aoDetailMode=stdMat.aoDetailMode;options.clearCoatTint=stdMat.clearCoat!==1?1:0;options.clearCoatGloss=!!stdMat.clearCoatGloss;options.clearCoatGlossTint=stdMat.clearCoatGloss!==1?1:0;options.iorTint=stdMat.refractionIndex!==1/1.5?1:0;options.iridescenceTint=stdMat.iridescence!==1?1:0;options.sheenTint=stdMat.useSheen&&notWhite(stdMat.sheen)?2:0;options.sheenGlossTint=1;options.glossInvert=stdMat.glossInvert;options.sheenGlossInvert=stdMat.sheenGlossInvert;options.clearCoatGlossInvert=stdMat.clearCoatGlossInvert;options.useSpecularColor=useSpecularColor;options.litOptions.separateAmbient=false;options.litOptions.useAmbientTint=stdMat.ambientTint;options.litOptions.customFragmentShader=stdMat.customFragmentShader;options.litOptions.pixelSnap=stdMat.pixelSnap;options.litOptions.shadingModel=stdMat.shadingModel;options.litOptions.ambientSH=!!stdMat.ambientSH;options.litOptions.fastTbn=stdMat.fastTbn;options.litOptions.twoSidedLighting=stdMat.twoSidedLighting;options.litOptions.occludeSpecular=stdMat.occludeSpecular;options.litOptions.occludeSpecularFloat=stdMat.occludeSpecularIntensity!==1;options.litOptions.useMsdf=!!stdMat.msdfMap;options.litOptions.msdfTextAttribute=!!stdMat.msdfTextAttribute;options.litOptions.alphaToCoverage=stdMat.alphaToCoverage;options.litOptions.opacityFadesSpecular=stdMat.opacityFadesSpecular;options.litOptions.opacityDither=stdMat.opacityDither;options.litOptions.cubeMapProjection=stdMat.cubeMapProjection;options.litOptions.occludeDirect=stdMat.occludeDirect;options.litOptions.conserveEnergy=stdMat.conserveEnergy&&stdMat.shadingModel!==SPECULAR_PHONG;options.litOptions.useSpecular=useSpecular;options.litOptions.useSpecularityFactor=(specularityFactorTint||!!stdMat.specularityFactorMap)&&stdMat.useMetalnessSpecularColor;options.litOptions.enableGGXSpecular=stdMat.enableGGXSpecular;options.litOptions.fresnelModel=stdMat.fresnelModel;options.litOptions.useRefraction=(stdMat.refraction||!!stdMat.refractionMap)&&(stdMat.useDynamicRefraction||!!options.litOptions.reflectionSource);options.litOptions.useClearCoat=!!stdMat.clearCoat;options.litOptions.useSheen=stdMat.useSheen;options.litOptions.useIridescence=stdMat.useIridescence&&stdMat.iridescence!==0;options.litOptions.useMetalness=stdMat.useMetalness;options.litOptions.useDynamicRefraction=stdMat.useDynamicRefraction;options.litOptions.dispersion=stdMat.dispersion>0;}_updateEnvOptions(options,stdMat,scene){options.litOptions.fog=stdMat.useFog?scene.fog:"none";options.litOptions.gamma=stdMat.useGammaTonemap?scene.gammaCorrection:GAMMA_NONE;options.litOptions.toneMap=stdMat.useGammaTonemap?scene.toneMapping:-1;options.litOptions.fixSeams=stdMat.cubeMap?stdMat.cubeMap.fixCubemapSeams:false;const isPhong=stdMat.shadingModel===SPECULAR_PHONG;let usingSceneEnv=false;if(stdMat.envAtlas&&stdMat.cubeMap&&!isPhong){options.litOptions.reflectionSource="envAtlasHQ";options.litOptions.reflectionEncoding=stdMat.envAtlas.encoding;options.litOptions.reflectionCubemapEncoding=stdMat.cubeMap.encoding;}else if(stdMat.envAtlas&&!isPhong){options.litOptions.reflectionSource="envAtlas";options.litOptions.reflectionEncoding=stdMat.envAtlas.encoding;}else if(stdMat.cubeMap){options.litOptions.reflectionSource="cubeMap";options.litOptions.reflectionEncoding=stdMat.cubeMap.encoding;}else if(stdMat.sphereMap){options.litOptions.reflectionSource="sphereMap";options.litOptions.reflectionEncoding=stdMat.sphereMap.encoding;}else if(stdMat.useSkybox&&scene.envAtlas&&scene.skybox&&!isPhong){options.litOptions.reflectionSource="envAtlasHQ";options.litOptions.reflectionEncoding=scene.envAtlas.encoding;options.litOptions.reflectionCubemapEncoding=scene.skybox.encoding;usingSceneEnv=true;}else if(stdMat.useSkybox&&scene.envAtlas&&!isPhong){options.litOptions.reflectionSource="envAtlas";options.litOptions.reflectionEncoding=scene.envAtlas.encoding;usingSceneEnv=true;}else if(stdMat.useSkybox&&scene.skybox){options.litOptions.reflectionSource="cubeMap";options.litOptions.reflectionEncoding=scene.skybox.encoding;usingSceneEnv=true;}else {options.litOptions.reflectionSource=null;options.litOptions.reflectionEncoding=null;}if(stdMat.ambientSH&&!isPhong){options.litOptions.ambientSource="ambientSH";options.litOptions.ambientEncoding=null;}else {const envAtlas=stdMat.envAtlas||(stdMat.useSkybox&&scene.envAtlas?scene.envAtlas:null);if(envAtlas&&!isPhong){options.litOptions.ambientSource="envAtlas";options.litOptions.ambientEncoding=envAtlas.encoding;}else {options.litOptions.ambientSource="constant";options.litOptions.ambientEncoding=null;}}options.litOptions.skyboxIntensity=usingSceneEnv;options.litOptions.useCubeMapRotation=usingSceneEnv&&scene._skyboxRotationShaderInclude;}_updateLightOptions(options,scene,stdMat,objDefs,sortedLights){options.lightMap=false;options.lightMapChannel="";options.lightMapUv=0;options.lightMapTransform=0;options.litOptions.lightMapWithoutAmbient=false;options.dirLightMap=false;if(objDefs){options.litOptions.noShadow=(objDefs&SHADERDEF_NOSHADOW)!==0;if((objDefs&SHADERDEF_LM)!==0){options.lightMapEncoding=scene.lightmapPixelFormat===PIXELFORMAT_RGBA8?"rgbm":"linear";options.lightMap=true;options.lightMapChannel="rgb";options.lightMapUv=1;options.lightMapTransform=0;options.litOptions.lightMapWithoutAmbient=!stdMat.lightMap;if((objDefs&SHADERDEF_DIRLM)!==0){options.dirLightMap=true;}if((objDefs&SHADERDEF_LMAMBIENT)!==0){options.litOptions.lightMapWithoutAmbient=false;}}}if(stdMat.useLighting){const lightsFiltered=[];const mask=objDefs?objDefs>>16:MASK_AFFECT_DYNAMIC;options.litOptions.lightMaskDynamic=!!(mask&MASK_AFFECT_DYNAMIC);if(sortedLights){LitMaterialOptionsBuilder.collectLights(LIGHTTYPE_DIRECTIONAL,sortedLights[LIGHTTYPE_DIRECTIONAL],lightsFiltered,mask);LitMaterialOptionsBuilder.collectLights(LIGHTTYPE_OMNI,sortedLights[LIGHTTYPE_OMNI],lightsFiltered,mask);LitMaterialOptionsBuilder.collectLights(LIGHTTYPE_SPOT,sortedLights[LIGHTTYPE_SPOT],lightsFiltered,mask);}options.litOptions.lights=lightsFiltered;}else {options.litOptions.lights=[];}if(options.litOptions.lights.length===0){options.litOptions.noShadow=true;}}_getMapTransformID(xform,uv){if(!xform)return 0;let xforms=this._mapXForms[uv];if(!xforms){xforms=[];this._mapXForms[uv]=xforms;}for(let i=0;i<xforms.length;i++){if(arraysEqual(xforms[i][0].value,xform[0].value)&&arraysEqual(xforms[i][1].value,xform[1].value)){return i+1}}return xforms.push(xform)}constructor(){this._mapXForms=null;}}function __adjustStandardMaterialParameterTypes(types){types.useGamma="boolean";types.aoIntensity="number";}const _tintProperties=["ambientTint","emissiveTint","diffuseTint","sheenTint"];function __adjustStandardMaterialData(data){_tintProperties.forEach(prop=>{if(data[prop]===undefined){data[prop]=true;}});}function _textureParameter(name,channel=true,vertexColor=true){const result={};result[`${name}Map`]="texture";result[`${name}MapTiling`]="vec2";result[`${name}MapOffset`]="vec2";result[`${name}MapRotation`]="number";result[`${name}MapUv`]="number";if(channel){result[`${name}MapChannel`]="string";if(vertexColor){result[`${name}VertexColor`]="boolean";result[`${name}VertexColorChannel`]="string";}}return result}const standardMaterialParameterTypes=_extends({name:"string",chunks:"chunks",mappingFormat:"string",_engine:"boolean",ambient:"rgb",ambientTint:"boolean"},_textureParameter("ao"),_textureParameter("aoDetail",true,false),{aoDetailMode:"string",diffuse:"rgb",diffuseTint:"boolean"},_textureParameter("diffuse"),_textureParameter("diffuseDetail",true,false),{diffuseDetailMode:"string",specular:"rgb",specularTint:"boolean"},_textureParameter("specular"),{occludeSpecular:"enum:occludeSpecular",specularityFactor:"number",specularityFactorTint:"boolean"},_textureParameter("specularityFactor"),{useMetalness:"boolean",metalness:"number",enableGGXSpecular:"boolean",anisotropy:"number",metalnessTint:"boolean"},_textureParameter("metalness"),{useMetalnessSpecularColor:"boolean",conserveEnergy:"boolean",shininess:"number",gloss:"number",glossInvert:"boolean"},_textureParameter("gloss"),{clearCoat:"number"},_textureParameter("clearCoat"),{clearCoatGloss:"number",clearCoatGlossInvert:"boolean"},_textureParameter("clearCoatGloss"),{clearCoatBumpiness:"number"},_textureParameter("clearCoatNormal",false),{useSheen:"boolean",sheen:"rgb",sheenTint:"boolean"},_textureParameter("sheen"),{sheenGloss:"number",sheenGlossTint:"boolean",sheenGlossInvert:"boolean"},_textureParameter("sheenGloss"),{fresnelModel:"number",emissive:"rgb",emissiveTint:"boolean"},_textureParameter("emissive"),{emissiveIntensity:"number"},_textureParameter("normal",false),{bumpiness:"number"},_textureParameter("normalDetail",false),{normalDetailMapBumpiness:"number"},_textureParameter("height",true,false),{heightMapFactor:"number",alphaToCoverage:"boolean",alphaTest:"number",alphaFade:"number",opacity:"number"},_textureParameter("opacity"),{opacityFadesSpecular:"boolean",opacityDither:"string",opacityShadowDither:"string",reflectivity:"number",refraction:"number",refractionTint:"boolean"},_textureParameter("refraction"),{refractionIndex:"number",dispersion:"number",thickness:"number",thicknessTint:"boolean"},_textureParameter("thickness"),{attenuation:"rgb",attenuationDistance:"number",useDynamicRefraction:"boolean",sphereMap:"texture",cubeMap:"cubemap",cubeMapProjection:"number",cubeMapProjectionBox:"boundingbox",useIridescence:"boolean",iridescence:"number",iridescenceTint:"boolean"},_textureParameter("iridescence"),{iridescenceThicknessTint:"boolean",iridescenceThicknessMin:"number",iridescenceThicknessMax:"number",iridescenceRefractionIndex:"number"},_textureParameter("iridescenceThickness"),_textureParameter("light"),{depthTest:"boolean",depthFunc:"enum:depthFunc",depthWrite:"boolean",depthBias:"number",slopeDepthBias:"number",cull:"enum:cull",blendType:"enum:blendType",shadingModel:"enum:shadingModel",useFog:"boolean",useLighting:"boolean",useSkybox:"boolean",useGammaTonemap:"boolean",envAtlas:"texture",twoSidedLighting:"boolean"});__adjustStandardMaterialParameterTypes(standardMaterialParameterTypes);const standardMaterialTextureParameters=[];for(const key in standardMaterialParameterTypes){const type=standardMaterialParameterTypes[key];if(type==="texture"){standardMaterialTextureParameters.push(key);}}const standardMaterialCubemapParameters=[];for(const key in standardMaterialParameterTypes){const type=standardMaterialParameterTypes[key];if(type==="cubemap"){standardMaterialCubemapParameters.push(key);}}const standardMaterialRemovedParameters={aoMapVertexColor:"boolean",diffuseMapTint:"boolean",diffuseMapVertexColor:"boolean",emissiveMapTint:"boolean",emissiveMapVertexColor:"boolean",glossMapVertexColor:"boolean",metalnessMapVertexColor:"boolean",opacityMapVertexColor:"boolean",specularAntialias:"boolean",specularMapTint:"boolean",specularMapVertexColor:"boolean",useTonemap:"boolean",aoIntensity:"number"};const _props={};const _uniforms={};let _params=new Set;class StandardMaterial extends Material{reset(){Object.keys(_props).forEach(name=>{this[`_${name}`]=_props[name].value();});this._chunks={};this._uniformCache={};}set shader(shader){}get shader(){return null}set chunks(value){this._dirtyShader=true;this._chunks=value;}get chunks(){this._dirtyShader=true;return this._chunks}copy(source){super.copy(source);Object.keys(_props).forEach(k=>{this[k]=source[k];});for(const p in source._chunks){if(source._chunks.hasOwnProperty(p)){this._chunks[p]=source._chunks[p];}}return this}setAttribute(name,semantic){this.userAttributes.set(semantic,name);}_setParameter(name,value){_params.add(name);this.setParameter(name,value);}_setParameters(parameters){parameters.forEach(v=>{this._setParameter(v.name,v.value);});}_processParameters(paramsName){const prevParams=this[paramsName];prevParams.forEach(param=>{if(!_params.has(param)){delete this.parameters[param];}});this[paramsName]=_params;_params=prevParams;_params.clear();}_updateMap(p){const mname=`${p}Map`;const map=this[mname];if(map){this._setParameter(`texture_${mname}`,map);const tname=`${mname}Transform`;const uniform=this.getUniform(tname);if(uniform){this._setParameters(uniform);}}}_allocUniform(name,allocFunc){let uniform=this._uniformCache[name];if(!uniform){uniform=allocFunc();this._uniformCache[name]=uniform;}return uniform}getUniform(name,device,scene){return _uniforms[name](this,device,scene)}updateUniforms(device,scene){const getUniform=name=>{return this.getUniform(name,device,scene)};this._setParameter("material_ambient",getUniform("ambient"));if(!this.diffuseMap||this.diffuseTint){this._setParameter("material_diffuse",getUniform("diffuse"));}if(this.useMetalness){if(!this.metalnessMap||this.metalness<1){this._setParameter("material_metalness",this.metalness);}if(!this.specularMap||this.specularTint){this._setParameter("material_specular",getUniform("specular"));}if(!this.specularityFactorMap||this.specularityFactorTint){this._setParameter("material_specularityFactor",this.specularityFactor);}if(!this.sheenMap||this.sheenTint){this._setParameter("material_sheen",getUniform("sheen"));}if(!this.sheenGlossMap||this.sheenGlossTint){this._setParameter("material_sheenGloss",this.sheenGloss);}this._setParameter("material_refractionIndex",this.refractionIndex);}else {if(!this.specularMap||this.specularTint){this._setParameter("material_specular",getUniform("specular"));}}if(this.enableGGXSpecular){this._setParameter("material_anisotropy",this.anisotropy);}if(this.clearCoat>0){this._setParameter("material_clearCoat",this.clearCoat);this._setParameter("material_clearCoatGloss",this.clearCoatGloss);this._setParameter("material_clearCoatBumpiness",this.clearCoatBumpiness);}this._setParameter("material_gloss",getUniform("gloss"));if(!this.emissiveMap||this.emissiveTint){this._setParameter("material_emissive",getUniform("emissive"));}if(this.emissiveIntensity!==1){this._setParameter("material_emissiveIntensity",this.emissiveIntensity);}if(this.refraction>0){this._setParameter("material_refraction",this.refraction);}if(this.dispersion>0){this._setParameter("material_dispersion",this.dispersion);}if(this.useDynamicRefraction){this._setParameter("material_thickness",this.thickness);this._setParameter("material_attenuation",getUniform("attenuation"));this._setParameter("material_invAttenuationDistance",this.attenuationDistance===0?0:1/this.attenuationDistance);}if(this.useIridescence){this._setParameter("material_iridescence",this.iridescence);this._setParameter("material_iridescenceRefractionIndex",this.iridescenceRefractionIndex);this._setParameter("material_iridescenceThicknessMin",this.iridescenceThicknessMin);this._setParameter("material_iridescenceThicknessMax",this.iridescenceThicknessMax);}this._setParameter("material_opacity",this.opacity);if(this.opacityFadesSpecular===false){this._setParameter("material_alphaFade",this.alphaFade);}if(this.occludeSpecular){this._setParameter("material_occludeSpecularIntensity",this.occludeSpecularIntensity);}if(this.cubeMapProjection===CUBEPROJ_BOX){this._setParameter(getUniform("cubeMapProjectionBox"));}for(const p in _matTex2D){this._updateMap(p);}if(this.ambientSH){this._setParameter("ambientSH[0]",this.ambientSH);}if(this.normalMap){this._setParameter("material_bumpiness",this.bumpiness);}if(this.normalMap&&this.normalDetailMap){this._setParameter("material_normalDetailMapBumpiness",this.normalDetailMapBumpiness);}if(this.heightMap){this._setParameter("material_heightMapFactor",getUniform("heightMapFactor"));}const isPhong=this.shadingModel===SPECULAR_PHONG;if(this.envAtlas&&this.cubeMap&&!isPhong){this._setParameter("texture_envAtlas",this.envAtlas);this._setParameter("texture_cubeMap",this.cubeMap);}else if(this.envAtlas&&!isPhong){this._setParameter("texture_envAtlas",this.envAtlas);}else if(this.cubeMap){this._setParameter("texture_cubeMap",this.cubeMap);}else if(this.sphereMap){this._setParameter("texture_sphereMap",this.sphereMap);}this._setParameter("material_reflectivity",this.reflectivity);this._processParameters("_activeParams");if(this._dirtyShader){this.clearVariants();}}updateEnvUniforms(device,scene){const isPhong=this.shadingModel===SPECULAR_PHONG;const hasLocalEnvOverride=this.envAtlas&&!isPhong||this.cubeMap||this.sphereMap;if(!hasLocalEnvOverride&&this.useSkybox){if(scene.envAtlas&&scene.skybox&&!isPhong){this._setParameter("texture_envAtlas",scene.envAtlas);this._setParameter("texture_cubeMap",scene.skybox);}else if(scene.envAtlas&&!isPhong){this._setParameter("texture_envAtlas",scene.envAtlas);}else if(scene.skybox){this._setParameter("texture_cubeMap",scene.skybox);}}this._processParameters("_activeLightingParams");}getShaderVariant(device,scene,objDefs,unused,pass,sortedLights,viewUniformFormat,viewBindGroupFormat,vertexFormat){this.updateEnvUniforms(device,scene);const shaderPassInfo=ShaderPass.get(device).getByIndex(pass);const minimalOptions=pass===SHADER_DEPTH||pass===SHADER_PICK||pass===SHADER_PREPASS_VELOCITY||shaderPassInfo.isShadow;let options=minimalOptions?standard.optionsContextMin:standard.optionsContext;if(minimalOptions){this.shaderOptBuilder.updateMinRef(options,scene,this,objDefs,pass,sortedLights);}else {this.shaderOptBuilder.updateRef(options,scene,this,objDefs,pass,sortedLights);}if(this.onUpdateShader){options=this.onUpdateShader(options);}const processingOptions=new ShaderProcessorOptions(viewUniformFormat,viewBindGroupFormat,vertexFormat);const library=getProgramLibrary(device);library.register("standard",standard);const shader=library.getProgram("standard",options,processingOptions,this.userId);this._dirtyShader=false;return shader}destroy(){for(const asset in this._assetReferences){this._assetReferences[asset]._unbind();}this._assetReferences=null;super.destroy();}constructor(){super();this.userAttributes=new Map;this._dirtyShader=true;this._assetReferences={};this._activeParams=new Set;this._activeLightingParams=new Set;this.shaderOptBuilder=new StandardMaterialOptionsBuilder;this.reset();}}StandardMaterial.TEXTURE_PARAMETERS=standardMaterialTextureParameters;StandardMaterial.CUBEMAP_PARAMETERS=standardMaterialCubemapParameters;const defineUniform=(name,getUniformFunc)=>{_uniforms[name]=getUniformFunc;};const definePropInternal=(name,constructorFunc,setterFunc,getterFunc)=>{Object.defineProperty(StandardMaterial.prototype,name,{get:getterFunc||function(){return this[`_${name}`]},set:setterFunc});_props[name]={value:constructorFunc};};const defineValueProp=prop=>{const internalName=`_${prop.name}`;const dirtyShaderFunc=prop.dirtyShaderFunc||(()=>true);const setterFunc=function setterFunc(value){const oldValue=this[internalName];if(oldValue!==value){this._dirtyShader=this._dirtyShader||dirtyShaderFunc(oldValue,value);this[internalName]=value;}};definePropInternal(prop.name,()=>prop.defaultValue,setterFunc,prop.getterFunc);};const defineAggProp=prop=>{const internalName=`_${prop.name}`;const dirtyShaderFunc=prop.dirtyShaderFunc||(()=>true);const setterFunc=function setterFunc(value){const oldValue=this[internalName];if(!oldValue.equals(value)){this._dirtyShader=this._dirtyShader||dirtyShaderFunc(oldValue,value);this[internalName]=oldValue.copy(value);}};definePropInternal(prop.name,()=>prop.defaultValue.clone(),setterFunc,prop.getterFunc);};const defineProp=prop=>{return prop.defaultValue&&prop.defaultValue.clone?defineAggProp(prop):defineValueProp(prop)};function _defineTex2D(name,channel="rgb",vertexColor=true,uv=0){_matTex2D[name]=channel.length||-1;defineProp({name:`${name}Map`,defaultValue:null,dirtyShaderFunc:(oldValue,newValue)=>{return !!oldValue!==!!newValue||oldValue&&(oldValue.type!==newValue.type||oldValue.fixCubemapSeams!==newValue.fixCubemapSeams||oldValue.format!==newValue.format)}});defineProp({name:`${name}MapTiling`,defaultValue:new Vec2(1,1)});defineProp({name:`${name}MapOffset`,defaultValue:new Vec2(0,0)});defineProp({name:`${name}MapRotation`,defaultValue:0});defineProp({name:`${name}MapUv`,defaultValue:uv});if(channel){defineProp({name:`${name}MapChannel`,defaultValue:channel});if(vertexColor){defineProp({name:`${name}VertexColor`,defaultValue:false});defineProp({name:`${name}VertexColorChannel`,defaultValue:channel});}}const mapTiling=`${name}MapTiling`;const mapOffset=`${name}MapOffset`;const mapRotation=`${name}MapRotation`;const mapTransform=`${name}MapTransform`;defineUniform(mapTransform,(material,device,scene)=>{const tiling=material[mapTiling];const offset=material[mapOffset];const rotation=material[mapRotation];if(tiling.x===1&&tiling.y===1&&offset.x===0&&offset.y===0&&rotation===0){return null}const uniform=material._allocUniform(mapTransform,()=>{return [{name:`texture_${mapTransform}0`,value:new Float32Array(3)},{name:`texture_${mapTransform}1`,value:new Float32Array(3)}]});const cr=Math.cos(rotation*math.DEG_TO_RAD);const sr=Math.sin(rotation*math.DEG_TO_RAD);const uniform0=uniform[0].value;uniform0[0]=cr*tiling.x;uniform0[1]=-sr*tiling.y;uniform0[2]=offset.x;const uniform1=uniform[1].value;uniform1[0]=sr*tiling.x;uniform1[1]=cr*tiling.y;uniform1[2]=1-tiling.y-offset.y;return uniform});}function _defineColor(name,defaultValue){defineProp({name:name,defaultValue:defaultValue,getterFunc:function(){this._dirtyShader=true;return this[`_${name}`]}});defineUniform(name,(material,device,scene)=>{const uniform=material._allocUniform(name,()=>new Float32Array(3));const color=material[name];const gamma=material.useGammaTonemap&&scene.gammaCorrection;if(gamma){uniform[0]=Math.pow(color.r,2.2);uniform[1]=Math.pow(color.g,2.2);uniform[2]=Math.pow(color.b,2.2);}else {uniform[0]=color.r;uniform[1]=color.g;uniform[2]=color.b;}return uniform});}function _defineFloat(name,defaultValue,getUniformFunc){defineProp({name:name,defaultValue:defaultValue,dirtyShaderFunc:(oldValue,newValue)=>{return (oldValue===0||oldValue===1)!==(newValue===0||newValue===1)}});defineUniform(name,getUniformFunc);}function _defineObject(name,getUniformFunc){defineProp({name:name,defaultValue:null,dirtyShaderFunc:(oldValue,newValue)=>{return !!oldValue===!!newValue}});defineUniform(name,getUniformFunc);}function _defineFlag(name,defaultValue){defineProp({name:name,defaultValue:defaultValue});}function _defineMaterialProps(){_defineColor("ambient",new Color(.7,.7,.7));_defineColor("diffuse",new Color(1,1,1));_defineColor("specular",new Color(0,0,0));_defineColor("emissive",new Color(0,0,0));_defineColor("sheen",new Color(1,1,1));_defineColor("attenuation",new Color(1,1,1));_defineFloat("emissiveIntensity",1);_defineFloat("specularityFactor",1);_defineFloat("sheenGloss",0);_defineFloat("gloss",.25,(material,device,scene)=>{return material.shadingModel===SPECULAR_PHONG?Math.pow(2,material.gloss*11):material.gloss});_defineFloat("heightMapFactor",1,(material,device,scene)=>{return material.heightMapFactor*.025});_defineFloat("opacity",1);_defineFloat("alphaFade",1);_defineFloat("alphaTest",0);_defineFloat("bumpiness",1);_defineFloat("normalDetailMapBumpiness",1);_defineFloat("reflectivity",1);_defineFloat("occludeSpecularIntensity",1);_defineFloat("refraction",0);_defineFloat("refractionIndex",1/1.5);_defineFloat("dispersion",0);_defineFloat("thickness",0);_defineFloat("attenuationDistance",0);_defineFloat("metalness",1);_defineFloat("anisotropy",0);_defineFloat("clearCoat",0);_defineFloat("clearCoatGloss",1);_defineFloat("clearCoatBumpiness",1);_defineFloat("aoUvSet",0,null);_defineFloat("iridescence",0);_defineFloat("iridescenceRefractionIndex",1/1.5);_defineFloat("iridescenceThicknessMin",0);_defineFloat("iridescenceThicknessMax",0);_defineObject("ambientSH");_defineObject("cubeMapProjectionBox",(material,device,scene)=>{const uniform=material._allocUniform("cubeMapProjectionBox",()=>{return [{name:"envBoxMin",value:new Float32Array(3)},{name:"envBoxMax",value:new Float32Array(3)}]});const bboxMin=material.cubeMapProjectionBox.getMin();const minUniform=uniform[0].value;minUniform[0]=bboxMin.x;minUniform[1]=bboxMin.y;minUniform[2]=bboxMin.z;const bboxMax=material.cubeMapProjectionBox.getMax();const maxUniform=uniform[1].value;maxUniform[0]=bboxMax.x;maxUniform[1]=bboxMax.y;maxUniform[2]=bboxMax.z;return uniform});_defineFlag("ambientTint",false);_defineFlag("diffuseTint",false);_defineFlag("sheenTint",false);_defineFlag("specularTint",false);_defineFlag("specularityFactorTint",false);_defineFlag("emissiveTint",false);_defineFlag("fastTbn",false);_defineFlag("useMetalness",false);_defineFlag("useMetalnessSpecularColor",false);_defineFlag("useSheen",false);_defineFlag("enableGGXSpecular",false);_defineFlag("occludeDirect",false);_defineFlag("normalizeNormalMap",true);_defineFlag("conserveEnergy",true);_defineFlag("opacityFadesSpecular",true);_defineFlag("occludeSpecular",SPECOCC_AO);_defineFlag("shadingModel",SPECULAR_BLINN);_defineFlag("fresnelModel",FRESNEL_SCHLICK);_defineFlag("useDynamicRefraction",false);_defineFlag("cubeMapProjection",CUBEPROJ_NONE);_defineFlag("customFragmentShader",null);_defineFlag("useFog",true);_defineFlag("useLighting",true);_defineFlag("useGammaTonemap",true);_defineFlag("useSkybox",true);_defineFlag("forceUv1",false);_defineFlag("pixelSnap",false);_defineFlag("twoSidedLighting",false);_defineFlag("nineSlicedMode",undefined);_defineFlag("msdfTextAttribute",false);_defineFlag("useIridescence",false);_defineFlag("glossInvert",false);_defineFlag("sheenGlossInvert",false);_defineFlag("clearCoatGlossInvert",false);_defineFlag("opacityDither",DITHER_NONE);_defineFlag("opacityShadowDither",DITHER_NONE);_defineTex2D("diffuse");_defineTex2D("specular");_defineTex2D("emissive");_defineTex2D("thickness","g");_defineTex2D("specularityFactor","g");_defineTex2D("normal","");_defineTex2D("metalness","g");_defineTex2D("gloss","g");_defineTex2D("opacity","a");_defineTex2D("refraction","g");_defineTex2D("height","g",false);_defineTex2D("ao","g");_defineTex2D("light","rgb",true,1);_defineTex2D("msdf","");_defineTex2D("diffuseDetail","rgb",false);_defineTex2D("normalDetail","");_defineTex2D("aoDetail","g",false);_defineTex2D("clearCoat","g");_defineTex2D("clearCoatGloss","g");_defineTex2D("clearCoatNormal","");_defineTex2D("sheen","rgb");_defineTex2D("sheenGloss","g");_defineTex2D("iridescence","g");_defineTex2D("iridescenceThickness","g");_defineFlag("diffuseDetailMode",DETAILMODE_MUL);_defineFlag("aoDetailMode",DETAILMODE_MUL);_defineObject("cubeMap");_defineObject("sphereMap");_defineObject("envAtlas");const getterFunc=function getterFunc(){return this._prefilteredCubemaps};const setterFunc=function setterFunc(value){const cubemaps=this._prefilteredCubemaps;value=value||[];let changed=false;let complete=true;for(let i=0;i<6;++i){const v=value[i]||null;if(cubemaps[i]!==v){cubemaps[i]=v;changed=true;}complete=complete&&!!cubemaps[i];}if(changed){if(complete){this.envAtlas=EnvLighting.generatePrefilteredAtlas(cubemaps,{target:this.envAtlas});}else {if(this.envAtlas){this.envAtlas.destroy();this.envAtlas=null;}}this._dirtyShader=true;}};const empty=[null,null,null,null,null,null];definePropInternal("prefilteredCubemaps",()=>empty.slice(),setterFunc,getterFunc);}_defineMaterialProps();class TextureAtlas extends EventHandler{set texture(value){this._texture=value;this.fire("set:texture",value);}get texture(){return this._texture}set frames(value){this._frames=value;this.fire("set:frames",value);}get frames(){return this._frames}setFrame(key,data){let frame=this._frames[key];if(!frame){frame={rect:data.rect.clone(),pivot:data.pivot.clone(),border:data.border.clone()};this._frames[key]=frame;}else {frame.rect.copy(data.rect);frame.pivot.copy(data.pivot);frame.border.copy(data.border);}this.fire("set:frame",key.toString(),frame);}removeFrame(key){const frame=this._frames[key];if(frame){delete this._frames[key];this.fire("remove:frame",key.toString(),frame);}}destroy(){if(this._texture){this._texture.destroy();}}constructor(){super();this._texture=null;this._frames=null;}}class Key{constructor(time,position,rotation,scale){this.time=time;this.position=position;this.rotation=rotation;this.scale=scale;}}class Node{constructor(){this._name="";this._keys=[];}}class Animation{getNode(name){return this._nodeDict[name]}addNode(node){this._nodes.push(node);this._nodeDict[node._name]=node;}get nodes(){return this._nodes}constructor(){this.name="";this.duration=0;this._nodes=[];this._nodeDict={};}}class InterpolatedKey{getTarget(){return this._targetNode}setTarget(node){this._targetNode=node;}constructor(){this._written=false;this._name="";this._keyFrames=[];this._quat=new Quat;this._pos=new Vec3;this._scale=new Vec3;this._targetNode=null;}}class Skeleton{set animation(value){this._animation=value;this.currentTime=0;}get animation(){return this._animation}set currentTime(value){this._time=value;const numNodes=this._interpolatedKeys.length;for(let i=0;i<numNodes;i++){const node=this._interpolatedKeys[i];const nodeName=node._name;this._currKeyIndices[nodeName]=0;}this.addTime(0);this.updateGraph();}get currentTime(){return this._time}get numNodes(){return this._interpolatedKeys.length}addTime(delta){if(this._animation!==null){const nodes=this._animation._nodes;const duration=this._animation.duration;if(this._time===duration&&!this.looping){return}this._time+=delta;if(this._time>duration){this._time=this.looping?0:duration;for(let i=0;i<nodes.length;i++){const node=nodes[i];const nodeName=node._name;this._currKeyIndices[nodeName]=0;}}else if(this._time<0){this._time=this.looping?duration:0;for(let i=0;i<nodes.length;i++){const node=nodes[i];const nodeName=node._name;this._currKeyIndices[nodeName]=node._keys.length-2;}}const offset=delta>=0?1:-1;for(let i=0;i<nodes.length;i++){const node=nodes[i];const nodeName=node._name;const keys=node._keys;const interpKey=this._interpolatedKeyDict[nodeName];if(interpKey===undefined){continue}let foundKey=false;if(keys.length!==1){for(let currKeyIndex=this._currKeyIndices[nodeName];currKeyIndex<keys.length-1&&currKeyIndex>=0;currKeyIndex+=offset){const k1=keys[currKeyIndex];const k2=keys[currKeyIndex+1];if(k1.time<=this._time&&k2.time>=this._time){const alpha=(this._time-k1.time)/(k2.time-k1.time);interpKey._pos.lerp(k1.position,k2.position,alpha);interpKey._quat.slerp(k1.rotation,k2.rotation,alpha);interpKey._scale.lerp(k1.scale,k2.scale,alpha);interpKey._written=true;this._currKeyIndices[nodeName]=currKeyIndex;foundKey=true;break}}}if(keys.length===1||!foundKey&&this._time===0&&this.looping){interpKey._pos.copy(keys[0].position);interpKey._quat.copy(keys[0].rotation);interpKey._scale.copy(keys[0].scale);interpKey._written=true;}}}}blend(skel1,skel2,alpha){const numNodes=this._interpolatedKeys.length;for(let i=0;i<numNodes;i++){const key1=skel1._interpolatedKeys[i];const key2=skel2._interpolatedKeys[i];const dstKey=this._interpolatedKeys[i];if(key1._written&&key2._written){dstKey._quat.slerp(key1._quat,skel2._interpolatedKeys[i]._quat,alpha);dstKey._pos.lerp(key1._pos,skel2._interpolatedKeys[i]._pos,alpha);dstKey._scale.lerp(key1._scale,key2._scale,alpha);dstKey._written=true;}else if(key1._written){dstKey._quat.copy(key1._quat);dstKey._pos.copy(key1._pos);dstKey._scale.copy(key1._scale);dstKey._written=true;}else if(key2._written){dstKey._quat.copy(key2._quat);dstKey._pos.copy(key2._pos);dstKey._scale.copy(key2._scale);dstKey._written=true;}}}setGraph(graph){this.graph=graph;if(graph){for(let i=0;i<this._interpolatedKeys.length;i++){const interpKey=this._interpolatedKeys[i];const graphNode=graph.findByName(interpKey._name);this._interpolatedKeys[i].setTarget(graphNode);}}else {for(let i=0;i<this._interpolatedKeys.length;i++){this._interpolatedKeys[i].setTarget(null);}}}updateGraph(){if(this.graph){for(let i=0;i<this._interpolatedKeys.length;i++){const interpKey=this._interpolatedKeys[i];if(interpKey._written){const transform=interpKey.getTarget();transform.localPosition.copy(interpKey._pos);transform.localRotation.copy(interpKey._quat);transform.localScale.copy(interpKey._scale);if(!transform._dirtyLocal){transform._dirtifyLocal();}interpKey._written=false;}}}}constructor(graph){this.looping=true;this._animation=null;this._time=0;this._interpolatedKeys=[];this._interpolatedKeyDict={};this._currKeyIndices={};this.graph=null;const addInterpolatedKeys=node=>{const interpKey=new InterpolatedKey;interpKey._name=node.name;this._interpolatedKeys.push(interpKey);this._interpolatedKeyDict[node.name]=interpKey;this._currKeyIndices[node.name]=0;for(let i=0;i<node._children.length;i++){addInterpolatedKeys(node._children[i]);}};addInterpolatedKeys(graph);}}const _viewport$1=new Vec4;class PostEffect{render(inputTarget,outputTarget,rect){}drawQuad(target,shader,rect){let viewport;if(rect){const w=target?target.width:this.device.width;const h=target?target.height:this.device.height;viewport=_viewport$1.set(rect.x*w,rect.y*h,rect.z*w,rect.w*h);}this.device.setBlendState(BlendState.NOBLEND);drawQuadWithShader(this.device,target,shader,viewport);}constructor(graphicsDevice){this.device=graphicsDevice;this.needsDepthBuffer=false;}}PostEffect.quadVertexShader=`
				attribute vec2 aPosition;
				varying vec2 vUv0;
				void main(void)
				{
						gl_Position = vec4(aPosition, 0.0, 1.0);
						vUv0 = getImageEffectUV((aPosition.xy + 1.0) * 0.5);
				}
		`;class RenderPassShaderQuad extends RenderPass{set shader(shader){var _this$quadRender,_this$_shader;(_this$quadRender=this.quadRender)==null||_this$quadRender.destroy();this.quadRender=null;(_this$_shader=this._shader)==null||_this$_shader.destroy();this._shader=shader;if(shader){this.quadRender=new QuadRender(shader);}}get shader(){return this._shader}createQuadShader(name,fs,shaderDefinitionOptions={}){return createShaderFromCode(this.device,RenderPassShaderQuad.quadVertexShader,fs,name,{aPosition:SEMANTIC_POSITION},shaderDefinitionOptions)}destroy(){var _this$shader;(_this$shader=this.shader)==null||_this$shader.destroy();this.shader=null;}execute(){const device=this.device;device.setBlendState(this.blendState);device.setCullMode(this.cullMode);device.setDepthState(this.depthState);device.setStencilState(this.stencilFront,this.stencilBack);this.quadRender.render();}constructor(...args){super(...args);this._shader=null;this.quadRender=null;this.cullMode=CULLFACE_NONE;this.blendState=BlendState.NOBLEND;this.depthState=DepthState.NODEPTH;this.stencilFront=null;this.stencilBack=null;}}RenderPassShaderQuad.quadVertexShader=`
				attribute vec2 aPosition;
				varying vec2 uv0;
				void main(void)
				{
						gl_Position = vec4(aPosition, 0.0, 1.0);
						uv0 = getImageEffectUV((aPosition.xy + 1.0) * 0.5);
				}
		`;function areaElement(x,y){return Math.atan2(x*y,Math.sqrt(x*x+y*y+1))}function texelCoordSolidAngle(u,v,size){let _u=2*(u+.5)/size-1;let _v=2*(v+.5)/size-1;_u*=1-1/size;_v*=1-1/size;const invResolution=1/size;const x0=_u-invResolution;const y0=_v-invResolution;const x1=_u+invResolution;const y1=_v+invResolution;let solidAngle=areaElement(x0,y0)-areaElement(x0,y1)-areaElement(x1,y0)+areaElement(x1,y1);if(u===0&&v===0||u===size-1&&v===0||u===0&&v===size-1||u===size-1&&v===size-1){solidAngle/=3;}else if(u===0||v===0||u===size-1||v===size-1){solidAngle*=.5;}return solidAngle}function shFromCubemap(device,source,dontFlipX){if(source.format!==PIXELFORMAT_RGBA8){return null}if(!source._levels[0]||!source._levels[0][0]){return null}const cubeSize=source.width;if(!source._levels[0][0].length){if(source._levels[0][0]instanceof HTMLImageElement){const shader=createShaderFromCode(device,shaderChunks.fullscreenQuadVS,shaderChunks.fullscreenQuadPS,"fsQuadSimple");const constantTexSource=device.scope.resolve("source");for(let face=0;face<6;face++){const img=source._levels[0][face];const tex=new Texture(device,{name:"prefiltered-cube",cubemap:false,type:TEXTURETYPE_DEFAULT,format:source.format,width:cubeSize,height:cubeSize,mipmaps:false});tex._levels[0]=img;tex.upload();const tex2=new Texture(device,{name:"prefiltered-cube",cubemap:false,type:TEXTURETYPE_DEFAULT,format:source.format,width:cubeSize,height:cubeSize,mipmaps:false});const targ=new RenderTarget({colorBuffer:tex2,depth:false});constantTexSource.setValue(tex);device.setBlendState(BlendState.NOBLEND);drawQuadWithShader(device,targ,shader);const gl=device.gl;gl.bindFramebuffer(gl.FRAMEBUFFER,targ.impl._glFrameBuffer);const pixels=new Uint8Array(cubeSize*cubeSize*4);gl.readPixels(0,0,tex.width,tex.height,gl.RGBA,gl.UNSIGNED_BYTE,pixels);source._levels[0][face]=pixels;}}else {return null}}const dirs=[];for(let y=0;y<cubeSize;y++){for(let x=0;x<cubeSize;x++){const u=x/(cubeSize-1)*2-1;const v=y/(cubeSize-1)*2-1;dirs[y*cubeSize+x]=new Vec3(u,v,1).normalize();}}const sh=new Float32Array(9*3);const coef1=0;const coef2=1*3;const coef3=2*3;const coef4=3*3;const coef5=4*3;const coef6=5*3;const coef7=6*3;const coef8=7*3;const coef9=8*3;const nx=0;const px=1;const ny=2;const py=3;const nz=4;const pz=5;let accum=0;for(let face=0;face<6;face++){for(let y=0;y<cubeSize;y++){for(let x=0;x<cubeSize;x++){const addr=y*cubeSize+x;const weight=texelCoordSolidAngle(x,y,cubeSize);const weight1=weight*4/17;const weight2=weight*8/17;const weight3=weight*15/17;const weight4=weight*5/68;const weight5=weight*15/68;const dir=dirs[addr];let dx,dy,dz;if(face===nx){dx=dir.z;dy=-dir.y;dz=-dir.x;}else if(face===px){dx=-dir.z;dy=-dir.y;dz=dir.x;}else if(face===ny){dx=dir.x;dy=dir.z;dz=dir.y;}else if(face===py){dx=dir.x;dy=-dir.z;dz=-dir.y;}else if(face===nz){dx=dir.x;dy=-dir.y;dz=dir.z;}else if(face===pz){dx=-dir.x;dy=-dir.y;dz=-dir.z;}if(!dontFlipX)dx=-dx;const a=source._levels[0][face][addr*4+3]/255;for(let c=0;c<3;c++){let value=source._levels[0][face][addr*4+c]/255;if(source.type===TEXTURETYPE_RGBM){value*=a*8;value*=value;}else {value=Math.pow(value,2.2);}sh[coef1+c]+=value*weight1;sh[coef2+c]+=value*weight2*dx;sh[coef3+c]+=value*weight2*dy;sh[coef4+c]+=value*weight2*dz;sh[coef5+c]+=value*weight3*dx*dz;sh[coef6+c]+=value*weight3*dz*dy;sh[coef7+c]+=value*weight3*dy*dx;sh[coef8+c]+=value*weight4*(3*dz*dz-1);sh[coef9+c]+=value*weight5*(dx*dx-dy*dy);accum+=weight;}}}}for(let c=0;c<sh.length;c++){sh[c]*=4*Math.PI/accum;}return sh}const primitiveUv1Padding=4/64;const primitiveUv1PaddingScale=1-primitiveUv1Padding*2;class ConeBaseGeometry extends Geometry{constructor(baseRadius,peakRadius,height,heightSegments,capSegments,roundedCaps){super();const pos=new Vec3;const bottomToTop=new Vec3;const norm=new Vec3;const top=new Vec3;const bottom=new Vec3;const tangent=new Vec3;const positions=[];const normals=[];const uvs=[];const uvs1=[];const indices=[];let offset;if(height>0){for(let i=0;i<=heightSegments;i++){for(let j=0;j<=capSegments;j++){const theta=j/capSegments*2*Math.PI-Math.PI;const sinTheta=Math.sin(theta);const cosTheta=Math.cos(theta);bottom.set(sinTheta*baseRadius,-height/2,cosTheta*baseRadius);top.set(sinTheta*peakRadius,height/2,cosTheta*peakRadius);pos.lerp(bottom,top,i/heightSegments);bottomToTop.sub2(top,bottom).normalize();tangent.set(cosTheta,0,-sinTheta);norm.cross(tangent,bottomToTop).normalize();positions.push(pos.x,pos.y,pos.z);normals.push(norm.x,norm.y,norm.z);let u=j/capSegments;let v=i/heightSegments;uvs.push(u,1-v);const _v=v;v=u;u=_v;u=u*primitiveUv1PaddingScale+primitiveUv1Padding;v=v*primitiveUv1PaddingScale+primitiveUv1Padding;u/=3;uvs1.push(u,1-v);if(i<heightSegments&&j<capSegments){const first=i*(capSegments+1)+j;const second=i*(capSegments+1)+(j+1);const third=(i+1)*(capSegments+1)+j;const fourth=(i+1)*(capSegments+1)+(j+1);indices.push(first,second,third);indices.push(second,fourth,third);}}}}if(roundedCaps){const latitudeBands=Math.floor(capSegments/2);const longitudeBands=capSegments;const capOffset=height/2;for(let lat=0;lat<=latitudeBands;lat++){const theta=lat*Math.PI*.5/latitudeBands;const sinTheta=Math.sin(theta);const cosTheta=Math.cos(theta);for(let lon=0;lon<=longitudeBands;lon++){const phi=lon*2*Math.PI/longitudeBands-Math.PI/2;const sinPhi=Math.sin(phi);const cosPhi=Math.cos(phi);const x=cosPhi*sinTheta;const y=cosTheta;const z=sinPhi*sinTheta;let u=1-lon/longitudeBands;let v=1-lat/latitudeBands;positions.push(x*peakRadius,y*peakRadius+capOffset,z*peakRadius);normals.push(x,y,z);uvs.push(u,1-v);u=u*primitiveUv1PaddingScale+primitiveUv1Padding;v=v*primitiveUv1PaddingScale+primitiveUv1Padding;u/=3;v/=3;u+=1/3;uvs1.push(u,1-v);}}offset=(heightSegments+1)*(capSegments+1);for(let lat=0;lat<latitudeBands;++lat){for(let lon=0;lon<longitudeBands;++lon){const first=lat*(longitudeBands+1)+lon;const second=first+longitudeBands+1;indices.push(offset+first+1,offset+second,offset+first);indices.push(offset+first+1,offset+second+1,offset+second);}}for(let lat=0;lat<=latitudeBands;lat++){const theta=Math.PI*.5+lat*Math.PI*.5/latitudeBands;const sinTheta=Math.sin(theta);const cosTheta=Math.cos(theta);for(let lon=0;lon<=longitudeBands;lon++){const phi=lon*2*Math.PI/longitudeBands-Math.PI/2;const sinPhi=Math.sin(phi);const cosPhi=Math.cos(phi);const x=cosPhi*sinTheta;const y=cosTheta;const z=sinPhi*sinTheta;let u=1-lon/longitudeBands;let v=1-lat/latitudeBands;positions.push(x*peakRadius,y*peakRadius-capOffset,z*peakRadius);normals.push(x,y,z);uvs.push(u,1-v);u=u*primitiveUv1PaddingScale+primitiveUv1Padding;v=v*primitiveUv1PaddingScale+primitiveUv1Padding;u/=3;v/=3;u+=2/3;uvs1.push(u,1-v);}}offset=(heightSegments+1)*(capSegments+1)+(longitudeBands+1)*(latitudeBands+1);for(let lat=0;lat<latitudeBands;++lat){for(let lon=0;lon<longitudeBands;++lon){const first=lat*(longitudeBands+1)+lon;const second=first+longitudeBands+1;indices.push(offset+first+1,offset+second,offset+first);indices.push(offset+first+1,offset+second+1,offset+second);}}}else {offset=(heightSegments+1)*(capSegments+1);if(baseRadius>0){for(let i=0;i<capSegments;i++){const theta=i/capSegments*2*Math.PI;const x=Math.sin(theta);const y=-height/2;const z=Math.cos(theta);let u=1-(x+1)/2;let v=(z+1)/2;positions.push(x*baseRadius,y,z*baseRadius);normals.push(0,-1,0);uvs.push(u,1-v);u=u*primitiveUv1PaddingScale+primitiveUv1Padding;v=v*primitiveUv1PaddingScale+primitiveUv1Padding;u/=3;v/=3;u+=1/3;uvs1.push(u,1-v);if(i>1){indices.push(offset,offset+i,offset+i-1);}}}offset+=capSegments;if(peakRadius>0){for(let i=0;i<capSegments;i++){const theta=i/capSegments*2*Math.PI;const x=Math.sin(theta);const y=height/2;const z=Math.cos(theta);let u=1-(x+1)/2;let v=(z+1)/2;positions.push(x*peakRadius,y,z*peakRadius);normals.push(0,1,0);uvs.push(u,1-v);u=u*primitiveUv1PaddingScale+primitiveUv1Padding;v=v*primitiveUv1PaddingScale+primitiveUv1Padding;u/=3;v/=3;u+=2/3;uvs1.push(u,1-v);if(i>1){indices.push(offset,offset+i-1,offset+i);}}}}this.positions=positions;this.normals=normals;this.uvs=uvs;this.uvs1=uvs1;this.indices=indices;}}class CapsuleGeometry extends ConeBaseGeometry{constructor(opts={}){var _opts$radius,_opts$height,_opts$heightSegments,_opts$sides;const radius=(_opts$radius=opts.radius)!=null?_opts$radius:.3;const height=(_opts$height=opts.height)!=null?_opts$height:1;const heightSegments=(_opts$heightSegments=opts.heightSegments)!=null?_opts$heightSegments:1;const sides=(_opts$sides=opts.sides)!=null?_opts$sides:20;super(radius,radius,height-2*radius,heightSegments,sides,true);if(opts.calculateTangents){this.tangents=calculateTangents(this.positions,this.normals,this.uvs,this.indices);}}}class ConeGeometry extends ConeBaseGeometry{constructor(opts={}){var _opts$baseRadius,_opts$peakRadius,_opts$height,_opts$heightSegments,_opts$capSegments;const baseRadius=(_opts$baseRadius=opts.baseRadius)!=null?_opts$baseRadius:.5;const peakRadius=(_opts$peakRadius=opts.peakRadius)!=null?_opts$peakRadius:0;const height=(_opts$height=opts.height)!=null?_opts$height:1;const heightSegments=(_opts$heightSegments=opts.heightSegments)!=null?_opts$heightSegments:5;const capSegments=(_opts$capSegments=opts.capSegments)!=null?_opts$capSegments:18;super(baseRadius,peakRadius,height,heightSegments,capSegments,false);if(opts.calculateTangents){this.tangents=calculateTangents(this.positions,this.normals,this.uvs,this.indices);}}}class CylinderGeometry extends ConeBaseGeometry{constructor(opts={}){var _opts$radius,_opts$height,_opts$heightSegments,_opts$capSegments;const radius=(_opts$radius=opts.radius)!=null?_opts$radius:.5;const height=(_opts$height=opts.height)!=null?_opts$height:1;const heightSegments=(_opts$heightSegments=opts.heightSegments)!=null?_opts$heightSegments:5;const capSegments=(_opts$capSegments=opts.capSegments)!=null?_opts$capSegments:20;super(radius,radius,height,heightSegments,capSegments,false);if(opts.calculateTangents){this.tangents=calculateTangents(this.positions,this.normals,this.uvs,this.indices);}}}class PlaneGeometry extends Geometry{constructor(opts={}){var _opts$halfExtents,_opts$widthSegments,_opts$lengthSegments;super();const he=(_opts$halfExtents=opts.halfExtents)!=null?_opts$halfExtents:new Vec2(.5,.5);const ws=(_opts$widthSegments=opts.widthSegments)!=null?_opts$widthSegments:5;const ls=(_opts$lengthSegments=opts.lengthSegments)!=null?_opts$lengthSegments:5;const positions=[];const normals=[];const uvs=[];const indices=[];let vcounter=0;for(let i=0;i<=ws;i++){for(let j=0;j<=ls;j++){const x=-he.x+2*he.x*i/ws;const y=0;const z=-(-he.y+2*he.y*j/ls);const u=i/ws;const v=j/ls;positions.push(x,y,z);normals.push(0,1,0);uvs.push(u,1-v);if(i<ws&&j<ls){indices.push(vcounter+ls+1,vcounter+1,vcounter);indices.push(vcounter+ls+1,vcounter+ls+2,vcounter+1);}vcounter++;}}this.positions=positions;this.normals=normals;this.uvs=uvs;this.uvs1=uvs;this.indices=indices;if(opts.calculateTangents){this.tangents=calculateTangents(positions,normals,uvs,indices);}}}class TorusGeometry extends Geometry{constructor(opts={}){var _opts$tubeRadius,_opts$ringRadius,_opts$sectorAngle,_opts$segments,_opts$sides;super();const rc=(_opts$tubeRadius=opts.tubeRadius)!=null?_opts$tubeRadius:.2;const rt=(_opts$ringRadius=opts.ringRadius)!=null?_opts$ringRadius:.3;const sectorAngle=((_opts$sectorAngle=opts.sectorAngle)!=null?_opts$sectorAngle:360)*math.DEG_TO_RAD;const segments=(_opts$segments=opts.segments)!=null?_opts$segments:30;const sides=(_opts$sides=opts.sides)!=null?_opts$sides:20;const positions=[];const normals=[];const uvs=[];const indices=[];for(let i=0;i<=sides;i++){for(let j=0;j<=segments;j++){const x=Math.cos(sectorAngle*j/segments)*(rt+rc*Math.cos(2*Math.PI*i/sides));const y=Math.sin(2*Math.PI*i/sides)*rc;const z=Math.sin(sectorAngle*j/segments)*(rt+rc*Math.cos(2*Math.PI*i/sides));const nx=Math.cos(sectorAngle*j/segments)*Math.cos(2*Math.PI*i/sides);const ny=Math.sin(2*Math.PI*i/sides);const nz=Math.sin(sectorAngle*j/segments)*Math.cos(2*Math.PI*i/sides);const u=i/sides;const v=1-j/segments;positions.push(x,y,z);normals.push(nx,ny,nz);uvs.push(u,1-v);if(i<sides&&j<segments){const first=i*(segments+1)+j;const second=(i+1)*(segments+1)+j;const third=i*(segments+1)+(j+1);const fourth=(i+1)*(segments+1)+(j+1);indices.push(first,second,third);indices.push(second,fourth,third);}}}this.positions=positions;this.normals=normals;this.uvs=uvs;this.uvs1=uvs;this.indices=indices;if(opts.calculateTangents){this.tangents=calculateTangents(positions,normals,uvs,indices);}}}class ProgramLibrary{destroy(){this.clearCache();}register(name,generator){if(!this._generators.has(name)){this._generators.set(name,generator);}}unregister(name){if(this._generators.has(name)){this._generators.delete(name);}}isRegistered(name){return this._generators.has(name)}generateShaderDefinition(generator,name,key,options){let def=this.definitionsCache.get(key);if(!def){var _options$litOptions,_options$litOptions2,_def$name;let lights;if((_options$litOptions=options.litOptions)!=null&&_options$litOptions.lights){lights=options.litOptions.lights;options.litOptions.lights=lights.map(l=>{const lcopy=l.clone?l.clone():l;lcopy.key=l.key;return lcopy});}this.storeNewProgram(name,options);if((_options$litOptions2=options.litOptions)!=null&&_options$litOptions2.lights){options.litOptions.lights=lights;}if(this._precached);const device=this._device;def=generator.createShaderDefinition(device,options);def.name=(_def$name=def.name)!=null?_def$name:options.pass?`${name}-pass:${options.pass}`:name;this.definitionsCache.set(key,def);}return def}getCachedShader(key){return this.processedCache.get(key)}setCachedShader(key,shader){this.processedCache.set(key,shader);}getProgram(name,options,processingOptions,userMaterialId){const generator=this._generators.get(name);if(!generator){return null}const generationKeyString=generator.generateKey(options);const generationKey=hashCode(generationKeyString);const processingKeyString=processingOptions.generateKey(this._device);const processingKey=hashCode(processingKeyString);const totalKey=`${generationKey}#${processingKey}`;let processedShader=this.getCachedShader(totalKey);if(!processedShader){const generatedShaderDef=this.generateShaderDefinition(generator,name,generationKey,options);let passName="";let shaderPassInfo;if(options.pass!==undefined){shaderPassInfo=ShaderPass.get(this._device).getByIndex(options.pass);passName=`-${shaderPassInfo.name}`;}this._device.fire("shader:generate",{userMaterialId,shaderPassInfo,definition:generatedShaderDef});const shaderDefinition={name:`${generatedShaderDef.name}${passName}-proc`,attributes:generatedShaderDef.attributes,vshader:generatedShaderDef.vshader,vincludes:generatedShaderDef.vincludes,fincludes:generatedShaderDef.fincludes,fshader:generatedShaderDef.fshader,processingOptions:processingOptions,shaderLanguage:generatedShaderDef.shaderLanguage};processedShader=new Shader(this._device,shaderDefinition);this.setCachedShader(totalKey,processedShader);}return processedShader}storeNewProgram(name,options){let opt={};if(name==="standard"){const defaultMat=this._getDefaultStdMatOptions(options.pass);for(const p in options){if(options.hasOwnProperty(p)&&defaultMat[p]!==options[p]||p==="pass"){opt[p]=options[p];}}for(const p in options.litOptions){opt[p]=options.litOptions[p];}}else {opt=options;}this._programsCollection.push(JSON.stringify({name:name,options:opt}));}dumpPrograms(){let text="let device = pc.app ? pc.app.graphicsDevice : pc.Application.getApplication().graphicsDevice;\n";text+="let shaders = [";if(this._programsCollection[0]){text+=`
	${this._programsCollection[0]}`;}for(let i=1;i<this._programsCollection.length;++i){text+=`,
	${this._programsCollection[i]}`;}text+="\n];\n";text+="device.getProgramLibrary().precompile(shaders);\n";text+=`if (pc.version != "${version}" || pc.revision != "${revision}")
`;text+='	console.warn("precompile-shaders.js: engine version mismatch, rebuild shaders lib with current engine");';const element=document.createElement("a");element.setAttribute("href",`data:text/plain;charset=utf-8,${encodeURIComponent(text)}`);element.setAttribute("download","precompile-shaders.js");element.style.display="none";document.body.appendChild(element);element.click();document.body.removeChild(element);}clearCache(){this._isClearingCache=true;this.processedCache.forEach(shader=>{shader.destroy();});this.processedCache.clear();this._isClearingCache=false;}removeFromCache(shader){if(this._isClearingCache){return}this.processedCache.forEach((cachedShader,key)=>{if(shader===cachedShader){this.processedCache.delete(key);}});}_getDefaultStdMatOptions(pass){const shaderPassInfo=ShaderPass.get(this._device).getByIndex(pass);return pass===SHADER_DEPTH||pass===SHADER_PICK||pass===SHADER_PREPASS_VELOCITY||shaderPassInfo.isShadow?this._defaultStdMatOptionMin:this._defaultStdMatOption}precompile(cache){if(cache){const shaders=new Array(cache.length);for(let i=0;i<cache.length;i++){if(cache[i].name==="standard"){const opt=cache[i].options;const defaultMat=this._getDefaultStdMatOptions(opt.pass);for(const p in defaultMat){if(defaultMat.hasOwnProperty(p)&&opt[p]===undefined){opt[p]=defaultMat[p];}}}shaders[i]=this.getProgram(cache[i].name,cache[i].options);}}this._precached=true;}constructor(device,standardMaterial){this.processedCache=new Map;this.definitionsCache=new Map;this._generators=new Map;this._device=device;this._isClearingCache=false;this._precached=false;this._programsCollection=[];this._defaultStdMatOption=new StandardMaterialOptions;this._defaultStdMatOptionMin=new StandardMaterialOptions;standardMaterial.shaderOptBuilder.updateRef(this._defaultStdMatOption,{},standardMaterial,null,[],SHADER_FORWARD,null);standardMaterial.shaderOptBuilder.updateMinRef(this._defaultStdMatOptionMin,{},standardMaterial,null,SHADER_SHADOW,null);device.on("destroy:shader",shader=>{this.removeFromCache(shader);});}}var bakeDirLmEndPS=`
	vec4 dirLm = texture2D(texture_dirLightMap, vUv1);
	if (bakeDir > 0.5) {
		if (dAtten > 0.00001) {
			dirLm.xyz = dirLm.xyz * 2.0 - vec3(1.0);
			dAtten = saturate(dAtten);
			gl_FragColor.rgb = normalize(dLightDirNormW.xyz*dAtten + dirLm.xyz*dirLm.w) * 0.5 + vec3(0.5);
			gl_FragColor.a = dirLm.w + dAtten;
			gl_FragColor.a = max(gl_FragColor.a, 1.0 / 255.0);
		} else {
			gl_FragColor = dirLm;
		}
	} else {
		gl_FragColor.rgb = dirLm.xyz;
		gl_FragColor.a = max(dirLm.w, dAtten > 0.00001? (1.0/255.0) : 0.0);
	}
`;var bakeLmEndPS=`
#ifdef LIGHTMAP_RGBM
	gl_FragColor.rgb = dDiffuseLight;
	gl_FragColor.rgb = pow(gl_FragColor.rgb, vec3(0.5));
	gl_FragColor.rgb /= 8.0;
	gl_FragColor.a = clamp( max( max( gl_FragColor.r, gl_FragColor.g ), max( gl_FragColor.b, 1.0 / 255.0 ) ), 0.0,1.0 );
	gl_FragColor.a = ceil(gl_FragColor.a * 255.0) / 255.0;
	gl_FragColor.rgb /= gl_FragColor.a;
#else
	gl_FragColor = vec4(dDiffuseLight, 1.0);
#endif
`;var dilatePS=`
varying vec2 vUv0;
uniform sampler2D source;
uniform vec2 pixelOffset;
void main(void) {
	vec4 c = texture2DLodEXT(source, vUv0, 0.0);
	c = c.a>0.0? c : texture2DLodEXT(source, vUv0 - pixelOffset, 0.0);
	c = c.a>0.0? c : texture2DLodEXT(source, vUv0 + vec2(0, -pixelOffset.y), 0.0);
	c = c.a>0.0? c : texture2DLodEXT(source, vUv0 + vec2(pixelOffset.x, -pixelOffset.y), 0.0);
	c = c.a>0.0? c : texture2DLodEXT(source, vUv0 + vec2(-pixelOffset.x, 0), 0.0);
	c = c.a>0.0? c : texture2DLodEXT(source, vUv0 + vec2(pixelOffset.x, 0), 0.0);
	c = c.a>0.0? c : texture2DLodEXT(source, vUv0 + vec2(-pixelOffset.x, pixelOffset.y), 0.0);
	c = c.a>0.0? c : texture2DLodEXT(source, vUv0 + vec2(0, pixelOffset.y), 0.0);
	c = c.a>0.0? c : texture2DLodEXT(source, vUv0 + pixelOffset, 0.0);
	gl_FragColor = c;
}
`;var bilateralDeNoisePS=`
float normpdf3(in vec3 v, in float sigma) {
	return 0.39894 * exp(-0.5 * dot(v, v) / (sigma * sigma)) / sigma;
}
vec3 decodeRGBM(vec4 rgbm) {
	vec3 color = (8.0 * rgbm.a) * rgbm.rgb;
	return color * color;
}
float saturate(float x) {
	return clamp(x, 0.0, 1.0);
}
vec4 encodeRGBM(vec3 color) {
	vec4 encoded;
	encoded.rgb = pow(color.rgb, vec3(0.5));
	encoded.rgb *= 1.0 / 8.0;
	encoded.a = saturate( max( max( encoded.r, encoded.g ), max( encoded.b, 1.0 / 255.0 ) ) );
	encoded.a = ceil(encoded.a * 255.0) / 255.0;
	encoded.rgb /= encoded.a;
	return encoded;
}
#define MSIZE 15
varying vec2 vUv0;
uniform sampler2D source;
uniform vec2 pixelOffset;
uniform vec2 sigmas;
uniform float bZnorm;
uniform float kernel[MSIZE];
void main(void) {
	
	vec4 pixelRgbm = texture2DLodEXT(source, vUv0, 0.0);
	if (pixelRgbm.a <= 0.0) {
		gl_FragColor = pixelRgbm;
		return ;
	}
	float sigma = sigmas.x;
	float bSigma = sigmas.y;
	vec3 pixelHdr = decodeRGBM(pixelRgbm);
	vec3 accumulatedHdr = vec3(0.0);
	float accumulatedFactor = 0.0;
	const int kSize = (MSIZE-1)/2;
	for (int i = -kSize; i <= kSize; ++i) {
		for (int j = -kSize; j <= kSize; ++j) {
			
			vec2 coord = vUv0 + vec2(float(i), float(j)) * pixelOffset;
			vec4 rgbm = texture2DLodEXT(source, coord, 0.0);
			if (rgbm.a > 0.0) {
				vec3 hdr = decodeRGBM(rgbm);
				float factor = kernel[kSize + j] * kernel[kSize + i];
				factor *= normpdf3(hdr - pixelHdr, bSigma) * bZnorm;
				accumulatedHdr += factor * hdr;
				accumulatedFactor += factor;
			}
		}
	}
	gl_FragColor = encodeRGBM(accumulatedHdr / accumulatedFactor);
}
`;const shaderChunksLightmapper={bakeDirLmEndPS,bakeLmEndPS,dilatePS,bilateralDeNoisePS};const mat4$1=new Mat4;const quat$2=new Quat;const aabb=new BoundingBox;const aabb2=new BoundingBox;const debugColor=new Color(1,1,0,.4);const SH_C0$1=.28209479177387814;class SplatIterator{constructor(gsplatData,p,r,s,c){const x=gsplatData.getProp("x");const y=gsplatData.getProp("y");const z=gsplatData.getProp("z");const rx=gsplatData.getProp("rot_1");const ry=gsplatData.getProp("rot_2");const rz=gsplatData.getProp("rot_3");const rw=gsplatData.getProp("rot_0");const sx=gsplatData.getProp("scale_0");const sy=gsplatData.getProp("scale_1");const sz=gsplatData.getProp("scale_2");const cr=gsplatData.getProp("f_dc_0");const cg=gsplatData.getProp("f_dc_1");const cb=gsplatData.getProp("f_dc_2");const ca=gsplatData.getProp("opacity");const sigmoid=v=>{if(v>0){return 1/(1+Math.exp(-v))}const t=Math.exp(v);return t/(1+t)};this.read=i=>{if(p){p.x=x[i];p.y=y[i];p.z=z[i];}if(r){r.set(rx[i],ry[i],rz[i],rw[i]);}if(s){s.set(Math.exp(sx[i]),Math.exp(sy[i]),Math.exp(sz[i]));}if(c){c.set(.5+cr[i]*SH_C0$1,.5+cg[i]*SH_C0$1,.5+cb[i]*SH_C0$1,sigmoid(ca[i]));}};}}const calcSplatMat=(result,p,r)=>{quat$2.set(r.x,r.y,r.z,r.w).normalize();result.setTRS(p,quat$2,Vec3.ONE);};class GSplatData{static calcSplatAabb(result,p,r,s){calcSplatMat(mat4$1,p,r);aabb.center.set(0,0,0);aabb.halfExtents.set(s.x*2,s.y*2,s.z*2);result.setFromTransformedAabb(aabb,mat4$1);}getProp(name,elementName="vertex"){var _this$getElement;return (_this$getElement=this.getElement(elementName))==null||(_this$getElement=_this$getElement.properties.find(p=>p.name===name))==null?void 0:_this$getElement.storage}getElement(name){return this.elements.find(e=>e.name===name)}addProp(name,storage){this.getElement("vertex").properties.push({type:"float",name,storage,byteSize:4});}createIter(p,r,s,c){return new SplatIterator(this,p,r,s,c)}calcAabb(result,pred){let mx,my,mz,Mx,My,Mz;let first=true;const x=this.getProp("x");const y=this.getProp("y");const z=this.getProp("z");const sx=this.getProp("scale_0");const sy=this.getProp("scale_1");const sz=this.getProp("scale_2");for(let i=0;i<this.numSplats;++i){if(pred&&!pred(i)){continue}const scaleVal=2*Math.exp(Math.max(sx[i],sy[i],sz[i]));const px=x[i];const py=y[i];const pz=z[i];if(first){first=false;mx=px-scaleVal;my=py-scaleVal;mz=pz-scaleVal;Mx=px+scaleVal;My=py+scaleVal;Mz=pz+scaleVal;}else {mx=Math.min(mx,px-scaleVal);my=Math.min(my,py-scaleVal);mz=Math.min(mz,pz-scaleVal);Mx=Math.max(Mx,px+scaleVal);My=Math.max(My,py+scaleVal);Mz=Math.max(Mz,pz+scaleVal);}}if(!first){result.center.set((mx+Mx)*.5,(my+My)*.5,(mz+Mz)*.5);result.halfExtents.set((Mx-mx)*.5,(My-my)*.5,(Mz-mz)*.5);}return !first}calcAabbExact(result,pred){const p=new Vec3;const r=new Quat;const s=new Vec3;const iter=this.createIter(p,r,s);let first=true;for(let i=0;i<this.numSplats;++i){if(pred&&!pred(i)){continue}iter.read(i);if(first){first=false;GSplatData.calcSplatAabb(result,p,r,s);}else {GSplatData.calcSplatAabb(aabb2,p,r,s);result.add(aabb2);}}return !first}getCenters(result){const x=this.getProp("x");const y=this.getProp("y");const z=this.getProp("z");for(let i=0;i<this.numSplats;++i){result[i*3+0]=x[i];result[i*3+1]=y[i];result[i*3+2]=z[i];}}calcFocalPoint(result,pred){const x=this.getProp("x");const y=this.getProp("y");const z=this.getProp("z");const sx=this.getProp("scale_0");const sy=this.getProp("scale_1");const sz=this.getProp("scale_2");result.x=0;result.y=0;result.z=0;let sum=0;for(let i=0;i<this.numSplats;++i){if(pred&&!pred(i)){continue}const weight=1/(1+Math.exp(Math.max(sx[i],sy[i],sz[i])));result.x+=x[i]*weight;result.y+=y[i]*weight;result.z+=z[i]*weight;sum+=weight;}result.mulScalar(1/sum);}renderWireframeBounds(scene,worldMat){const p=new Vec3;const r=new Quat;const s=new Vec3;const min=new Vec3;const max=new Vec3;const iter=this.createIter(p,r,s);for(let i=0;i<this.numSplats;++i){iter.read(i);calcSplatMat(mat4$1,p,r);mat4$1.mul2(worldMat,mat4$1);min.set(s.x*-2,s.y*-2,s.z*-2);max.set(s.x*2,s.y*2,s.z*2);scene.immediate.drawWireAlignedBox(min,max,debugColor,true,scene.defaultDrawLayer,mat4$1);}}get isCompressed(){return false}get hasSHData(){for(let i=0;i<45;++i){if(!this.getProp(`f_rest_${i}`)){return false}}return true}calcMortonOrder(){const calcMinMax=arr=>{let min=arr[0];let max=arr[0];for(let i=1;i<arr.length;i++){if(arr[i]<min)min=arr[i];if(arr[i]>max)max=arr[i];}return {min,max}};const encodeMorton3=(x,y,z)=>{const Part1By2=x=>{x&=1023;x=(x^x<<16)&4278190335;x=(x^x<<8)&50393103;x=(x^x<<4)&51130563;x=(x^x<<2)&153391689;return x};return (Part1By2(z)<<2)+(Part1By2(y)<<1)+Part1By2(x)};const x=this.getProp("x");const y=this.getProp("y");const z=this.getProp("z");const{min:minX,max:maxX}=calcMinMax(x);const{min:minY,max:maxY}=calcMinMax(y);const{min:minZ,max:maxZ}=calcMinMax(z);const sizeX=minX===maxX?0:1024/(maxX-minX);const sizeY=minY===maxY?0:1024/(maxY-minY);const sizeZ=minZ===maxZ?0:1024/(maxZ-minZ);const codes=new Map;for(let i=0;i<this.numSplats;i++){const ix=Math.floor((x[i]-minX)*sizeX);const iy=Math.floor((y[i]-minY)*sizeY);const iz=Math.floor((z[i]-minZ)*sizeZ);const code=encodeMorton3(ix,iy,iz);const val=codes.get(code);if(val){val.push(i);}else {codes.set(code,[i]);}}const keys=Array.from(codes.keys()).sort((a,b)=>a-b);const indices=new Uint32Array(this.numSplats);let idx=0;for(let i=0;i<keys.length;++i){const val=codes.get(keys[i]);for(let j=0;j<val.length;++j){indices[idx++]=val[j];}}return indices}reorder(order){const cache=new Map;const getStorage=size=>{if(cache.has(size)){const buffer=cache.get(size);cache.delete(size);return buffer}return new ArrayBuffer(size)};const returnStorage=buffer=>{cache.set(buffer.byteLength,buffer);};const reorder=data=>{const result=new data.constructor(getStorage(data.byteLength));for(let i=0;i<order.length;i++){result[i]=data[order[i]];}returnStorage(data.buffer);return result};this.elements.forEach(element=>{element.properties.forEach(property=>{if(property.storage){property.storage=reorder(property.storage);}});});}reorderData(){this.reorder(this.calcMortonOrder());}constructor(elements){this.elements=void 0;this.numSplats=void 0;this.elements=elements;this.numSplats=this.getElement("vertex").count;}}const splatCoreVS$1=`
	uniform mat4 matrix_model;
	uniform mat4 matrix_view;
	uniform mat4 matrix_projection;
	uniform vec2 viewport;
	uniform vec4 tex_params;
	uniform highp usampler2D splatOrder;
	uniform highp usampler2D transformA;
	uniform highp sampler2D transformB;
	attribute vec3 vertex_position;
	attribute uint vertex_id_attrib;
	#ifndef DITHER_NONE
		varying float id;
	#endif
	uint orderId;
	uint splatId;
	ivec2 splatUV;
	bool calcSplatUV() {
		uint numSplats = uint(tex_params.x);
		uint textureWidth = uint(tex_params.y);
		orderId = vertex_id_attrib + uint(vertex_position.z);
		if (orderId >= numSplats) {
			return false;
		}
		ivec2 orderUV = ivec2(
			int(orderId % textureWidth),
			int(orderId / textureWidth)
		);
		splatId = texelFetch(splatOrder, orderUV, 0).r;
		splatUV = ivec2(
			int(splatId % textureWidth),
			int(splatId / textureWidth)
		);
		return true;
	}
	uvec4 tA;
	vec3 getCenter() {
		tA = texelFetch(transformA, splatUV, 0);
		return uintBitsToFloat(tA.xyz);
	}
	void getCovariance(out vec3 covA, out vec3 covB) {
		vec4 tB = texelFetch(transformB, splatUV, 0);
		vec2 tC = unpackHalf2x16(tA.w);
		covA = tB.xyz;
		covB = vec3(tC.x, tC.y, tB.w);
	}
	vec4 calcV1V2(in vec3 splat_cam, in vec3 covA, in vec3 covB, mat3 W) {
		mat3 Vrk = mat3(
			covA.x, covA.y, covA.z, 
			covA.y, covB.x, covB.y,
			covA.z, covB.y, covB.z
		);
		float focal = viewport.x * matrix_projection[0][0];
		float J1 = focal / splat_cam.z;
		vec2 J2 = -J1 / splat_cam.z * splat_cam.xy;
		mat3 J = mat3(
			J1, 0.0, J2.x, 
			0.0, J1, J2.y, 
			0.0, 0.0, 0.0
		);
		mat3 T = W * J;
		mat3 cov = transpose(T) * Vrk * T;
		float diagonal1 = cov[0][0] + 0.3;
		float offDiagonal = cov[0][1];
		float diagonal2 = cov[1][1] + 0.3;
		float mid = 0.5 * (diagonal1 + diagonal2);
		float radius = length(vec2((diagonal1 - diagonal2) / 2.0, offDiagonal));
		float lambda1 = mid + radius;
		float lambda2 = max(mid - radius, 0.1);
		vec2 diagonalVector = normalize(vec2(offDiagonal, lambda1 - diagonal1));
		vec2 v1 = min(sqrt(2.0 * lambda1), 1024.0) * diagonalVector;
		vec2 v2 = min(sqrt(2.0 * lambda2), 1024.0) * vec2(diagonalVector.y, -diagonalVector.x);
		return vec4(v1, v2);
	}
	vec3 unpack111011(uint bits) {
		return vec3(
			float(bits >> 21u) / 2047.0,
			float((bits >> 11u) & 0x3ffu) / 1023.0,
			float(bits & 0x7ffu) / 2047.0
		);
	}
	void fetchScale(in uvec4 t, out float scale, out vec3 a, out vec3 b, out vec3 c) {
		scale = uintBitsToFloat(t.x);
		a = unpack111011(t.y) * 2.0 - 1.0;
		b = unpack111011(t.z) * 2.0 - 1.0;
		c = unpack111011(t.w) * 2.0 - 1.0;
	}
	void fetch(in uvec4 t, out vec3 a, out vec3 b, out vec3 c, out vec3 d) {
		a = unpack111011(t.x) * 2.0 - 1.0;
		b = unpack111011(t.y) * 2.0 - 1.0;
		c = unpack111011(t.z) * 2.0 - 1.0;
		d = unpack111011(t.w) * 2.0 - 1.0;
	}
	#if defined(USE_SH1)
		#define SH_C1 0.4886025119029199f
		uniform highp usampler2D splatSH_1to3;
	#if defined(USE_SH2)
		#define SH_C2_0 1.0925484305920792f
		#define SH_C2_1 -1.0925484305920792f
		#define SH_C2_2 0.31539156525252005f
		#define SH_C2_3 -1.0925484305920792f
		#define SH_C2_4 0.5462742152960396f
		uniform highp usampler2D splatSH_4to7;
		uniform highp usampler2D splatSH_8to11;
	#if defined(USE_SH3)
		#define SH_C3_0 -0.5900435899266435f
		#define SH_C3_1 2.890611442640554f
		#define SH_C3_2 -0.4570457994644658f
		#define SH_C3_3 0.3731763325901154f
		#define SH_C3_4 -0.4570457994644658f
		#define SH_C3_5 1.445305721320277f
		#define SH_C3_6 -0.5900435899266435f
		uniform highp usampler2D splatSH_12to15;
	#endif
	#endif
	#endif
	vec3 evalSH(in vec3 dir) {
		vec3 result = vec3(0.0);
	#if defined(USE_SH1)
		float x = dir.x;
		float y = dir.y;
		float z = dir.z;
		float scale;
		vec3 sh1, sh2, sh3;
		fetchScale(texelFetch(splatSH_1to3, splatUV, 0), scale, sh1, sh2, sh3);
		result += SH_C1 * (-sh1 * y + sh2 * z - sh3 * x);
	#if defined(USE_SH2)
		float xx = x * x;
		float yy = y * y;
		float zz = z * z;
		float xy = x * y;
		float yz = y * z;
		float xz = x * z;
		vec3 sh4, sh5, sh6, sh7;
		vec3 sh8, sh9, sh10, sh11;
		fetch(texelFetch(splatSH_4to7, splatUV, 0), sh4, sh5, sh6, sh7);
		fetch(texelFetch(splatSH_8to11, splatUV, 0), sh8, sh9, sh10, sh11);
		result +=
			sh4 * (SH_C2_0 * xy) *  +
			sh5 * (SH_C2_1 * yz) +
			sh6 * (SH_C2_2 * (2.0 * zz - xx - yy)) +
			sh7 * (SH_C2_3 * xz) +
			sh8 * (SH_C2_4 * (xx - yy));
	#if defined(USE_SH3)
		vec3 sh12, sh13, sh14, sh15;
		fetch(texelFetch(splatSH_12to15, splatUV, 0), sh12, sh13, sh14, sh15);
		result +=
			sh9  * (SH_C3_0 * y * (3.0 * xx - yy)) +
			sh10 * (SH_C3_1 * xy * z) +
			sh11 * (SH_C3_2 * y * (4.0 * zz - xx - yy)) +
			sh12 * (SH_C3_3 * z * (2.0 * zz - 3.0 * xx - 3.0 * yy)) +
			sh13 * (SH_C3_4 * x * (4.0 * zz - xx - yy)) +
			sh14 * (SH_C3_5 * z * (xx - yy)) +
			sh15 * (SH_C3_6 * x * (xx - 3.0 * yy));
	#endif
	#endif
		result *= scale;
	#endif
		return result;
	}
`;const splatCoreFS$1=`
	#ifndef DITHER_NONE
		varying float id;
	#endif
	#ifdef PICK_PASS
		uniform vec4 uColor;
	#endif
	vec4 evalSplat(vec2 texCoord, vec4 color) {
		mediump float A = dot(texCoord, texCoord);
		if (A > 1.0) {
			discard;
		}
		mediump float B = exp(-A * 4.0) * color.a;
		if (B < 1.0 / 255.0) {
			discard;
		}
		#ifdef PICK_PASS
			if (B < 0.3) {
				discard;
			}
			return uColor;
		#endif
		#ifndef DITHER_NONE
			opacityDither(B, id * 0.013);
		#endif
		#ifdef TONEMAP_ENABLED
			return vec4(gammaCorrectOutput(toneMap(decodeGamma(color.rgb))), B);
		#else
			return vec4(color.rgb, B);
		#endif
	}
`;class GSplatShaderGenerator{generateKey(options){var _options$defines$sort,_options$defines;const vsHash=hashCode(options.vertex);const fsHash=hashCode(options.fragment);const defines=(_options$defines$sort=(_options$defines=options.defines)==null?void 0:_options$defines.sort().join("-"))!=null?_options$defines$sort:"";return `splat-${options.pass}-${options.gamma}-${options.toneMapping}-${vsHash}-${fsHash}-${options.dither}-${defines}`}createShaderDefinition(device,options){var _options$defines2;const shaderPassInfo=ShaderPass.get(device).getByIndex(options.pass);const shaderPassDefines=shaderPassInfo.shaderDefines;const optionDefines=((_options$defines2=options.defines)!=null?_options$defines2:[]).map(d=>`#define ${d}`).join("\n");const defines=`${shaderPassDefines}
`+`${optionDefines}
`+`#define DITHER_${options.dither.toUpperCase()}
`+`#define TONEMAP_${options.toneMapping===TONEMAP_LINEAR?"DISABLED":"ENABLED"}
`;const vs=defines+splatCoreVS$1+options.vertex;const fs=defines+shaderChunks.decodePS+(options.dither===DITHER_NONE?"":shaderChunks.bayerPS+shaderChunks.opacityDitherPS)+ShaderGenerator.tonemapCode(options.toneMapping)+ShaderGenerator.gammaCode(options.gamma)+splatCoreFS$1+options.fragment;return ShaderUtils.createDefinition(device,{name:"SplatShader",attributes:{vertex_position:SEMANTIC_POSITION,vertex_id_attrib:SEMANTIC_ATTR13},vertexCode:vs,fragmentCode:fs})}}const gsplat=new GSplatShaderGenerator;const splatMainVS$1=`
	uniform vec3 view_position;
	uniform sampler2D splatColor;
	varying mediump vec2 texCoord;
	varying mediump vec4 color;
	mediump vec4 discardVec = vec4(0.0, 0.0, 2.0, 1.0);
	void main(void)
	{
		if (!calcSplatUV()) {
			gl_Position = discardVec;
			return;
		}
		vec3 center = getCenter();
		mat4 model_view = matrix_view * matrix_model;
		vec4 splat_cam = model_view * vec4(center, 1.0);
		if (splat_cam.z > 0.0) {
			gl_Position = discardVec;
			return;
		}
		vec4 splat_proj = matrix_projection * splat_cam;
		splat_proj.z = clamp(splat_proj.z, -abs(splat_proj.w), abs(splat_proj.w));
		vec3 covA, covB;
		getCovariance(covA, covB);
		vec4 v1v2 = calcV1V2(splat_cam.xyz, covA, covB, transpose(mat3(model_view)));
		color = texelFetch(splatColor, splatUV, 0);
		float scale = min(1.0, sqrt(-log(1.0 / 255.0 / color.a)) / 2.0);
		v1v2 *= scale;
		if (dot(v1v2.xy, v1v2.xy) < 4.0 && dot(v1v2.zw, v1v2.zw) < 4.0) {
			gl_Position = discardVec;
			return;
		}
		gl_Position = splat_proj + vec4((vertex_position.x * v1v2.xy + vertex_position.y * v1v2.zw) / viewport * splat_proj.w, 0, 0);
		texCoord = vertex_position.xy * scale / 2.0;
		#ifdef USE_SH1
			vec4 worldCenter = matrix_model * vec4(center, 1.0);
			vec3 viewDir = normalize((worldCenter.xyz / worldCenter.w - view_position) * mat3(matrix_model));
			color.xyz = max(color.xyz + evalSH(viewDir), 0.0);
		#endif
		#ifndef DITHER_NONE
			id = float(splatId);
		#endif
	}
`;const splatMainFS$1=`
	varying mediump vec2 texCoord;
	varying mediump vec4 color;
	void main(void)
	{
		gl_FragColor = evalSplat(texCoord, color);
	}
`;const createGSplatMaterial=(options={})=>{var _options$dither;const ditherEnum=(_options$dither=options.dither)!=null?_options$dither:DITHER_NONE;const dither=ditherEnum!==DITHER_NONE;const material=new Material;material.name="splatMaterial";material.cull=CULLFACE_NONE;material.blendType=dither?BLEND_NONE:BLEND_NORMAL;material.depthWrite=dither;material.getShaderVariant=function(device,scene,defs,unused,pass,sortedLights,viewUniformFormat,viewBindGroupFormat){var _options$vertex,_options$fragment;const programOptions={pass:pass,gamma:pass===SHADER_FORWARDHDR?scene.gammaCorrection?GAMMA_SRGBHDR:GAMMA_NONE:scene.gammaCorrection,toneMapping:pass===SHADER_FORWARDHDR?TONEMAP_LINEAR:scene.toneMapping,vertex:(_options$vertex=options.vertex)!=null?_options$vertex:splatMainVS$1,fragment:(_options$fragment=options.fragment)!=null?_options$fragment:splatMainFS$1,dither:ditherEnum,defines:options.defines};const processingOptions=new ShaderProcessorOptions(viewUniformFormat,viewBindGroupFormat);const library=getProgramLibrary(device);library.register("splat",gsplat);return library.getProgram("splat",programOptions,processingOptions)};material.update();return material};const getSHData=gsplatData=>{const result=[];for(let i=0;i<45;++i){result.push(gsplatData.getProp(`f_rest_${i}`));}return result};class GSplat{destroy(){var _this$colorTexture,_this$transformATextu,_this$transformBTextu,_this$sh1to3Texture,_this$sh4to7Texture,_this$sh8to11Texture,_this$sh12to15Texture;(_this$colorTexture=this.colorTexture)==null||_this$colorTexture.destroy();(_this$transformATextu=this.transformATexture)==null||_this$transformATextu.destroy();(_this$transformBTextu=this.transformBTexture)==null||_this$transformBTextu.destroy();(_this$sh1to3Texture=this.sh1to3Texture)==null||_this$sh1to3Texture.destroy();(_this$sh4to7Texture=this.sh4to7Texture)==null||_this$sh4to7Texture.destroy();(_this$sh8to11Texture=this.sh8to11Texture)==null||_this$sh8to11Texture.destroy();(_this$sh12to15Texture=this.sh12to15Texture)==null||_this$sh12to15Texture.destroy();}createMaterial(options){const result=createGSplatMaterial(_extends({},this.hasSH?{defines:["USE_SH1","USE_SH2","USE_SH3"]}:{},options));result.setParameter("splatColor",this.colorTexture);result.setParameter("transformA",this.transformATexture);result.setParameter("transformB",this.transformBTexture);result.setParameter("tex_params",new Float32Array([this.numSplats,this.colorTexture.width,0,0]));if(this.hasSH){result.setParameter("splatSH_1to3",this.sh1to3Texture);result.setParameter("splatSH_4to7",this.sh4to7Texture);result.setParameter("splatSH_8to11",this.sh8to11Texture);result.setParameter("splatSH_12to15",this.sh12to15Texture);}return result}evalTextureSize(count){const width=Math.ceil(Math.sqrt(count));const height=Math.ceil(count/width);return new Vec2(width,height)}createTexture(name,format,size){return new Texture(this.device,{name:name,width:size.x,height:size.y,format:format,cubemap:false,mipmaps:false,minFilter:FILTER_NEAREST,magFilter:FILTER_NEAREST,addressU:ADDRESS_CLAMP_TO_EDGE,addressV:ADDRESS_CLAMP_TO_EDGE})}getTextureFormat(device,preferHighPrecision){if(device.isWebGL1){preferHighPrecision=false;}const halfSupported=device.extTextureHalfFloat&&device.textureHalfFloatUpdatable;const floatSupported=device.extTextureFloat;let halfFormat;if(preferHighPrecision){if(floatSupported){halfFormat=false;}else if(halfSupported){halfFormat=true;}}else {if(halfSupported){halfFormat=true;}else if(floatSupported){halfFormat=false;}}return halfFormat}updateColorData(gsplatData){const texture=this.colorTexture;if(!texture){return}const data=texture.lock();const cr=gsplatData.getProp("f_dc_0");const cg=gsplatData.getProp("f_dc_1");const cb=gsplatData.getProp("f_dc_2");const ca=gsplatData.getProp("opacity");const SH_C0=.28209479177387814;for(let i=0;i<this.numSplats;++i){const r=(cr[i]*SH_C0+.5)*255;const g=(cg[i]*SH_C0+.5)*255;const b=(cb[i]*SH_C0+.5)*255;const a=255/(1+Math.exp(-ca[i]));data[i*4+0]=r<0?0:r>255?255:r;data[i*4+1]=g<0?0:g>255?255:g;data[i*4+2]=b<0?0:b>255?255:b;data[i*4+3]=a<0?0:a>255?255:a;}texture.unlock();}updateTransformData(gsplatData){const float2Half=FloatPacking.float2Half;if(!this.transformATexture){return}const dataA=this.transformATexture.lock();const dataAFloat32=new Float32Array(dataA.buffer);const dataB=this.transformBTexture.lock();const p=new Vec3;const r=new Quat;const s=new Vec3;const iter=gsplatData.createIter(p,r,s);const mat=new Mat3;const cA=new Vec3;const cB=new Vec3;for(let i=0;i<this.numSplats;i++){iter.read(i);r.normalize();mat.setFromQuat(r);this.computeCov3d(mat,s,cA,cB);dataAFloat32[i*4+0]=p.x;dataAFloat32[i*4+1]=p.y;dataAFloat32[i*4+2]=p.z;dataA[i*4+3]=float2Half(cB.x)|float2Half(cB.y)<<16;dataB[i*4+0]=float2Half(cA.x);dataB[i*4+1]=float2Half(cA.y);dataB[i*4+2]=float2Half(cA.z);dataB[i*4+3]=float2Half(cB.z);}this.transformATexture.unlock();this.transformBTexture.unlock();}computeCov3d(rot,scale,covA,covB){const sx=scale.x;const sy=scale.y;const sz=scale.z;const data=rot.data;const r00=data[0]*sx;const r01=data[1]*sx;const r02=data[2]*sx;const r10=data[3]*sy;const r11=data[4]*sy;const r12=data[5]*sy;const r20=data[6]*sz;const r21=data[7]*sz;const r22=data[8]*sz;covA.x=r00*r00+r10*r10+r20*r20;covA.y=r00*r01+r10*r11+r20*r21;covA.z=r00*r02+r10*r12+r20*r22;covB.x=r01*r01+r11*r11+r21*r21;covB.y=r01*r02+r11*r12+r21*r22;covB.z=r02*r02+r12*r12+r22*r22;}updateSHData(gsplatData){const sh1to3Data=this.sh1to3Texture.lock();const sh4to7Data=this.sh4to7Texture.lock();const sh8to11Data=this.sh8to11Texture.lock();const sh12to15Data=this.sh12to15Texture.lock();const src=getSHData(gsplatData);const t11=(1<<11)-1;const t10=(1<<10)-1;const pack=(r,g,b)=>{const rb=Math.floor(r*t11+.5);const gb=Math.floor(g*t10+.5);const bb=Math.floor(b*t11+.5);return (rb<0?0:rb>t11?t11:rb)<<21|(gb<0?0:gb>t10?t10:gb)<<11|(bb<0?0:bb>t11?t11:bb)};const float32=new Float32Array(1);const uint32=new Uint32Array(float32.buffer);const c=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];for(let i=0;i<gsplatData.numSplats;++i){for(let j=0;j<45;++j){c[j]=src[j][i];}let m=Math.abs(c[0]);for(let j=1;j<45;++j){const as=Math.abs(c[j]);if(as>m)m=as;}if(m===0){continue}for(let j=0;j<45;++j){c[j]=c[j]/m*.5+.5;}float32[0]=m;sh1to3Data[i*4+0]=uint32[0];sh1to3Data[i*4+1]=pack(c[0],c[15],c[30]);sh1to3Data[i*4+2]=pack(c[1],c[16],c[31]);sh1to3Data[i*4+3]=pack(c[2],c[17],c[32]);sh4to7Data[i*4+0]=pack(c[3],c[18],c[33]);sh4to7Data[i*4+1]=pack(c[4],c[19],c[34]);sh4to7Data[i*4+2]=pack(c[5],c[20],c[35]);sh4to7Data[i*4+3]=pack(c[6],c[21],c[36]);sh8to11Data[i*4+0]=pack(c[7],c[22],c[37]);sh8to11Data[i*4+1]=pack(c[8],c[23],c[38]);sh8to11Data[i*4+2]=pack(c[9],c[24],c[39]);sh8to11Data[i*4+3]=pack(c[10],c[25],c[40]);sh12to15Data[i*4+0]=pack(c[11],c[26],c[41]);sh12to15Data[i*4+1]=pack(c[12],c[27],c[42]);sh12to15Data[i*4+2]=pack(c[13],c[28],c[43]);sh12to15Data[i*4+3]=pack(c[14],c[29],c[44]);}this.sh1to3Texture.unlock();this.sh4to7Texture.unlock();this.sh8to11Texture.unlock();this.sh12to15Texture.unlock();}constructor(device,gsplatData){this.device=void 0;this.numSplats=void 0;this.centers=void 0;this.aabb=void 0;this.colorTexture=void 0;this.transformATexture=void 0;this.transformBTexture=void 0;this.hasSH=void 0;this.sh1to3Texture=void 0;this.sh4to7Texture=void 0;this.sh8to11Texture=void 0;this.sh12to15Texture=void 0;const numSplats=gsplatData.numSplats;this.device=device;this.numSplats=numSplats;this.centers=new Float32Array(gsplatData.numSplats*3);gsplatData.getCenters(this.centers);this.aabb=new BoundingBox;gsplatData.calcAabb(this.aabb);const size=this.evalTextureSize(numSplats);this.colorTexture=this.createTexture("splatColor",PIXELFORMAT_RGBA8,size);this.transformATexture=this.createTexture("transformA",PIXELFORMAT_RGBA32U,size);this.transformBTexture=this.createTexture("transformB",PIXELFORMAT_RGBA16F,size);this.updateColorData(gsplatData);this.updateTransformData(gsplatData);this.hasSH=gsplatData.hasSHData;if(this.hasSH){this.sh1to3Texture=this.createTexture("splatSH_1to3",PIXELFORMAT_RGBA32U,size);this.sh4to7Texture=this.createTexture("splatSH_4to7",PIXELFORMAT_RGBA32U,size);this.sh8to11Texture=this.createTexture("splatSH_8to11",PIXELFORMAT_RGBA32U,size);this.sh12to15Texture=this.createTexture("splatSH_12to15",PIXELFORMAT_RGBA32U,size);this.updateSHData(gsplatData);}}}function SortWorker(){let order;let centers;let mapping;let cameraPosition;let cameraDirection;let forceUpdate=false;const lastCameraPosition={x:0,y:0,z:0};const lastCameraDirection={x:0,y:0,z:0};const boundMin={x:0,y:0,z:0};const boundMax={x:0,y:0,z:0};let distances;let countBuffer;const binarySearch=(m,n,compare_fn)=>{while(m<=n){const k=n+m>>1;const cmp=compare_fn(k);if(cmp>0){m=k+1;}else if(cmp<0){n=k-1;}else {return k}}return ~m};const update=()=>{var _distances;if(!order||!centers||centers.length===0||!cameraPosition||!cameraDirection)return;const px=cameraPosition.x;const py=cameraPosition.y;const pz=cameraPosition.z;const dx=cameraDirection.x;const dy=cameraDirection.y;const dz=cameraDirection.z;const epsilon=.001;if(!forceUpdate&&Math.abs(px-lastCameraPosition.x)<epsilon&&Math.abs(py-lastCameraPosition.y)<epsilon&&Math.abs(pz-lastCameraPosition.z)<epsilon&&Math.abs(dx-lastCameraDirection.x)<epsilon&&Math.abs(dy-lastCameraDirection.y)<epsilon&&Math.abs(dz-lastCameraDirection.z)<epsilon){return}forceUpdate=false;lastCameraPosition.x=px;lastCameraPosition.y=py;lastCameraPosition.z=pz;lastCameraDirection.x=dx;lastCameraDirection.y=dy;lastCameraDirection.z=dz;let minDist;let maxDist;for(let i=0;i<8;++i){const x=(i&1?boundMin.x:boundMax.x)-px;const y=(i&2?boundMin.y:boundMax.y)-py;const z=(i&4?boundMin.z:boundMax.z)-pz;const d=x*dx+y*dy+z*dz;if(i===0){minDist=maxDist=d;}else {minDist=Math.min(minDist,d);maxDist=Math.max(maxDist,d);}}const numVertices=centers.length/3;const compareBits=Math.max(10,Math.min(20,Math.round(Math.log2(numVertices/4))));const bucketCount=2**compareBits+1;if(((_distances=distances)==null?void 0:_distances.length)!==numVertices){distances=new Uint32Array(numVertices);}if(!countBuffer||countBuffer.length!==bucketCount){countBuffer=new Uint32Array(bucketCount);}else {countBuffer.fill(0);}const range=maxDist-minDist;const divider=range<1e-6?0:1/range*2**compareBits;for(let i=0;i<numVertices;++i){const istride=i*3;const x=centers[istride+0]-px;const y=centers[istride+1]-py;const z=centers[istride+2]-pz;const d=x*dx+y*dy+z*dz;const sortKey=Math.floor((d-minDist)*divider);distances[i]=sortKey;countBuffer[sortKey]++;}for(let i=1;i<bucketCount;i++){countBuffer[i]+=countBuffer[i-1];}for(let i=0;i<numVertices;i++){const distance=distances[i];const destIndex=--countBuffer[distance];order[destIndex]=i;}const dist=i=>distances[order[i]]/divider+minDist;const findZero=()=>{const result=binarySearch(0,numVertices-1,i=>-dist(i));return Math.min(numVertices,Math.abs(result))};const count=dist(numVertices-1)>=0?findZero():numVertices;if(mapping){for(let i=0;i<numVertices;++i){order[i]=mapping[order[i]];}}self.postMessage({order:order.buffer,count},[order.buffer]);order=null;};self.onmessage=message=>{if(message.data.order){order=new Uint32Array(message.data.order);}if(message.data.centers){centers=new Float32Array(message.data.centers);boundMin.x=boundMax.x=centers[0];boundMin.y=boundMax.y=centers[1];boundMin.z=boundMax.z=centers[2];const numVertices=centers.length/3;for(let i=1;i<numVertices;++i){const x=centers[i*3+0];const y=centers[i*3+1];const z=centers[i*3+2];boundMin.x=Math.min(boundMin.x,x);boundMin.y=Math.min(boundMin.y,y);boundMin.z=Math.min(boundMin.z,z);boundMax.x=Math.max(boundMax.x,x);boundMax.y=Math.max(boundMax.y,y);boundMax.z=Math.max(boundMax.z,z);}forceUpdate=true;}if(message.data.hasOwnProperty("mapping")){mapping=message.data.mapping?new Uint32Array(message.data.mapping):null;forceUpdate=true;}if(message.data.cameraPosition)cameraPosition=message.data.cameraPosition;if(message.data.cameraDirection)cameraDirection=message.data.cameraDirection;update();};}class GSplatSorter extends EventHandler{destroy(){this.worker.terminate();this.worker=null;}init(orderTexture,centers){this.orderTexture=orderTexture;this.centers=centers.slice();const orderBuffer=this.orderTexture.lock({mode:TEXTURELOCK_READ}).buffer.slice();this.orderTexture.unlock();this.worker.postMessage({order:orderBuffer,centers:centers.buffer},[orderBuffer,centers.buffer]);}setMapping(mapping){if(mapping){const centers=new Float32Array(mapping.length*3);for(let i=0;i<mapping.length;++i){const src=mapping[i]*3;const dst=i*3;centers[dst+0]=this.centers[src+0];centers[dst+1]=this.centers[src+1];centers[dst+2]=this.centers[src+2];}this.worker.postMessage({centers:centers.buffer,mapping:mapping.buffer},[centers.buffer,mapping.buffer]);}else {const centers=this.centers.slice();this.worker.postMessage({centers:centers.buffer,mapping:null},[centers.buffer]);}}setCamera(pos,dir){this.worker.postMessage({cameraPosition:{x:pos.x,y:pos.y,z:pos.z},cameraDirection:{x:dir.x,y:dir.y,z:dir.z}});}constructor(){super();this.worker=void 0;this.orderTexture=void 0;this.centers=void 0;this.worker=new Worker(URL.createObjectURL(new Blob([`(${SortWorker.toString()})()`],{type:"application/javascript"})));this.worker.onmessage=message=>{const newOrder=message.data.order;const oldOrder=this.orderTexture._levels[0].buffer;this.worker.postMessage({order:oldOrder},[oldOrder]);this.orderTexture._levels[0]=new Uint32Array(newOrder);this.orderTexture.upload();this.fire("updated",message.data.count);};}}const mat=new Mat4;const cameraPosition=new Vec3;const cameraDirection=new Vec3;const viewport=[0,0];class GSplatInstance{destroy(){var _this$material,_this$meshInstance,_this$sorter;(_this$material=this.material)==null||_this$material.destroy();(_this$meshInstance=this.meshInstance)==null||_this$meshInstance.destroy();(_this$sorter=this.sorter)==null||_this$sorter.destroy();}clone(){return new GSplatInstance(this.splat,this.options)}createMaterial(options){this.material=this.splat.createMaterial(options);this.material.setParameter("splatOrder",this.orderTexture);if(this.meshInstance){this.meshInstance.material=this.material;}}updateViewport(){const device=this.splat.device;viewport[0]=device.width;viewport[1]=device.height;if(this.cameras.length>0){const camera=this.cameras[0];const xr=camera.xr;if(xr&&xr.active&&xr.views.list.length===2){viewport[0]/=2;}}this.material.setParameter("viewport",viewport);}sort(cameraNode){if(this.sorter){const cameraMat=cameraNode.getWorldTransform();cameraMat.getTranslation(cameraPosition);cameraMat.getZ(cameraDirection);const modelMat=this.meshInstance.node.getWorldTransform();const invModelMat=mat.invert(modelMat);invModelMat.transformPoint(cameraPosition,cameraPosition);invModelMat.transformVector(cameraDirection,cameraDirection);if(!cameraPosition.equalsApprox(this.lastCameraPosition)||!cameraDirection.equalsApprox(this.lastCameraDirection)){this.lastCameraPosition.copy(cameraPosition);this.lastCameraDirection.copy(cameraDirection);this.sorter.setCamera(cameraPosition,cameraDirection);}}this.updateViewport();}update(){if(this.cameras.length>0){const camera=this.cameras[0];this.sort(camera._node);this.cameras.length=0;}}constructor(splat,options){this.splat=void 0;this.mesh=void 0;this.meshInstance=void 0;this.material=void 0;this.orderTexture=void 0;this.options={};this.sorter=null;this.lastCameraPosition=new Vec3;this.lastCameraDirection=new Vec3;this.cameras=[];this.splat=splat;options=Object.assign(this.options,options);const device=splat.device;this.orderTexture=this.splat.createTexture("splatOrder",PIXELFORMAT_R32U,this.splat.evalTextureSize(this.splat.numSplats));this.createMaterial(options);const splatInstanceSize=128;const numSplats=Math.ceil(splat.numSplats/splatInstanceSize)*splatInstanceSize;const numSplatInstances=numSplats/splatInstanceSize;const indexData=new Uint32Array(numSplatInstances);for(let i=0;i<numSplatInstances;++i){indexData[i]=i*splatInstanceSize;}const vertexFormat=new VertexFormat(device,[{semantic:SEMANTIC_ATTR13,components:1,type:TYPE_UINT32,asInt:true}]);const indicesVB=new VertexBuffer(device,vertexFormat,numSplatInstances,{usage:BUFFER_STATIC,data:indexData.buffer});const meshPositions=new Float32Array(12*splatInstanceSize);const meshIndices=new Uint32Array(6*splatInstanceSize);for(let i=0;i<splatInstanceSize;++i){meshPositions.set([-2,-2,i,2,-2,i,2,2,i,-2,2,i],i*12);const b=i*4;meshIndices.set([0+b,1+b,2+b,0+b,2+b,3+b],i*6);}const mesh=new Mesh(device);mesh.setPositions(meshPositions,3);mesh.setIndices(meshIndices);mesh.update();this.mesh=mesh;this.mesh.aabb.copy(splat.aabb);this.meshInstance=new MeshInstance(this.mesh,this.material);this.meshInstance.setInstancing(indicesVB,true);this.meshInstance.gsplatInstance=this;this.meshInstance.instancingCount=0;this.centers=new Float32Array(splat.centers);if(!options.dither||options.dither===DITHER_NONE){this.sorter=new GSplatSorter;this.sorter.init(this.orderTexture,this.centers);this.sorter.on("updated",count=>{this.meshInstance.instancingCount=Math.ceil(count/splatInstanceSize);const tex_params=this.material.getParameter("tex_params");if(tex_params!=null&&tex_params.data){tex_params.data[0]=count;}});}}}const FILLMODE_NONE="NONE";const FILLMODE_FILL_WINDOW="FILL_WINDOW";const FILLMODE_KEEP_ASPECT="KEEP_ASPECT";const RESOLUTION_AUTO="AUTO";const RESOLUTION_FIXED="FIXED";let currentApplication;function getApplication(){return currentApplication}function setApplication(app){currentApplication=app;}class ScriptTypes{static push(Type,isLegacy){if(isLegacy&&ScriptTypes._types.length>0){console.assert("Script Ordering Error. Contact support@playcanvas.com");}else {ScriptTypes._types.push(Type);}}}ScriptTypes._types=[];let _legacy=false;let _createdLoadingScreen=false;const script={app:null,create(name,callback){if(!_legacy){return}const ScriptType=callback(script.app);ScriptType._pcScriptName=name;ScriptTypes.push(ScriptType,_legacy);this.fire("created",name,callback);},attribute(name,type,defaultValue,options){},createLoadingScreen(callback){if(_createdLoadingScreen){return}_createdLoadingScreen=true;const app=getApplication();callback(app);}};Object.defineProperty(script,"legacy",{get:function(){return _legacy},set:function(value){_legacy=value;}});events.attach(script);class FrameGraph{addRenderPass(renderPass){renderPass.frameUpdate();const beforePasses=renderPass.beforePasses;for(let i=0;i<beforePasses.length;i++){const pass=beforePasses[i];if(pass.enabled){this.addRenderPass(pass);}}if(renderPass.enabled){this.renderPasses.push(renderPass);}const afterPasses=renderPass.afterPasses;for(let i=0;i<afterPasses.length;i++){const pass=afterPasses[i];if(pass.enabled){this.addRenderPass(pass);}}}reset(){this.renderPasses.length=0;}compile(){const renderTargetMap=this.renderTargetMap;const renderPasses=this.renderPasses;for(let i=0;i<renderPasses.length;i++){const renderPass=renderPasses[i];const renderTarget=renderPass.renderTarget;if(renderTarget!==undefined){const prevPass=renderTargetMap.get(renderTarget);if(prevPass){const count=renderPass.colorArrayOps.length;for(let j=0;j<count;j++){const colorOps=renderPass.colorArrayOps[j];if(!colorOps.clear){prevPass.colorArrayOps[j].store=true;}}if(!renderPass.depthStencilOps.clearDepth){prevPass.depthStencilOps.storeDepth=true;}if(!renderPass.depthStencilOps.clearStencil){prevPass.depthStencilOps.storeStencil=true;}}renderTargetMap.set(renderTarget,renderPass);}}let lastCubeTexture=null;let lastCubeRenderPass=null;for(let i=0;i<renderPasses.length;i++){const renderPass=renderPasses[i];const renderTarget=renderPass.renderTarget;const thisTexture=renderTarget==null?void 0:renderTarget.colorBuffer;if(thisTexture!=null&&thisTexture.cubemap){if(lastCubeTexture===thisTexture){const count=lastCubeRenderPass.colorArrayOps.length;for(let j=0;j<count;j++){lastCubeRenderPass.colorArrayOps[j].mipmaps=false;}}lastCubeTexture=renderTarget.colorBuffer;lastCubeRenderPass=renderPass;}else if(renderPass.requiresCubemaps){lastCubeTexture=null;lastCubeRenderPass=null;}}renderTargetMap.clear();}render(device){this.compile();const renderPasses=this.renderPasses;for(let i=0;i<renderPasses.length;i++){renderPasses[i].render();}}constructor(){this.renderPasses=[];this.renderTargetMap=new Map;}}class AreaLightCacheEntry{destroy(){var _this$texture,_this$texture2;(_this$texture=this.texture0)==null||_this$texture.destroy();(_this$texture2=this.texture1)==null||_this$texture2.destroy();}constructor(texture0,texture1){this.texture0=texture0;this.texture1=texture1;}}const deviceCache=new DeviceCache;class AreaLightLuts{static createTexture(device,format,size,postfix=""){const tex=new Texture(device,{name:`AreaLightLUT${postfix}`,width:size,height:size,format:format,addressU:ADDRESS_CLAMP_TO_EDGE,addressV:ADDRESS_CLAMP_TO_EDGE,type:TEXTURETYPE_DEFAULT,magFilter:FILTER_LINEAR,minFilter:FILTER_NEAREST,anisotropy:1,mipmaps:false});return tex}static applyTextures(device,texture1,texture2){deviceCache.remove(device);deviceCache.get(device,()=>{return new AreaLightCacheEntry(texture1,texture1===texture2?null:texture2)});device.scope.resolve("areaLightsLutTex1").setValue(texture1);device.scope.resolve("areaLightsLutTex2").setValue(texture2);}static createPlaceholder(device){const texture=AreaLightLuts.createTexture(device,device.areaLightLutFormat,2,"placeholder");const pixels=texture.lock();pixels.fill(0);texture.unlock();AreaLightLuts.applyTextures(device,texture,texture);}static set(device,ltcMat1,ltcMat2){function buildTexture(device,data,format){const texture=AreaLightLuts.createTexture(device,format,64);texture.lock().set(data);texture.unlock();return texture}function offsetScale(data,offset,scale){const count=data.length;const ret=new Float32Array(count);for(let i=0;i<count;i++){const n=i%4;ret[i]=(data[i]+offset[n])*scale[n];}return ret}function convertToHalfFloat(data){const count=data.length;const ret=new Uint16Array(count);const float2Half=FloatPacking.float2Half;for(let i=0;i<count;i++){ret[i]=float2Half(data[i]);}return ret}function convertToUint(data){const count=data.length;const ret=new Uint8ClampedArray(count);for(let i=0;i<count;i++){ret[i]=data[i]*255;}return ret}const srcData1=ltcMat1;const srcData2=ltcMat2;let data1,data2;const format=device.areaLightLutFormat;if(format===PIXELFORMAT_RGBA32F){data1=srcData1;data2=srcData2;}else if(format===PIXELFORMAT_RGBA16F){data1=convertToHalfFloat(srcData1);data2=convertToHalfFloat(srcData2);}else {const o1=[0,.2976,.01381,0];const s1=[.999,3.08737,1.6546,.603249];const o2=[-.306897,0,0,0];const s2=[1.442787,1,1,1];data1=convertToUint(offsetScale(srcData1,o1,s1));data2=convertToUint(offsetScale(srcData2,o2,s2));}const tex1=buildTexture(device,data1,format);const tex2=buildTexture(device,data2,format);AreaLightLuts.applyTextures(device,tex1,tex2);}}const DEFAULT_LOCALE="en-US";const DEFAULT_LOCALE_FALLBACKS={"en":"en-US","es":"en-ES","zh":"zh-CN","zh-HK":"zh-TW","zh-TW":"zh-HK","zh-MO":"zh-HK","fr":"fr-FR","de":"de-DE","it":"it-IT","ru":"ru-RU","ja":"ja-JP"};const PLURALS={};function definePluralFn(locales,fn){for(let i=0,len=locales.length;i<len;i++){PLURALS[locales[i]]=fn;}}function getLang(locale){const idx=locale.indexOf("-");if(idx!==-1){return locale.substring(0,idx)}return locale}function replaceLang(locale,desiredLang){const idx=locale.indexOf("-");if(idx!==-1){return desiredLang+locale.substring(idx)}return desiredLang}function findAvailableLocale(desiredLocale,availableLocales){if(availableLocales[desiredLocale]){return desiredLocale}let fallback=DEFAULT_LOCALE_FALLBACKS[desiredLocale];if(fallback&&availableLocales[fallback]){return fallback}const lang=getLang(desiredLocale);fallback=DEFAULT_LOCALE_FALLBACKS[lang];if(availableLocales[fallback]){return fallback}if(availableLocales[lang]){return lang}return DEFAULT_LOCALE}definePluralFn(["ja","ko","th","vi","zh","id"],n=>{return 0});definePluralFn(["fa","hi"],n=>{if(n>=0&&n<=1){return 0}return 1});definePluralFn(["fr","pt"],n=>{if(n>=0&&n<2){return 0}return 1});definePluralFn(["da"],n=>{if(n===1||!Number.isInteger(n)&&n>=0&&n<=1){return 0}return 1});definePluralFn(["de","en","it","el","es","tr","fi","sv","nb","no","ur"],n=>{if(n===1){return 0}return 1});definePluralFn(["ru","uk"],n=>{if(Number.isInteger(n)){const mod10=n%10;const mod100=n%100;if(mod10===1&&mod100!==11){return 0}else if(mod10>=2&&mod10<=4&&(mod100<12||mod100>14)){return 1}else if(mod10===0||mod10>=5&&mod10<=9||mod100>=11&&mod100<=14){return 2}}return 3});definePluralFn(["pl"],n=>{if(Number.isInteger(n)){if(n===1){return 0}const mod10=n%10;const mod100=n%100;if(mod10>=2&&mod10<=4&&(mod100<12||mod100>14)){return 1}else if(mod10>=0&&mod10<=1||mod10>=5&&mod10<=9||mod100>=12&&mod100<=14){return 2}}return 3});definePluralFn(["ar"],n=>{if(n===0){return 0}else if(n===1){return 1}else if(n===2){return 2}if(Number.isInteger(n)){const mod100=n%100;if(mod100>=3&&mod100<=10){return 3}else if(mod100>=11&&mod100<=99){return 4}}return 5});const DEFAULT_PLURAL_FN=PLURALS[getLang(DEFAULT_LOCALE)];function getPluralFn(lang){return PLURALS[lang]||DEFAULT_PLURAL_FN}const ABSOLUTE_URL=new RegExp("^"+"\\s*"+"(?:"+"(?:"+"[a-z]+[a-z0-9\\-+.]*"+":"+")?"+"//"+"|"+"data:"+"|blob:"+")","i");const ASSET_ANIMATION="animation";const ASSET_AUDIO="audio";const ASSET_IMAGE="image";const ASSET_JSON="json";const ASSET_MODEL="model";const ASSET_MATERIAL="material";const ASSET_TEXT="text";const ASSET_TEXTURE="texture";const ASSET_TEXTUREATLAS="textureatlas";const ASSET_CUBEMAP="cubemap";const ASSET_SHADER="shader";const ASSET_CSS="css";const ASSET_HTML="html";const ASSET_SCRIPT="script";const ASSET_CONTAINER="container";class AssetFile{equals(other){return this.url===other.url&&this.filename===other.filename&&this.hash===other.hash&&this.size===other.size&&this.opt===other.opt&&this.contents===other.contents}constructor(url="",filename="",hash=null,size=null,opt=null,contents=null){this.url=url;this.filename=filename;this.hash=hash;this.size=size;this.opt=opt;this.contents=contents;}}let assetIdCounter=-1;const VARIANT_SUPPORT={pvr:"extCompressedTexturePVRTC",dxt:"extCompressedTextureS3TC",etc2:"extCompressedTextureETC",etc1:"extCompressedTextureETC1",basis:"canvas"};const VARIANT_DEFAULT_PRIORITY=["pvr","dxt","etc2","etc1","basis"];class Asset extends EventHandler{set id(value){this._id=value;}get id(){return this._id}set name(value){if(this._name===value){return}const old=this._name;this._name=value;this.fire("name",this,this._name,old);}get name(){return this._name}set file(value){if(value&&value.variants&&["texture","textureatlas","bundle"].indexOf(this.type)!==-1){var _this$registry;const app=((_this$registry=this.registry)==null||(_this$registry=_this$registry._loader)==null?void 0:_this$registry._app)||getApplication();const device=app==null?void 0:app.graphicsDevice;if(device){for(let i=0,len=VARIANT_DEFAULT_PRIORITY.length;i<len;i++){const variant=VARIANT_DEFAULT_PRIORITY[i];if(value.variants[variant]&&device[VARIANT_SUPPORT[variant]]){value=value.variants[variant];break}if(app.enableBundles){const bundles=app.bundles.listBundlesForAsset(this);if(bundles&&bundles.find(b=>{var _b$file;return b==null||(_b$file=b.file)==null?void 0:_b$file.variants[variant]})){break}}}}}const oldFile=this._file;const newFile=value?new AssetFile(value.url,value.filename,value.hash,value.size,value.opt,value.contents):null;if(!!newFile!==!!oldFile||newFile&&!newFile.equals(oldFile)){this._file=newFile;this.fire("change",this,"file",newFile,oldFile);this.reload();}}get file(){return this._file}set data(value){const old=this._data;this._data=value;if(value!==old){this.fire("change",this,"data",value,old);if(this.loaded){this.registry._loader.patch(this,this.registry);}}}get data(){return this._data}set resource(value){const _old=this._resources[0];this._resources[0]=value;this.fire("change",this,"resource",value,_old);}get resource(){return this._resources[0]}set resources(value){const _old=this._resources;this._resources=value;this.fire("change",this,"resources",value,_old);}get resources(){return this._resources}set preload(value){value=!!value;if(this._preload===value){return}this._preload=value;if(this._preload&&!this.loaded&&!this.loading&&this.registry){this.registry.load(this);}}get preload(){return this._preload}set loadFaces(value){value=!!value;if(!this.hasOwnProperty("_loadFaces")||value!==this._loadFaces){this._loadFaces=value;if(this.loaded){this.registry._loader.patch(this,this.registry);}}}get loadFaces(){return this._loadFaces}getFileUrl(){const file=this.file;if(!file||!file.url){return null}let url=file.url;if(this.registry&&this.registry.prefix&&!ABSOLUTE_URL.test(url)){url=this.registry.prefix+url;}if(this.type!=="script"&&file.hash){const separator=url.indexOf("?")!==-1?"&":"?";url+=`${separator}t=${file.hash}`;}return url}getAbsoluteUrl(relativePath){if(relativePath.startsWith("blob:")||relativePath.startsWith("data:")){return relativePath}const base=path.getDirectory(this.file.url);return path.join(base,relativePath)}getLocalizedAssetId(locale){locale=findAvailableLocale(locale,this._i18n);return this._i18n[locale]||null}addLocalizedAssetId(locale,assetId){this._i18n[locale]=assetId;this.fire("add:localized",locale,assetId);}removeLocalizedAssetId(locale){const assetId=this._i18n[locale];if(assetId){delete this._i18n[locale];this.fire("remove:localized",locale,assetId);}}ready(callback,scope){scope=scope||this;if(this.loaded){callback.call(scope,this);}else {this.once("load",asset=>{callback.call(scope,asset);});}}reload(){if(this.loaded){this.loaded=false;this.registry.load(this);}}unload(){if(!this.loaded&&this._resources.length===0){return}this.fire("unload",this);this.registry.fire(`unload:${this.id}`,this);const old=this._resources;if(this.urlObject){URL.revokeObjectURL(this.urlObject);this.urlObject=null;}this.resources=[];this.loaded=false;if(this.file){this.registry._loader.clearCache(this.getFileUrl(),this.type);}for(let i=0;i<old.length;++i){const resource=old[i];if(resource&&resource.destroy){resource.destroy();}}}static fetchArrayBuffer(loadUrl,callback,asset,maxRetries=0){var _asset$file;if(asset!=null&&(_asset$file=asset.file)!=null&&_asset$file.contents){setTimeout(()=>{callback(null,asset.file.contents);});}else {http.get(loadUrl,{cache:true,responseType:"arraybuffer",retry:maxRetries>0,maxRetries:maxRetries},callback);}}constructor(name,type,file,data,options){super();this._id=assetIdCounter--;this._name=name||"";this.type=type;this.tags=new Tags(this);this._preload=false;this._file=null;this._data=data||{};this.options=options||{};this._resources=[];this.urlObject=null;this._i18n={};this.loaded=false;this.loading=false;this.registry=null;if(file)this.file=file;}}Asset.EVENT_LOAD="load";Asset.EVENT_UNLOAD="unload";Asset.EVENT_REMOVE="remove";Asset.EVENT_ERROR="error";Asset.EVENT_CHANGE="change";Asset.EVENT_ADDLOCALIZED="add:localized";Asset.EVENT_REMOVELOCALIZED="remove:localized";class TagsCache{addItem(item){const tags=item.tags._list;for(const tag of tags){this.add(tag,item);}}removeItem(item){const tags=item.tags._list;for(const tag of tags){this.remove(tag,item);}}add(tag,item){if(this._index[tag]&&this._index[tag].list.indexOf(item)!==-1){return}if(!this._index[tag]){this._index[tag]={list:[]};if(this._key){this._index[tag].keys={};}}this._index[tag].list.push(item);if(this._key){this._index[tag].keys[item[this._key]]=item;}}remove(tag,item){if(!this._index[tag]){return}if(this._key){if(!this._index[tag].keys[item[this._key]]){return}}const ind=this._index[tag].list.indexOf(item);if(ind===-1){return}this._index[tag].list.splice(ind,1);if(this._key){delete this._index[tag].keys[item[this._key]];}if(this._index[tag].list.length===0){delete this._index[tag];}}find(args){const index={};const items=[];let item,tag,tags,tagsRest,missingIndex;const sort=(a,b)=>{return this._index[a].list.length-this._index[b].list.length};for(let i=0;i<args.length;i++){tag=args[i];if(tag instanceof Array){if(tag.length===0){continue}if(tag.length===1){tag=tag[0];}else {missingIndex=false;for(let t=0;t<tag.length;t++){if(!this._index[tag[t]]){missingIndex=true;break}}if(missingIndex){continue}tags=tag.slice(0).sort(sort);tagsRest=tags.slice(1);if(tagsRest.length===1){tagsRest=tagsRest[0];}for(let n=0;n<this._index[tags[0]].list.length;n++){item=this._index[tags[0]].list[n];if((this._key?!index[item[this._key]]:items.indexOf(item)===-1)&&item.tags.has(tagsRest)){if(this._key){index[item[this._key]]=true;}items.push(item);}}continue}}if(tag&&typeof tag==="string"&&this._index[tag]){for(let n=0;n<this._index[tag].list.length;n++){item=this._index[tag].list[n];if(this._key){if(!index[item[this._key]]){index[item[this._key]]=true;items.push(item);}}else if(items.indexOf(item)===-1){items.push(item);}}}}return items}constructor(key=null){this._index={};this._key=void 0;this._key=key;}}class AssetRegistry extends EventHandler{list(filters={}){const assets=Array.from(this._assets);if(filters.preload!==undefined){return assets.filter(asset=>asset.preload===filters.preload)}return assets}add(asset){var _asset$file,_asset$file2;if(this._assets.has(asset))return;this._assets.add(asset);this._idToAsset.set(asset.id,asset);if((_asset$file=asset.file)!=null&&_asset$file.url){this._urlToAsset.set(asset.file.url,asset);}if(!this._nameToAsset.has(asset.name)){this._nameToAsset.set(asset.name,new Set);}this._nameToAsset.get(asset.name).add(asset);asset.on("name",this._onNameChange,this);asset.registry=this;this._tags.addItem(asset);asset.tags.on("add",this._onTagAdd,this);asset.tags.on("remove",this._onTagRemove,this);this.fire("add",asset);this.fire(`add:${asset.id}`,asset);if((_asset$file2=asset.file)!=null&&_asset$file2.url){this.fire(`add:url:${asset.file.url}`,asset);}if(asset.preload){this.load(asset);}}remove(asset){var _asset$file3,_asset$file4;if(!this._assets.has(asset))return false;this._assets.delete(asset);this._idToAsset.delete(asset.id);if((_asset$file3=asset.file)!=null&&_asset$file3.url){this._urlToAsset.delete(asset.file.url);}asset.off("name",this._onNameChange,this);if(this._nameToAsset.has(asset.name)){const items=this._nameToAsset.get(asset.name);items.delete(asset);if(items.size===0){this._nameToAsset.delete(asset.name);}}this._tags.removeItem(asset);asset.tags.off("add",this._onTagAdd,this);asset.tags.off("remove",this._onTagRemove,this);asset.fire("remove",asset);this.fire("remove",asset);this.fire(`remove:${asset.id}`,asset);if((_asset$file4=asset.file)!=null&&_asset$file4.url){this.fire(`remove:url:${asset.file.url}`,asset);}return true}get(id){return this._idToAsset.get(Number(id))}getByUrl(url){return this._urlToAsset.get(url)}load(asset,options){if((asset.loading||asset.loaded)&&!(options!=null&&options.force)){return}const file=asset.file;const _fireLoad=()=>{this.fire("load",asset);this.fire(`load:${asset.id}`,asset);if(file&&file.url){this.fire(`load:url:${file.url}`,asset);}asset.fire("load",asset);};const _opened=resource=>{if(resource instanceof Array){asset.resources=resource;}else {asset.resource=resource;}this._loader.patch(asset,this);if(asset.type==="bundle"){const assetIds=asset.data.assets;for(let i=0;i<assetIds.length;i++){const assetInBundle=this._idToAsset.get(assetIds[i]);if(assetInBundle&&!assetInBundle.loaded){this.load(assetInBundle,{force:true});}}if(asset.resource.loaded){_fireLoad();}else {this.fire("load:start",asset);this.fire(`load:start:${asset.id}`,asset);if(file&&file.url){this.fire(`load:start:url:${file.url}`,asset);}asset.fire("load:start",asset);asset.resource.on("load",_fireLoad);}}else {_fireLoad();}};const _loaded=(err,resource,extra)=>{asset.loaded=true;asset.loading=false;if(err){this.fire("error",err,asset);this.fire(`error:${asset.id}`,err,asset);asset.fire("error",err,asset);}else {if(!script.legacy&&asset.type==="script"){const handler=this._loader.getHandler("script");if(handler._cache[asset.id]&&handler._cache[asset.id].parentNode===document.head){document.head.removeChild(handler._cache[asset.id]);}handler._cache[asset.id]=extra;}_opened(resource);}};if(file||asset.type==="cubemap"){this.fire("load:start",asset);this.fire(`load:${asset.id}:start`,asset);asset.loading=true;const fileUrl=asset.getFileUrl();if(asset.type==="bundle"){const assetIds=asset.data.assets;for(let i=0;i<assetIds.length;i++){const assetInBundle=this._idToAsset.get(assetIds[i]);if(!assetInBundle){continue}if(assetInBundle.loaded||assetInBundle.resource||assetInBundle.loading){continue}assetInBundle.loading=true;}}this._loader.load(fileUrl,asset.type,_loaded,asset,options);}else {const resource=this._loader.open(asset.type,asset.data);asset.loaded=true;_opened(resource);}}loadFromUrl(url,type,callback){this.loadFromUrlAndFilename(url,null,type,callback);}loadFromUrlAndFilename(url,filename,type,callback){const name=path.getBasename(filename||url);const file={filename:filename||name,url:url};let asset=this.getByUrl(url);if(!asset){asset=new Asset(name,type,file);this.add(asset);}else if(asset.loaded){callback(asset.loadFromUrlError||null,asset);return}const startLoad=asset=>{asset.once("load",loadedAsset=>{if(type==="material"){this._loadTextures(loadedAsset,(err,textures)=>{callback(err,loadedAsset);});}else {callback(null,loadedAsset);}});asset.once("error",err=>{if(err){this.loadFromUrlError=err;}callback(err,asset);});this.load(asset);};if(asset.resource){callback(null,asset);}else if(type==="model"){this._loadModel(asset,startLoad);}else {startLoad(asset);}}_loadModel(modelAsset,continuation){const url=modelAsset.getFileUrl();const ext=path.getExtension(url);if(ext===".json"||ext===".glb"){const dir=path.getDirectory(url);const basename=path.getBasename(url);const mappingUrl=path.join(dir,basename.replace(ext,".mapping.json"));this._loader.load(mappingUrl,"json",(err,data)=>{if(err){modelAsset.data={mapping:[]};continuation(modelAsset);}else {this._loadMaterials(modelAsset,data,(e,materials)=>{modelAsset.data=data;continuation(modelAsset);});}});}else {continuation(modelAsset);}}_loadMaterials(modelAsset,mapping,callback){const materials=[];let count=0;const onMaterialLoaded=(err,materialAsset)=>{this._loadTextures(materialAsset,(err,textures)=>{materials.push(materialAsset);if(materials.length===count){callback(null,materials);}});};for(let i=0;i<mapping.mapping.length;i++){const path=mapping.mapping[i].path;if(path){count++;const url=modelAsset.getAbsoluteUrl(path);this.loadFromUrl(url,"material",onMaterialLoaded);}}if(count===0){callback(null,materials);}}_loadTextures(materialAsset,callback){const textures=[];let count=0;const data=materialAsset.data;if(data.mappingFormat!=="path"){callback(null,textures);return}const onTextureLoaded=(err,texture)=>{if(err)console.error(err);textures.push(texture);if(textures.length===count){callback(null,textures);}};const texParams=standardMaterialTextureParameters;for(let i=0;i<texParams.length;i++){const path=data[texParams[i]];if(path&&typeof path==="string"){count++;const url=materialAsset.getAbsoluteUrl(path);this.loadFromUrl(url,"texture",onTextureLoaded);}}if(count===0){callback(null,textures);}}_onTagAdd(tag,asset){this._tags.add(tag,asset);}_onTagRemove(tag,asset){this._tags.remove(tag,asset);}_onNameChange(asset,name,nameOld){if(this._nameToAsset.has(nameOld)){const items=this._nameToAsset.get(nameOld);items.delete(asset);if(items.size===0){this._nameToAsset.delete(nameOld);}}if(!this._nameToAsset.has(asset.name)){this._nameToAsset.set(asset.name,new Set);}this._nameToAsset.get(asset.name).add(asset);}findByTag(){return this._tags.find(arguments)}filter(callback){return Array.from(this._assets).filter(asset=>callback(asset))}find(name,type){const items=this._nameToAsset.get(name);if(!items)return null;for(const asset of items){if(!type||asset.type===type){return asset}}return null}findAll(name,type){const items=this._nameToAsset.get(name);if(!items)return [];const results=Array.from(items);if(!type)return results;return results.filter(asset=>asset.type===type)}constructor(loader){super();this._assets=new Set;this._idToAsset=new Map;this._urlToAsset=new Map;this._nameToAsset=new Map;this._tags=new TagsCache("_id");this.prefix=null;this.bundles=null;this._loader=loader;}}AssetRegistry.EVENT_LOAD="load";AssetRegistry.EVENT_ADD="add";AssetRegistry.EVENT_REMOVE="remove";AssetRegistry.EVENT_ERROR="error";class BundleRegistry{_onAssetAdd(asset){if(asset.type==="bundle"){this._idToBundle.set(asset.id,asset);this._assets.on(`load:start:${asset.id}`,this._onBundleLoadStart,this);this._assets.on(`load:${asset.id}`,this._onBundleLoad,this);this._assets.on(`error:${asset.id}`,this._onBundleError,this);const assetIds=asset.data.assets;for(let i=0;i<assetIds.length;i++){this._indexAssetInBundle(assetIds[i],asset);}}else {if(this._assetToBundles.has(asset.id)){this._indexAssetFileUrls(asset);}}}_unbindAssetEvents(id){this._assets.off(`load:start:${id}`,this._onBundleLoadStart,this);this._assets.off(`load:${id}`,this._onBundleLoad,this);this._assets.off(`error:${id}`,this._onBundleError,this);}_indexAssetInBundle(id,bundle){let bundles=this._assetToBundles.get(id);if(!bundles){bundles=new Set;this._assetToBundles.set(id,bundles);}bundles.add(bundle);const asset=this._assets.get(id);if(asset)this._indexAssetFileUrls(asset);}_indexAssetFileUrls(asset){const urls=this._getAssetFileUrls(asset);if(!urls)return;for(let i=0;i<urls.length;i++){const bundles=this._assetToBundles.get(asset.id);if(!bundles)continue;this._urlsToBundles.set(urls[i],bundles);}}_getAssetFileUrls(asset){let url=asset.getFileUrl();if(!url)return null;url=url.split("?")[0];const urls=[url];if(asset.type==="font"){const numFiles=asset.data.info.maps.length;for(let i=1;i<numFiles;i++){urls.push(url.replace(".png",`${i}.png`));}}return urls}_onAssetRemove(asset){if(asset.type==="bundle"){this._idToBundle.delete(asset.id);this._unbindAssetEvents(asset.id);const assetIds=asset.data.assets;for(let i=0;i<assetIds.length;i++){const bundles=this._assetToBundles.get(assetIds[i]);if(!bundles)continue;bundles.delete(asset);if(bundles.size===0){this._assetToBundles.delete(assetIds[i]);for(const[url,otherBundles]of this._urlsToBundles){if(otherBundles!==bundles){continue}this._urlsToBundles.delete(url);}}}this._onBundleError(`Bundle ${asset.id} was removed`);}else {const bundles=this._assetToBundles.get(asset.id);if(!bundles)return;this._assetToBundles.delete(asset.id);const urls=this._getAssetFileUrls(asset);if(!urls)return;for(let i=0;i<urls.length;i++){this._urlsToBundles.delete(urls[i]);}}}_onBundleLoadStart(asset){asset.resource.on("add",(url,data)=>{const callbacks=this._fileRequests.get(url);if(!callbacks)return;for(let i=0;i<callbacks.length;i++){callbacks[i](null,data);}this._fileRequests.delete(url);});}_onBundleLoad(asset){if(!asset.resource){this._onBundleError(`Bundle ${asset.id} failed to load`);return}if(!this._fileRequests){return}for(const[url,requests]of this._fileRequests){const bundles=this._urlsToBundles.get(url);if(!bundles||!bundles.has(asset))continue;const decodedUrl=decodeURIComponent(url);let err,data;if(asset.resource.has(decodedUrl)){data=asset.resource.get(decodedUrl);}else if(asset.resource.loaded){err=`Bundle ${asset.id} does not contain URL ${url}`;}else {continue}for(let i=0;i<requests.length;i++){requests[i](err,err||data);}this._fileRequests.delete(url);}}_onBundleError(err){for(const[url,requests]of this._fileRequests){const bundle=this._findLoadedOrLoadingBundleForUrl(url);if(!bundle){for(let i=0;i<requests.length;i++){requests[i](err);}this._fileRequests.delete(url);}}}_findLoadedOrLoadingBundleForUrl(url){const bundles=this._urlsToBundles.get(url);if(!bundles)return null;let candidate=null;for(const bundle of bundles){if(bundle.loaded&&bundle.resource){return bundle}else if(bundle.loading){candidate=bundle;}}return candidate}listBundlesForAsset(asset){const bundles=this._assetToBundles.get(asset.id);if(bundles)return Array.from(bundles);return null}list(){return Array.from(this._idToBundle.values())}hasUrl(url){return this._urlsToBundles.has(url)}urlIsLoadedOrLoading(url){return !!this._findLoadedOrLoadingBundleForUrl(url)}loadUrl(url,callback){const bundle=this._findLoadedOrLoadingBundleForUrl(url);if(!bundle){callback(`URL ${url} not found in any bundles`);return}if(bundle.loaded){const decodedUrl=decodeURIComponent(url);if(bundle.resource.has(decodedUrl)){callback(null,bundle.resource.get(decodedUrl));return}else if(bundle.resource.loaded){callback(`Bundle ${bundle.id} does not contain URL ${url}`);return}}let callbacks=this._fileRequests.get(url);if(!callbacks){callbacks=[];this._fileRequests.set(url,callbacks);}callbacks.push(callback);}destroy(){this._assets.off("add",this._onAssetAdd,this);this._assets.off("remove",this._onAssetRemove,this);for(const id of this._idToBundle.keys()){this._unbindAssetEvents(id);}this._assets=null;this._idToBundle.clear();this._idToBundle=null;this._assetToBundles.clear();this._assetToBundles=null;this._urlsToBundles.clear();this._urlsToBundles=null;this._fileRequests.clear();this._fileRequests=null;}constructor(assets){this._idToBundle=new Map;this._assetToBundles=new Map;this._urlsToBundles=new Map;this._fileRequests=new Map;this._assets=assets;this._assets.bundles=this;this._assets.on("add",this._onAssetAdd,this);this._assets.on("remove",this._onAssetRemove,this);}}class ComponentSystemRegistry extends EventHandler{add(system){const id=system.id;if(this[id]){throw new Error(`ComponentSystem name '${id}' already registered or not allowed`)}this[id]=system;this.list.push(system);}remove(system){const id=system.id;if(!this[id]){throw new Error(`No ComponentSystem named '${id}' registered`)}delete this[id];const index=this.list.indexOf(this[id]);if(index!==-1){this.list.splice(index,1);}}destroy(){this.off();for(let i=0;i<this.list.length;i++){this.list[i].destroy();}}constructor(){super();this.anim=void 0;this.animation=void 0;this.audiolistener=void 0;this.audiosource=void 0;this.button=void 0;this.camera=void 0;this.collision=void 0;this.element=void 0;this.joint=void 0;this.layoutchild=void 0;this.layoutgroup=void 0;this.light=void 0;this.model=void 0;this.particlesystem=void 0;this.render=void 0;this.rigidbody=void 0;this.screen=void 0;this.script=void 0;this.scrollbar=void 0;this.scrollview=void 0;this.sound=void 0;this.sprite=void 0;this.zone=void 0;this.list=[];}}class Bundle extends EventHandler{addFile(url,data){if(this._index.has(url)){return}this._index.set(url,data);this.fire("add",url,data);}has(url){return this._index.has(url)}get(url){return this._index.get(url)||null}destroy(){this._index.clear();}set loaded(value){if(!value||this._loaded){return}this._loaded=true;this.fire("load");}get loaded(){return this._loaded}constructor(...args){super(...args);this._index=new Map;this._loaded=false;}}Bundle.EVENT_ADD="add";Bundle.EVENT_LOAD="load";class Untar extends EventHandler{pump(done,value){if(done){this.fire("done");return null}this.bytesReceived+=value.byteLength;const data=new Uint8Array(this.data.length+value.length);data.set(this.data);data.set(value,this.data.length);this.data=data;while(this.readFile());return this.reader.read().then(res=>{this.pump(res.done,res.value);}).catch(err=>{this.fire("error",err);})}readFile(){if(!this.headerRead&&this.bytesReceived>this.bytesRead+this.headerSize){var _this$decoder;this.headerRead=true;const view=new DataView(this.data.buffer,this.bytesRead,this.headerSize);(_this$decoder=this.decoder)!=null?_this$decoder:this.decoder=new TextDecoder("windows-1252");const headers=this.decoder.decode(view);this.fileName=headers.substring(0,100).replace(/\0/g,"");this.fileSize=parseInt(headers.substring(124,136),8);this.fileType=headers.substring(156,157);this.ustarFormat=headers.substring(257,263);if(this.ustarFormat.indexOf("ustar")!==-1){const prefix=headers.substring(345,500).replace(/\0/g,"");if(prefix.length>0){this.fileName=prefix.trim()+this.fileName.trim();}}this.bytesRead+=512;}if(this.headerRead){if(this.bytesReceived<this.bytesRead+this.fileSize){return false}if(this.fileType===""||this.fileType==="0"){const dataView=new DataView(this.data.buffer,this.bytesRead,this.fileSize);const file={name:this.prefix+this.fileName,size:this.fileSize,data:dataView};this.fire("file",file);}this.bytesRead+=this.fileSize;this.headerRead=false;const bytesRemained=this.bytesRead%this.paddingSize;if(bytesRemained!==0){this.bytesRead+=this.paddingSize-bytesRemained;}return true}return false}constructor(fetchPromise,assetsPrefix=""){super();this.headerSize=512;this.paddingSize=512;this.bytesRead=0;this.bytesReceived=0;this.headerRead=false;this.reader=null;this.data=new Uint8Array(0);this.decoder=null;this.prefix="";this.fileName="";this.fileSize=0;this.fileType="";this.ustarFormat="";this.prefix=assetsPrefix||"";this.reader=fetchPromise.body.getReader();this.reader.read().then(res=>{this.pump(res.done,res.value);}).catch(err=>{this.fire("error",err);});}}class ResourceHandler{set maxRetries(value){this._maxRetries=value;}get maxRetries(){return this._maxRetries}load(url,callback,asset){}open(url,data,asset){return data}patch(asset,assets){}constructor(app,handlerType){this.handlerType="";this._app=void 0;this._maxRetries=0;this._app=app;this.handlerType=handlerType;}}class BundleHandler extends ResourceHandler{_fetchRetries(url,options,retries=0){return new Promise((resolve,reject)=>{const tryFetch=()=>{fetch(url,options).then(resolve).catch(err=>{retries++;if(retries<this.maxRetries){tryFetch();}else {reject(err);}});};tryFetch();})}load(url,callback){if(typeof url==="string"){url={load:url,original:url};}this._fetchRetries(url.load,{mode:"cors",credentials:"include"},this.maxRetries).then(res=>{const bundle=new Bundle;callback(null,bundle);const untar=new Untar(res,this._assets.prefix);untar.on("file",file=>{bundle.addFile(file.name,file.data);});untar.on("done",()=>{bundle.loaded=true;});untar.on("error",err=>{callback(err);});}).catch(err=>{callback(err);});}open(url,bundle){return bundle}constructor(app){super(app,"bundle");this._assets=app.assets;}}class ResourceLoader{addHandler(type,handler){this._handlers[type]=handler;handler._loader=this;}removeHandler(type){delete this._handlers[type];}getHandler(type){return this._handlers[type]}static makeKey(url,type){return `${url}-${type}`}load(url,type,callback,asset,options){const handler=this._handlers[type];if(!handler){const err=`No resource handler for asset type: '${type}' when loading [${url}]`;callback(err);return}if(!url){this._loadNull(handler,callback,asset);return}const key=ResourceLoader.makeKey(url,type);if(this._cache[key]!==undefined){callback(null,this._cache[key]);}else if(this._requests[key]){this._requests[key].push(callback);}else {this._requests[key]=[callback];const self1=this;const handleLoad=function handleLoad(err,urlObj){if(err){self1._onFailure(key,err);return}if(urlObj.load instanceof DataView){if(handler.openBinary){if(!self1._requests[key]){return}try{const data=handler.openBinary(urlObj.load);self1._onSuccess(key,data);}catch(err){self1._onFailure(key,err);}return}urlObj.load=URL.createObjectURL(new Blob([urlObj.load]));if(asset){if(asset.urlObject){URL.revokeObjectURL(asset.urlObject);}asset.urlObject=urlObj.load;}}handler.load(urlObj,(err,data,extra)=>{if(!self1._requests[key]){return}if(err){self1._onFailure(key,err);return}try{self1._onSuccess(key,handler.open(urlObj.original,data,asset),extra);}catch(e){self1._onFailure(key,e);}},asset);};const normalizedUrl=url.split("?")[0];if(this._app.enableBundles&&this._app.bundles.hasUrl(normalizedUrl)&&!(options&&options.bundlesIgnore)){if(!this._app.bundles.urlIsLoadedOrLoading(normalizedUrl)){var _this$_app$assets;const bundles=this._app.bundles.listBundlesForAsset(asset);let bundle;if(options&&options.bundlesFilter){bundle=options.bundlesFilter(bundles);}if(!bundle){bundles==null||bundles.sort((a,b)=>{return a.file.size-b.file.size});bundle=bundles==null?void 0:bundles[0];}if(bundle)(_this$_app$assets=this._app.assets)==null||_this$_app$assets.load(bundle);}this._app.bundles.loadUrl(normalizedUrl,(err,fileUrlFromBundle)=>{handleLoad(err,{load:fileUrlFromBundle,original:normalizedUrl});});}else {handleLoad(null,{load:url,original:asset&&asset.file.filename||url});}}}_loadNull(handler,callback,asset){const onLoad=function onLoad(err,data,extra){if(err){callback(err);}else {try{callback(null,handler.open(null,data,asset),extra);}catch(e){callback(e);}}};handler.load(null,onLoad,asset);}_onSuccess(key,result,extra){if(result!==null){this._cache[key]=result;}else {delete this._cache[key];}for(let i=0;i<this._requests[key].length;i++){this._requests[key][i](null,result,extra);}delete this._requests[key];}_onFailure(key,err){console.error(err);if(this._requests[key]){for(let i=0;i<this._requests[key].length;i++){this._requests[key][i](err);}delete this._requests[key];}}open(type,data){const handler=this._handlers[type];if(!handler){console.warn(`No resource handler found for: ${type}`);return data}return handler.open(null,data)}patch(asset,assets){const handler=this._handlers[asset.type];if(!handler){console.warn(`No resource handler found for: ${asset.type}`);return}if(handler.patch){handler.patch(asset,assets);}}clearCache(url,type){const key=ResourceLoader.makeKey(url,type);delete this._cache[key];}getFromCache(url,type){const key=ResourceLoader.makeKey(url,type);if(this._cache[key]){return this._cache[key]}return undefined}enableRetry(maxRetries=5){maxRetries=Math.max(0,maxRetries)||0;for(const key in this._handlers){this._handlers[key].maxRetries=maxRetries;}}disableRetry(){for(const key in this._handlers){this._handlers[key].maxRetries=0;}}destroy(){this._handlers={};this._requests={};this._cache={};}constructor(app){this._handlers={};this._requests={};this._cache={};this._app=app;}}class I18nParser{_validate(data){if(!data.header){throw new Error('pc.I18n#addData: Missing "header" field')}if(!data.header.version){throw new Error('pc.I18n#addData: Missing "header.version" field')}if(data.header.version!==1){throw new Error('pc.I18n#addData: Invalid "header.version" field')}if(!data.data){throw new Error('pc.I18n#addData: Missing "data" field')}else if(!Array.isArray(data.data)){throw new Error('pc.I18n#addData: "data" field must be an array')}for(let i=0,len=data.data.length;i<len;i++){const entry=data.data[i];if(!entry.info){throw new Error(`pc.I18n#addData: missing "data[${i}].info" field`)}if(!entry.info.locale){throw new Error(`pc.I18n#addData: missing "data[${i}].info.locale" field`)}if(typeof entry.info.locale!=="string"){throw new Error(`pc.I18n#addData: "data[${i}].info.locale" must be a string`)}if(!entry.messages){throw new Error(`pc.I18n#addData: missing "data[${i}].messages" field`)}}}parse(data){return data.data}}class I18n extends EventHandler{set assets(value){const index={};for(let _i=0,len=value.length;_i<len;_i++){const id=value[_i]instanceof Asset?value[_i].id:value[_i];index[id]=true;}let i=this._assets.length;while(i--){const id=this._assets[i];if(!index[id]){this._app.assets.off(`add:${id}`,this._onAssetAdd,this);const asset=this._app.assets.get(id);if(asset){this._onAssetRemove(asset);}this._assets.splice(i,1);}}for(const id in index){const idNum=parseInt(id,10);if(this._assets.indexOf(idNum)!==-1)continue;this._assets.push(idNum);const asset=this._app.assets.get(idNum);if(!asset){this._app.assets.once(`add:${idNum}`,this._onAssetAdd,this);}else {this._onAssetAdd(asset);}}}get assets(){return this._assets}set locale(value){if(this._locale===value){return}let lang=getLang(value);if(lang==="in"){lang="id";value=replaceLang(value,lang);if(this._locale===value){return}}const old=this._locale;this._locale=value;this._lang=lang;this._pluralFn=getPluralFn(this._lang);this.fire("set:locale",value,old);}get locale(){return this._locale}static findAvailableLocale(desiredLocale,availableLocales){return findAvailableLocale(desiredLocale,availableLocales)}findAvailableLocale(desiredLocale){if(this._translations[desiredLocale]){return desiredLocale}const lang=getLang(desiredLocale);return this._findFallbackLocale(desiredLocale,lang)}getText(key,locale){let result=key;let lang;if(!locale){locale=this._locale;lang=this._lang;}let translations=this._translations[locale];if(!translations){if(!lang){lang=getLang(locale);}locale=this._findFallbackLocale(locale,lang);translations=this._translations[locale];}if(translations&&translations.hasOwnProperty(key)){result=translations[key];if(Array.isArray(result)){result=result[0];}if(result===null||result===undefined){result=key;}}return result}getPluralText(key,n,locale){let result=key;let lang;let pluralFn;if(!locale){locale=this._locale;lang=this._lang;pluralFn=this._pluralFn;}else {lang=getLang(locale);pluralFn=getPluralFn(lang);}let translations=this._translations[locale];if(!translations){locale=this._findFallbackLocale(locale,lang);lang=getLang(locale);pluralFn=getPluralFn(lang);translations=this._translations[locale];}if(translations&&translations[key]&&pluralFn){const index=pluralFn(n);result=translations[key][index];if(result===null||result===undefined){result=key;}}return result}addData(data){let parsed;try{parsed=this._parser.parse(data);}catch(err){console.error(err);return}for(let i=0,len=parsed.length;i<len;i++){const entry=parsed[i];const locale=entry.info.locale;const messages=entry.messages;if(!this._translations[locale]){this._translations[locale]={};const lang=getLang(locale);if(!this._availableLangs[lang]){this._availableLangs[lang]=locale;}}Object.assign(this._translations[locale],messages);this.fire("data:add",locale,messages);}}removeData(data){let parsed;try{parsed=this._parser.parse(data);}catch(err){console.error(err);return}for(let i=0,len=parsed.length;i<len;i++){const entry=parsed[i];const locale=entry.info.locale;const translations=this._translations[locale];if(!translations)continue;const messages=entry.messages;for(const key in messages){delete translations[key];}if(Object.keys(translations).length===0){delete this._translations[locale];delete this._availableLangs[getLang(locale)];}this.fire("data:remove",locale,messages);}}destroy(){this._translations=null;this._availableLangs=null;this._assets=null;this._parser=null;this.off();}_findFallbackLocale(locale,lang){let result=DEFAULT_LOCALE_FALLBACKS[locale];if(result&&this._translations[result]){return result}result=DEFAULT_LOCALE_FALLBACKS[lang];if(result&&this._translations[result]){return result}result=this._availableLangs[lang];if(result&&this._translations[result]){return result}return DEFAULT_LOCALE}_onAssetAdd(asset){asset.on("load",this._onAssetLoad,this);asset.on("change",this._onAssetChange,this);asset.on("remove",this._onAssetRemove,this);asset.on("unload",this._onAssetUnload,this);if(asset.resource){this._onAssetLoad(asset);}}_onAssetLoad(asset){this.addData(asset.resource);}_onAssetChange(asset){if(asset.resource){this.addData(asset.resource);}}_onAssetRemove(asset){asset.off("load",this._onAssetLoad,this);asset.off("change",this._onAssetChange,this);asset.off("remove",this._onAssetRemove,this);asset.off("unload",this._onAssetUnload,this);if(asset.resource){this.removeData(asset.resource);}this._app.assets.once(`add:${asset.id}`,this._onAssetAdd,this);}_onAssetUnload(asset){if(asset.resource){this.removeData(asset.resource);}}constructor(app){super();this.locale=DEFAULT_LOCALE;this._translations={};this._availableLangs={};this._app=app;this._assets=[];this._parser=new I18nParser;}}class ScriptRegistry extends EventHandler{destroy(){this.app=null;this.off();}addSchema(id,schema){if(!schema)return;this._scriptSchemas.set(id,schema);}getSchema(id){return this._scriptSchemas.get(id)}add(script){const scriptName=script.__name;if(this._scripts.hasOwnProperty(scriptName)){setTimeout(()=>{if(script.prototype.swap){const old=this._scripts[scriptName];const ind=this._list.indexOf(old);this._list[ind]=script;this._scripts[scriptName]=script;this.fire("swap",scriptName,script);this.fire(`swap:${scriptName}`,script);}else {console.warn(`script registry already has '${scriptName}' script, define 'swap' method for new script type to enable code hot swapping`);}});return false}this._scripts[scriptName]=script;this._list.push(script);this.fire("add",scriptName,script);this.fire(`add:${scriptName}`,script);setTimeout(()=>{if(!this._scripts.hasOwnProperty(scriptName)){return}if(!this.app||!this.app.systems||!this.app.systems.script){return}const components=this.app.systems.script._components;let attributes;const scriptInstances=[];const scriptInstancesInitialized=[];for(components.loopIndex=0;components.loopIndex<components.length;components.loopIndex++){const component=components.items[components.loopIndex];if(component._scriptsIndex[scriptName]&&component._scriptsIndex[scriptName].awaiting){if(component._scriptsData&&component._scriptsData[scriptName]){attributes=component._scriptsData[scriptName].attributes;}const scriptInstance=component.create(scriptName,{preloading:true,ind:component._scriptsIndex[scriptName].ind,attributes:attributes});if(scriptInstance){scriptInstances.push(scriptInstance);}for(const script of component.scripts){component.initializeAttributes(script);}}}for(let i=0;i<scriptInstances.length;i++){if(scriptInstances[i].enabled){scriptInstances[i]._initialized=true;scriptInstancesInitialized.push(scriptInstances[i]);if(scriptInstances[i].initialize){scriptInstances[i].initialize();}}}for(let i=0;i<scriptInstancesInitialized.length;i++){if(!scriptInstancesInitialized[i].enabled||scriptInstancesInitialized[i]._postInitialized){continue}scriptInstancesInitialized[i]._postInitialized=true;if(scriptInstancesInitialized[i].postInitialize){scriptInstancesInitialized[i].postInitialize();}}});return true}remove(nameOrType){let scriptType=nameOrType;let scriptName=nameOrType;if(typeof scriptName!=="string"){scriptName=scriptType.__name;}else {scriptType=this.get(scriptName);}if(this.get(scriptName)!==scriptType){return false}delete this._scripts[scriptName];const ind=this._list.indexOf(scriptType);this._list.splice(ind,1);this.fire("remove",scriptName,scriptType);this.fire(`remove:${scriptName}`,scriptType);return true}get(name){return this._scripts[name]||null}has(nameOrType){if(typeof nameOrType==="string"){return this._scripts.hasOwnProperty(nameOrType)}if(!nameOrType)return false;const scriptName=nameOrType.__name;return this._scripts[scriptName]===nameOrType}list(){return this._list}constructor(app){super();this._scripts={};this._list=[];this._scriptSchemas=new Map;this.app=app;}}const _enableList=[];class Entity extends GraphNode{addComponent(type,data){const system=this._app.systems[type];if(!system){return null}if(this.c[type]){return null}return system.addComponent(this,data)}removeComponent(type){const system=this._app.systems[type];if(!system){return}if(!this.c[type]){return}system.removeComponent(this);}findComponent(type){const entity=this.findOne(node=>{return node.c&&node.c[type]});return entity&&entity.c[type]}findComponents(type){const entities=this.find(node=>{return node.c&&node.c[type]});return entities.map(entity=>{return entity.c[type]})}findScript(nameOrType){const entity=this.findOne(node=>{var _node$c;return (_node$c=node.c)==null||(_node$c=_node$c.script)==null?void 0:_node$c.has(nameOrType)});return entity==null?void 0:entity.c.script.get(nameOrType)}findScripts(nameOrType){const entities=this.find(node=>{var _node$c2;return (_node$c2=node.c)==null||(_node$c2=_node$c2.script)==null?void 0:_node$c2.has(nameOrType)});return entities.map(entity=>entity.c.script.get(nameOrType))}getGuid(){if(!this._guid){this.setGuid(guid.create());}return this._guid}setGuid(guid){const index=this._app._entityIndex;if(this._guid){delete index[this._guid];}this._guid=guid;index[this._guid]=this;}_notifyHierarchyStateChanged(node,enabled){let enableFirst=false;if(node===this&&_enableList.length===0){enableFirst=true;}node._beingEnabled=true;node._onHierarchyStateChanged(enabled);if(node._onHierarchyStatePostChanged){_enableList.push(node);}const c=node._children;for(let i=0,len=c.length;i<len;i++){if(c[i]._enabled){this._notifyHierarchyStateChanged(c[i],enabled);}}node._beingEnabled=false;if(enableFirst){for(let i=0;i<_enableList.length;i++){_enableList[i]._onHierarchyStatePostChanged();}_enableList.length=0;}}_onHierarchyStateChanged(enabled){super._onHierarchyStateChanged(enabled);const components=this.c;for(const type in components){if(components.hasOwnProperty(type)){const component=components[type];if(component.enabled){if(enabled){component.onEnable();}else {component.onDisable();}}}}}_onHierarchyStatePostChanged(){const components=this.c;for(const type in components){if(components.hasOwnProperty(type)){components[type].onPostStateChange();}}}findByGuid(guid){if(this._guid===guid)return this;const e=this._app._entityIndex[guid];if(e&&(e===this||e.isDescendantOf(this))){return e}return null}destroy(){this._destroying=true;for(const name in this.c){this.c[name].enabled=false;}for(const name in this.c){this.c[name].system.removeComponent(this);}super.destroy();if(this._guid){delete this._app._entityIndex[this._guid];}this._destroying=false;}clone(){const duplicatedIdsMap={};const clone=this._cloneRecursively(duplicatedIdsMap);duplicatedIdsMap[this.getGuid()]=clone;resolveDuplicatedEntityReferenceProperties(this,this,clone,duplicatedIdsMap);return clone}_cloneRecursively(duplicatedIdsMap){const clone=new this.constructor(undefined,this._app);super._cloneInternal(clone);for(const type in this.c){const component=this.c[type];component.system.cloneComponent(this,clone);}for(let i=0;i<this._children.length;i++){const oldChild=this._children[i];if(oldChild instanceof Entity){const newChild=oldChild._cloneRecursively(duplicatedIdsMap);clone.addChild(newChild);duplicatedIdsMap[oldChild.getGuid()]=newChild;}}return clone}constructor(name,app=getApplication()){super(name);this.anim=void 0;this.animation=void 0;this.audiolistener=void 0;this.button=void 0;this.camera=void 0;this.collision=void 0;this.element=void 0;this.gsplat=void 0;this.layoutchild=void 0;this.layoutgroup=void 0;this.light=void 0;this.model=void 0;this.particlesystem=void 0;this.render=void 0;this.rigidbody=void 0;this.screen=void 0;this.script=void 0;this.scrollbar=void 0;this.scrollview=void 0;this.sound=void 0;this.sprite=void 0;this.c={};this._app=void 0;this._destroying=false;this._guid=null;this._template=false;this._app=app;}}Entity.EVENT_DESTROY="destroy";function resolveDuplicatedEntityReferenceProperties(oldSubtreeRoot,oldEntity,newEntity,duplicatedIdsMap){if(oldEntity instanceof Entity){const components=oldEntity.c;for(const componentName in components){const component=components[componentName];const entityProperties=component.system.getPropertiesOfType("entity");for(let i=0,len=entityProperties.length;i<len;i++){const propertyDescriptor=entityProperties[i];const propertyName=propertyDescriptor.name;const oldEntityReferenceId=component[propertyName];const entityIsWithinOldSubtree=!!oldSubtreeRoot.findByGuid(oldEntityReferenceId);if(entityIsWithinOldSubtree){const newEntityReferenceId=duplicatedIdsMap[oldEntityReferenceId].getGuid();if(newEntityReferenceId){newEntity.c[componentName][propertyName]=newEntityReferenceId;}}}}if(components.script&&!newEntity._app.useLegacyScriptAttributeCloning){newEntity.script.resolveDuplicatedEntityReferenceProperties(components.script,duplicatedIdsMap);}if(components.render){newEntity.render.resolveDuplicatedEntityReferenceProperties(components.render,duplicatedIdsMap);}if(components.button){newEntity.button.resolveDuplicatedEntityReferenceProperties(components.button,duplicatedIdsMap);}if(components.scrollview){newEntity.scrollview.resolveDuplicatedEntityReferenceProperties(components.scrollview,duplicatedIdsMap);}if(components.scrollbar){newEntity.scrollbar.resolveDuplicatedEntityReferenceProperties(components.scrollbar,duplicatedIdsMap);}if(components.anim){newEntity.anim.resolveDuplicatedEntityReferenceProperties(components.anim,duplicatedIdsMap);}const _old=oldEntity.children.filter(e=>{return e instanceof Entity});const _new=newEntity.children.filter(e=>{return e instanceof Entity});for(let i=0,len=_old.length;i<len;i++){resolveDuplicatedEntityReferenceProperties(oldSubtreeRoot,_old[i],_new[i],duplicatedIdsMap);}}}class SceneRegistryItem{get loaded(){return !!this.data}get loading(){return this._loading}constructor(name,url){this.name=void 0;this.url=void 0;this.data=null;this._loading=false;this._onLoadedCallbacks=[];this.name=name;this.url=url;}}class SceneRegistry{destroy(){this._app=null;}list(){return this._list}add(name,url){if(this._index.hasOwnProperty(name)){return false}const item=new SceneRegistryItem(name,url);const i=this._list.push(item);this._index[item.name]=i-1;this._urlIndex[item.url]=i-1;return true}find(name){if(this._index.hasOwnProperty(name)){return this._list[this._index[name]]}return null}findByUrl(url){if(this._urlIndex.hasOwnProperty(url)){return this._list[this._urlIndex[url]]}return null}remove(name){if(this._index.hasOwnProperty(name)){const idx=this._index[name];let item=this._list[idx];delete this._urlIndex[item.url];delete this._index[name];this._list.splice(idx,1);for(let i=0;i<this._list.length;i++){item=this._list[i];this._index[item.name]=i;this._urlIndex[item.url]=i;}}}_loadSceneData(sceneItem,storeInCache,callback){const app=this._app;let url=sceneItem;if(typeof sceneItem==="string"){sceneItem=this.findByUrl(url)||this.find(url)||new SceneRegistryItem("Untitled",url);}url=sceneItem.url;if(!url){callback("Cannot find scene to load");return}if(sceneItem.loaded){callback(null,sceneItem);return}if(app.assets&&app.assets.prefix&&!ABSOLUTE_URL.test(url)){url=path.join(app.assets.prefix,url);}sceneItem._onLoadedCallbacks.push(callback);if(!sceneItem._loading){const handler=app.loader.getHandler("hierarchy");handler.load(url,(err,data)=>{sceneItem.data=data;sceneItem._loading=false;for(let i=0;i<sceneItem._onLoadedCallbacks.length;i++){sceneItem._onLoadedCallbacks[i](err,sceneItem);}if(!storeInCache){sceneItem.data=null;}sceneItem._onLoadedCallbacks.length=0;});}sceneItem._loading=true;}loadSceneData(sceneItem,callback){this._loadSceneData(sceneItem,true,callback);}unloadSceneData(sceneItem){if(typeof sceneItem==="string"){sceneItem=this.findByUrl(sceneItem);}if(sceneItem){sceneItem.data=null;}}_loadSceneHierarchy(sceneItem,onBeforeAddHierarchy,callback){this._loadSceneData(sceneItem,false,(err,sceneItem)=>{if(err){if(callback){callback(err);}return}if(onBeforeAddHierarchy){onBeforeAddHierarchy(sceneItem);}const app=this._app;const _loaded=()=>{const handler=app.loader.getHandler("hierarchy");app.systems.script.preloading=true;const entity=handler.open(sceneItem.url,sceneItem.data);app.systems.script.preloading=false;app.loader.clearCache(sceneItem.url,"hierarchy");app.root.addChild(entity);app.systems.fire("initialize",entity);app.systems.fire("postInitialize",entity);app.systems.fire("postPostInitialize",entity);if(callback)callback(null,entity);};app._preloadScripts(sceneItem.data,_loaded);});}loadSceneHierarchy(sceneItem,callback){this._loadSceneHierarchy(sceneItem,null,callback);}loadSceneSettings(sceneItem,callback){this._loadSceneData(sceneItem,false,(err,sceneItem)=>{if(!err){this._app.applySceneSettings(sceneItem.data.settings);if(callback){callback(null);}}else {if(callback){callback(err);}}});}changeScene(sceneItem,callback){const app=this._app;const onBeforeAddHierarchy=sceneItem=>{const{children}=app.root;while(children.length){children[0].destroy();}app.applySceneSettings(sceneItem.data.settings);};this._loadSceneHierarchy(sceneItem,onBeforeAddHierarchy,callback);}loadScene(url,callback){const app=this._app;const handler=app.loader.getHandler("scene");if(app.assets&&app.assets.prefix&&!ABSOLUTE_URL.test(url)){url=path.join(app.assets.prefix,url);}handler.load(url,(err,data)=>{if(!err){const _loaded=()=>{app.systems.script.preloading=true;const scene=handler.open(url,data);const sceneItem=this.findByUrl(url);if(sceneItem&&!sceneItem.loaded){sceneItem.data=data;}app.systems.script.preloading=false;app.loader.clearCache(url,"scene");app.loader.patch({resource:scene,type:"scene"},app.assets);app.root.addChild(scene.root);if(app.systems.rigidbody&&typeof Ammo!=="undefined"){app.systems.rigidbody.gravity.set(scene._gravity.x,scene._gravity.y,scene._gravity.z);}if(callback){callback(null,scene);}};app._preloadScripts(data,_loaded);}else {if(callback){callback(err);}}});}constructor(app){this._app=void 0;this._list=[];this._index={};this._urlIndex={};this._app=app;}}class ApplicationStats{get scene(){return getApplication().scene._stats}get lightmapper(){var _getApplication$light;return (_getApplication$light=getApplication().lightmapper)==null?void 0:_getApplication$light.stats}get batcher(){const batcher=getApplication()._batcher;return batcher?batcher._stats:null}constructor(device){this.frame={fps:0,ms:0,dt:0,updateStart:0,updateTime:0,renderStart:0,renderTime:0,physicsStart:0,physicsTime:0,cullTime:0,sortTime:0,skinTime:0,morphTime:0,instancingTime:0,triangles:0,otherPrimitives:0,shaders:0,materials:0,cameras:0,shadowMapUpdates:0,shadowMapTime:0,depthMapTime:0,forwardTime:0,lightClustersTime:0,lightClusters:0,_timeToCountFrames:0,_fpsAccum:0};this.drawCalls={forward:0,depth:0,shadow:0,immediate:0,misc:0,total:0,skinned:0,instanced:0,removedByInstancing:0};this.misc={renderTargetCreationTime:0};this.particles={updatesPerFrame:0,_updatesPerFrame:0,frameTime:0,_frameTime:0};this.shaders=device._shaderStats;this.vram=device._vram;Object.defineProperty(this.vram,"totalUsed",{get:function(){return this.tex+this.vb+this.ib}});Object.defineProperty(this.vram,"geom",{get:function(){return this.vb+this.ib}});}}class Progress{inc(){this.count++;}done(){return this.count===this.length}constructor(length){this.length=length;this.count=0;}}let app$1=null;class AppBase extends EventHandler{init(appOptions){const device=appOptions.graphicsDevice;this.graphicsDevice=device;this._initDefaultMaterial();this._initProgramLibrary();this.stats=new ApplicationStats(device);this._soundManager=appOptions.soundManager;this.loader=new ResourceLoader(this);this._entityIndex={};this.scene=new Scene(device);this._registerSceneImmediate(this.scene);this.root=new Entity;this.root._enabledInHierarchy=true;this.assets=new AssetRegistry(this.loader);if(appOptions.assetPrefix)this.assets.prefix=appOptions.assetPrefix;this.bundles=new BundleRegistry(this.assets);this.enableBundles=typeof TextDecoder!=="undefined";this.scriptsOrder=appOptions.scriptsOrder||[];this.scripts=new ScriptRegistry(this);this.i18n=new I18n(this);this.scenes=new SceneRegistry(this);this.defaultLayerWorld=new Layer({name:"World",id:LAYERID_WORLD});this.defaultLayerDepth=new Layer({name:"Depth",id:LAYERID_DEPTH,enabled:false,opaqueSortMode:SORTMODE_NONE});this.defaultLayerSkybox=new Layer({name:"Skybox",id:LAYERID_SKYBOX,opaqueSortMode:SORTMODE_NONE});this.defaultLayerUi=new Layer({name:"UI",id:LAYERID_UI,transparentSortMode:SORTMODE_MANUAL});this.defaultLayerImmediate=new Layer({name:"Immediate",id:LAYERID_IMMEDIATE,opaqueSortMode:SORTMODE_NONE});const defaultLayerComposition=new LayerComposition("default");defaultLayerComposition.pushOpaque(this.defaultLayerWorld);defaultLayerComposition.pushOpaque(this.defaultLayerDepth);defaultLayerComposition.pushOpaque(this.defaultLayerSkybox);defaultLayerComposition.pushTransparent(this.defaultLayerWorld);defaultLayerComposition.pushOpaque(this.defaultLayerImmediate);defaultLayerComposition.pushTransparent(this.defaultLayerImmediate);defaultLayerComposition.pushTransparent(this.defaultLayerUi);this.scene.layers=defaultLayerComposition;AreaLightLuts.createPlaceholder(device);this.renderer=new ForwardRenderer(device);this.renderer.scene=this.scene;this.frameGraph=new FrameGraph;this.lightmapper=null;if(appOptions.lightmapper){this.lightmapper=new appOptions.lightmapper(device,this.root,this.scene,this.renderer,this.assets);this.once("prerender",this._firstBake,this);}this._batcher=null;if(appOptions.batchManager){this._batcher=new appOptions.batchManager(device,this.root,this.scene);this.once("prerender",this._firstBatch,this);}this.keyboard=appOptions.keyboard||null;this.mouse=appOptions.mouse||null;this.touch=appOptions.touch||null;this.gamepads=appOptions.gamepads||null;this.elementInput=appOptions.elementInput||null;if(this.elementInput){this.elementInput.app=this;}this.xr=appOptions.xr?new appOptions.xr(this):null;if(this.elementInput){this.elementInput.attachSelectEvents();}this._inTools=false;this._skyboxAsset=null;this._scriptPrefix=appOptions.scriptPrefix||"";if(this.enableBundles){this.loader.addHandler("bundle",new BundleHandler(this));}appOptions.resourceHandlers.forEach(resourceHandler=>{const handler=new resourceHandler(this);this.loader.addHandler(handler.handlerType,handler);});this.systems=new ComponentSystemRegistry;appOptions.componentSystems.forEach(componentSystem=>{this.systems.add(new componentSystem(this));});this._visibilityChangeHandler=this.onVisibilityChange.bind(this);if(typeof document!=="undefined"){if(document.hidden!==undefined){this._hiddenAttr="hidden";document.addEventListener("visibilitychange",this._visibilityChangeHandler,false);}else if(document.mozHidden!==undefined){this._hiddenAttr="mozHidden";document.addEventListener("mozvisibilitychange",this._visibilityChangeHandler,false);}else if(document.msHidden!==undefined){this._hiddenAttr="msHidden";document.addEventListener("msvisibilitychange",this._visibilityChangeHandler,false);}else if(document.webkitHidden!==undefined){this._hiddenAttr="webkitHidden";document.addEventListener("webkitvisibilitychange",this._visibilityChangeHandler,false);}}this.tick=makeTick(this);}static getApplication(id){return id?AppBase._applications[id]:getApplication()}_initDefaultMaterial(){const material=new StandardMaterial;material.name="Default Material";material.shadingModel=SPECULAR_BLINN;setDefaultMaterial(this.graphicsDevice,material);}_initProgramLibrary(){const library=new ProgramLibrary(this.graphicsDevice,new StandardMaterial);setProgramLibrary(this.graphicsDevice,library);}get soundManager(){return this._soundManager}get batcher(){return this._batcher}get fillMode(){return this._fillMode}get resolutionMode(){return this._resolutionMode}configure(url,callback){http.get(url,(err,response)=>{if(err){callback(err);return}const props=response.application_properties;const scenes=response.scenes;const assets=response.assets;this._parseApplicationProperties(props,err=>{this._parseScenes(scenes);this._parseAssets(assets);if(!err){callback(null);}else {callback(err);}});});}preload(callback){this.fire("preload:start");const assets=this.assets.list({preload:true});const progress=new Progress(assets.length);let _done=false;const done=()=>{if(!this.graphicsDevice){return}if(!_done&&progress.done()){_done=true;this.fire("preload:end");callback();}};const total=assets.length;if(progress.length){const onAssetLoad=asset=>{progress.inc();this.fire("preload:progress",progress.count/total);if(progress.done()){done();}};const onAssetError=(err,asset)=>{progress.inc();this.fire("preload:progress",progress.count/total);if(progress.done()){done();}};for(let i=0;i<assets.length;i++){if(!assets[i].loaded){assets[i].once("load",onAssetLoad);assets[i].once("error",onAssetError);this.assets.load(assets[i]);}else {progress.inc();this.fire("preload:progress",progress.count/total);if(progress.done()){done();}}}}else {done();}}_preloadScripts(sceneData,callback){if(!script.legacy){callback();return}this.systems.script.preloading=true;const scripts=this._getScriptReferences(sceneData);const l=scripts.length;const progress=new Progress(l);const regex=/^https?:\/\//;if(l){const onLoad=(err,ScriptType)=>{if(err){console.error(err);}progress.inc();if(progress.done()){this.systems.script.preloading=false;callback();}};for(let i=0;i<l;i++){let scriptUrl=scripts[i];if(!regex.test(scriptUrl.toLowerCase())&&this._scriptPrefix){scriptUrl=path.join(this._scriptPrefix,scripts[i]);}this.loader.load(scriptUrl,"script",onLoad);}}else {this.systems.script.preloading=false;callback();}}_parseApplicationProperties(props,callback){if(typeof props.maxAssetRetries==="number"&&props.maxAssetRetries>0){this.loader.enableRetry(props.maxAssetRetries);}if(!props.useDevicePixelRatio){props.useDevicePixelRatio=props.use_device_pixel_ratio;}if(!props.resolutionMode){props.resolutionMode=props.resolution_mode;}if(!props.fillMode){props.fillMode=props.fill_mode;}this._width=props.width;this._height=props.height;if(props.useDevicePixelRatio){this.graphicsDevice.maxPixelRatio=window.devicePixelRatio;}this.setCanvasResolution(props.resolutionMode,this._width,this._height);this.setCanvasFillMode(props.fillMode,this._width,this._height);if(props.layers&&props.layerOrder){const composition=new LayerComposition("application");const layers={};for(const key in props.layers){const data=props.layers[key];data.id=parseInt(key,10);data.enabled=data.id!==LAYERID_DEPTH;layers[key]=new Layer(data);}for(let i=0,len=props.layerOrder.length;i<len;i++){const sublayer=props.layerOrder[i];const layer=layers[sublayer.layer];if(!layer)continue;if(sublayer.transparent){composition.pushTransparent(layer);}else {composition.pushOpaque(layer);}composition.subLayerEnabled[i]=sublayer.enabled;}this.scene.layers=composition;}if(props.batchGroups){const batcher=this.batcher;if(batcher){for(let i=0,len=props.batchGroups.length;i<len;i++){const grp=props.batchGroups[i];batcher.addGroup(grp.name,grp.dynamic,grp.maxAabbSize,grp.id,grp.layers);}}}if(props.i18nAssets){this.i18n.assets=props.i18nAssets;}this._loadLibraries(props.libraries,callback);}_loadLibraries(urls,callback){const len=urls.length;let count=len;const regex=/^https?:\/\//;if(len){const onLoad=(err,script)=>{count--;if(err){callback(err);}else if(count===0){this.onLibrariesLoaded();callback(null);}};for(let i=0;i<len;++i){let url=urls[i];if(!regex.test(url.toLowerCase())&&this._scriptPrefix){url=path.join(this._scriptPrefix,url);}this.loader.load(url,"script",onLoad);}}else {this.onLibrariesLoaded();callback(null);}}_parseScenes(scenes){if(!scenes)return;for(let i=0;i<scenes.length;i++){this.scenes.add(scenes[i].name,scenes[i].url);}}_parseAssets(assets){const list=[];const scriptsIndex={};const bundlesIndex={};if(!script.legacy){for(let i=0;i<this.scriptsOrder.length;i++){const id=this.scriptsOrder[i];if(!assets[id]){continue}scriptsIndex[id]=true;list.push(assets[id]);}if(this.enableBundles){for(const id in assets){if(assets[id].type==="bundle"){bundlesIndex[id]=true;list.push(assets[id]);}}}for(const id in assets){if(scriptsIndex[id]||bundlesIndex[id]){continue}list.push(assets[id]);}}else {if(this.enableBundles){for(const id in assets){if(assets[id].type==="bundle"){bundlesIndex[id]=true;list.push(assets[id]);}}}for(const id in assets){if(bundlesIndex[id]){continue}list.push(assets[id]);}}for(let i=0;i<list.length;i++){const data=list[i];const asset=new Asset(data.name,data.type,data.file,data.data);asset.id=parseInt(data.id,10);asset.preload=data.preload?data.preload:false;asset.loaded=data.type==="script"&&data.data&&data.data.loadingType>0;asset.tags.add(data.tags);if(data.i18n){for(const locale in data.i18n){asset.addLocalizedAssetId(locale,data.i18n[locale]);}}this.assets.add(asset);}}_getScriptReferences(scene){let priorityScripts=[];if(scene.settings.priority_scripts){priorityScripts=scene.settings.priority_scripts;}const _scripts=[];const _index={};for(let i=0;i<priorityScripts.length;i++){_scripts.push(priorityScripts[i]);_index[priorityScripts[i]]=true;}const entities=scene.entities;for(const key in entities){if(!entities[key].components.script){continue}const scripts=entities[key].components.script.scripts;for(let i=0;i<scripts.length;i++){if(_index[scripts[i].url]){continue}_scripts.push(scripts[i].url);_index[scripts[i].url]=true;}}return _scripts}start(){this.frame=0;this.fire("start",{timestamp:now(),target:this});if(!this._librariesLoaded){this.onLibrariesLoaded();}this.systems.fire("initialize",this.root);this.fire("initialize");this.systems.fire("postInitialize",this.root);this.systems.fire("postPostInitialize",this.root);this.fire("postinitialize");this.tick();}inputUpdate(dt){if(this.controller){this.controller.update(dt);}if(this.mouse){this.mouse.update();}if(this.keyboard){this.keyboard.update();}if(this.gamepads){this.gamepads.update();}}update(dt){this.frame++;this.graphicsDevice.updateClientRect();if(script.legacy){this.systems.fire("fixedUpdate",1/60);}this.systems.fire(this._inTools?"toolsUpdate":"update",dt);this.systems.fire("animationUpdate",dt);this.systems.fire("postUpdate",dt);this.fire("update",dt);this.inputUpdate(dt);}frameStart(){this.graphicsDevice.frameStart();}frameEnd(){this.graphicsDevice.frameEnd();}render(){this.fire("prerender");this.root.syncHierarchy();if(this._batcher){this._batcher.updateAll();}this.renderComposition(this.scene.layers);this.fire("postrender");}renderComposition(layerComposition){this.renderer.buildFrameGraph(this.frameGraph,layerComposition);this.frameGraph.render(this.graphicsDevice);}_fillFrameStatsBasic(now,dt,ms){const stats=this.stats.frame;stats.dt=dt;stats.ms=ms;if(now>stats._timeToCountFrames){stats.fps=stats._fpsAccum;stats._fpsAccum=0;stats._timeToCountFrames=now+1e3;}else {stats._fpsAccum++;}this.stats.drawCalls.total=this.graphicsDevice._drawCallsPerFrame;this.graphicsDevice._drawCallsPerFrame=0;}_fillFrameStats(){let stats=this.stats.frame;stats.cameras=this.renderer._camerasRendered;stats.materials=this.renderer._materialSwitches;stats.shaders=this.graphicsDevice._shaderSwitchesPerFrame;stats.shadowMapUpdates=this.renderer._shadowMapUpdates;stats.shadowMapTime=this.renderer._shadowMapTime;stats.depthMapTime=this.renderer._depthMapTime;stats.forwardTime=this.renderer._forwardTime;const prims=this.graphicsDevice._primsPerFrame;stats.triangles=prims[PRIMITIVE_TRIANGLES]/3+Math.max(prims[PRIMITIVE_TRISTRIP]-2,0)+Math.max(prims[PRIMITIVE_TRIFAN]-2,0);stats.cullTime=this.renderer._cullTime;stats.sortTime=this.renderer._sortTime;stats.skinTime=this.renderer._skinTime;stats.morphTime=this.renderer._morphTime;stats.lightClusters=this.renderer._lightClusters;stats.lightClustersTime=this.renderer._lightClustersTime;stats.otherPrimitives=0;for(let i=0;i<prims.length;i++){if(i<PRIMITIVE_TRIANGLES){stats.otherPrimitives+=prims[i];}prims[i]=0;}this.renderer._camerasRendered=0;this.renderer._materialSwitches=0;this.renderer._shadowMapUpdates=0;this.graphicsDevice._shaderSwitchesPerFrame=0;this.renderer._cullTime=0;this.renderer._layerCompositionUpdateTime=0;this.renderer._lightClustersTime=0;this.renderer._sortTime=0;this.renderer._skinTime=0;this.renderer._morphTime=0;this.renderer._shadowMapTime=0;this.renderer._depthMapTime=0;this.renderer._forwardTime=0;stats=this.stats.drawCalls;stats.forward=this.renderer._forwardDrawCalls;stats.culled=this.renderer._numDrawCallsCulled;stats.depth=0;stats.shadow=this.renderer._shadowDrawCalls;stats.skinned=this.renderer._skinDrawCalls;stats.immediate=0;stats.instanced=0;stats.removedByInstancing=0;stats.misc=stats.total-(stats.forward+stats.shadow);this.renderer._depthDrawCalls=0;this.renderer._shadowDrawCalls=0;this.renderer._forwardDrawCalls=0;this.renderer._numDrawCallsCulled=0;this.renderer._skinDrawCalls=0;this.renderer._immediateRendered=0;this.renderer._instancedDrawCalls=0;this.stats.misc.renderTargetCreationTime=this.graphicsDevice.renderTargetCreationTime;stats=this.stats.particles;stats.updatesPerFrame=stats._updatesPerFrame;stats.frameTime=stats._frameTime;stats._updatesPerFrame=0;stats._frameTime=0;}setCanvasFillMode(mode,width,height){this._fillMode=mode;this.resizeCanvas(width,height);}setCanvasResolution(mode,width,height){this._resolutionMode=mode;if(mode===RESOLUTION_AUTO&&width===undefined){width=this.graphicsDevice.canvas.clientWidth;height=this.graphicsDevice.canvas.clientHeight;}this.graphicsDevice.resizeCanvas(width,height);}isHidden(){return document[this._hiddenAttr]}onVisibilityChange(){if(this.isHidden()){if(this._soundManager){this._soundManager.suspend();}}else {if(this._soundManager){this._soundManager.resume();}}}resizeCanvas(width,height){if(!this._allowResize)return undefined;if(this.xr&&this.xr.session){return undefined}const windowWidth=window.innerWidth;const windowHeight=window.innerHeight;if(this._fillMode===FILLMODE_KEEP_ASPECT){const r=this.graphicsDevice.canvas.width/this.graphicsDevice.canvas.height;const winR=windowWidth/windowHeight;if(r>winR){width=windowWidth;height=width/r;}else {height=windowHeight;width=height*r;}}else if(this._fillMode===FILLMODE_FILL_WINDOW){width=windowWidth;height=windowHeight;}this.graphicsDevice.canvas.style.width=`${width}px`;this.graphicsDevice.canvas.style.height=`${height}px`;this.updateCanvasSize();return {width:width,height:height}}updateCanvasSize(){var _this$xr;if(!this._allowResize||(_this$xr=this.xr)!=null&&_this$xr.active){return}if(this._resolutionMode===RESOLUTION_AUTO){const canvas=this.graphicsDevice.canvas;this.graphicsDevice.resizeCanvas(canvas.clientWidth,canvas.clientHeight);}}onLibrariesLoaded(){this._librariesLoaded=true;if(this.systems.rigidbody){this.systems.rigidbody.onLibraryLoaded();}}applySceneSettings(settings){let asset;if(this.systems.rigidbody&&typeof Ammo!=="undefined"){const gravity=settings.physics.gravity;this.systems.rigidbody.gravity.set(gravity[0],gravity[1],gravity[2]);}this.scene.applySettings(settings);if(settings.render.hasOwnProperty("skybox")){if(settings.render.skybox){asset=this.assets.get(settings.render.skybox);if(asset){this.setSkybox(asset);}else {this.assets.once(`add:${settings.render.skybox}`,this.setSkybox,this);}}else {this.setSkybox(null);}}}setAreaLightLuts(ltcMat1,ltcMat2){if(ltcMat1&&ltcMat2){AreaLightLuts.set(this.graphicsDevice,ltcMat1,ltcMat2);}}setSkybox(asset){if(asset!==this._skyboxAsset){const onSkyboxRemoved=()=>{this.setSkybox(null);};const onSkyboxChanged=()=>{this.scene.setSkybox(this._skyboxAsset?this._skyboxAsset.resources:null);};if(this._skyboxAsset){this.assets.off(`load:${this._skyboxAsset.id}`,onSkyboxChanged,this);this.assets.off(`remove:${this._skyboxAsset.id}`,onSkyboxRemoved,this);this._skyboxAsset.off("change",onSkyboxChanged,this);}this._skyboxAsset=asset;if(this._skyboxAsset){this.assets.on(`load:${this._skyboxAsset.id}`,onSkyboxChanged,this);this.assets.once(`remove:${this._skyboxAsset.id}`,onSkyboxRemoved,this);this._skyboxAsset.on("change",onSkyboxChanged,this);if(this.scene.skyboxMip===0&&!this._skyboxAsset.loadFaces){this._skyboxAsset.loadFaces=true;}this.assets.load(this._skyboxAsset);}onSkyboxChanged();}}_firstBake(){var _this$lightmapper;(_this$lightmapper=this.lightmapper)==null||_this$lightmapper.bake(null,this.scene.lightmapMode);}_firstBatch(){var _this$batcher;(_this$batcher=this.batcher)==null||_this$batcher.generate();}_processTimestamp(timestamp){return timestamp}drawLine(start,end,color,depthTest,layer){this.scene.drawLine(start,end,color,depthTest,layer);}drawLines(positions,colors,depthTest=true,layer=this.scene.defaultDrawLayer){this.scene.drawLines(positions,colors,depthTest,layer);}drawLineArrays(positions,colors,depthTest=true,layer=this.scene.defaultDrawLayer){this.scene.drawLineArrays(positions,colors,depthTest,layer);}drawWireSphere(center,radius,color=Color.WHITE,segments=20,depthTest=true,layer=this.scene.defaultDrawLayer){this.scene.immediate.drawWireSphere(center,radius,color,segments,depthTest,layer);}drawWireAlignedBox(minPoint,maxPoint,color=Color.WHITE,depthTest=true,layer=this.scene.defaultDrawLayer,mat){this.scene.immediate.drawWireAlignedBox(minPoint,maxPoint,color,depthTest,layer,mat);}drawMeshInstance(meshInstance,layer=this.scene.defaultDrawLayer){this.scene.immediate.drawMesh(null,null,null,meshInstance,layer);}drawMesh(mesh,material,matrix,layer=this.scene.defaultDrawLayer){this.scene.immediate.drawMesh(material,matrix,mesh,null,layer);}drawQuad(matrix,material,layer=this.scene.defaultDrawLayer){this.scene.immediate.drawMesh(material,matrix,this.scene.immediate.getQuadMesh(),null,layer);}drawTexture(x,y,width,height,texture,material,layer=this.scene.defaultDrawLayer,filterable=true){if(filterable===false&&!this.graphicsDevice.isWebGPU){return}const matrix=new Mat4;matrix.setTRS(new Vec3(x,y,0),Quat.IDENTITY,new Vec3(width,-height,0));if(!material){material=new Material;material.cull=CULLFACE_NONE;material.setParameter("colorMap",texture);material.shader=filterable?this.scene.immediate.getTextureShader():this.scene.immediate.getUnfilterableTextureShader();material.update();}this.drawQuad(matrix,material,layer);}drawDepthTexture(x,y,width,height,layer=this.scene.defaultDrawLayer){const material=new Material;material.cull=CULLFACE_NONE;material.shader=this.scene.immediate.getDepthTextureShader();material.update();this.drawTexture(x,y,width,height,null,material,layer);}destroy(){var _this$lightmapper2,_this$xr2,_this$xr3,_this$_soundManager;if(this._inFrameUpdate){this._destroyRequested=true;return}const canvasId=this.graphicsDevice.canvas.id;this.fire("destroy",this);this.off("librariesloaded");if(typeof document!=="undefined"){document.removeEventListener("visibilitychange",this._visibilityChangeHandler,false);document.removeEventListener("mozvisibilitychange",this._visibilityChangeHandler,false);document.removeEventListener("msvisibilitychange",this._visibilityChangeHandler,false);document.removeEventListener("webkitvisibilitychange",this._visibilityChangeHandler,false);}this._visibilityChangeHandler=null;this.root.destroy();this.root=null;if(this.mouse){this.mouse.off();this.mouse.detach();this.mouse=null;}if(this.keyboard){this.keyboard.off();this.keyboard.detach();this.keyboard=null;}if(this.touch){this.touch.off();this.touch.detach();this.touch=null;}if(this.elementInput){this.elementInput.detach();this.elementInput=null;}if(this.gamepads){this.gamepads.destroy();this.gamepads=null;}if(this.controller){this.controller=null;}this.systems.destroy();if(this.scene.layers){this.scene.layers.destroy();}const assets=this.assets.list();for(let i=0;i<assets.length;i++){assets[i].unload();assets[i].off();}this.assets.off();this.bundles.destroy();this.bundles=null;this.i18n.destroy();this.i18n=null;const scriptHandler=this.loader.getHandler("script");scriptHandler==null||scriptHandler.clearCache();this.loader.destroy();this.loader=null;this.scene.destroy();this.scene=null;this.systems=null;this.context=null;this.scripts.destroy();this.scripts=null;this.scenes.destroy();this.scenes=null;(_this$lightmapper2=this.lightmapper)==null||_this$lightmapper2.destroy();this.lightmapper=null;if(this._batcher){this._batcher.destroy();this._batcher=null;}this._entityIndex={};this.defaultLayerDepth.onPreRenderOpaque=null;this.defaultLayerDepth.onPostRenderOpaque=null;this.defaultLayerDepth.onDisable=null;this.defaultLayerDepth.onEnable=null;this.defaultLayerDepth=null;this.defaultLayerWorld=null;(_this$xr2=this.xr)==null||_this$xr2.end();(_this$xr3=this.xr)==null||_this$xr3.destroy();this.renderer.destroy();this.renderer=null;this.graphicsDevice.destroy();this.graphicsDevice=null;this.tick=null;this.off();(_this$_soundManager=this._soundManager)==null||_this$_soundManager.destroy();this._soundManager=null;script.app=null;AppBase._applications[canvasId]=null;if(getApplication()===this){setApplication(null);}AppBase.cancelTick(this);}static cancelTick(app){if(app.frameRequestId){window.cancelAnimationFrame(app.frameRequestId);app.frameRequestId=undefined;}}getEntityFromIndex(guid){return this._entityIndex[guid]}_registerSceneImmediate(scene){this.on("postrender",scene.immediate.onPostRender,scene.immediate);}constructor(canvas){super();this.frameRequestId=void 0;AppBase._applications[canvas.id]=this;setApplication(this);app$1=this;this._destroyRequested=false;this._inFrameUpdate=false;this._time=0;this.timeScale=1;this.maxDeltaTime=.1;this.frame=0;this.autoRender=true;this.renderNextFrame=false;this.useLegacyScriptAttributeCloning=script.legacy;this._librariesLoaded=false;this._fillMode=FILLMODE_KEEP_ASPECT;this._resolutionMode=RESOLUTION_FIXED;this._allowResize=true;this.context=this;}}AppBase._applications={};const _frameEndData={};const makeTick=function makeTick(_app){const application=_app;return function(timestamp,frame){var _application$xr2;if(!application.graphicsDevice){return}if(application.frameRequestId){var _application$xr;(_application$xr=application.xr)==null||(_application$xr=_application$xr.session)==null||_application$xr.cancelAnimationFrame(application.frameRequestId);cancelAnimationFrame(application.frameRequestId);application.frameRequestId=null;}application._inFrameUpdate=true;setApplication(application);app$1=application;const currentTime=application._processTimestamp(timestamp)||now();const ms=currentTime-(application._time||currentTime);let dt=ms/1e3;dt=math.clamp(dt,0,application.maxDeltaTime);dt*=application.timeScale;application._time=currentTime;if((_application$xr2=application.xr)!=null&&_application$xr2.session){application.frameRequestId=application.xr.session.requestAnimationFrame(application.tick);}else {application.frameRequestId=platform.browser||platform.worker?requestAnimationFrame(application.tick):null;}if(application.graphicsDevice.contextLost){return}application._fillFrameStatsBasic(currentTime,dt,ms);application.fire("frameupdate",ms);let shouldRenderFrame=true;if(frame){var _application$xr3;shouldRenderFrame=(_application$xr3=application.xr)==null?void 0:_application$xr3.update(frame);application.graphicsDevice.defaultFramebuffer=frame.session.renderState.baseLayer.framebuffer;}else {application.graphicsDevice.defaultFramebuffer=null;}if(shouldRenderFrame){application.update(dt);application.fire("framerender");if(application.autoRender||application.renderNextFrame){application.updateCanvasSize();application.frameStart();application.render();application.frameEnd();application.renderNextFrame=false;}_frameEndData.timestamp=now();_frameEndData.target=application;application.fire("frameend",_frameEndData);}application._inFrameUpdate=false;if(application._destroyRequested){application.destroy();}}};class AppOptions{constructor(){this.elementInput=void 0;this.keyboard=void 0;this.mouse=void 0;this.touch=void 0;this.gamepads=void 0;this.scriptPrefix=void 0;this.assetPrefix=void 0;this.scriptsOrder=void 0;this.soundManager=void 0;this.graphicsDevice=void 0;this.lightmapper=void 0;this.batchManager=void 0;this.xr=void 0;this.componentSystems=[];this.resourceHandlers=[];}}const tempSphere=new BoundingSphere;class BakeLight{store(){this.mask=this.light.mask;this.shadowUpdateMode=this.light.shadowUpdateMode;this.enabled=this.light.enabled;this.intensity=this.light.intensity;this.rotation=this.light._node.getLocalRotation().clone();this.numCascades=this.light.numCascades;this.castShadows=this.light._castShadows;}restore(){const light=this.light;light.mask=this.mask;light.shadowUpdateMode=this.shadowUpdateMode;light.enabled=this.enabled;light.intensity=this.intensity;light._node.setLocalRotation(this.rotation);light.numCascades=this.numCascades;light._castShadows=this.castShadows;}startBake(){this.light.enabled=true;this.light._destroyShadowMap();this.light.beginFrame();}endBake(shadowMapCache){const light=this.light;light.enabled=false;if(light.shadowMap){if(light.shadowMap.cached){shadowMapCache.add(light,light.shadowMap);}light.shadowMap=null;}}constructor(scene,light,lightingParams){this.scene=scene;this.light=light;this.store();light.numCascades=1;if(this.scene.clusteredLightingEnabled){light.castShadows=light.bakeShadows&&lightingParams.shadowsEnabled;}if(light.type!==LIGHTTYPE_DIRECTIONAL){light._node.getWorldTransform();light.getBoundingSphere(tempSphere);this.lightBounds=new BoundingBox;this.lightBounds.center.copy(tempSphere.center);this.lightBounds.halfExtents.set(tempSphere.radius,tempSphere.radius,tempSphere.radius);}}}const _tempPoint$1=new Vec2;class BakeLightSimple extends BakeLight{get numVirtualLights(){if(this.light.type===LIGHTTYPE_DIRECTIONAL){return this.light.bakeNumSamples}return 1}prepareVirtualLight(index,numVirtualLights){const light=this.light;light._node.setLocalRotation(this.rotation);if(index>0){const directionalSpreadAngle=light.bakeArea;random.circlePointDeterministic(_tempPoint$1,index,numVirtualLights);_tempPoint$1.mulScalar(directionalSpreadAngle*.5);light._node.rotateLocal(_tempPoint$1.x,0,_tempPoint$1.y);}light._node.getWorldTransform();const gamma=this.scene.gammaCorrection?2.2:1;const linearIntensity=Math.pow(this.intensity,gamma);light.intensity=Math.pow(linearIntensity/numVirtualLights,1/gamma);}constructor(lightmapper,light){super(lightmapper.scene,light,lightmapper.lightingParams);}}const _tempPoint=new Vec3;class BakeLightAmbient extends BakeLight{get numVirtualLights(){return this.light.bakeNumSamples}prepareVirtualLight(index,numVirtualLights){random.spherePointDeterministic(_tempPoint,index,numVirtualLights,0,this.scene.ambientBakeSpherePart);this.light._node.lookAt(_tempPoint.mulScalar(-1));this.light._node.rotateLocal(90,0,0);const gamma=this.scene.gammaCorrection?2.2:1;const fullIntensity=2*Math.PI*this.scene.ambientBakeSpherePart;const linearIntensity=Math.pow(fullIntensity,gamma);this.light.intensity=Math.pow(linearIntensity/numVirtualLights,1/gamma);}constructor(lightmapper){const scene=lightmapper.scene;const lightEntity=new Entity("AmbientLight");lightEntity.addComponent("light",{type:"directional",affectDynamic:true,affectLightmapped:false,bake:true,bakeNumSamples:scene.ambientBakeNumSamples,castShadows:true,normalOffsetBias:.05,shadowBias:.2,shadowDistance:1,shadowResolution:2048,shadowType:SHADOW_PCF3,color:Color.WHITE,intensity:1,bakeDir:false});super(scene,lightEntity.light.light,lightmapper.lightingParams);}}class BakeMeshNode{store(){this.castShadows=this.component.castShadows;}restore(){this.component.castShadows=this.castShadows;}constructor(node,meshInstances=null){this.node=node;this.component=node.render||node.model;meshInstances=meshInstances||this.component.meshInstances;this.store();this.meshInstances=meshInstances;this.bounds=null;this.renderTargets=[];}}const DENOISE_FILTER_SIZE=15;class LightmapFilters{setSourceTexture(texture){this.constantTexSource.setValue(texture);}prepare(textureWidth,textureHeight){this.pixelOffset[0]=1/textureWidth;this.pixelOffset[1]=1/textureHeight;this.constantPixelOffset.setValue(this.pixelOffset);}prepareDenoise(filterRange,filterSmoothness){if(!this.shaderDenoise){this.shaderDenoise=createShaderFromCode(this.device,shaderChunks.fullscreenQuadVS,shaderChunksLightmapper.bilateralDeNoisePS,"lmBilateralDeNoise");this.sigmas=new Float32Array(2);this.constantSigmas=this.device.scope.resolve("sigmas");this.constantKernel=this.device.scope.resolve("kernel[0]");this.bZnorm=this.device.scope.resolve("bZnorm");}this.sigmas[0]=filterRange;this.sigmas[1]=filterSmoothness;this.constantSigmas.setValue(this.sigmas);this.evaluateDenoiseUniforms(filterRange,filterSmoothness);}evaluateDenoiseUniforms(filterRange,filterSmoothness){function normpdf(x,sigma){return .39894*Math.exp(-.5*x*x/(sigma*sigma))/sigma}this.kernel=this.kernel||new Float32Array(DENOISE_FILTER_SIZE);const kernel=this.kernel;const kSize=Math.floor((DENOISE_FILTER_SIZE-1)/2);for(let j=0;j<=kSize;++j){const value=normpdf(j,filterRange);kernel[kSize+j]=value;kernel[kSize-j]=value;}this.constantKernel.setValue(this.kernel);const bZnorm=1/normpdf(0,filterSmoothness);this.bZnorm.setValue(bZnorm);}constructor(device){this.device=device;this.shaderDilate=createShaderFromCode(device,shaderChunks.fullscreenQuadVS,shaderChunksLightmapper.dilatePS,"lmDilate");this.constantTexSource=device.scope.resolve("source");this.constantPixelOffset=device.scope.resolve("pixelOffset");this.pixelOffset=new Float32Array(2);this.shaderDenoise=null;this.sigmas=null;this.constantSigmas=null;this.kernel=null;}}class RenderPassLightmapper extends RenderPass{destroy(){this.viewBindGroups.forEach(bg=>{bg.defaultUniformBuffer.destroy();bg.destroy();});this.viewBindGroups.length=0;}execute(){this.device;const{renderer,camera,receivers,renderTarget,worldClusters,lightArray}=this;renderer.renderForwardLayer(camera,renderTarget,null,undefined,SHADER_FORWARDHDR,this.viewBindGroups,{meshInstances:receivers,splitLights:lightArray,lightClusters:worldClusters});}constructor(device,renderer,camera,worldClusters,receivers,lightArray){super(device);this.viewBindGroups=[];this.renderer=renderer;this.camera=camera;this.worldClusters=worldClusters;this.receivers=receivers;this.lightArray=lightArray;}}const MAX_LIGHTMAP_SIZE=2048;const PASS_COLOR=0;const PASS_DIR=1;const tempVec$1=new Vec3;class Lightmapper{destroy(){var _this$camera;LightmapCache.decRef(this.blackTex);this.blackTex=null;LightmapCache.destroy();this.device=null;this.root=null;this.scene=null;this.renderer=null;this.assets=null;(_this$camera=this.camera)==null||_this$camera.destroy();this.camera=null;}initBake(device){if(!this._initCalled){this._initCalled=true;this.lightmapFilters=new LightmapFilters(device);this.constantBakeDir=device.scope.resolve("bakeDir");this.materials=[];this.blackTex=new Texture(this.device,{width:4,height:4,format:PIXELFORMAT_RGBA8,type:TEXTURETYPE_RGBM,name:"lightmapBlack"});LightmapCache.incRef(this.blackTex);const camera=new Camera;camera.clearColor.set(0,0,0,0);camera.clearColorBuffer=true;camera.clearDepthBuffer=false;camera.clearStencilBuffer=false;camera.frustumCulling=false;camera.projection=PROJECTION_ORTHOGRAPHIC;camera.aspectRatio=1;camera.node=new GraphNode;this.camera=camera;}if(this.scene.clusteredLightingEnabled){const lightingParams=new LightingParams(device.supportsAreaLights,device.maxTextureSize,()=>{});this.lightingParams=lightingParams;const srcParams=this.scene.lighting;lightingParams.shadowsEnabled=srcParams.shadowsEnabled;lightingParams.shadowAtlasResolution=srcParams.shadowAtlasResolution;lightingParams.cookiesEnabled=srcParams.cookiesEnabled;lightingParams.cookieAtlasResolution=srcParams.cookieAtlasResolution;lightingParams.areaLightsEnabled=srcParams.areaLightsEnabled;lightingParams.cells=new Vec3(3,3,3);lightingParams.maxLightsPerCell=4;this.worldClusters=new WorldClusters(device);this.worldClusters.name="ClusterLightmapper";}}finishBake(bakeNodes){this.materials=[];function destroyRT(rt){LightmapCache.decRef(rt.colorBuffer);rt.destroy();}this.renderTargets.forEach(rt=>{destroyRT(rt);});this.renderTargets.clear();bakeNodes.forEach(node=>{node.renderTargets.forEach(rt=>{destroyRT(rt);});node.renderTargets.length=0;});this.ambientAOMaterial=null;if(this.worldClusters){this.worldClusters.destroy();this.worldClusters=null;}}createMaterialForPass(device,scene,pass,addAmbient){const material=new StandardMaterial;material.name=`lmMaterial-pass:${pass}-ambient:${addAmbient}`;material.chunks.APIVersion=CHUNKAPI_1_65;const transformDefines="#define UV1LAYOUT\n";material.chunks.transformVS=transformDefines+shaderChunks.transformVS;if(pass===PASS_COLOR){let bakeLmEndChunk=shaderChunksLightmapper.bakeLmEndPS;if(addAmbient){bakeLmEndChunk=`
										dDiffuseLight = ((dDiffuseLight - 0.5) * max(${scene.ambientBakeOcclusionContrast.toFixed(1)} + 1.0, 0.0)) + 0.5;
										dDiffuseLight += vec3(${scene.ambientBakeOcclusionBrightness.toFixed(1)});
										dDiffuseLight = saturate(dDiffuseLight);
										dDiffuseLight *= dAmbientLight;
								${bakeLmEndChunk}`;}else {material.ambient=new Color(0,0,0);material.ambientTint=true;}material.chunks.basePS=shaderChunks.basePS+(scene.lightmapPixelFormat===PIXELFORMAT_RGBA8?"\n#define LIGHTMAP_RGBM\n":"");material.chunks.endPS=bakeLmEndChunk;material.lightMap=this.blackTex;}else {material.chunks.basePS=`${shaderChunks.basePS}
uniform sampler2D texture_dirLightMap;
uniform float bakeDir;
`;material.chunks.endPS=shaderChunksLightmapper.bakeDirLmEndPS;}material.chunks.outputAlphaPS="\n";material.chunks.outputAlphaOpaquePS="\n";material.chunks.outputAlphaPremulPS="\n";material.cull=CULLFACE_NONE;material.forceUv1=true;material.update();return material}createMaterials(device,scene,passCount){for(let pass=0;pass<passCount;pass++){if(!this.passMaterials[pass]){this.passMaterials[pass]=this.createMaterialForPass(device,scene,pass,false);}}if(!this.ambientAOMaterial){this.ambientAOMaterial=this.createMaterialForPass(device,scene,0,true);this.ambientAOMaterial.onUpdateShader=function(options){options.litOptions.lightMapWithoutAmbient=true;options.litOptions.separateAmbient=true;return options};}}createTexture(size,name){return new Texture(this.device,{width:size,height:size,format:this.scene.lightmapPixelFormat,mipmaps:false,type:this.scene.lightmapPixelFormat===PIXELFORMAT_RGBA8?TEXTURETYPE_RGBM:TEXTURETYPE_DEFAULT,minFilter:FILTER_NEAREST,magFilter:FILTER_NEAREST,addressU:ADDRESS_CLAMP_TO_EDGE,addressV:ADDRESS_CLAMP_TO_EDGE,name:name})}collectModels(node,bakeNodes,allNodes){var _node$model,_node$model2,_node$render;if(!node.enabled)return;let meshInstances;if((_node$model=node.model)!=null&&_node$model.model&&(_node$model2=node.model)!=null&&_node$model2.enabled){if(allNodes)allNodes.push(new BakeMeshNode(node));if(node.model.lightmapped){if(bakeNodes){meshInstances=node.model.model.meshInstances;}}}if((_node$render=node.render)!=null&&_node$render.enabled){if(allNodes)allNodes.push(new BakeMeshNode(node));if(node.render.lightmapped){if(bakeNodes){meshInstances=node.render.meshInstances;}}}if(meshInstances){let hasUv1=true;for(let i=0;i<meshInstances.length;i++){if(!meshInstances[i].mesh.vertexBuffer.format.hasUv1){hasUv1=false;break}}if(hasUv1){const notInstancedMeshInstances=[];for(let i=0;i<meshInstances.length;i++){const mesh=meshInstances[i].mesh;if(this._tempSet.has(mesh)){bakeNodes.push(new BakeMeshNode(node,[meshInstances[i]]));}else {notInstancedMeshInstances.push(meshInstances[i]);}this._tempSet.add(mesh);}this._tempSet.clear();if(notInstancedMeshInstances.length>0){bakeNodes.push(new BakeMeshNode(node,notInstancedMeshInstances));}}}for(let i=0;i<node._children.length;i++){this.collectModels(node._children[i],bakeNodes,allNodes);}}prepareShadowCasters(nodes){const casters=[];for(let n=0;n<nodes.length;n++){const component=nodes[n].component;component.castShadows=component.castShadowsLightmap;if(component.castShadowsLightmap){const meshes=nodes[n].meshInstances;for(let i=0;i<meshes.length;i++){meshes[i].visibleThisFrame=true;casters.push(meshes[i]);}}}return casters}updateTransforms(nodes){for(let i=0;i<nodes.length;i++){const meshInstances=nodes[i].meshInstances;for(let j=0;j<meshInstances.length;j++){meshInstances[j].node.getWorldTransform();}}}calculateLightmapSize(node){let data;const sizeMult=this.scene.lightmapSizeMultiplier||16;const scale=tempVec$1;let srcArea,lightmapSizeMultiplier;if(node.model){lightmapSizeMultiplier=node.model.lightmapSizeMultiplier;if(node.model.asset){data=this.assets.get(node.model.asset).data;if(data.area){srcArea=data.area;}}else if(node.model._area){data=node.model;if(data._area){srcArea=data._area;}}}else if(node.render){lightmapSizeMultiplier=node.render.lightmapSizeMultiplier;if(node.render.type!=="asset"){if(node.render._area){data=node.render;if(data._area){srcArea=data._area;}}}}const area={x:1,y:1,z:1,uv:1};if(srcArea){area.x=srcArea.x;area.y=srcArea.y;area.z=srcArea.z;area.uv=srcArea.uv;}const areaMult=lightmapSizeMultiplier||1;area.x*=areaMult;area.y*=areaMult;area.z*=areaMult;const component=node.render||node.model;const bounds=this.computeNodeBounds(component.meshInstances);scale.copy(bounds.halfExtents);let totalArea=area.x*scale.y*scale.z+area.y*scale.x*scale.z+area.z*scale.x*scale.y;totalArea/=area.uv;totalArea=Math.sqrt(totalArea);const lightmapSize=Math.min(math.nextPowerOfTwo(totalArea*sizeMult),this.scene.lightmapMaxResolution||MAX_LIGHTMAP_SIZE);return lightmapSize}setLightmapping(nodes,value,passCount,shaderDefs){for(let i=0;i<nodes.length;i++){const node=nodes[i];const meshInstances=node.meshInstances;for(let j=0;j<meshInstances.length;j++){const meshInstance=meshInstances[j];meshInstance.setLightmapped(value);if(value){if(shaderDefs){meshInstance._shaderDefs|=shaderDefs;}meshInstance.mask=MASK_AFFECT_LIGHTMAPPED;for(let pass=0;pass<passCount;pass++){const tex=node.renderTargets[pass].colorBuffer;tex.minFilter=FILTER_LINEAR;tex.magFilter=FILTER_LINEAR;meshInstance.setRealtimeLightmap(MeshInstance.lightmapParamNames[pass],tex);}}}}}bake(nodes,mode=BAKE_COLORDIR){const device=this.device;const startTime=now();this.scene._updateSkyMesh();this.stats.renderPasses=0;this.stats.shadowMapTime=0;this.stats.forwardTime=0;const startShaders=device._shaderStats.linked;const startFboTime=device._renderTargetCreationTime;const startCompileTime=device._shaderStats.compileTime;const bakeNodes=[];const allNodes=[];if(nodes){for(let i=0;i<nodes.length;i++){this.collectModels(nodes[i],bakeNodes,null);}this.collectModels(this.root,null,allNodes);}else {this.collectModels(this.root,bakeNodes,allNodes);}if(bakeNodes.length>0){this.renderer.shadowRenderer.frameUpdate();const passCount=mode===BAKE_COLORDIR?2:1;this.setLightmapping(bakeNodes,false,passCount);this.initBake(device);this.bakeInternal(passCount,bakeNodes,allNodes);let shaderDefs=SHADERDEF_LM;if(mode===BAKE_COLORDIR){shaderDefs|=SHADERDEF_DIRLM;}if(this.scene.ambientBake){shaderDefs|=SHADERDEF_LMAMBIENT;}this.setLightmapping(bakeNodes,true,passCount,shaderDefs);this.finishBake(bakeNodes);}const nowTime=now();this.stats.totalRenderTime=nowTime-startTime;this.stats.shadersLinked=device._shaderStats.linked-startShaders;this.stats.compileTime=device._shaderStats.compileTime-startCompileTime;this.stats.fboTime=device._renderTargetCreationTime-startFboTime;this.stats.lightmapCount=bakeNodes.length;}allocateTextures(bakeNodes,passCount){for(let i=0;i<bakeNodes.length;i++){const bakeNode=bakeNodes[i];const size=this.calculateLightmapSize(bakeNode.node);for(let pass=0;pass<passCount;pass++){const tex=this.createTexture(size,`lightmapper_lightmap_${i}`);LightmapCache.incRef(tex);bakeNode.renderTargets[pass]=new RenderTarget({colorBuffer:tex,depth:false});}if(!this.renderTargets.has(size)){const tex=this.createTexture(size,`lightmapper_temp_lightmap_${size}`);LightmapCache.incRef(tex);this.renderTargets.set(size,new RenderTarget({colorBuffer:tex,depth:false}));}}}prepareLightsToBake(allLights,bakeLights){if(this.scene.ambientBake){const ambientLight=new BakeLightAmbient(this);bakeLights.push(ambientLight);}const sceneLights=this.renderer.lights;for(let i=0;i<sceneLights.length;i++){const light=sceneLights[i];const bakeLight=new BakeLightSimple(this,light);allLights.push(bakeLight);if(light.enabled&&(light.mask&MASK_BAKE)!==0){light.mask=MASK_BAKE|MASK_AFFECT_LIGHTMAPPED|MASK_AFFECT_DYNAMIC;light.shadowUpdateMode=light.type===LIGHTTYPE_DIRECTIONAL?SHADOWUPDATE_REALTIME:SHADOWUPDATE_THISFRAME;bakeLights.push(bakeLight);}}bakeLights.sort();}restoreLights(allLights){for(let i=0;i<allLights.length;i++){allLights[i].restore();}}setupScene(){this.fog=this.scene.fog;this.ambientLight.copy(this.scene.ambientLight);this.scene.fog=FOG_NONE;if(!this.scene.ambientBake){this.scene.ambientLight.set(0,0,0);}this.renderer.setSceneConstants();}restoreScene(){this.scene.fog=this.fog;this.scene.ambientLight.copy(this.ambientLight);}computeNodeBounds(meshInstances){const bounds=new BoundingBox;if(meshInstances.length>0){bounds.copy(meshInstances[0].aabb);for(let m=1;m<meshInstances.length;m++){bounds.add(meshInstances[m].aabb);}}return bounds}computeNodesBounds(nodes){for(let i=0;i<nodes.length;i++){const meshInstances=nodes[i].meshInstances;nodes[i].bounds=this.computeNodeBounds(meshInstances);}}computeBounds(meshInstances){const bounds=new BoundingBox;for(let i=0;i<meshInstances.length;i++){bounds.copy(meshInstances[0].aabb);for(let m=1;m<meshInstances.length;m++){bounds.add(meshInstances[m].aabb);}}return bounds}backupMaterials(meshInstances){for(let i=0;i<meshInstances.length;i++){this.materials[i]=meshInstances[i].material;}}restoreMaterials(meshInstances){for(let i=0;i<meshInstances.length;i++){meshInstances[i].material=this.materials[i];}}lightCameraPrepare(device,bakeLight){const light=bakeLight.light;let shadowCam;if(light.type===LIGHTTYPE_SPOT){const lightRenderData=light.getRenderData(null,0);shadowCam=lightRenderData.shadowCamera;shadowCam._node.setPosition(light._node.getPosition());shadowCam._node.setRotation(light._node.getRotation());shadowCam._node.rotateLocal(-90,0,0);shadowCam.projection=PROJECTION_PERSPECTIVE;shadowCam.nearClip=light.attenuationEnd/1e3;shadowCam.farClip=light.attenuationEnd;shadowCam.aspectRatio=1;shadowCam.fov=light._outerConeAngle*2;this.renderer.updateCameraFrustum(shadowCam);}return shadowCam}lightCameraPrepareAndCull(bakeLight,bakeNode,shadowCam,casterBounds){const light=bakeLight.light;let lightAffectsNode=true;if(light.type===LIGHTTYPE_DIRECTIONAL){tempVec$1.copy(casterBounds.center);tempVec$1.y+=casterBounds.halfExtents.y;this.camera.node.setPosition(tempVec$1);this.camera.node.setEulerAngles(-90,0,0);this.camera.nearClip=0;this.camera.farClip=casterBounds.halfExtents.y*2;const frustumSize=Math.max(casterBounds.halfExtents.x,casterBounds.halfExtents.z);this.camera.orthoHeight=frustumSize;}else {if(!bakeLight.lightBounds.intersects(bakeNode.bounds)){lightAffectsNode=false;}}if(light.type===LIGHTTYPE_SPOT){let nodeVisible=false;const meshInstances=bakeNode.meshInstances;for(let i=0;i<meshInstances.length;i++){if(meshInstances[i]._isVisible(shadowCam)){nodeVisible=true;break}}if(!nodeVisible){lightAffectsNode=false;}}return lightAffectsNode}setupLightArray(lightArray,light){lightArray[LIGHTTYPE_DIRECTIONAL].length=0;lightArray[LIGHTTYPE_OMNI].length=0;lightArray[LIGHTTYPE_SPOT].length=0;lightArray[light.type][0]=light;light.visibleThisFrame=true;}renderShadowMap(comp,shadowMapRendered,casters,bakeLight){const light=bakeLight.light;const isClustered=this.scene.clusteredLightingEnabled;const castShadow=light.castShadows&&(!isClustered||this.scene.lighting.shadowsEnabled);if(!shadowMapRendered&&castShadow){if(!light.shadowMap&&!isClustered){light.shadowMap=this.shadowMapCache.get(this.device,light);}if(light.type===LIGHTTYPE_DIRECTIONAL){this.renderer._shadowRendererDirectional.cull(light,comp,this.camera,casters);const shadowPass=this.renderer._shadowRendererDirectional.getLightRenderPass(light,this.camera);shadowPass==null||shadowPass.render();}else {if(this.device.isWebGPU){return true}this.renderer._shadowRendererLocal.cull(light,comp,casters);const insideRenderPass=false;this.renderer.shadowRenderer.render(light,this.camera,insideRenderPass);}}return true}postprocessTextures(device,bakeNodes,passCount){const numDilates2x=1;const dilateShader=this.lightmapFilters.shaderDilate;const filterLightmap=this.scene.lightmapFilterEnabled;if(filterLightmap){this.lightmapFilters.prepareDenoise(this.scene.lightmapFilterRange,this.scene.lightmapFilterSmoothness);}device.setBlendState(BlendState.NOBLEND);device.setDepthState(DepthState.NODEPTH);device.setStencilState(null,null);for(let node=0;node<bakeNodes.length;node++){const bakeNode=bakeNodes[node];for(let pass=0;pass<passCount;pass++){const nodeRT=bakeNode.renderTargets[pass];const lightmap=nodeRT.colorBuffer;const tempRT=this.renderTargets.get(lightmap.width);const tempTex=tempRT.colorBuffer;this.lightmapFilters.prepare(lightmap.width,lightmap.height);for(let i=0;i<numDilates2x;i++){this.lightmapFilters.setSourceTexture(lightmap);const bilateralFilterEnabled=filterLightmap&&pass===0&&i===0;drawQuadWithShader(device,tempRT,bilateralFilterEnabled?this.lightmapFilters.shaderDenoise:dilateShader);this.lightmapFilters.setSourceTexture(tempTex);drawQuadWithShader(device,nodeRT,dilateShader);}}}}bakeInternal(passCount,bakeNodes,allNodes){const scene=this.scene;const comp=scene.layers;const device=this.device;const clusteredLightingEnabled=scene.clusteredLightingEnabled;this.createMaterials(device,scene,passCount);this.setupScene();comp._update();this.computeNodesBounds(bakeNodes);this.allocateTextures(bakeNodes,passCount);this.renderer.collectLights(comp);const allLights=[],bakeLights=[];this.prepareLightsToBake(allLights,bakeLights);this.updateTransforms(allNodes);const casters=this.prepareShadowCasters(allNodes);this.renderer.updateCpuSkinMatrices(casters);this.renderer.gpuUpdate(casters);const casterBounds=this.computeBounds(casters);let i,j,rcv,m;for(i=0;i<bakeNodes.length;i++){const bakeNode=bakeNodes[i];rcv=bakeNode.meshInstances;for(j=0;j<rcv.length;j++){m=rcv[j];m.setLightmapped(false);m.mask=MASK_BAKE;m.setRealtimeLightmap(MeshInstance.lightmapParamNames[0],this.blackTex);m.setRealtimeLightmap(MeshInstance.lightmapParamNames[1],this.blackTex);}}for(j=0;j<bakeLights.length;j++){bakeLights[j].light.enabled=false;}const lightArray=[[],[],[]];let pass,node;let shadersUpdatedOn1stPass=false;for(i=0;i<bakeLights.length;i++){const bakeLight=bakeLights[i];const isAmbientLight=bakeLight instanceof BakeLightAmbient;const isDirectional=bakeLight.light.type===LIGHTTYPE_DIRECTIONAL;let numVirtualLights=bakeLight.numVirtualLights;if(passCount>1&&numVirtualLights>1&&bakeLight.light.bakeDir){numVirtualLights=1;}for(let virtualLightIndex=0;virtualLightIndex<numVirtualLights;virtualLightIndex++){if(numVirtualLights>1){bakeLight.prepareVirtualLight(virtualLightIndex,numVirtualLights);}bakeLight.startBake();let shadowMapRendered=false;const shadowCam=this.lightCameraPrepare(device,bakeLight);for(node=0;node<bakeNodes.length;node++){const bakeNode=bakeNodes[node];rcv=bakeNode.meshInstances;const lightAffectsNode=this.lightCameraPrepareAndCull(bakeLight,bakeNode,shadowCam,casterBounds);if(!lightAffectsNode){continue}this.setupLightArray(lightArray,bakeLight.light);const clusterLights=isDirectional?[]:[bakeLight.light];if(clusteredLightingEnabled){this.renderer.lightTextureAtlas.update(clusterLights,this.lightingParams);}shadowMapRendered=this.renderShadowMap(comp,shadowMapRendered,casters,bakeLight);if(clusteredLightingEnabled){this.worldClusters.update(clusterLights,this.scene.gammaCorrection,this.lightingParams);}this.backupMaterials(rcv);for(pass=0;pass<passCount;pass++){if(pass>0&&virtualLightIndex>0){break}if(isAmbientLight&&pass>0){break}const nodeRT=bakeNode.renderTargets[pass];const lightmapSize=bakeNode.renderTargets[pass].colorBuffer.width;const tempRT=this.renderTargets.get(lightmapSize);const tempTex=tempRT.colorBuffer;if(pass===0){shadersUpdatedOn1stPass=scene.updateShaders;}else if(shadersUpdatedOn1stPass){scene.updateShaders=true;}let passMaterial=this.passMaterials[pass];if(isAmbientLight){const lastVirtualLightForPass=virtualLightIndex+1===numVirtualLights;if(lastVirtualLightForPass&&pass===0){passMaterial=this.ambientAOMaterial;}}for(j=0;j<rcv.length;j++){rcv[j].material=passMaterial;}this.renderer.updateShaders(rcv);if(pass===PASS_DIR){this.constantBakeDir.setValue(bakeLight.light.bakeDir?1:0);}if(device.isWebGPU){const renderPass=new RenderPassLightmapper(device,this.renderer,this.camera,clusteredLightingEnabled?this.worldClusters:null,rcv,lightArray);renderPass.init(tempRT);renderPass.render();renderPass.destroy();}else {this.renderer.setCamera(this.camera,tempRT,true);if(clusteredLightingEnabled){this.worldClusters.activate();}this.renderer._forwardTime=0;this.renderer._shadowMapTime=0;this.renderer.renderForward(this.camera,rcv,lightArray,SHADER_FORWARDHDR);device.updateEnd();}bakeNode.renderTargets[pass]=tempRT;this.renderTargets.set(lightmapSize,nodeRT);for(j=0;j<rcv.length;j++){m=rcv[j];m.setRealtimeLightmap(MeshInstance.lightmapParamNames[pass],tempTex);m._shaderDefs|=SHADERDEF_LM;}}this.restoreMaterials(rcv);}bakeLight.endBake(this.shadowMapCache);}}this.postprocessTextures(device,bakeNodes,passCount);for(node=0;node<allNodes.length;node++){allNodes[node].restore();}this.restoreLights(allLights);this.restoreScene();if(!clusteredLightingEnabled){this.shadowMapCache.clear();}}constructor(device,root,scene,renderer,assets){this.device=device;this.root=root;this.scene=scene;this.renderer=renderer;this.assets=assets;this.shadowMapCache=renderer.shadowMapCache;this._tempSet=new Set;this._initCalled=false;this.passMaterials=[];this.ambientAOMaterial=null;this.fog="";this.ambientLight=new Color;this.renderTargets=new Map;this.stats={renderPasses:0,lightmapCount:0,totalRenderTime:0,forwardTime:0,fboTime:0,shadowMapTime:0,compileTime:0,shadersLinked:0};}}class Component extends EventHandler{static _buildAccessors(obj,schema){schema.forEach(descriptor=>{const name=typeof descriptor==="object"?descriptor.name:descriptor;Object.defineProperty(obj,name,{get:function(){return this.data[name]},set:function(value){const data=this.data;const oldValue=data[name];data[name]=value;this.fire("set",name,oldValue,value);},configurable:true});});obj._accessorsBuilt=true;}buildAccessors(schema){Component._buildAccessors(this,schema);}onSetEnabled(name,oldValue,newValue){if(oldValue!==newValue){if(this.entity.enabled){if(newValue){this.onEnable();}else {this.onDisable();}}}}onEnable(){}onDisable(){}onPostStateChange(){}get data(){const record=this.system.store[this.entity.getGuid()];return record?record.data:null}set enabled(arg){}get enabled(){return true}constructor(system,entity){super();this.system=void 0;this.entity=void 0;this.system=system;this.entity=entity;if(this.system.schema&&!this._accessorsBuilt){this.buildAccessors(this.system.schema);}this.on("set",function(name,oldValue,newValue){this.fire(`set_${name}`,name,oldValue,newValue);});this.on("set_enabled",this.onSetEnabled,this);}}class ComponentSystem extends EventHandler{addComponent(entity,data={}){const component=new this.ComponentType(this,entity);const componentData=new this.DataType;this.store[entity.getGuid()]={entity:entity,data:componentData};entity[this.id]=component;entity.c[this.id]=component;this.initializeComponentData(component,data,[]);this.fire("add",entity,component);return component}removeComponent(entity){const record=this.store[entity.getGuid()];const component=entity.c[this.id];component.fire("beforeremove");this.fire("beforeremove",entity,component);delete this.store[entity.getGuid()];entity[this.id]=undefined;delete entity.c[this.id];this.fire("remove",entity,record.data);}cloneComponent(entity,clone){const src=this.store[entity.getGuid()];return this.addComponent(clone,src.data)}initializeComponentData(component,data={},properties){for(let i=0,len=properties.length;i<len;i++){const descriptor=properties[i];let name,type;if(typeof descriptor==="object"){name=descriptor.name;type=descriptor.type;}else {name=descriptor;type=undefined;}let value=data[name];if(value!==undefined){if(type!==undefined){value=convertValue(value,type);}component[name]=value;}else {component[name]=component.data[name];}}if(component.enabled&&component.entity.enabled){component.onEnable();}}getPropertiesOfType(type){const matchingProperties=[];const schema=this.schema||[];schema.forEach(descriptor=>{if(descriptor&&typeof descriptor==="object"&&descriptor.type===type){matchingProperties.push(descriptor);}});return matchingProperties}destroy(){this.off();}constructor(app){super();this.app=app;this.store={};this.schema=[];}}function convertValue(value,type){if(!value){return value}switch(type){case"rgb":if(value instanceof Color){return value.clone()}return new Color(value[0],value[1],value[2]);case"rgba":if(value instanceof Color){return value.clone()}return new Color(value[0],value[1],value[2],value[3]);case"vec2":if(value instanceof Vec2){return value.clone()}return new Vec2(value[0],value[1]);case"vec3":if(value instanceof Vec3){return value.clone()}return new Vec3(value[0],value[1],value[2]);case"vec4":if(value instanceof Vec4){return value.clone()}return new Vec4(value[0],value[1],value[2],value[3]);case"boolean":case"number":case"string":return value;case"entity":return value;default:throw new Error(`Could not convert unhandled type: ${type}`)}}const INTERPOLATION_STEP=0;const INTERPOLATION_LINEAR=1;const INTERPOLATION_CUBIC=2;class AnimCache{update(time,input){if(time<this._left||time>=this._right){const len=input.length;if(!len){this._left=-Infinity;this._right=Infinity;this._len=0;this._recip=0;this._p0=this._p1=0;}else {if(time<input[0]){this._left=-Infinity;this._right=input[0];this._len=0;this._recip=0;this._p0=this._p1=0;}else if(time>=input[len-1]){this._left=input[len-1];this._right=Infinity;this._len=0;this._recip=0;this._p0=this._p1=len-1;}else {const index=this._findKey(time,input);this._left=input[index];this._right=input[index+1];this._len=this._right-this._left;const diff=1/this._len;this._recip=isFinite(diff)?diff:0;this._p0=index;this._p1=index+1;}}}this._t=this._recip===0?0:(time-this._left)*this._recip;this._hermite.valid=false;}_findKey(time,input){let index=0;while(time>=input[index+1]){index++;}return index}eval(result,interpolation,output){const data=output._data;const comp=output._components;const idx0=this._p0*comp;if(interpolation===INTERPOLATION_STEP){for(let i=0;i<comp;++i){result[i]=data[idx0+i];}}else {const t=this._t;const idx1=this._p1*comp;switch(interpolation){case INTERPOLATION_LINEAR:for(let i=0;i<comp;++i){result[i]=math.lerp(data[idx0+i],data[idx1+i],t);}break;case INTERPOLATION_CUBIC:{const hermite=this._hermite;if(!hermite.valid){const t2=t*t;const twot=t+t;const omt=1-t;const omt2=omt*omt;hermite.valid=true;hermite.p0=(1+twot)*omt2;hermite.m0=t*omt2;hermite.p1=t2*(3-twot);hermite.m1=t2*(t-1);}const p0=(this._p0*3+1)*comp;const m0=(this._p0*3+2)*comp;const p1=(this._p1*3+1)*comp;const m1=(this._p1*3+0)*comp;for(let i=0;i<comp;++i){result[i]=hermite.p0*data[p0+i]+hermite.m0*data[m0+i]*this._len+hermite.p1*data[p1+i]+hermite.m1*data[m1+i]*this._len;}break}}}}constructor(){this._left=Infinity;this._right=-Infinity;this._len=0;this._recip=0;this._p0=0;this._p1=0;this._t=0;this._hermite={valid:false,p0:0,m0:0,p1:0,m1:0};}}class AnimSnapshot{constructor(animTrack){this._name=`${animTrack.name}Snapshot`;this._time=-1;this._cache=[];this._results=[];for(let i=0;i<animTrack._inputs.length;++i){this._cache[i]=new AnimCache;}const curves=animTrack._curves;const outputs=animTrack._outputs;for(let i=0;i<curves.length;++i){const curve=curves[i];const output=outputs[curve._output];const storage=[];for(let j=0;j<output._components;++j){storage[j]=0;}this._results[i]=storage;}}}class AnimClip{set name(name){this._name=name;}get name(){return this._name}set track(track){this._track=track;this._snapshot=new AnimSnapshot(track);}get track(){return this._track}get snapshot(){return this._snapshot}set time(time){this._time=time;this.alignCursorToCurrentTime();}get time(){return this._time}set speed(speed){const signChanged=Math.sign(speed)!==Math.sign(this._speed);this._speed=speed;if(signChanged){this.alignCursorToCurrentTime();}}get speed(){return this._speed}set loop(loop){this._loop=loop;}get loop(){return this._loop}set blendWeight(blendWeight){this._blendWeight=blendWeight;}get blendWeight(){return this._blendWeight}set blendOrder(blendOrder){this._blendOrder=blendOrder;}get blendOrder(){return this._blendOrder}set eventCursor(value){this._eventCursor=value;}get eventCursor(){return this._eventCursor}get eventCursorEnd(){return this.isReverse?0:this._track.events.length-1}get nextEvent(){return this._track.events[this._eventCursor]}get isReverse(){return this._speed<0}nextEventAheadOfTime(time){if(!this.nextEvent)return false;return this.isReverse?this.nextEvent.time<=time:this.nextEvent.time>=time}nextEventBehindTime(time){if(!this.nextEvent)return false;if(time===this.track.duration){return this.isReverse?this.nextEvent.time>=time:this.nextEvent.time<=time}return this.isReverse?this.nextEvent.time>time:this.nextEvent.time<time}resetEventCursor(){this._eventCursor=this.isReverse?this._track.events.length-1:0;}moveEventCursor(){this._eventCursor+=this.isReverse?-1:1;if(this._eventCursor>=this.track.events.length){this._eventCursor=0;}else if(this._eventCursor<0){this._eventCursor=this.track.events.length-1;}}clipFrameTime(frameEndTime){const eventFrame=AnimClip.eventFrame;eventFrame.start=0;eventFrame.end=frameEndTime;eventFrame.residual=0;if(this.isReverse){if(frameEndTime<0){eventFrame.start=this.track.duration;eventFrame.end=0;eventFrame.residual=frameEndTime+this.track.duration;}}else {if(frameEndTime>this.track.duration){eventFrame.start=0;eventFrame.end=this.track.duration;eventFrame.residual=frameEndTime-this.track.duration;}}}alignCursorToCurrentTime(){this.resetEventCursor();while(this.nextEventBehindTime(this._time)&&this._eventCursor!==this.eventCursorEnd){this.moveEventCursor();}}fireNextEvent(){this._eventHandler.fire(this.nextEvent.name,_extends({track:this.track},this.nextEvent));this.moveEventCursor();}fireNextEventInFrame(frameStartTime,frameEndTime){if(this.nextEventAheadOfTime(frameStartTime)&&this.nextEventBehindTime(frameEndTime)){this.fireNextEvent();return true}return false}activeEventsForFrame(frameStartTime,frameEndTime){const eventFrame=AnimClip.eventFrame;this.clipFrameTime(frameEndTime);const initialCursor=this.eventCursor;while(this.fireNextEventInFrame(frameStartTime,eventFrame.end)){if(initialCursor===this.eventCursor){break}}if(this.loop&&Math.abs(eventFrame.residual)>0){this.activeEventsForFrame(eventFrame.start,eventFrame.residual);}}progressForTime(time){return time*this._speed/this._track.duration}_update(deltaTime){if(this._playing){let time=this._time;const duration=this._track.duration;const speed=this._speed;const loop=this._loop;if(this._track.events.length>0&&duration>0){this.activeEventsForFrame(time,time+speed*deltaTime);}time+=speed*deltaTime;if(speed>=0){if(time>duration){if(loop){time=time%duration||0;}else {time=this._track.duration;this.pause();}}}else {if(time<0){if(loop){time=duration+(time%duration||0);}else {time=0;this.pause();}}}this._time=time;}if(this._time!==this._snapshot._time){this._track.eval(this._time,this._snapshot);}}play(){this._playing=true;this._time=0;}stop(){this._playing=false;this._time=0;}pause(){this._playing=false;}resume(){this._playing=true;}reset(){this._time=0;}constructor(track,time,speed,playing,loop,eventHandler){this._name=track.name;this._track=track;this._snapshot=new AnimSnapshot(track);this._playing=playing;this._time=time;this._speed=speed;this._loop=loop;this._blendWeight=1;this._blendOrder=0;this._eventHandler=eventHandler;this.alignCursorToCurrentTime();}}AnimClip.eventFrame={start:0,end:0,residual:0};const ANIM_INTERRUPTION_NONE="NONE";const ANIM_INTERRUPTION_PREV="PREV_STATE";const ANIM_INTERRUPTION_NEXT="NEXT_STATE";const ANIM_INTERRUPTION_PREV_NEXT="PREV_STATE_NEXT_STATE";const ANIM_INTERRUPTION_NEXT_PREV="NEXT_STATE_PREV_STATE";const ANIM_GREATER_THAN="GREATER_THAN";const ANIM_LESS_THAN="LESS_THAN";const ANIM_GREATER_THAN_EQUAL_TO="GREATER_THAN_EQUAL_TO";const ANIM_LESS_THAN_EQUAL_TO="LESS_THAN_EQUAL_TO";const ANIM_EQUAL_TO="EQUAL_TO";const ANIM_NOT_EQUAL_TO="NOT_EQUAL_TO";const ANIM_PARAMETER_INTEGER="INTEGER";const ANIM_PARAMETER_FLOAT="FLOAT";const ANIM_PARAMETER_BOOLEAN="BOOLEAN";const ANIM_PARAMETER_TRIGGER="TRIGGER";const ANIM_BLEND_1D="1D";const ANIM_BLEND_2D_DIRECTIONAL="2D_DIRECTIONAL";const ANIM_BLEND_2D_CARTESIAN="2D_CARTESIAN";const ANIM_BLEND_DIRECT="DIRECT";const ANIM_STATE_START="START";const ANIM_STATE_END="END";const ANIM_STATE_ANY="ANY";const ANIM_CONTROL_STATES=[ANIM_STATE_START,ANIM_STATE_END,ANIM_STATE_ANY];const ANIM_LAYER_OVERWRITE="OVERWRITE";const ANIM_LAYER_ADDITIVE="ADDITIVE";class AnimBlend{static dot(a,b){const len=a.length;let result=0;for(let i=0;i<len;++i){result+=a[i]*b[i];}return result}static normalize(a){let l=AnimBlend.dot(a,a);if(l>0){l=1/Math.sqrt(l);const len=a.length;for(let i=0;i<len;++i){a[i]*=l;}}}static set(a,b,type){const len=a.length;if(type==="quaternion"){let l=AnimBlend.dot(b,b);if(l>0){l=1/Math.sqrt(l);}for(let i=0;i<len;++i){a[i]=b[i]*l;}}else {for(let i=0;i<len;++i){a[i]=b[i];}}}static blendVec(a,b,t,additive){const it=additive?1:1-t;const len=a.length;for(let i=0;i<len;++i){a[i]=a[i]*it+b[i]*t;}}static blendQuat(a,b,t,additive){const len=a.length;const it=additive?1:1-t;if(AnimBlend.dot(a,b)<0){t=-t;}for(let i=0;i<len;++i){a[i]=a[i]*it+b[i]*t;}if(!additive){AnimBlend.normalize(a);}}static blend(a,b,t,type,additive){if(type==="quaternion"){AnimBlend.blendQuat(a,b,t,additive);}else {AnimBlend.blendVec(a,b,t,additive);}}static stableSort(a,lessFunc){const len=a.length;for(let i=0;i<len-1;++i){for(let j=i+1;j<len;++j){if(lessFunc(a[j],a[i])){const tmp=a[i];a[i]=a[j];a[j]=tmp;}}}}}class AnimTargetValue{get _normalizeWeights(){return this._component.normalizeWeights}getWeight(index){if(this.dirty)this.updateWeights();if(this._normalizeWeights&&this.totalWeight===0||!this.mask[index]){return 0}else if(this._normalizeWeights){return this.weights[index]/this.totalWeight}return math.clamp(this.weights[index],0,1)}_layerBlendType(index){return this._component.layers[index].blendType}setMask(index,value){this.mask[index]=value;if(this._normalizeWeights){if(this._component.layers[index].blendType===ANIM_LAYER_OVERWRITE){this.mask=this.mask.fill(0,0,index);}this.dirty=true;}}updateWeights(){this.totalWeight=0;for(let i=0;i<this.weights.length;i++){this.weights[i]=this._component.layers[i].weight;this.totalWeight+=this.mask[i]*this.weights[i];}this.dirty=false;}updateValue(index,value){if(this.counter===0){AnimBlend.set(this.value,AnimTargetValue.IDENTITY_QUAT_ARR,this.valueType);if(!this._normalizeWeights){AnimBlend.blend(this.value,this.baseValue,1,this.valueType);}}if(!this.mask[index]||this.getWeight(index)===0)return;if(this._layerBlendType(index)===ANIM_LAYER_ADDITIVE&&!this._normalizeWeights){if(this.valueType===AnimTargetValue.TYPE_QUAT){const v=AnimTargetValue.q1.set(this.value[0],this.value[1],this.value[2],this.value[3]);const aV1=AnimTargetValue.q2.set(this.baseValue[0],this.baseValue[1],this.baseValue[2],this.baseValue[3]);const aV2=AnimTargetValue.q3.set(value[0],value[1],value[2],value[3]);const aV=aV1.invert().mul(aV2);aV.slerp(Quat.IDENTITY,aV,this.getWeight(index));v.mul(aV);AnimTargetValue.quatArr[0]=v.x;AnimTargetValue.quatArr[1]=v.y;AnimTargetValue.quatArr[2]=v.z;AnimTargetValue.quatArr[3]=v.w;AnimBlend.set(this.value,AnimTargetValue.quatArr,this.valueType);}else {AnimTargetValue.vecArr[0]=value[0]-this.baseValue[0];AnimTargetValue.vecArr[1]=value[1]-this.baseValue[1];AnimTargetValue.vecArr[2]=value[2]-this.baseValue[2];AnimBlend.blend(this.value,AnimTargetValue.vecArr,this.getWeight(index),this.valueType,true);}}else {AnimBlend.blend(this.value,value,this.getWeight(index),this.valueType);}if(this.setter)this.setter(this.value);}unbind(){if(this.setter){this.setter(this.baseValue);}}constructor(component,type){this._component=component;this.mask=new Int8Array(component.layers.length);this.weights=new Float32Array(component.layers.length);this.totalWeight=0;this.counter=0;this.layerCounter=0;this.valueType=type;this.dirty=true;this.value=type===AnimTargetValue.TYPE_QUAT?[0,0,0,1]:[0,0,0];this.baseValue=null;this.setter=null;}}AnimTargetValue.TYPE_QUAT="quaternion";AnimTargetValue.TYPE_VEC3="vector3";AnimTargetValue.q1=new Quat;AnimTargetValue.q2=new Quat;AnimTargetValue.q3=new Quat;AnimTargetValue.quatArr=[0,0,0,1];AnimTargetValue.vecArr=[0,0,0];AnimTargetValue.IDENTITY_QUAT_ARR=[0,0,0,1];class AnimEvaluator{get clips(){return this._clips}addClip(clip){const targets=this._targets;const binder=this._binder;const curves=clip.track.curves;const snapshot=clip.snapshot;const inputs=[];const outputs=[];for(let i=0;i<curves.length;++i){const curve=curves[i];const paths=curve.paths;for(let j=0;j<paths.length;++j){const path=paths[j];const resolved=binder.resolve(path);let target=targets[resolved&&resolved.targetPath||null];if(!target&&resolved){target={target:resolved,value:[],curves:0,blendCounter:0};for(let k=0;k<target.target.components;++k){target.value.push(0);}targets[resolved.targetPath]=target;if(binder.animComponent){if(!binder.animComponent.targets[resolved.targetPath]){let type;if(resolved.targetPath.substring(resolved.targetPath.length-13)==="localRotation"){type=AnimTargetValue.TYPE_QUAT;}else {type=AnimTargetValue.TYPE_VEC3;}binder.animComponent.targets[resolved.targetPath]=new AnimTargetValue(binder.animComponent,type);}binder.animComponent.targets[resolved.targetPath].layerCounter++;binder.animComponent.targets[resolved.targetPath].setMask(binder.layerIndex,1);}}if(target){target.curves++;inputs.push(snapshot._results[i]);outputs.push(target);}}}this._clips.push(clip);this._inputs.push(inputs);this._outputs.push(outputs);}removeClip(index){const targets=this._targets;const binder=this._binder;const clips=this._clips;const clip=clips[index];const curves=clip.track.curves;for(let i=0;i<curves.length;++i){const curve=curves[i];const paths=curve.paths;for(let j=0;j<paths.length;++j){const path=paths[j];const target=this._binder.resolve(path);if(target){target.curves--;if(target.curves===0){binder.unresolve(path);delete targets[target.targetPath];if(binder.animComponent){binder.animComponent.targets[target.targetPath].layerCounter--;}}}}}clips.splice(index,1);this._inputs.splice(index,1);this._outputs.splice(index,1);}removeClips(){while(this._clips.length>0){this.removeClip(0);}}updateClipTrack(name,animTrack){this._clips.forEach(clip=>{if(clip.name.includes(name)){clip.track=animTrack;}});this.rebind();}findClip(name){const clips=this._clips;for(let i=0;i<clips.length;++i){const clip=clips[i];if(clip.name===name){return clip}}return null}rebind(){this._binder.rebind();this._targets={};const clips=[...this.clips];this.removeClips();clips.forEach(clip=>{this.addClip(clip);});}assignMask(mask){return this._binder.assignMask(mask)}update(deltaTime,outputAnimation=true){const clips=this._clips;const order=clips.map((c,i)=>{return i});AnimBlend.stableSort(order,(a,b)=>{return clips[a].blendOrder<clips[b].blendOrder});for(let i=0;i<order.length;++i){const index=order[i];const clip=clips[index];const inputs=this._inputs[index];const outputs=this._outputs[index];const blendWeight=clip.blendWeight;if(blendWeight>0){clip._update(deltaTime);}if(!outputAnimation)break;let input;let output;let value;if(blendWeight>=1){for(let j=0;j<inputs.length;++j){input=inputs[j];output=outputs[j];value=output.value;AnimBlend.set(value,input,output.target.type);output.blendCounter++;}}else if(blendWeight>0){for(let j=0;j<inputs.length;++j){input=inputs[j];output=outputs[j];value=output.value;if(output.blendCounter===0){AnimBlend.set(value,input,output.target.type);}else {AnimBlend.blend(value,input,blendWeight,output.target.type);}output.blendCounter++;}}}const targets=this._targets;const binder=this._binder;for(const path in targets){if(targets.hasOwnProperty(path)){const target=targets[path];if(binder.animComponent&&target.target.isTransform){const animTarget=binder.animComponent.targets[path];if(animTarget.counter===animTarget.layerCounter){animTarget.counter=0;}if(!animTarget.path){animTarget.path=path;animTarget.baseValue=target.target.get();animTarget.setter=target.target.set;}animTarget.updateValue(binder.layerIndex,target.value);animTarget.counter++;}else {target.target.set(target.value);}target.blendCounter=0;}}this._binder.update(deltaTime);}constructor(binder){this._binder=binder;this._clips=[];this._inputs=[];this._outputs=[];this._targets={};}}class AnimEvents{get events(){return this._events}constructor(events){this._events=[...events];this._events.sort((a,b)=>a.time-b.time);}}var _AnimTrack;class AnimTrack{get name(){return this._name}get duration(){return this._duration}get inputs(){return this._inputs}get outputs(){return this._outputs}get curves(){return this._curves}set events(animEvents){this._animEvents=animEvents;}get events(){return this._animEvents.events}eval(time,snapshot){snapshot._time=time;const inputs=this._inputs;const outputs=this._outputs;const curves=this._curves;const cache=snapshot._cache;const results=snapshot._results;for(let i=0;i<inputs.length;++i){cache[i].update(time,inputs[i]._data);}for(let i=0;i<curves.length;++i){const curve=curves[i];const output=outputs[curve._output];const result=results[i];cache[curve._input].eval(result,curve._interpolation,output);}}constructor(name,duration,inputs,outputs,curves,animEvents=new AnimEvents([])){this._name=name;this._duration=duration;this._inputs=inputs;this._outputs=outputs;this._curves=curves;this._animEvents=animEvents;}}_AnimTrack=AnimTrack;AnimTrack.EMPTY=Object.freeze(new _AnimTrack("empty",Number.MAX_VALUE,[],[],[]));class AnimBinder{static joinPath(pathSegments,character){character=character||".";const escape1=function escape1(string){return string.replace(/\\/g,"\\\\").replace(new RegExp(`\\${character}`,"g"),`\\${character}`)};return pathSegments.map(escape1).join(character)}static splitPath(path,character){character=character||".";const result=[];let curr="";let i=0;while(i<path.length){let c=path[i++];if(c==="\\"&&i<path.length){c=path[i++];if(c==="\\"||c===character){curr+=c;}else {curr+=`\\${c}`;}}else if(c===character){result.push(curr);curr="";}else {curr+=c;}}if(curr.length>0){result.push(curr);}return result}static encode(entityPath,component,propertyPath){return `${Array.isArray(entityPath)?entityPath.join("/"):entityPath}/${component}/${Array.isArray(propertyPath)?propertyPath.join("/"):propertyPath}`}resolve(path){return null}unresolve(path){}update(deltaTime){}}class AnimTarget{get set(){return this._set}get get(){return this._get}get type(){return this._type}get components(){return this._components}get targetPath(){return this._targetPath}get isTransform(){return this._isTransform}constructor(func,type,components,targetPath){if(func.set){this._set=func.set;this._get=func.get;}else {this._set=func;}this._type=type;this._components=components;this._targetPath=targetPath;this._isTransform=this._targetPath.substring(this._targetPath.length-13)==="localRotation"||this._targetPath.substring(this._targetPath.length-13)==="localPosition"||this._targetPath.substring(this._targetPath.length-10)==="localScale";}}class DefaultAnimBinder{_isPathActive(path){if(!this._mask)return true;const rootNodeNames=[path.entityPath[0],this.graph.name];for(let j=0;j<rootNodeNames.length;++j){let currEntityPath=rootNodeNames[j];if(this._isPathInMask(currEntityPath,path.entityPath.length===1))return true;for(let i=1;i<path.entityPath.length;i++){currEntityPath+=`/${path.entityPath[i]}`;if(this._isPathInMask(currEntityPath,i===path.entityPath.length-1))return true}}return false}findNode(path){if(!this._isPathActive(path)){return null}let node;if(this.graph){node=this.graph.findByPath(path.entityPath);if(!node){node=this.graph.findByPath(path.entityPath.slice(1));}}if(!node){node=this.nodes[path.entityPath[path.entityPath.length-1]||""];}return node}static createAnimTarget(func,type,valueCount,node,propertyPath,componentType){const targetPath=AnimBinder.encode(node.path,componentType?componentType:"entity",propertyPath);return new AnimTarget(func,type,valueCount,targetPath)}resolve(path){const encodedPath=AnimBinder.encode(path.entityPath,path.component,path.propertyPath);let target=this.targetCache[encodedPath];if(target)return target;const node=this.findNode(path);if(!node){return null}const handler=this.handlers[path.propertyPath];if(!handler){return null}target=handler(node);if(!target){return null}this.targetCache[encodedPath]=target;if(!this.nodeCounts[node.path]){this.activeNodes.push(node);this.nodeCounts[node.path]=1;}else {this.nodeCounts[node.path]++;}return target}unresolve(path){if(path.component!=="graph"){return}const node=this.nodes[path.entityPath[path.entityPath.length-1]||""];this.nodeCounts[node.path]--;if(this.nodeCounts[node.path]===0){const activeNodes=this.activeNodes;const i=activeNodes.indexOf(node.node);const len=activeNodes.length;if(i<len-1){activeNodes[i]=activeNodes[len-1];}activeNodes.pop();}}update(deltaTime){const activeNodes=this.activeNodes;for(let i=0;i<activeNodes.length;++i){activeNodes[i]._dirtifyLocal();}}assignMask(mask){if(mask!==this._mask){this._mask=mask;return true}return false}constructor(graph){this._isPathInMask=(path,checkMaskValue)=>{const maskItem=this._mask[path];if(!maskItem)return false;else if(maskItem.children||checkMaskValue&&maskItem.value!==false)return true;return false};this.graph=graph;if(!graph)return;this._mask=null;const nodes={};const flatten=function flatten(node){nodes[node.name]=node;for(let i=0;i<node.children.length;++i){flatten(node.children[i]);}};flatten(graph);this.nodes=nodes;this.targetCache={};const findMeshInstances=function findMeshInstances(node){let object=node;while(object&&!(object instanceof Entity)){object=object.parent;}let meshInstances;if(object){if(object.render){meshInstances=object.render.meshInstances;}else if(object.model){meshInstances=object.model.meshInstances;}}return meshInstances};this.nodeCounts={};this.activeNodes=[];this.handlers={"localPosition":function(node){const object=node.localPosition;const func=function func(value){object.set(...value);};return DefaultAnimBinder.createAnimTarget(func,"vector",3,node,"localPosition")},"localRotation":function(node){const object=node.localRotation;const func=function func(value){object.set(...value);};return DefaultAnimBinder.createAnimTarget(func,"quaternion",4,node,"localRotation")},"localScale":function(node){const object=node.localScale;const func=function func(value){object.set(...value);};return DefaultAnimBinder.createAnimTarget(func,"vector",3,node,"localScale")},"weight":function(node,weightName){if(weightName.indexOf("name.")===0){weightName=weightName.replace("name.","");}else {weightName=Number(weightName);}const meshInstances=findMeshInstances(node);let setters;if(meshInstances){for(let i=0;i<meshInstances.length;++i){if(meshInstances[i].node.name===node.name&&meshInstances[i].morphInstance){const morphInstance=meshInstances[i].morphInstance;const func=value=>{morphInstance.setWeight(weightName,value[0]);};if(!setters)setters=[];setters.push(func);}}}if(setters){const callSetters=value=>{for(let i=0;i<setters.length;++i){setters[i](value);}};return DefaultAnimBinder.createAnimTarget(callSetters,"number",1,node,`weight.${weightName}`)}return null},"materialTexture":(node,textureName)=>{const meshInstances=findMeshInstances(node);if(meshInstances){let meshInstance;for(let i=0;i<meshInstances.length;++i){if(meshInstances[i].node.name===node.name){meshInstance=meshInstances[i];break}}if(meshInstance){const func=value=>{const textureAsset=this.animComponent.system.app.assets.get(value[0]);if(textureAsset&&textureAsset.resource&&textureAsset.type==="texture"){meshInstance.material[textureName]=textureAsset.resource;meshInstance.material.update();}};return DefaultAnimBinder.createAnimTarget(func,"vector",1,node,"materialTexture","material")}}return null}};}}class AnimationComponent extends Component{set animations(value){this._animations=value;this.onSetAnimations();}get animations(){return this._animations}set assets(value){const assets=this._assets;if(assets&&assets.length){for(let i=0;i<assets.length;i++){if(assets[i]){const asset=this.system.app.assets.get(assets[i]);if(asset){asset.off("change",this.onAssetChanged,this);asset.off("remove",this.onAssetRemoved,this);const animName=this.animationsIndex[asset.id];if(this.currAnim===animName){this._stopCurrentAnimation();}delete this.animations[animName];delete this.animationsIndex[asset.id];}}}}this._assets=value;const assetIds=value.map(value=>{return value instanceof Asset?value.id:value});this.loadAnimationAssets(assetIds);}get assets(){return this._assets}set currentTime(currentTime){if(this.skeleton){this.skeleton.currentTime=currentTime;this.skeleton.addTime(0);this.skeleton.updateGraph();}if(this.animEvaluator){const clips=this.animEvaluator.clips;for(let i=0;i<clips.length;++i){clips[i].time=currentTime;}}}get currentTime(){if(this.skeleton){return this.skeleton._time}if(this.animEvaluator){const clips=this.animEvaluator.clips;if(clips.length>0){return clips[clips.length-1].time}}return 0}get duration(){if(this.currAnim){return this.animations[this.currAnim].duration}return 0}set loop(value){this._loop=value;if(this.skeleton){this.skeleton.looping=value;}if(this.animEvaluator){for(let i=0;i<this.animEvaluator.clips.length;++i){this.animEvaluator.clips[i].loop=value;}}}get loop(){return this._loop}play(name,blendTime=0){if(!this.enabled||!this.entity.enabled){return}if(!this.animations[name]){return}this.prevAnim=this.currAnim;this.currAnim=name;if(this.model){if(!this.skeleton&&!this.animEvaluator){this._createAnimationController();}const prevAnim=this.animations[this.prevAnim];const currAnim=this.animations[this.currAnim];this.blending=blendTime>0&&!!this.prevAnim;if(this.blending){this.blend=0;this.blendSpeed=1/blendTime;}if(this.skeleton){if(this.blending){this.fromSkel.animation=prevAnim;this.fromSkel.addTime(this.skeleton._time);this.toSkel.animation=currAnim;}else {this.skeleton.animation=currAnim;}}if(this.animEvaluator){const animEvaluator=this.animEvaluator;if(this.blending){while(animEvaluator.clips.length>1){animEvaluator.removeClip(0);}}else {this.animEvaluator.removeClips();}const clip=new AnimClip(this.animations[this.currAnim],0,1,true,this.loop);clip.name=this.currAnim;clip.blendWeight=this.blending?0:1;clip.reset();this.animEvaluator.addClip(clip);}}this.playing=true;}getAnimation(name){return this.animations[name]}setModel(model){if(model!==this.model){this._resetAnimationController();this.model=model;if(this.animations&&this.currAnim&&this.animations[this.currAnim]){this.play(this.currAnim);}}}onSetAnimations(){const modelComponent=this.entity.model;if(modelComponent){const m=modelComponent.model;if(m&&m!==this.model){this.setModel(m);}}if(!this.currAnim&&this.activate&&this.enabled&&this.entity.enabled){const animationNames=Object.keys(this._animations);if(animationNames.length>0){this.play(animationNames[0]);}}}_resetAnimationController(){this.skeleton=null;this.fromSkel=null;this.toSkel=null;this.animEvaluator=null;}_createAnimationController(){const model=this.model;const animations=this.animations;let hasJson=false;let hasGlb=false;for(const animation in animations){if(animations.hasOwnProperty(animation)){const anim=animations[animation];if(anim.constructor===AnimTrack){hasGlb=true;}else {hasJson=true;}}}const graph=model.getGraph();if(hasJson){this.fromSkel=new Skeleton(graph);this.toSkel=new Skeleton(graph);this.skeleton=new Skeleton(graph);this.skeleton.looping=this.loop;this.skeleton.setGraph(graph);}else if(hasGlb){this.animEvaluator=new AnimEvaluator(new DefaultAnimBinder(this.entity));}}loadAnimationAssets(ids){if(!ids||!ids.length){return}const assets=this.system.app.assets;const onAssetReady=asset=>{if(asset.resources.length>1){for(let i=0;i<asset.resources.length;i++){this.animations[asset.resources[i].name]=asset.resources[i];this.animationsIndex[asset.id]=asset.resources[i].name;}}else {this.animations[asset.name]=asset.resource;this.animationsIndex[asset.id]=asset.name;}this.animations=this.animations;};const onAssetAdd=asset=>{asset.off("change",this.onAssetChanged,this);asset.on("change",this.onAssetChanged,this);asset.off("remove",this.onAssetRemoved,this);asset.on("remove",this.onAssetRemoved,this);if(asset.resource){onAssetReady(asset);}else {asset.once("load",onAssetReady,this);if(this.enabled&&this.entity.enabled){assets.load(asset);}}};for(let i=0,l=ids.length;i<l;i++){const asset=assets.get(ids[i]);if(asset){onAssetAdd(asset);}else {assets.on(`add:${ids[i]}`,onAssetAdd);}}}onAssetChanged(asset,attribute,newValue,oldValue){if(attribute==="resource"||attribute==="resources"){if(attribute==="resources"&&newValue&&newValue.length===0){newValue=null;}if(newValue){let restarted=false;if(newValue.length>1){if(oldValue&&oldValue.length>1){for(let i=0;i<oldValue.length;i++){delete this.animations[oldValue[i].name];}}else {delete this.animations[asset.name];}restarted=false;for(let i=0;i<newValue.length;i++){this.animations[newValue[i].name]=newValue[i];if(!restarted&&this.currAnim===newValue[i].name){if(this.playing&&this.enabled&&this.entity.enabled){restarted=true;this.play(newValue[i].name);}}}if(!restarted){this._stopCurrentAnimation();this.onSetAnimations();}}else {if(oldValue&&oldValue.length>1){for(let i=0;i<oldValue.length;i++){delete this.animations[oldValue[i].name];}}this.animations[asset.name]=newValue[0]||newValue;restarted=false;if(this.currAnim===asset.name){if(this.playing&&this.enabled&&this.entity.enabled){restarted=true;this.play(asset.name);}}if(!restarted){this._stopCurrentAnimation();this.onSetAnimations();}}this.animationsIndex[asset.id]=asset.name;}else {if(oldValue.length>1){for(let i=0;i<oldValue.length;i++){delete this.animations[oldValue[i].name];if(this.currAnim===oldValue[i].name){this._stopCurrentAnimation();}}}else {delete this.animations[asset.name];if(this.currAnim===asset.name){this._stopCurrentAnimation();}}delete this.animationsIndex[asset.id];}}}onAssetRemoved(asset){asset.off("remove",this.onAssetRemoved,this);if(this.animations){if(asset.resources.length>1){for(let i=0;i<asset.resources.length;i++){delete this.animations[asset.resources[i].name];if(this.currAnim===asset.resources[i].name){this._stopCurrentAnimation();}}}else {delete this.animations[asset.name];if(this.currAnim===asset.name){this._stopCurrentAnimation();}}delete this.animationsIndex[asset.id];}}_stopCurrentAnimation(){this.currAnim=null;this.playing=false;if(this.skeleton){this.skeleton.currentTime=0;this.skeleton.animation=null;}if(this.animEvaluator){for(let i=0;i<this.animEvaluator.clips.length;++i){this.animEvaluator.clips[i].stop();}this.animEvaluator.update(0);this.animEvaluator.removeClips();}}onEnable(){super.onEnable();const assets=this.assets;const registry=this.system.app.assets;if(assets){for(let i=0,len=assets.length;i<len;i++){let asset=assets[i];if(!(asset instanceof Asset)){asset=registry.get(asset);}if(asset&&!asset.resource){registry.load(asset);}}}if(this.activate&&!this.currAnim){const animationNames=Object.keys(this.animations);if(animationNames.length>0){this.play(animationNames[0]);}}}onBeforeRemove(){for(let i=0;i<this.assets.length;i++){let asset=this.assets[i];if(typeof asset==="number"){asset=this.system.app.assets.get(asset);}if(!asset)continue;asset.off("change",this.onAssetChanged,this);asset.off("remove",this.onAssetRemoved,this);}this.skeleton=null;this.fromSkel=null;this.toSkel=null;this.animEvaluator=null;}update(dt){if(this.blending){this.blend+=dt*this.blendSpeed;if(this.blend>=1){this.blend=1;}}if(this.playing){const skeleton=this.skeleton;if(skeleton!==null&&this.model!==null){if(this.blending){skeleton.blend(this.fromSkel,this.toSkel,this.blend);}else {const delta=dt*this.speed;skeleton.addTime(delta);if(this.speed>0&&skeleton._time===skeleton.animation.duration&&!this.loop){this.playing=false;}else if(this.speed<0&&skeleton._time===0&&!this.loop){this.playing=false;}}if(this.blending&&this.blend===1){skeleton.animation=this.toSkel.animation;}skeleton.updateGraph();}}const animEvaluator=this.animEvaluator;if(animEvaluator){for(let i=0;i<animEvaluator.clips.length;++i){const clip=animEvaluator.clips[i];clip.speed=this.speed;if(!this.playing){clip.pause();}else {clip.resume();}}if(this.blending&&animEvaluator.clips.length>1){animEvaluator.clips[1].blendWeight=this.blend;}animEvaluator.update(dt);}if(this.blending&&this.blend===1){this.blending=false;}}constructor(system,entity){super(system,entity);this._animations={};this._assets=[];this._loop=true;this.animEvaluator=null;this.model=null;this.skeleton=null;this.fromSkel=null;this.toSkel=null;this.animationsIndex={};this.prevAnim=null;this.currAnim=null;this.blend=0;this.blending=false;this.blendSpeed=0;this.activate=true;this.speed=1;}}class AnimationComponentData{constructor(){this.enabled=true;}}const _schema$m=["enabled"];class AnimationComponentSystem extends ComponentSystem{initializeComponentData(component,data,properties){properties=["activate","enabled","loop","speed","assets"];for(const property of properties){if(data.hasOwnProperty(property)){component[property]=data[property];}}super.initializeComponentData(component,data,_schema$m);}cloneComponent(entity,clone){this.addComponent(clone,{});clone.animation.assets=entity.animation.assets.slice();clone.animation.speed=entity.animation.speed;clone.animation.loop=entity.animation.loop;clone.animation.activate=entity.animation.activate;clone.animation.enabled=entity.animation.enabled;const clonedAnimations={};const animations=entity.animation.animations;for(const key in animations){if(animations.hasOwnProperty(key)){clonedAnimations[key]=animations[key];}}clone.animation.animations=clonedAnimations;const clonedAnimationsIndex={};const animationsIndex=entity.animation.animationsIndex;for(const key in animationsIndex){if(animationsIndex.hasOwnProperty(key)){clonedAnimationsIndex[key]=animationsIndex[key];}}clone.animation.animationsIndex=clonedAnimationsIndex;return clone.animation}onBeforeRemove(entity,component){component.onBeforeRemove();}onUpdate(dt){const components=this.store;for(const id in components){if(components.hasOwnProperty(id)){const component=components[id];if(component.data.enabled&&component.entity.enabled){component.entity.animation.update(dt);}}}}destroy(){super.destroy();this.app.systems.off("update",this.onUpdate,this);}constructor(app){super(app);this.id="animation";this.ComponentType=AnimationComponent;this.DataType=AnimationComponentData;this.schema=_schema$m;this.on("beforeremove",this.onBeforeRemove,this);this.app.systems.on("update",this.onUpdate,this);}}Component._buildAccessors(AnimationComponent.prototype,_schema$m);class AnimNode{get parent(){return this._parent}get name(){return this._name}get path(){return this._parent?`${this._parent.path}.${this._name}`:this._name}get point(){return this._point}get pointLength(){return this._pointLength}set weight(value){this._weight=value;}get weight(){return this._parent?this._parent.weight*this._weight:this._weight}get normalizedWeight(){const totalWeight=this._state.totalWeight;if(totalWeight===0)return 0;return this.weight/totalWeight}get speed(){return this._weightedSpeed*this._speed}get absoluteSpeed(){return Math.abs(this._speed)}set weightedSpeed(weightedSpeed){this._weightedSpeed=weightedSpeed;}get weightedSpeed(){return this._weightedSpeed}set animTrack(value){this._animTrack=value;}get animTrack(){return this._animTrack}constructor(state,parent,name,point,speed=1){this._state=state;this._parent=parent;this._name=name;if(Array.isArray(point)){this._point=new Vec2(point[0],point[1]);this._pointLength=this._point.length();}else {this._point=point;this._pointLength=point;}this._speed=speed;this._weightedSpeed=1;this._weight=1;this._animTrack=null;}}class AnimBlendTree extends AnimNode{get weight(){this.calculateWeights();return this._parent?this._parent.weight*this._weight:this._weight}get syncAnimations(){return this._syncAnimations}getChild(name){for(let i=0;i<this._children.length;i++){if(this._children[i].name===name)return this._children[i]}return null}updateParameterValues(){let paramsEqual=true;for(let i=0;i<this._parameterValues.length;i++){const updatedParameter=this._findParameter(this._parameters[i]).value;if(this._parameterValues[i]!==updatedParameter){this._parameterValues[i]=updatedParameter;paramsEqual=false;}}return paramsEqual}getNodeWeightedDuration(i){return this._children[i].animTrack.duration/this._children[i].speedMultiplier*this._children[i].weight}getNodeCount(){let count=0;for(let i=0;i<this._children.length;i++){const child=this._children[i];if(child.constructor===AnimBlendTree){count+=this._children[i].getNodeCount();}else {count++;}}return count}constructor(state,parent,name,point,parameters,children,syncAnimations,createTree,findParameter){super(state,parent,name,point);this._parameters=parameters;this._parameterValues=new Array(parameters.length);this._children=[];this._findParameter=findParameter;this._syncAnimations=syncAnimations!==false;this._pointCache={};for(let i=0;i<children.length;i++){const child=children[i];if(child.children){this._children.push(createTree(child.type,state,this,child.name,1,child.parameter?[child.parameter]:child.parameters,child.children,child.syncAnimations,createTree,findParameter));}else {this._children.push(new AnimNode(state,this,child.name,child.point,child.speed));}}}}class AnimBlendTree1D extends AnimBlendTree{calculateWeights(){if(this.updateParameterValues())return;let weightedDurationSum=0;this._children[0].weight=0;for(let i=0;i<this._children.length;i++){const c1=this._children[i];if(i!==this._children.length-1){const c2=this._children[i+1];if(c1.point===c2.point){c1.weight=.5;c2.weight=.5;}else if(math.between(this._parameterValues[0],c1.point,c2.point,true)){const child2Distance=Math.abs(c1.point-c2.point);const parameterDistance=Math.abs(c1.point-this._parameterValues[0]);const weight=(child2Distance-parameterDistance)/child2Distance;c1.weight=weight;c2.weight=1-weight;}else {c2.weight=0;}}if(this._syncAnimations){weightedDurationSum+=c1.animTrack.duration/c1.absoluteSpeed*c1.weight;}}if(this._syncAnimations){for(let i=0;i<this._children.length;i++){const child=this._children[i];child.weightedSpeed=child.animTrack.duration/child.absoluteSpeed/weightedDurationSum;}}}constructor(state,parent,name,point,parameters,children,syncAnimations,createTree,findParameter){children.sort((a,b)=>a.point-b.point);super(state,parent,name,point,parameters,children,syncAnimations,createTree,findParameter);}}class AnimBlendTreeCartesian2D extends AnimBlendTree{pointDistanceCache(i,j){const pointKey=`${i}${j}`;if(!this._pointCache[pointKey]){this._pointCache[pointKey]=this._children[j].point.clone().sub(this._children[i].point);}return this._pointCache[pointKey]}calculateWeights(){if(this.updateParameterValues())return;let weightSum,weightedDurationSum;AnimBlendTreeCartesian2D._p.set(...this._parameterValues);weightSum=0;weightedDurationSum=0;for(let i=0;i<this._children.length;i++){const child=this._children[i];const pi=child.point;AnimBlendTreeCartesian2D._pip.set(AnimBlendTreeCartesian2D._p.x,AnimBlendTreeCartesian2D._p.y).sub(pi);let minj=Number.MAX_VALUE;for(let j=0;j<this._children.length;j++){if(i===j)continue;const pipj=this.pointDistanceCache(i,j);const result=math.clamp(1-AnimBlendTreeCartesian2D._pip.dot(pipj)/pipj.lengthSq(),0,1);if(result<minj)minj=result;}child.weight=minj;weightSum+=minj;if(this._syncAnimations){weightedDurationSum+=child.animTrack.duration/child.absoluteSpeed*child.weight;}}for(let i=0;i<this._children.length;i++){const child=this._children[i];child.weight=child._weight/weightSum;if(this._syncAnimations){child.weightedSpeed=child.animTrack.duration/child.absoluteSpeed/weightedDurationSum;}}}}AnimBlendTreeCartesian2D._p=new Vec2;AnimBlendTreeCartesian2D._pip=new Vec2;class AnimBlendTreeDirectional2D extends AnimBlendTree{pointCache(i,j){const pointKey=`${i}${j}`;if(!this._pointCache[pointKey]){this._pointCache[pointKey]=new Vec2((this._children[j].pointLength-this._children[i].pointLength)/((this._children[j].pointLength+this._children[i].pointLength)/2),Vec2.angleRad(this._children[i].point,this._children[j].point)*2);}return this._pointCache[pointKey]}calculateWeights(){if(this.updateParameterValues())return;let weightSum,weightedDurationSum;AnimBlendTreeDirectional2D._p.set(...this._parameterValues);const pLength=AnimBlendTreeDirectional2D._p.length();weightSum=0;weightedDurationSum=0;for(let i=0;i<this._children.length;i++){const child=this._children[i];const pi=child.point;const piLength=child.pointLength;let minj=Number.MAX_VALUE;for(let j=0;j<this._children.length;j++){if(i===j)continue;const pipj=this.pointCache(i,j);const pjLength=this._children[j].pointLength;AnimBlendTreeDirectional2D._pip.set((pLength-piLength)/((pjLength+piLength)/2),Vec2.angleRad(pi,AnimBlendTreeDirectional2D._p)*2);const result=math.clamp(1-Math.abs(AnimBlendTreeDirectional2D._pip.dot(pipj)/pipj.lengthSq()),0,1);if(result<minj)minj=result;}child.weight=minj;weightSum+=minj;if(this._syncAnimations){weightedDurationSum+=child.animTrack.duration/child.absoluteSpeed*child.weight;}}for(let i=0;i<this._children.length;i++){const child=this._children[i];child.weight=child._weight/weightSum;if(this._syncAnimations){const weightedChildDuration=child.animTrack.duration/weightedDurationSum*weightSum;child.weightedSpeed=child.absoluteSpeed*weightedChildDuration;}}}}AnimBlendTreeDirectional2D._p=new Vec2;AnimBlendTreeDirectional2D._pip=new Vec2;class AnimBlendTreeDirect extends AnimBlendTree{calculateWeights(){if(this.updateParameterValues())return;let weightSum=0;let weightedDurationSum=0;for(let i=0;i<this._children.length;i++){weightSum+=Math.max(this._parameterValues[i],0);if(this._syncAnimations){const child=this._children[i];weightedDurationSum+=child.animTrack.duration/child.absoluteSpeed*child.weight;}}for(let i=0;i<this._children.length;i++){const child=this._children[i];const weight=Math.max(this._parameterValues[i],0);if(weightSum){child.weight=weight/weightSum;if(this._syncAnimations){child.weightedSpeed=child.animTrack.duration/child.absoluteSpeed/weightedDurationSum;}}else {child.weight=0;if(this._syncAnimations){child.weightedSpeed=0;}}}}}class AnimState{_createTree(type,state,parent,name,point,parameters,children,syncAnimations,createTree,findParameter){switch(type){case ANIM_BLEND_1D:return new AnimBlendTree1D(state,parent,name,point,parameters,children,syncAnimations,createTree,findParameter);case ANIM_BLEND_2D_CARTESIAN:return new AnimBlendTreeCartesian2D(state,parent,name,point,parameters,children,syncAnimations,createTree,findParameter);case ANIM_BLEND_2D_DIRECTIONAL:return new AnimBlendTreeDirectional2D(state,parent,name,point,parameters,children,syncAnimations,createTree,findParameter);case ANIM_BLEND_DIRECT:return new AnimBlendTreeDirect(state,parent,name,point,parameters,children,syncAnimations,createTree,findParameter)}return undefined}_getNodeFromPath(path){let currNode=this._blendTree;for(let i=1;i<path.length;i++){currNode=currNode.getChild(path[i]);}return currNode}addAnimation(path,animTrack){const pathString=path.join(".");const indexOfAnimation=this._animationList.findIndex(animation=>{return animation.path===pathString});if(indexOfAnimation>=0){this._animationList[indexOfAnimation].animTrack=animTrack;}else {const node=this._getNodeFromPath(path);node.animTrack=animTrack;this._animationList.push(node);}this._updateHasAnimations();}_updateHasAnimations(){this._hasAnimations=this._animationList.length>0&&this._animationList.every(animation=>animation.animTrack&&animation.animTrack!==AnimTrack.EMPTY);}get name(){return this._name}set animations(value){this._animationList=value;this._updateHasAnimations();}get animations(){return this._animationList}get hasAnimations(){return this._hasAnimations}set speed(value){this._speed=value;}get speed(){return this._speed}set loop(value){this._loop=value;}get loop(){return this._loop}get nodeCount(){if(!this._blendTree||this._blendTree.constructor===AnimNode)return 1;return this._blendTree.getNodeCount()}get playable(){return ANIM_CONTROL_STATES.indexOf(this.name)!==-1||this.animations.length===this.nodeCount}get looping(){if(this.animations.length>0){const trackClipName=`${this.name}.${this.animations[0].animTrack.name}`;const trackClip=this._controller.animEvaluator.findClip(trackClipName);if(trackClip){return trackClip.loop}}return false}get totalWeight(){let sum=0;for(let i=0;i<this.animations.length;i++){sum+=this.animations[i].weight;}return sum}get timelineDuration(){let duration=0;for(let i=0;i<this.animations.length;i++){const animation=this.animations[i];if(animation.animTrack.duration>duration){duration=animation.animTrack.duration;}}return duration}constructor(controller,name,speed=1,loop=true,blendTree){this._animations={};this._animationList=[];this._controller=controller;this._name=name;this._speed=speed;this._loop=loop;this._hasAnimations=false;if(blendTree){this._blendTree=this._createTree(blendTree.type,this,null,name,1,blendTree.parameter?[blendTree.parameter]:blendTree.parameters,blendTree.children,blendTree.syncAnimations,this._createTree,this._controller.findParameter);}else {this._blendTree=new AnimNode(this,null,name,1,speed);}}}class AnimTransition{get from(){return this._from}set to(value){this._to=value;}get to(){return this._to}get time(){return this._time}get priority(){return this._priority}get conditions(){return this._conditions}get exitTime(){return this._exitTime}get transitionOffset(){return this._transitionOffset}get interruptionSource(){return this._interruptionSource}get hasExitTime(){return !!this.exitTime}constructor({from,to,time=0,priority=0,conditions=[],exitTime=null,transitionOffset=null,interruptionSource=ANIM_INTERRUPTION_NONE}){this._from=from;this._to=to;this._time=time;this._priority=priority;this._conditions=conditions;this._exitTime=exitTime;this._transitionOffset=transitionOffset;this._interruptionSource=interruptionSource;}}class AnimController{get animEvaluator(){return this._animEvaluator}set activeState(stateName){this._activeStateName=stateName;}get activeState(){return this._findState(this._activeStateName)}get activeStateName(){return this._activeStateName}get activeStateAnimations(){return this.activeState.animations}set previousState(stateName){this._previousStateName=stateName;}get previousState(){return this._findState(this._previousStateName)}get previousStateName(){return this._previousStateName}get playable(){let playable=true;for(let i=0;i<this._stateNames.length;i++){if(!this._states[this._stateNames[i]].playable){playable=false;}}return playable}set playing(value){this._playing=value;}get playing(){return this._playing}get activeStateProgress(){return this._getActiveStateProgressForTime(this._timeInState)}get activeStateDuration(){if(this._activeStateDurationDirty){let maxDuration=0;for(let i=0;i<this.activeStateAnimations.length;i++){const activeClip=this._animEvaluator.findClip(this.activeStateAnimations[i].name);if(activeClip){maxDuration=Math.max(maxDuration,activeClip.track.duration);}}this._activeStateDuration=maxDuration;this._activeStateDurationDirty=false;}return this._activeStateDuration}set activeStateCurrentTime(time){this._timeInStateBefore=time;this._timeInState=time;for(let i=0;i<this.activeStateAnimations.length;i++){const clip=this.animEvaluator.findClip(this.activeStateAnimations[i].name);if(clip){clip.time=time;}}}get activeStateCurrentTime(){return this._timeInState}get transitioning(){return this._isTransitioning}get transitionProgress(){return this._currTransitionTime/this._totalTransitionTime}get states(){return this._stateNames}assignMask(mask){return this._animEvaluator.assignMask(mask)}_findState(stateName){return this._states[stateName]}_getActiveStateProgressForTime(time){if(this.activeStateName===ANIM_STATE_START||this.activeStateName===ANIM_STATE_END||this.activeStateName===ANIM_STATE_ANY){return 1}const activeClip=this._animEvaluator.findClip(this.activeStateAnimations[0].name);if(activeClip){return activeClip.progressForTime(time)}return null}_findTransitionsFromState(stateName){let transitions=this._findTransitionsFromStateCache[stateName];if(!transitions){transitions=this._transitions.filter(transition=>{return transition.from===stateName});sortPriority(transitions);this._findTransitionsFromStateCache[stateName]=transitions;}return transitions}_findTransitionsBetweenStates(sourceStateName,destinationStateName){let transitions=this._findTransitionsBetweenStatesCache[`${sourceStateName}->${destinationStateName}`];if(!transitions){transitions=this._transitions.filter(transition=>{return transition.from===sourceStateName&&transition.to===destinationStateName});sortPriority(transitions);this._findTransitionsBetweenStatesCache[`${sourceStateName}->${destinationStateName}`]=transitions;}return transitions}_transitionHasConditionsMet(transition){const conditions=transition.conditions;for(let i=0;i<conditions.length;i++){const condition=conditions[i];const parameter=this._findParameter(condition.parameterName);switch(condition.predicate){case ANIM_GREATER_THAN:if(!(parameter.value>condition.value))return false;break;case ANIM_LESS_THAN:if(!(parameter.value<condition.value))return false;break;case ANIM_GREATER_THAN_EQUAL_TO:if(!(parameter.value>=condition.value))return false;break;case ANIM_LESS_THAN_EQUAL_TO:if(!(parameter.value<=condition.value))return false;break;case ANIM_EQUAL_TO:if(!(parameter.value===condition.value))return false;break;case ANIM_NOT_EQUAL_TO:if(!(parameter.value!==condition.value))return false;break}}return true}_findTransition(from,to){let transitions=[];if(from&&to){transitions=transitions.concat(this._findTransitionsBetweenStates(from,to));}else {if(!this._isTransitioning){transitions=transitions.concat(this._findTransitionsFromState(this._activeStateName));transitions=transitions.concat(this._findTransitionsFromState(ANIM_STATE_ANY));}else {switch(this._transitionInterruptionSource){case ANIM_INTERRUPTION_PREV:transitions=transitions.concat(this._findTransitionsFromState(this._previousStateName));transitions=transitions.concat(this._findTransitionsFromState(ANIM_STATE_ANY));break;case ANIM_INTERRUPTION_NEXT:transitions=transitions.concat(this._findTransitionsFromState(this._activeStateName));transitions=transitions.concat(this._findTransitionsFromState(ANIM_STATE_ANY));break;case ANIM_INTERRUPTION_PREV_NEXT:transitions=transitions.concat(this._findTransitionsFromState(this._previousStateName));transitions=transitions.concat(this._findTransitionsFromState(this._activeStateName));transitions=transitions.concat(this._findTransitionsFromState(ANIM_STATE_ANY));break;case ANIM_INTERRUPTION_NEXT_PREV:transitions=transitions.concat(this._findTransitionsFromState(this._activeStateName));transitions=transitions.concat(this._findTransitionsFromState(this._previousStateName));transitions=transitions.concat(this._findTransitionsFromState(ANIM_STATE_ANY));break}}}transitions=transitions.filter(transition=>{if(transition.to===this.activeStateName){return false}if(transition.hasExitTime){let progressBefore=this._getActiveStateProgressForTime(this._timeInStateBefore);let progress=this._getActiveStateProgressForTime(this._timeInState);if(transition.exitTime<1&&this.activeState.loop){progressBefore-=Math.floor(progressBefore);progress-=Math.floor(progress);}if(progress===progressBefore){if(progress!==transition.exitTime){return null}}else if(!(transition.exitTime>progressBefore&&transition.exitTime<=progress)){return null}}return this._transitionHasConditionsMet(transition)});if(transitions.length>0){const transition=transitions[0];if(transition.to===ANIM_STATE_END){const startTransition=this._findTransitionsFromState(ANIM_STATE_START)[0];transition.to=startTransition.to;}return transition}return null}updateStateFromTransition(transition){let state;let animation;let clip;this.previousState=transition.from?this.activeStateName:null;this.activeState=transition.to;this._activeStateDurationDirty=true;for(let i=0;i<transition.conditions.length;i++){const condition=transition.conditions[i];const parameter=this._findParameter(condition.parameterName);if(parameter.type===ANIM_PARAMETER_TRIGGER){this._consumeTrigger(condition.parameterName);}}if(this.previousState){if(!this._isTransitioning){this._transitionPreviousStates=[];}this._transitionPreviousStates.push({name:this._previousStateName,weight:1});const interpolatedTime=Math.min(this._totalTransitionTime!==0?this._currTransitionTime/this._totalTransitionTime:1,1);for(let i=0;i<this._transitionPreviousStates.length;i++){if(!this._isTransitioning){this._transitionPreviousStates[i].weight=1;}else if(i!==this._transitionPreviousStates.length-1){this._transitionPreviousStates[i].weight*=1-interpolatedTime;}else {this._transitionPreviousStates[i].weight=interpolatedTime;}state=this._findState(this._transitionPreviousStates[i].name);for(let j=0;j<state.animations.length;j++){animation=state.animations[j];clip=this._animEvaluator.findClip(`${animation.name}.previous.${i}`);if(!clip){clip=this._animEvaluator.findClip(animation.name);clip.name=`${animation.name}.previous.${i}`;}if(i!==this._transitionPreviousStates.length-1){clip.pause();}}}}this._isTransitioning=true;this._totalTransitionTime=transition.time;this._currTransitionTime=0;this._transitionInterruptionSource=transition.interruptionSource;const activeState=this.activeState;const hasTransitionOffset=transition.transitionOffset&&transition.transitionOffset>0&&transition.transitionOffset<1;let timeInState=0;let timeInStateBefore=0;if(hasTransitionOffset){const offsetTime=activeState.timelineDuration*transition.transitionOffset;timeInState=offsetTime;timeInStateBefore=offsetTime;}this._timeInState=timeInState;this._timeInStateBefore=timeInStateBefore;for(let i=0;i<activeState.animations.length;i++){clip=this._animEvaluator.findClip(activeState.animations[i].name);if(!clip){const speed=Number.isFinite(activeState.animations[i].speed)?activeState.animations[i].speed:activeState.speed;clip=new AnimClip(activeState.animations[i].animTrack,this._timeInState,speed,true,activeState.loop,this._eventHandler);clip.name=activeState.animations[i].name;this._animEvaluator.addClip(clip);}else {clip.reset();}if(transition.time>0){clip.blendWeight=0;}else {clip.blendWeight=activeState.animations[i].normalizedWeight;}clip.play();if(hasTransitionOffset){clip.time=activeState.timelineDuration*transition.transitionOffset;}else {const startTime=activeState.speed>=0?0:this.activeStateDuration;clip.time=startTime;}}}_transitionToState(newStateName){if(!this._findState(newStateName)){return}let transition=this._findTransition(this._activeStateName,newStateName);if(!transition){this._animEvaluator.removeClips();transition=new AnimTransition({from:null,to:newStateName});}this.updateStateFromTransition(transition);}assignAnimation(pathString,animTrack,speed,loop){const path=pathString.split(".");let state=this._findState(path[0]);if(!state){state=new AnimState(this,path[0],speed);this._states[path[0]]=state;this._stateNames.push(path[0]);}state.addAnimation(path,animTrack);this._animEvaluator.updateClipTrack(state.name,animTrack);if(speed!==undefined){state.speed=speed;}if(loop!==undefined){state.loop=loop;}if(!this._playing&&this._activate&&this.playable){this.play();}this._activeStateDurationDirty=true;}removeNodeAnimations(nodeName){if(ANIM_CONTROL_STATES.indexOf(nodeName)!==-1){return false}const state=this._findState(nodeName);if(!state){return false}state.animations=[];return true}play(stateName){if(stateName){this._transitionToState(stateName);}this._playing=true;}pause(){this._playing=false;}reset(){this._previousStateName=null;this._activeStateName=ANIM_STATE_START;this._playing=false;this._currTransitionTime=1;this._totalTransitionTime=1;this._isTransitioning=false;this._timeInState=0;this._timeInStateBefore=0;this._animEvaluator.removeClips();}rebind(){this._animEvaluator.rebind();}update(dt){if(!this._playing){return}let state;let animation;let clip;if(this.activeState.loop||this._timeInState<this.activeStateDuration){this._timeInStateBefore=this._timeInState;this._timeInState+=dt*this.activeState.speed;if(!this.activeState.loop&&this._timeInState>this.activeStateDuration){this._timeInState=this.activeStateDuration;dt=this.activeStateDuration-this._timeInStateBefore;}}const transition=this._findTransition(this._activeStateName);if(transition){this.updateStateFromTransition(transition);}if(this._isTransitioning){this._currTransitionTime+=dt;if(this._currTransitionTime<=this._totalTransitionTime){const interpolatedTime=this._totalTransitionTime!==0?this._currTransitionTime/this._totalTransitionTime:1;for(let i=0;i<this._transitionPreviousStates.length;i++){state=this._findState(this._transitionPreviousStates[i].name);const stateWeight=this._transitionPreviousStates[i].weight;for(let j=0;j<state.animations.length;j++){animation=state.animations[j];clip=this._animEvaluator.findClip(`${animation.name}.previous.${i}`);if(clip){clip.blendWeight=(1-interpolatedTime)*animation.normalizedWeight*stateWeight;}}}state=this.activeState;for(let i=0;i<state.animations.length;i++){animation=state.animations[i];this._animEvaluator.findClip(animation.name).blendWeight=interpolatedTime*animation.normalizedWeight;}}else {this._isTransitioning=false;const activeClips=this.activeStateAnimations.length;const totalClips=this._animEvaluator.clips.length;for(let i=0;i<totalClips-activeClips;i++){this._animEvaluator.removeClip(0);}this._transitionPreviousStates=[];state=this.activeState;for(let i=0;i<state.animations.length;i++){animation=state.animations[i];clip=this._animEvaluator.findClip(animation.name);if(clip){clip.blendWeight=animation.normalizedWeight;}}}}else {if(this.activeState._blendTree.constructor!==AnimNode){state=this.activeState;for(let i=0;i<state.animations.length;i++){animation=state.animations[i];clip=this._animEvaluator.findClip(animation.name);if(clip){clip.blendWeight=animation.normalizedWeight;if(animation.parent.syncAnimations){clip.speed=animation.speed;}}}}}this._animEvaluator.update(dt,this.activeState.hasAnimations);}constructor(animEvaluator,states,transitions,activate,eventHandler,findParameter,consumeTrigger){this._states={};this._stateNames=[];this._findTransitionsFromStateCache={};this._findTransitionsBetweenStatesCache={};this._previousStateName=null;this._activeStateName=ANIM_STATE_START;this._activeStateDuration=0;this._activeStateDurationDirty=true;this._playing=false;this._activate=void 0;this._transitions=void 0;this._currTransitionTime=1;this._totalTransitionTime=1;this._isTransitioning=false;this._transitionInterruptionSource=ANIM_INTERRUPTION_NONE;this._transitionPreviousStates=[];this._timeInState=0;this._timeInStateBefore=0;this.findParameter=name=>{return this._findParameter(name)};this._animEvaluator=animEvaluator;this._eventHandler=eventHandler;this._findParameter=findParameter;this._consumeTrigger=consumeTrigger;for(let i=0;i<states.length;i++){this._states[states[i].name]=new AnimState(this,states[i].name,states[i].speed,states[i].loop,states[i].blendTree);this._stateNames.push(states[i].name);}this._transitions=transitions.map(transition=>{return new AnimTransition(_extends({},transition))});this._activate=activate;}}const v2=new Vec2;const v3=new Vec3;const v4=new Vec4;const c=new Color;const q=new Quat;class AnimComponentBinder extends DefaultAnimBinder{static _packFloat(values){return values[0]}static _packBoolean(values){return !!values[0]}static _packVec2(values){v2.x=values[0];v2.y=values[1];return v2}static _packVec3(values){v3.x=values[0];v3.y=values[1];v3.z=values[2];return v3}static _packVec4(values){v4.x=values[0];v4.y=values[1];v4.z=values[2];v4.w=values[3];return v4}static _packColor(values){c.r=values[0];c.g=values[1];c.b=values[2];c.a=values[3];return c}static _packQuat(values){q.x=values[0];q.y=values[1];q.z=values[2];q.w=values[3];return q}resolve(path){const encodedPath=AnimBinder.encode(path.entityPath,path.component,path.propertyPath);let target=this.targetCache[encodedPath];if(target)return target;let entity;let propertyComponent;let targetPath;switch(path.component){case"entity":entity=this._getEntityFromHierarchy(path.entityPath);targetPath=AnimBinder.encode(entity.path,"entity",path.propertyPath);propertyComponent=entity;break;case"graph":propertyComponent=this.findNode(path);if(!propertyComponent)return null;targetPath=AnimBinder.encode(propertyComponent.path,"graph",path.propertyPath);break;default:entity=this._getEntityFromHierarchy(path.entityPath);propertyComponent=entity.findComponent(path.component);if(!propertyComponent){return null}targetPath=AnimBinder.encode(entity.path,path.component,path.propertyPath);break}target=this._createAnimTargetForProperty(propertyComponent,path.propertyPath,targetPath);this.targetCache[encodedPath]=target;return target}update(deltaTime){const activeNodes=this.activeNodes;if(activeNodes){for(let i=0;i<activeNodes.length;i++){activeNodes[i]._dirtifyLocal();}}}_getEntityFromHierarchy(entityHierarchy){if(!this.animComponent.entity.name===entityHierarchy[0]){return null}const currEntity=this.animComponent.entity;if(entityHierarchy.length===1){return currEntity}return currEntity._parent.findByPath(entityHierarchy)}_resolvePath(object,path,resolveLeaf){const steps=path.length-(resolveLeaf?0:1);for(let i=0;i<steps;i++){object=object[path[i]];}return object}_setter(object,path,packFunc){const obj=this._resolvePath(object,path);const key=path[path.length-1];const setterFuncName=`set${key.substring(0,1).toUpperCase()}${key.substring(1)}`;if(obj[setterFuncName]){const getterFunc=obj[`get${key.substring(0,1).toUpperCase()}${key.substring(1)}`].bind(obj);let baseValues=getterFunc();baseValues=[baseValues.x,baseValues.y,baseValues.z,baseValues.w];const setterFunc=obj[setterFuncName].bind(obj);return {set:values=>{setterFunc(packFunc(values));},get:()=>baseValues}}const prop=obj[key];if(typeof prop==="object"&&prop.hasOwnProperty("copy")){return function(values){prop.copy(packFunc(values));}}if([Vec2,Vec3,Vec4,Color,Quat].indexOf(obj.constructor)!==-1&&path.length>1){const parent=path.length>2?this._resolvePath(object,path.slice(0,-1)):object;const objKey=path[path.length-2];return function(values){obj[key]=packFunc(values);parent[objKey]=obj;}}return function(values){obj[key]=packFunc(values);}}_createAnimTargetForProperty(propertyComponent,propertyHierarchy,targetPath){if(this.handlers&&propertyHierarchy[0].startsWith("weight.")){return this.handlers.weight(propertyComponent,propertyHierarchy[0].replace("weight.",""))}else if(this.handlers&&propertyHierarchy[0]==="material"&&propertyHierarchy.length===2){const materialPropertyName=propertyHierarchy[1];if(materialPropertyName.endsWith("Map")){return this.handlers.materialTexture(propertyComponent,materialPropertyName)}}const property=this._resolvePath(propertyComponent,propertyHierarchy,true);if(typeof property==="undefined"){return null}let setter;let animDataType;let animDataComponents;if(typeof property==="number"){setter=this._setter(propertyComponent,propertyHierarchy,AnimComponentBinder._packFloat);animDataType="vector";animDataComponents=1;}else if(typeof property==="boolean"){setter=this._setter(propertyComponent,propertyHierarchy,AnimComponentBinder._packBoolean);animDataType="vector";animDataComponents=1;}else if(typeof property==="object"){switch(property.constructor){case Vec2:setter=this._setter(propertyComponent,propertyHierarchy,AnimComponentBinder._packVec2);animDataType="vector";animDataComponents=2;break;case Vec3:setter=this._setter(propertyComponent,propertyHierarchy,AnimComponentBinder._packVec3);animDataType="vector";animDataComponents=3;break;case Vec4:setter=this._setter(propertyComponent,propertyHierarchy,AnimComponentBinder._packVec4);animDataType="vector";animDataComponents=4;break;case Color:setter=this._setter(propertyComponent,propertyHierarchy,AnimComponentBinder._packColor);animDataType="vector";animDataComponents=4;break;case Quat:setter=this._setter(propertyComponent,propertyHierarchy,AnimComponentBinder._packQuat);animDataType="quaternion";animDataComponents=4;break;default:return null}}if(propertyHierarchy.indexOf("material")!==-1){return new AnimTarget(values=>{setter(values);propertyComponent.material.update();},animDataType,animDataComponents,targetPath)}return new AnimTarget(setter,animDataType,animDataComponents,targetPath)}rebind(){this.targetCache={};if(this.animComponent.rootBone){this.graph=this.animComponent.rootBone;}else {this.graph=this.animComponent.entity;}const nodes={};const flatten=function flatten(node){nodes[node.name]=node;for(let i=0;i<node.children.length;++i){flatten(node.children[i]);}};flatten(this.graph);this.nodes=nodes;}constructor(animComponent,graph,layerName,mask,layerIndex){super(graph);this.animComponent=animComponent;this._mask=mask;this.layerName=layerName;this.layerIndex=layerIndex;}}class AnimComponentLayer{get name(){return this._name}set playing(value){this._controller.playing=value;}get playing(){return this._controller.playing}get playable(){return this._controller.playable}get activeState(){return this._controller.activeStateName}get previousState(){return this._controller.previousStateName}get activeStateProgress(){return this._controller.activeStateProgress}get activeStateDuration(){return this._controller.activeStateDuration}set activeStateCurrentTime(time){const controller=this._controller;const layerPlaying=controller.playing;controller.playing=true;controller.activeStateCurrentTime=time;if(!layerPlaying){controller.update(0);}controller.playing=layerPlaying;}get activeStateCurrentTime(){return this._controller.activeStateCurrentTime}get transitioning(){return this._controller.transitioning}get transitionProgress(){if(this.transitioning){return this._controller.transitionProgress}return null}get states(){return this._controller.states}set weight(value){this._weight=value;this._component.dirtifyTargets();}get weight(){return this._weight}set blendType(value){if(value!==this._blendType){this._blendType=value;if(this._controller.normalizeWeights){this._component.rebind();}}}get blendType(){return this._blendType}set mask(value){if(this._controller.assignMask(value)){this._component.rebind();}this._mask=value;}get mask(){return this._mask}play(name){this._controller.play(name);}pause(){this._controller.pause();}reset(){this._controller.reset();}rebind(){this._controller.rebind();}update(dt){if(this._blendTime){if(this._blendTimeElapsed<this._blendTime){this.weight=math.lerp(this._startingWeight,this._targetWeight,this._blendTimeElapsed/this._blendTime);this._blendTimeElapsed+=dt;}else {this.weight=this._targetWeight;this._blendTime=0;this._blendTimeElapsed=0;this._startingWeight=0;this._targetWeight=0;}}this._controller.update(dt);}blendToWeight(weight,time){this._startingWeight=this.weight;this._targetWeight=weight;this._blendTime=Math.max(0,time);this._blendTimeElapsed=0;}assignMask(mask){if(this._controller.assignMask(mask)){this._component.rebind();}this._mask=mask;}assignAnimation(nodePath,animTrack,speed,loop){if(!(animTrack instanceof AnimTrack)){return}this._controller.assignAnimation(nodePath,animTrack,speed,loop);if(this._controller._transitions.length===0){this._controller._transitions.push(new AnimTransition({from:"START",to:nodePath}));}if(this._component.activate&&this._component.playable){this._component.playing=true;}}removeNodeAnimations(nodeName){if(this._controller.removeNodeAnimations(nodeName)){this._component.playing=false;}}getAnimationAsset(stateName){return this._component.animationAssets[`${this.name}:${stateName}`]}transition(to,time=0,transitionOffset=null){this._controller.updateStateFromTransition(new AnimTransition({from:this._controller.activeStateName,to,time,transitionOffset}));}constructor(name,controller,component,weight=1,blendType=ANIM_LAYER_OVERWRITE){this._name=void 0;this._controller=void 0;this._component=void 0;this._weight=void 0;this._blendType=void 0;this._mask=null;this._blendTime=0;this._blendTimeElapsed=0;this._startingWeight=0;this._targetWeight=0;this._name=name;this._controller=controller;this._component=component;this._weight=weight;this._blendType=blendType;}}class AnimStateGraph{get parameters(){return Object.assign({},this._parameters)}get layers(){return this._layers}constructor(data){this._layers=[];this._parameters={};if(!Array.isArray(data.layers)){for(const layerId in data.layers){const dataLayer=data.layers[layerId];const layer={name:dataLayer.name,blendType:dataLayer.blendType,weight:dataLayer.weight,states:[],transitions:[]};for(let i=0;i<dataLayer.states.length;i++){layer.states.push(data.states[dataLayer.states[i]]);}for(let i=0;i<dataLayer.transitions.length;i++){const dataLayerTransition=data.transitions[dataLayer.transitions[i]];if(dataLayerTransition.conditions&&!Array.isArray(dataLayerTransition.conditions)){const conditionKeys=Object.keys(dataLayerTransition.conditions);const conditions=[];for(let j=0;j<conditionKeys.length;j++){const condition=dataLayerTransition.conditions[conditionKeys[j]];if(condition.parameterName){conditions.push(condition);}}dataLayerTransition.conditions=conditions;}if(Number.isInteger(dataLayerTransition.from)){dataLayerTransition.from=data.states[dataLayerTransition.from].name;}if(Number.isInteger(dataLayerTransition.to)){dataLayerTransition.to=data.states[dataLayerTransition.to].name;}layer.transitions.push(dataLayerTransition);}this._layers.push(layer);}}else {this._layers=data.layers;}for(const paramId in data.parameters){const param=data.parameters[paramId];this._parameters[param.name]={type:param.type,value:param.value};}}}class AnimComponent extends Component{set stateGraphAsset(value){if(value===null){this.removeStateGraph();return}if(this._stateGraphAsset){const stateGraphAsset=this.system.app.assets.get(this._stateGraphAsset);stateGraphAsset.off("change",this._onStateGraphAssetChangeEvent,this);}let _id;let _asset;if(value instanceof Asset){_id=value.id;_asset=this.system.app.assets.get(_id);if(!_asset){this.system.app.assets.add(value);_asset=this.system.app.assets.get(_id);}}else {_id=value;_asset=this.system.app.assets.get(_id);}if(!_asset||this._stateGraphAsset===_id){return}if(_asset.resource){this._stateGraph=_asset.resource;this.loadStateGraph(this._stateGraph);_asset.on("change",this._onStateGraphAssetChangeEvent,this);}else {_asset.once("load",asset=>{this._stateGraph=asset.resource;this.loadStateGraph(this._stateGraph);});_asset.on("change",this._onStateGraphAssetChangeEvent,this);this.system.app.assets.load(_asset);}this._stateGraphAsset=_id;}get stateGraphAsset(){return this._stateGraphAsset}set normalizeWeights(value){this._normalizeWeights=value;this.unbind();}get normalizeWeights(){return this._normalizeWeights}set animationAssets(value){this._animationAssets=value;this.loadAnimationAssets();}get animationAssets(){return this._animationAssets}set speed(value){this._speed=value;}get speed(){return this._speed}set activate(value){this._activate=value;}get activate(){return this._activate}set playing(value){this._playing=value;}get playing(){return this._playing}set rootBone(value){if(typeof value==="string"){const entity=this.entity.root.findByGuid(value);this._rootBone=entity;}else if(value instanceof Entity){this._rootBone=value;}else {this._rootBone=null;}this.rebind();}get rootBone(){return this._rootBone}set stateGraph(value){this._stateGraph=value;}get stateGraph(){return this._stateGraph}get layers(){return this._layers}set layerIndices(value){this._layerIndices=value;}get layerIndices(){return this._layerIndices}set parameters(value){this._parameters=value;}get parameters(){return this._parameters}set targets(value){this._targets=value;}get targets(){return this._targets}get playable(){for(let i=0;i<this._layers.length;i++){if(!this._layers[i].playable){return false}}return true}get baseLayer(){if(this._layers.length>0){return this._layers[0]}return null}_onStateGraphAssetChangeEvent(asset){const prevAnimationAssets=this.animationAssets;const prevMasks=this.layers.map(layer=>layer.mask);this.removeStateGraph();this._stateGraph=new AnimStateGraph(asset._data);this.loadStateGraph(this._stateGraph);this.animationAssets=prevAnimationAssets;this.loadAnimationAssets();this.layers.forEach((layer,i)=>{layer.mask=prevMasks[i];});this.rebind();}dirtifyTargets(){const targets=Object.values(this._targets);for(let i=0;i<targets.length;i++){targets[i].dirty=true;}}_addLayer({name,states,transitions,weight,mask,blendType}){let graph;if(this.rootBone){graph=this.rootBone;}else {graph=this.entity;}const layerIndex=this._layers.length;const animBinder=new AnimComponentBinder(this,graph,name,mask,layerIndex);const animEvaluator=new AnimEvaluator(animBinder);const controller=new AnimController(animEvaluator,states,transitions,this._activate,this,this.findParameter,this.consumeTrigger);this._layers.push(new AnimComponentLayer(name,controller,this,weight,blendType));this._layerIndices[name]=layerIndex;return this._layers[layerIndex]}addLayer(name,weight,mask,blendType){const layer=this.findAnimationLayer(name);if(layer)return layer;const states=[{"name":"START","speed":1}];const transitions=[];return this._addLayer({name,states,transitions,weight,mask,blendType})}_assignParameters(stateGraph){this._parameters={};const paramKeys=Object.keys(stateGraph.parameters);for(let i=0;i<paramKeys.length;i++){const paramKey=paramKeys[i];this._parameters[paramKey]={type:stateGraph.parameters[paramKey].type,value:stateGraph.parameters[paramKey].value};}}loadStateGraph(stateGraph){this._stateGraph=stateGraph;this._assignParameters(stateGraph);this._layers=[];let containsBlendTree=false;for(let i=0;i<stateGraph.layers.length;i++){const layer=stateGraph.layers[i];this._addLayer(_extends({},layer));if(layer.states.some(state=>state.blendTree)){containsBlendTree=true;}}if(!containsBlendTree){this.setupAnimationAssets();}}setupAnimationAssets(){for(let i=0;i<this._layers.length;i++){const layer=this._layers[i];const layerName=layer.name;for(let j=0;j<layer.states.length;j++){const stateName=layer.states[j];if(ANIM_CONTROL_STATES.indexOf(stateName)===-1){const stateKey=`${layerName}:${stateName}`;if(!this._animationAssets[stateKey]){this._animationAssets[stateKey]={asset:null};}}}}this.loadAnimationAssets();}loadAnimationAssets(){for(let i=0;i<this._layers.length;i++){const layer=this._layers[i];for(let j=0;j<layer.states.length;j++){const stateName=layer.states[j];if(ANIM_CONTROL_STATES.indexOf(stateName)!==-1)continue;const animationAsset=this._animationAssets[`${layer.name}:${stateName}`];if(!animationAsset||!animationAsset.asset){this.findAnimationLayer(layer.name).assignAnimation(stateName,AnimTrack.EMPTY);continue}const assetId=animationAsset.asset;const asset=this.system.app.assets.get(assetId);if(asset){if(asset.resource){this.onAnimationAssetLoaded(layer.name,stateName,asset);}else {asset.once("load",(function(layerName,stateName){return (function(asset){this.onAnimationAssetLoaded(layerName,stateName,asset);}).bind(this)}).bind(this)(layer.name,stateName));this.system.app.assets.load(asset);}}}}}onAnimationAssetLoaded(layerName,stateName,asset){this.findAnimationLayer(layerName).assignAnimation(stateName,asset.resource);}removeStateGraph(){this._stateGraph=null;this._stateGraphAsset=null;this._animationAssets={};this._layers=[];this._layerIndices={};this._parameters={};this._playing=false;this.unbind();this._targets={};}reset(){this._assignParameters(this._stateGraph);for(let i=0;i<this._layers.length;i++){const layerPlaying=this._layers[i].playing;this._layers[i].reset();this._layers[i].playing=layerPlaying;}}unbind(){if(!this._normalizeWeights){Object.keys(this._targets).forEach(targetKey=>{this._targets[targetKey].unbind();});}}rebind(){this._targets={};for(let i=0;i<this._layers.length;i++){this._layers[i].rebind();}}findAnimationLayer(name){const layerIndex=this._layerIndices[name];return this._layers[layerIndex]||null}addAnimationState(nodeName,animTrack,speed=1,loop=true,layerName="Base"){if(!this._stateGraph){this.loadStateGraph(new AnimStateGraph({"layers":[{"name":layerName,"states":[{"name":"START","speed":1},{"name":nodeName,"speed":speed,"loop":loop,"defaultState":true}],"transitions":[{"from":"START","to":nodeName}]}],"parameters":{}}));}const layer=this.findAnimationLayer(layerName);if(layer){layer.assignAnimation(nodeName,animTrack,speed,loop);}else {var _this$addLayer;(_this$addLayer=this.addLayer(layerName))==null||_this$addLayer.assignAnimation(nodeName,animTrack,speed,loop);}}assignAnimation(nodePath,animTrack,layerName,speed=1,loop=true){if(!this._stateGraph&&nodePath.indexOf(".")===-1){this.loadStateGraph(new AnimStateGraph({"layers":[{"name":"Base","states":[{"name":"START","speed":1},{"name":nodePath,"speed":speed,"loop":loop,"defaultState":true}],"transitions":[{"from":"START","to":nodePath}]}],"parameters":{}}));this.baseLayer.assignAnimation(nodePath,animTrack);return}const layer=layerName?this.findAnimationLayer(layerName):this.baseLayer;if(!layer){return}layer.assignAnimation(nodePath,animTrack,speed,loop);}removeNodeAnimations(nodeName,layerName){const layer=layerName?this.findAnimationLayer(layerName):this.baseLayer;if(!layer){return}layer.removeNodeAnimations(nodeName);}getParameterValue(name,type){const param=this._parameters[name];if(param&&param.type===type){return param.value}return undefined}setParameterValue(name,type,value){const param=this._parameters[name];if(param&&param.type===type){param.value=value;return}}getFloat(name){return this.getParameterValue(name,ANIM_PARAMETER_FLOAT)}setFloat(name,value){this.setParameterValue(name,ANIM_PARAMETER_FLOAT,value);}getInteger(name){return this.getParameterValue(name,ANIM_PARAMETER_INTEGER)}setInteger(name,value){if(typeof value==="number"&&value%1===0){this.setParameterValue(name,ANIM_PARAMETER_INTEGER,value);}}getBoolean(name){return this.getParameterValue(name,ANIM_PARAMETER_BOOLEAN)}setBoolean(name,value){this.setParameterValue(name,ANIM_PARAMETER_BOOLEAN,!!value);}getTrigger(name){return this.getParameterValue(name,ANIM_PARAMETER_TRIGGER)}setTrigger(name,singleFrame=false){this.setParameterValue(name,ANIM_PARAMETER_TRIGGER,true);if(singleFrame){this._consumedTriggers.add(name);}}resetTrigger(name){this.setParameterValue(name,ANIM_PARAMETER_TRIGGER,false);}onBeforeRemove(){if(Number.isFinite(this._stateGraphAsset)){const stateGraphAsset=this.system.app.assets.get(this._stateGraphAsset);stateGraphAsset.off("change",this._onStateGraphAssetChangeEvent,this);}}update(dt){for(let i=0;i<this.layers.length;i++){this.layers[i].update(dt*this.speed);}this._consumedTriggers.forEach(trigger=>{this.parameters[trigger].value=false;});this._consumedTriggers.clear();}resolveDuplicatedEntityReferenceProperties(oldAnim,duplicatedIdsMap){if(oldAnim.rootBone&&duplicatedIdsMap[oldAnim.rootBone.getGuid()]){this.rootBone=duplicatedIdsMap[oldAnim.rootBone.getGuid()];}else {this.rebind();}}constructor(system,entity){super(system,entity);this.findParameter=name=>{return this._parameters[name]};this.consumeTrigger=name=>{this._consumedTriggers.add(name);};this._stateGraphAsset=null;this._animationAssets={};this._speed=1;this._activate=true;this._playing=false;this._rootBone=null;this._stateGraph=null;this._layers=[];this._layerIndices={};this._parameters={};this._targets={};this._consumedTriggers=new Set;this._normalizeWeights=false;}}class AnimComponentData{constructor(){this.enabled=true;}}const _schema$l=["enabled"];class AnimComponentSystem extends ComponentSystem{initializeComponentData(component,data,properties){super.initializeComponentData(component,data,_schema$l);const complexProperties=["animationAssets","stateGraph","layers","masks"];Object.keys(data).forEach(key=>{if(complexProperties.includes(key))return;component[key]=data[key];});if(data.stateGraph){component.stateGraph=data.stateGraph;component.loadStateGraph(component.stateGraph);}if(data.layers){data.layers.forEach((layer,i)=>{layer._controller.states.forEach(stateKey=>{layer._controller._states[stateKey]._animationList.forEach(node=>{if(!node.animTrack||node.animTrack===AnimTrack.EMPTY){const animationAsset=this.app.assets.get(layer._component._animationAssets[`${layer.name}:${node.name}`].asset);if(animationAsset&&!animationAsset.loaded){animationAsset.once("load",()=>{component.layers[i].assignAnimation(node.name,animationAsset.resource);});}}else {component.layers[i].assignAnimation(node.name,node.animTrack);}});});});}if(data.animationAssets){component.animationAssets=Object.assign(component.animationAssets,data.animationAssets);}if(data.masks){Object.keys(data.masks).forEach(key=>{if(component.layers[key]){const maskData=data.masks[key].mask;const mask={};Object.keys(maskData).forEach(maskKey=>{mask[decodeURI(maskKey)]=maskData[maskKey];});component.layers[key].mask=mask;}});}}onAnimationUpdate(dt){const components=this.store;for(const id in components){if(components.hasOwnProperty(id)){const component=components[id].entity.anim;const componentData=component.data;if(componentData.enabled&&component.entity.enabled&&component.playing){component.update(dt);}}}}cloneComponent(entity,clone){let masks;if(!entity.anim.rootBone||entity.anim.rootBone===entity){masks={};entity.anim.layers.forEach((layer,i)=>{if(layer.mask){const mask={};Object.keys(layer.mask).forEach(path=>{const pathArr=path.split("/");pathArr.shift();const clonePath=[clone.name,...pathArr].join("/");mask[clonePath]=layer.mask[path];});masks[i]={mask};}});}const data={stateGraphAsset:entity.anim.stateGraphAsset,animationAssets:entity.anim.animationAssets,speed:entity.anim.speed,activate:entity.anim.activate,playing:entity.anim.playing,rootBone:entity.anim.rootBone,stateGraph:entity.anim.stateGraph,layers:entity.anim.layers,layerIndices:entity.anim.layerIndices,parameters:entity.anim.parameters,normalizeWeights:entity.anim.normalizeWeights,masks};return this.addComponent(clone,data)}onBeforeRemove(entity,component){component.onBeforeRemove();}destroy(){super.destroy();this.app.systems.off("animationUpdate",this.onAnimationUpdate,this);}constructor(app){super(app);this.id="anim";this.ComponentType=AnimComponent;this.DataType=AnimComponentData;this.schema=_schema$l;this.on("beforeremove",this.onBeforeRemove,this);this.app.systems.on("animationUpdate",this.onAnimationUpdate,this);}}Component._buildAccessors(AnimComponent.prototype,_schema$l);class AudioListenerComponent extends Component{setCurrentListener(){if(this.enabled&&this.entity.audiolistener&&this.entity.enabled){this.system.current=this.entity;const position=this.system.current.getPosition();this.system.manager.listener.setPosition(position);}}onEnable(){this.setCurrentListener();}onDisable(){if(this.system.current===this.entity){this.system.current=null;}}constructor(system,entity){super(system,entity);}}class AudioListenerComponentData{constructor(){this.enabled=true;}}const _schema$k=["enabled"];class AudioListenerComponentSystem extends ComponentSystem{initializeComponentData(component,data,properties){properties=["enabled"];super.initializeComponentData(component,data,properties);}onUpdate(dt){if(this.current){const position=this.current.getPosition();this.manager.listener.setPosition(position);const wtm=this.current.getWorldTransform();this.manager.listener.setOrientation(wtm);}}destroy(){super.destroy();this.app.systems.off("update",this.onUpdate,this);}constructor(app){super(app);this.id="audiolistener";this.ComponentType=AudioListenerComponent;this.DataType=AudioListenerComponentData;this.schema=_schema$k;this.manager=app.soundManager;this.current=null;this.app.systems.on("update",this.onUpdate,this);}}Component._buildAccessors(AudioListenerComponent.prototype,_schema$k);class AudioSourceComponent extends Component{play(name){if(!this.enabled||!this.entity.enabled){return}if(this.channel){this.stop();}let channel;const componentData=this.data;if(componentData.sources[name]){if(!componentData["3d"]){channel=this.system.manager.playSound(componentData.sources[name],componentData);componentData.currentSource=name;componentData.channel=channel;}else {const pos=this.entity.getPosition();channel=this.system.manager.playSound3d(componentData.sources[name],pos,componentData);componentData.currentSource=name;componentData.channel=channel;}}}pause(){if(this.channel){this.channel.pause();}}unpause(){if(this.channel&&this.channel.paused){this.channel.unpause();}}stop(){if(this.channel){this.channel.stop();this.channel=null;}}onSetAssets(name,oldValue,newValue){const newAssets=[];const len=newValue.length;if(oldValue&&oldValue.length){for(let i=0;i<oldValue.length;i++){if(oldValue[i]){const asset=this.system.app.assets.get(oldValue[i]);if(asset){asset.off("change",this.onAssetChanged,this);asset.off("remove",this.onAssetRemoved,this);if(this.currentSource===asset.name){this.stop();}}}}}if(len){for(let i=0;i<len;i++){if(oldValue.indexOf(newValue[i])<0){if(newValue[i]instanceof Asset){newAssets.push(newValue[i].id);}else {newAssets.push(newValue[i]);}}}}if(!this.system._inTools&&newAssets.length){this.loadAudioSourceAssets(newAssets);}}onAssetChanged(asset,attribute,newValue,oldValue){if(attribute==="resource"){const sources=this.data.sources;if(sources){this.data.sources[asset.name]=newValue;if(this.data.currentSource===asset.name){if(this.channel){if(this.channel.paused){this.play(asset.name);this.pause();}else {this.play(asset.name);}}}}}}onAssetRemoved(asset){asset.off("remove",this.onAssetRemoved,this);if(this.data.sources[asset.name]){delete this.data.sources[asset.name];if(this.data.currentSource===asset.name){this.stop();this.data.currentSource=null;}}}onSetLoop(name,oldValue,newValue){if(oldValue!==newValue){if(this.channel){this.channel.setLoop(newValue);}}}onSetVolume(name,oldValue,newValue){if(oldValue!==newValue){if(this.channel){this.channel.setVolume(newValue);}}}onSetPitch(name,oldValue,newValue){if(oldValue!==newValue){if(this.channel){this.channel.setPitch(newValue);}}}onSetMaxDistance(name,oldValue,newValue){if(oldValue!==newValue){if(this.channel instanceof Channel3d){this.channel.setMaxDistance(newValue);}}}onSetMinDistance(name,oldValue,newValue){if(oldValue!==newValue){if(this.channel instanceof Channel3d){this.channel.setMinDistance(newValue);}}}onSetRollOffFactor(name,oldValue,newValue){if(oldValue!==newValue){if(this.channel instanceof Channel3d){this.channel.setRollOffFactor(newValue);}}}onSetDistanceModel(name,oldValue,newValue){if(oldValue!==newValue){if(this.channel instanceof Channel3d){this.channel.setDistanceModel(newValue);}}}onSet3d(name,oldValue,newValue){if(oldValue!==newValue){if(this.system.initialized&&this.currentSource){let paused=false;let suspended=false;if(this.channel){paused=this.channel.paused;suspended=this.channel.suspended;}this.play(this.currentSource);if(this.channel){this.channel.paused=paused;this.channel.suspended=suspended;}}}}onEnable(){const assets=this.data.assets;if(assets){const registry=this.system.app.assets;for(let i=0,len=assets.length;i<len;i++){let asset=assets[i];if(!(asset instanceof Asset)){asset=registry.get(asset);}if(asset&&!asset.resource){registry.load(asset);}}}if(this.system.initialized){if(this.data.activate&&!this.channel){this.play(this.currentSource);}else {this.unpause();}}}onDisable(){this.pause();}loadAudioSourceAssets(ids){const assets=ids.map(id=>{return this.system.app.assets.get(id)});const sources={};let currentSource=null;let count=assets.length;const _error=e=>{count--;};const _done=()=>{this.data.sources=sources;this.data.currentSource=currentSource;if(this.enabled&&this.activate&&currentSource){this.onEnable();}};assets.forEach((asset,index)=>{if(asset){currentSource=currentSource||asset.name;asset.off("change",this.onAssetChanged,this);asset.on("change",this.onAssetChanged,this);asset.off("remove",this.onAssetRemoved,this);asset.on("remove",this.onAssetRemoved,this);asset.off("error",_error,this);asset.on("error",_error,this);asset.ready(asset=>{sources[asset.name]=asset.resource;count--;if(count===0){_done();}});if(!asset.resource&&this.enabled&&this.entity.enabled){this.system.app.assets.load(asset);}}else {count--;if(count===0){_done();}this.system.app.assets.on(`add:${ids[index]}`,asset=>{asset.ready(asset=>{this.data.sources[asset.name]=asset.resource;});if(!asset.resource){this.system.app.assets.load(asset);}});}});}constructor(system,entity){super(system,entity);this.on("set_assets",this.onSetAssets,this);this.on("set_loop",this.onSetLoop,this);this.on("set_volume",this.onSetVolume,this);this.on("set_pitch",this.onSetPitch,this);this.on("set_minDistance",this.onSetMinDistance,this);this.on("set_maxDistance",this.onSetMaxDistance,this);this.on("set_rollOffFactor",this.onSetRollOffFactor,this);this.on("set_distanceModel",this.onSetDistanceModel,this);this.on("set_3d",this.onSet3d,this);}}class AudioSourceComponentData{constructor(){this.enabled=true;this.assets=[];this.activate=true;this.volume=1;this.pitch=1;this.loop=false;this["3d"]=true;this.minDistance=1;this.maxDistance=1e4;this.rollOffFactor=1;this.distanceModel=DISTANCE_INVERSE;this.paused=true;this.sources={};this.currentSource=null;this.channel=null;}}const _schema$j=["enabled","assets","volume","pitch","loop","activate","3d","minDistance","maxDistance","rollOffFactor","distanceModel","sources","currentSource","channel"];class AudioSourceComponentSystem extends ComponentSystem{initializeComponentData(component,data,properties){properties=["activate","volume","pitch","loop","3d","minDistance","maxDistance","rollOffFactor","distanceModel","enabled","assets"];super.initializeComponentData(component,data,properties);component.paused=!(component.enabled&&component.activate);}onInitialize(root){if(root.audiosource&&root.enabled&&root.audiosource.enabled&&root.audiosource.activate){root.audiosource.play(root.audiosource.currentSource);}const children=root._children;for(let i=0,len=children.length;i<len;i++){if(children[i]instanceof Entity){this.onInitialize(children[i]);}}this.initialized=true;}onUpdate(dt){const components=this.store;for(const id in components){if(components.hasOwnProperty(id)){const component=components[id];const entity=component.entity;const componentData=component.data;if(componentData.enabled&&entity.enabled&&componentData.channel instanceof Channel3d){const pos=entity.getPosition();componentData.channel.setPosition(pos);}}}}onRemove(entity,data){if(data.channel){data.channel.stop();data.channel=null;}}setVolume(volume){this.manager.setVolume(volume);}destroy(){super.destroy();this.app.systems.off("initialize",this.onInitialize,this);this.app.systems.off("update",this.onUpdate,this);}constructor(app){super(app);this.id="audiosource";this.ComponentType=AudioSourceComponent;this.DataType=AudioSourceComponentData;this.schema=_schema$j;this.manager=app.soundManager;this.initialized=false;this.app.systems.on("initialize",this.onInitialize,this);this.app.systems.on("update",this.onUpdate,this);this.on("remove",this.onRemove,this);}}Component._buildAccessors(AudioSourceComponent.prototype,_schema$j);const BUTTON_TRANSITION_MODE_TINT=0;const BUTTON_TRANSITION_MODE_SPRITE_CHANGE=1;const ELEMENTTYPE_GROUP="group";const ELEMENTTYPE_IMAGE="image";const ELEMENTTYPE_TEXT="text";const FITMODE_STRETCH="stretch";const FITMODE_CONTAIN="contain";const FITMODE_COVER="cover";const VisualState={DEFAULT:"DEFAULT",HOVER:"HOVER",PRESSED:"PRESSED",INACTIVE:"INACTIVE"};const STATES_TO_TINT_NAMES={};STATES_TO_TINT_NAMES[VisualState.DEFAULT]="_defaultTint";STATES_TO_TINT_NAMES[VisualState.HOVER]="hoverTint";STATES_TO_TINT_NAMES[VisualState.PRESSED]="pressedTint";STATES_TO_TINT_NAMES[VisualState.INACTIVE]="inactiveTint";const STATES_TO_SPRITE_ASSET_NAMES={};STATES_TO_SPRITE_ASSET_NAMES[VisualState.DEFAULT]="_defaultSpriteAsset";STATES_TO_SPRITE_ASSET_NAMES[VisualState.HOVER]="hoverSpriteAsset";STATES_TO_SPRITE_ASSET_NAMES[VisualState.PRESSED]="pressedSpriteAsset";STATES_TO_SPRITE_ASSET_NAMES[VisualState.INACTIVE]="inactiveSpriteAsset";const STATES_TO_SPRITE_FRAME_NAMES={};STATES_TO_SPRITE_FRAME_NAMES[VisualState.DEFAULT]="_defaultSpriteFrame";STATES_TO_SPRITE_FRAME_NAMES[VisualState.HOVER]="hoverSpriteFrame";STATES_TO_SPRITE_FRAME_NAMES[VisualState.PRESSED]="pressedSpriteFrame";STATES_TO_SPRITE_FRAME_NAMES[VisualState.INACTIVE]="inactiveSpriteFrame";class ButtonComponent extends Component{get data(){const record=this.system.store[this.entity.getGuid()];return record?record.data:null}set enabled(arg){this._setValue("enabled",arg);}get enabled(){return this.data.enabled}set active(arg){this._setValue("active",arg);}get active(){return this.data.active}set imageEntity(arg){if(this._imageEntity!==arg){const isString=typeof arg==="string";if(this._imageEntity&&isString&&this._imageEntity.getGuid()===arg){return}if(this._imageEntity){this._imageEntityUnsubscribe();}if(arg instanceof GraphNode){this._imageEntity=arg;}else if(isString){this._imageEntity=this.system.app.getEntityFromIndex(arg)||null;}else {this._imageEntity=null;}if(this._imageEntity){this._imageEntitySubscribe();}if(this._imageEntity){this.data.imageEntity=this._imageEntity.getGuid();}else if(isString&&arg){this.data.imageEntity=arg;}}}get imageEntity(){return this._imageEntity}set hitPadding(arg){this._setValue("hitPadding",arg);}get hitPadding(){return this.data.hitPadding}set transitionMode(arg){this._setValue("transitionMode",arg);}get transitionMode(){return this.data.transitionMode}set hoverTint(arg){this._setValue("hoverTint",arg);}get hoverTint(){return this.data.hoverTint}set pressedTint(arg){this._setValue("pressedTint",arg);}get pressedTint(){return this.data.pressedTint}set inactiveTint(arg){this._setValue("inactiveTint",arg);}get inactiveTint(){return this.data.inactiveTint}set fadeDuration(arg){this._setValue("fadeDuration",arg);}get fadeDuration(){return this.data.fadeDuration}set hoverSpriteAsset(arg){this._setValue("hoverSpriteAsset",arg);}get hoverSpriteAsset(){return this.data.hoverSpriteAsset}set hoverSpriteFrame(arg){this._setValue("hoverSpriteFrame",arg);}get hoverSpriteFrame(){return this.data.hoverSpriteFrame}set pressedSpriteAsset(arg){this._setValue("pressedSpriteAsset",arg);}get pressedSpriteAsset(){return this.data.pressedSpriteAsset}set pressedSpriteFrame(arg){this._setValue("pressedSpriteFrame",arg);}get pressedSpriteFrame(){return this.data.pressedSpriteFrame}set inactiveSpriteAsset(arg){this._setValue("inactiveSpriteAsset",arg);}get inactiveSpriteAsset(){return this.data.inactiveSpriteAsset}set inactiveSpriteFrame(arg){this._setValue("inactiveSpriteFrame",arg);}get inactiveSpriteFrame(){return this.data.inactiveSpriteFrame}_setValue(name,value){const data=this.data;const oldValue=data[name];data[name]=value;this.fire("set",name,oldValue,value);}_toggleLifecycleListeners(onOrOff,system){this[onOrOff]("set_active",this._onSetActive,this);this[onOrOff]("set_transitionMode",this._onSetTransitionMode,this);this[onOrOff]("set_hoverTint",this._onSetTransitionValue,this);this[onOrOff]("set_pressedTint",this._onSetTransitionValue,this);this[onOrOff]("set_inactiveTint",this._onSetTransitionValue,this);this[onOrOff]("set_hoverSpriteAsset",this._onSetTransitionValue,this);this[onOrOff]("set_hoverSpriteFrame",this._onSetTransitionValue,this);this[onOrOff]("set_pressedSpriteAsset",this._onSetTransitionValue,this);this[onOrOff]("set_pressedSpriteFrame",this._onSetTransitionValue,this);this[onOrOff]("set_inactiveSpriteAsset",this._onSetTransitionValue,this);this[onOrOff]("set_inactiveSpriteFrame",this._onSetTransitionValue,this);if(onOrOff==="on"){this._evtElementAdd=this.entity.on("element:add",this._onElementComponentAdd,this);}else {var _this$_evtElementAdd;(_this$_evtElementAdd=this._evtElementAdd)==null||_this$_evtElementAdd.off();this._evtElementAdd=null;}}_onSetActive(name,oldValue,newValue){if(oldValue!==newValue){this._updateVisualState();}}_onSetTransitionMode(name,oldValue,newValue){if(oldValue!==newValue){this._cancelTween();this._resetToDefaultVisualState(oldValue);this._forceReapplyVisualState();}}_onSetTransitionValue(name,oldValue,newValue){if(oldValue!==newValue){this._forceReapplyVisualState();}}_imageEntitySubscribe(){this._evtImageEntityElementAdd=this._imageEntity.on("element:add",this._onImageElementGain,this);if(this._imageEntity.element){this._onImageElementGain();}}_imageEntityUnsubscribe(){var _this$_evtImageEntity,_this$_imageEntity;(_this$_evtImageEntity=this._evtImageEntityElementAdd)==null||_this$_evtImageEntity.off();this._evtImageEntityElementAdd=null;if((_this$_imageEntity=this._imageEntity)!=null&&_this$_imageEntity.element){this._onImageElementLose();}}_imageEntityElementSubscribe(){const element=this._imageEntity.element;this._evtImageEntityElementRemove=element.once("beforeremove",this._onImageElementLose,this);this._evtImageEntityElementColor=element.on("set:color",this._onSetColor,this);this._evtImageEntityElementOpacity=element.on("set:opacity",this._onSetOpacity,this);this._evtImageEntityElementSpriteAsset=element.on("set:spriteAsset",this._onSetSpriteAsset,this);this._evtImageEntityElementSpriteFrame=element.on("set:spriteFrame",this._onSetSpriteFrame,this);}_imageEntityElementUnsubscribe(){var _this$_evtImageEntity2,_this$_evtImageEntity3,_this$_evtImageEntity4,_this$_evtImageEntity5,_this$_evtImageEntity6;(_this$_evtImageEntity2=this._evtImageEntityElementRemove)==null||_this$_evtImageEntity2.off();this._evtImageEntityElementRemove=null;(_this$_evtImageEntity3=this._evtImageEntityElementColor)==null||_this$_evtImageEntity3.off();this._evtImageEntityElementColor=null;(_this$_evtImageEntity4=this._evtImageEntityElementOpacity)==null||_this$_evtImageEntity4.off();this._evtImageEntityElementOpacity=null;(_this$_evtImageEntity5=this._evtImageEntityElementSpriteAsset)==null||_this$_evtImageEntity5.off();this._evtImageEntityElementSpriteAsset=null;(_this$_evtImageEntity6=this._evtImageEntityElementSpriteFrame)==null||_this$_evtImageEntity6.off();this._evtImageEntityElementSpriteFrame=null;}_onElementComponentRemove(){this._toggleHitElementListeners("off");}_onElementComponentAdd(){this._toggleHitElementListeners("on");}_onImageElementLose(){this._imageEntityElementUnsubscribe();this._cancelTween();this._resetToDefaultVisualState(this.transitionMode);}_onImageElementGain(){this._imageEntityElementSubscribe();this._storeDefaultVisualState();this._forceReapplyVisualState();}_toggleHitElementListeners(onOrOff){if(this.entity.element){const isAdding=onOrOff==="on";if(isAdding&&this._hasHitElementListeners){return}this.entity.element[onOrOff]("beforeremove",this._onElementComponentRemove,this);this.entity.element[onOrOff]("mouseenter",this._onMouseEnter,this);this.entity.element[onOrOff]("mouseleave",this._onMouseLeave,this);this.entity.element[onOrOff]("mousedown",this._onMouseDown,this);this.entity.element[onOrOff]("mouseup",this._onMouseUp,this);this.entity.element[onOrOff]("touchstart",this._onTouchStart,this);this.entity.element[onOrOff]("touchend",this._onTouchEnd,this);this.entity.element[onOrOff]("touchleave",this._onTouchLeave,this);this.entity.element[onOrOff]("touchcancel",this._onTouchCancel,this);this.entity.element[onOrOff]("selectstart",this._onSelectStart,this);this.entity.element[onOrOff]("selectend",this._onSelectEnd,this);this.entity.element[onOrOff]("selectenter",this._onSelectEnter,this);this.entity.element[onOrOff]("selectleave",this._onSelectLeave,this);this.entity.element[onOrOff]("click",this._onClick,this);this._hasHitElementListeners=isAdding;}}_storeDefaultVisualState(){var _this$_imageEntity2;const element=(_this$_imageEntity2=this._imageEntity)==null?void 0:_this$_imageEntity2.element;if(!element||element.type===ELEMENTTYPE_GROUP){return}this._storeDefaultColor(element.color);this._storeDefaultOpacity(element.opacity);this._storeDefaultSpriteAsset(element.spriteAsset);this._storeDefaultSpriteFrame(element.spriteFrame);}_storeDefaultColor(color){this._defaultTint.r=color.r;this._defaultTint.g=color.g;this._defaultTint.b=color.b;}_storeDefaultOpacity(opacity){this._defaultTint.a=opacity;}_storeDefaultSpriteAsset(spriteAsset){this._defaultSpriteAsset=spriteAsset;}_storeDefaultSpriteFrame(spriteFrame){this._defaultSpriteFrame=spriteFrame;}_onSetColor(color){if(!this._isApplyingTint){this._storeDefaultColor(color);this._forceReapplyVisualState();}}_onSetOpacity(opacity){if(!this._isApplyingTint){this._storeDefaultOpacity(opacity);this._forceReapplyVisualState();}}_onSetSpriteAsset(spriteAsset){if(!this._isApplyingSprite){this._storeDefaultSpriteAsset(spriteAsset);this._forceReapplyVisualState();}}_onSetSpriteFrame(spriteFrame){if(!this._isApplyingSprite){this._storeDefaultSpriteFrame(spriteFrame);this._forceReapplyVisualState();}}_onMouseEnter(event){this._isHovering=true;this._updateVisualState();this._fireIfActive("mouseenter",event);}_onMouseLeave(event){this._isHovering=false;this._isPressed=false;this._updateVisualState();this._fireIfActive("mouseleave",event);}_onMouseDown(event){this._isPressed=true;this._updateVisualState();this._fireIfActive("mousedown",event);}_onMouseUp(event){this._isPressed=false;this._updateVisualState();this._fireIfActive("mouseup",event);}_onTouchStart(event){this._isPressed=true;this._updateVisualState();this._fireIfActive("touchstart",event);}_onTouchEnd(event){event.event.preventDefault();this._isPressed=false;this._updateVisualState();this._fireIfActive("touchend",event);}_onTouchLeave(event){this._isPressed=false;this._updateVisualState();this._fireIfActive("touchleave",event);}_onTouchCancel(event){this._isPressed=false;this._updateVisualState();this._fireIfActive("touchcancel",event);}_onSelectStart(event){this._isPressed=true;this._updateVisualState();this._fireIfActive("selectstart",event);}_onSelectEnd(event){this._isPressed=false;this._updateVisualState();this._fireIfActive("selectend",event);}_onSelectEnter(event){this._hoveringCounter++;if(this._hoveringCounter===1){this._isHovering=true;this._updateVisualState();}this._fireIfActive("selectenter",event);}_onSelectLeave(event){this._hoveringCounter--;if(this._hoveringCounter===0){this._isHovering=false;this._isPressed=false;this._updateVisualState();}this._fireIfActive("selectleave",event);}_onClick(event){this._fireIfActive("click",event);}_fireIfActive(name,event){if(this.data.active){this.fire(name,event);}}_updateVisualState(force){const oldVisualState=this._visualState;const newVisualState=this._determineVisualState();if((oldVisualState!==newVisualState||force)&&this.enabled){this._visualState=newVisualState;if(oldVisualState===VisualState.HOVER){this._fireIfActive("hoverend");}if(oldVisualState===VisualState.PRESSED){this._fireIfActive("pressedend");}if(newVisualState===VisualState.HOVER){this._fireIfActive("hoverstart");}if(newVisualState===VisualState.PRESSED){this._fireIfActive("pressedstart");}switch(this.transitionMode){case BUTTON_TRANSITION_MODE_TINT:{const tintName=STATES_TO_TINT_NAMES[this._visualState];const tintColor=this[tintName];this._applyTint(tintColor);break}case BUTTON_TRANSITION_MODE_SPRITE_CHANGE:{const spriteAssetName=STATES_TO_SPRITE_ASSET_NAMES[this._visualState];const spriteFrameName=STATES_TO_SPRITE_FRAME_NAMES[this._visualState];const spriteAsset=this[spriteAssetName];const spriteFrame=this[spriteFrameName];this._applySprite(spriteAsset,spriteFrame);break}}}}_forceReapplyVisualState(){this._updateVisualState(true);}_resetToDefaultVisualState(transitionMode){var _this$_imageEntity3;if(!((_this$_imageEntity3=this._imageEntity)!=null&&_this$_imageEntity3.element)){return}switch(transitionMode){case BUTTON_TRANSITION_MODE_TINT:this._cancelTween();this._applyTintImmediately(this._defaultTint);break;case BUTTON_TRANSITION_MODE_SPRITE_CHANGE:this._applySprite(this._defaultSpriteAsset,this._defaultSpriteFrame);break}}_determineVisualState(){if(!this.active){return VisualState.INACTIVE}else if(this._isPressed){return VisualState.PRESSED}else if(this._isHovering){return VisualState.HOVER}return VisualState.DEFAULT}_applySprite(spriteAsset,spriteFrame){var _this$_imageEntity4;const element=(_this$_imageEntity4=this._imageEntity)==null?void 0:_this$_imageEntity4.element;if(!element){return}spriteFrame=spriteFrame||0;this._isApplyingSprite=true;if(element.spriteAsset!==spriteAsset){element.spriteAsset=spriteAsset;}if(element.spriteFrame!==spriteFrame){element.spriteFrame=spriteFrame;}this._isApplyingSprite=false;}_applyTint(tintColor){this._cancelTween();if(this.fadeDuration===0){this._applyTintImmediately(tintColor);}else {this._applyTintWithTween(tintColor);}}_applyTintImmediately(tintColor){var _this$_imageEntity5;const element=(_this$_imageEntity5=this._imageEntity)==null?void 0:_this$_imageEntity5.element;if(!tintColor||!element||element.type===ELEMENTTYPE_GROUP){return}const color3=toColor3(tintColor);this._isApplyingTint=true;if(!color3.equals(element.color)){element.color=color3;}if(element.opacity!==tintColor.a){element.opacity=tintColor.a;}this._isApplyingTint=false;}_applyTintWithTween(tintColor){var _this$_imageEntity6;const element=(_this$_imageEntity6=this._imageEntity)==null?void 0:_this$_imageEntity6.element;if(!tintColor||!element||element.type===ELEMENTTYPE_GROUP){return}const color3=toColor3(tintColor);const color=element.color;const opacity=element.opacity;if(color3.equals(color)&&tintColor.a===opacity)return;this._tweenInfo={startTime:now(),from:new Color(color.r,color.g,color.b,opacity),to:tintColor.clone(),lerpColor:new Color};}_updateTintTween(){const elapsedTime=now()-this._tweenInfo.startTime;let elapsedProportion=this.fadeDuration===0?1:elapsedTime/this.fadeDuration;elapsedProportion=math.clamp(elapsedProportion,0,1);if(Math.abs(elapsedProportion-1)>1e-5){const lerpColor=this._tweenInfo.lerpColor;lerpColor.lerp(this._tweenInfo.from,this._tweenInfo.to,elapsedProportion);this._applyTintImmediately(new Color(lerpColor.r,lerpColor.g,lerpColor.b,lerpColor.a));}else {this._applyTintImmediately(this._tweenInfo.to);this._cancelTween();}}_cancelTween(){delete this._tweenInfo;}onUpdate(){if(this._tweenInfo){this._updateTintTween();}}onEnable(){this._isHovering=false;this._hoveringCounter=0;this._isPressed=false;this._toggleHitElementListeners("on");this._forceReapplyVisualState();}onDisable(){this._toggleHitElementListeners("off");this._resetToDefaultVisualState(this.transitionMode);}onRemove(){this._imageEntityUnsubscribe();this._toggleLifecycleListeners("off",this.system);this.onDisable();}resolveDuplicatedEntityReferenceProperties(oldButton,duplicatedIdsMap){if(oldButton.imageEntity){this.imageEntity=duplicatedIdsMap[oldButton.imageEntity.getGuid()];}}constructor(system,entity){super(system,entity);this._imageEntity=null;this._evtElementAdd=null;this._evtImageEntityElementAdd=null;this._evtImageEntityElementRemove=null;this._evtImageEntityElementColor=null;this._evtImageEntityElementOpacity=null;this._evtImageEntityElementSpriteAsset=null;this._evtImageEntityElementSpriteFrame=null;this._visualState=VisualState.DEFAULT;this._isHovering=false;this._hoveringCounter=0;this._isPressed=false;this._defaultTint=new Color(1,1,1,1);this._defaultSpriteAsset=null;this._defaultSpriteFrame=0;this._toggleLifecycleListeners("on",system);}}ButtonComponent.EVENT_MOUSEDOWN="mousedown";ButtonComponent.EVENT_MOUSEUP="mouseup";ButtonComponent.EVENT_MOUSEENTER="mouseenter";ButtonComponent.EVENT_MOUSELEAVE="mouseleave";ButtonComponent.EVENT_CLICK="click";ButtonComponent.EVENT_TOUCHSTART="touchstart";ButtonComponent.EVENT_TOUCHEND="touchend";ButtonComponent.EVENT_TOUCHCANCEL="touchcancel";ButtonComponent.EVENT_TOUCHLEAVE="touchleave";ButtonComponent.EVENT_SELECTSTART="selectstart";ButtonComponent.EVENT_SELECTEND="selectend";ButtonComponent.EVENT_SELECTENTER="selectenter";ButtonComponent.EVENT_SELECTLEAVE="selectleave";ButtonComponent.EVENT_HOVERSTART="hoverstart";ButtonComponent.EVENT_HOVEREND="hoverend";ButtonComponent.EVENT_PRESSEDSTART="pressedstart";ButtonComponent.EVENT_PRESSEDEND="pressedend";function toColor3(color4){return new Color(color4.r,color4.g,color4.b)}class ButtonComponentData{constructor(){this.enabled=true;this.active=true;this.imageEntity=null;this.hitPadding=new Vec4;this.transitionMode=BUTTON_TRANSITION_MODE_TINT;this.hoverTint=new Color(.75,.75,.75);this.pressedTint=new Color(.5,.5,.5);this.inactiveTint=new Color(.25,.25,.25);this.fadeDuration=0;this.hoverSpriteAsset=null;this.hoverSpriteFrame=0;this.pressedSpriteAsset=null;this.pressedSpriteFrame=0;this.inactiveSpriteAsset=null;this.inactiveSpriteFrame=0;}}const _schema$i=["enabled","active",{name:"hitPadding",type:"vec4"},"transitionMode",{name:"hoverTint",type:"rgba"},{name:"pressedTint",type:"rgba"},{name:"inactiveTint",type:"rgba"},"fadeDuration","hoverSpriteAsset","hoverSpriteFrame","pressedSpriteAsset","pressedSpriteFrame","inactiveSpriteAsset","inactiveSpriteFrame"];class ButtonComponentSystem extends ComponentSystem{initializeComponentData(component,data,properties){component.imageEntity=data.imageEntity;super.initializeComponentData(component,data,_schema$i);}onUpdate(dt){const components=this.store;for(const id in components){const entity=components[id].entity;const component=entity.button;if(component.enabled&&entity.enabled){component.onUpdate();}}}_onRemoveComponent(entity,component){component.onRemove();}destroy(){super.destroy();this.app.systems.off("update",this.onUpdate,this);}constructor(app){super(app);this.id="button";this.ComponentType=ButtonComponent;this.DataType=ButtonComponentData;this.schema=_schema$i;this.on("beforeremove",this._onRemoveComponent,this);this.app.systems.on("update",this.onUpdate,this);}}const _vec3$1=new Vec3;const _quat=new Quat;class CollisionComponent extends Component{get data(){const record=this.system.store[this.entity.getGuid()];return record?record.data:null}set enabled(arg){this._setValue("enabled",arg);}get enabled(){return this.data.enabled}set type(arg){this._setValue("type",arg);}get type(){return this.data.type}set halfExtents(arg){this._setValue("halfExtents",arg);}get halfExtents(){return this.data.halfExtents}set linearOffset(arg){this._setValue("linearOffset",arg);}get linearOffset(){return this.data.linearOffset}set angularOffset(arg){this._setValue("angularOffset",arg);}get angularOffset(){return this.data.angularOffset}set radius(arg){this._setValue("radius",arg);}get radius(){return this.data.radius}set axis(arg){this._setValue("axis",arg);}get axis(){return this.data.axis}set height(arg){this._setValue("height",arg);}get height(){return this.data.height}set asset(arg){this._setValue("asset",arg);}get asset(){return this.data.asset}set renderAsset(arg){this._setValue("renderAsset",arg);}get renderAsset(){return this.data.renderAsset}set convexHull(arg){this._setValue("convexHull",arg);}get convexHull(){return this.data.convexHull}set shape(arg){this._setValue("shape",arg);}get shape(){return this.data.shape}set model(arg){this._setValue("model",arg);}get model(){return this.data.model}set render(arg){this._setValue("render",arg);}get render(){return this.data.render}set checkVertexDuplicates(arg){this._setValue("checkVertexDuplicates",arg);}get checkVertexDuplicates(){return this.data.checkVertexDuplicates}_setValue(name,value){const data=this.data;const oldValue=data[name];data[name]=value;this.fire("set",name,oldValue,value);}onSetType(name,oldValue,newValue){if(oldValue!==newValue){this.system.changeType(this,oldValue,newValue);}}onSetHalfExtents(name,oldValue,newValue){const t=this.data.type;if(this.data.initialized&&t==="box"){this.system.recreatePhysicalShapes(this);}}onSetOffset(name,oldValue,newValue){this._hasOffset=!this.data.linearOffset.equals(Vec3.ZERO)||!this.data.angularOffset.equals(Quat.IDENTITY);if(this.data.initialized){this.system.recreatePhysicalShapes(this);}}onSetRadius(name,oldValue,newValue){const t=this.data.type;if(this.data.initialized&&(t==="sphere"||t==="capsule"||t==="cylinder"||t==="cone")){this.system.recreatePhysicalShapes(this);}}onSetHeight(name,oldValue,newValue){const t=this.data.type;if(this.data.initialized&&(t==="capsule"||t==="cylinder"||t==="cone")){this.system.recreatePhysicalShapes(this);}}onSetAxis(name,oldValue,newValue){const t=this.data.type;if(this.data.initialized&&(t==="capsule"||t==="cylinder"||t==="cone")){this.system.recreatePhysicalShapes(this);}}onSetAsset(name,oldValue,newValue){const assets=this.system.app.assets;if(oldValue){const asset=assets.get(oldValue);if(asset){asset.off("remove",this.onAssetRemoved,this);}}if(newValue){if(newValue instanceof Asset){this.data.asset=newValue.id;}const asset=assets.get(this.data.asset);if(asset){asset.off("remove",this.onAssetRemoved,this);asset.on("remove",this.onAssetRemoved,this);}}if(this.data.initialized&&this.data.type==="mesh"){if(!newValue){this.data.model=null;}this.system.recreatePhysicalShapes(this);}}onSetRenderAsset(name,oldValue,newValue){const assets=this.system.app.assets;if(oldValue){const asset=assets.get(oldValue);if(asset){asset.off("remove",this.onRenderAssetRemoved,this);}}if(newValue){if(newValue instanceof Asset){this.data.renderAsset=newValue.id;}const asset=assets.get(this.data.renderAsset);if(asset){asset.off("remove",this.onRenderAssetRemoved,this);asset.on("remove",this.onRenderAssetRemoved,this);}}if(this.data.initialized&&this.data.type==="mesh"){if(!newValue){this.data.render=null;}this.system.recreatePhysicalShapes(this);}}onSetModel(name,oldValue,newValue){if(this.data.initialized&&this.data.type==="mesh"){this.system.implementations.mesh.doRecreatePhysicalShape(this);}}onSetRender(name,oldValue,newValue){this.onSetModel(name,oldValue,newValue);}onAssetRemoved(asset){asset.off("remove",this.onAssetRemoved,this);if(this.data.asset===asset.id){this.asset=null;}}onRenderAssetRemoved(asset){asset.off("remove",this.onRenderAssetRemoved,this);if(this.data.renderAsset===asset.id){this.renderAsset=null;}}getCompoundChildShapeIndex(shape){const compound=this.data.shape;const shapes=compound.getNumChildShapes();for(let i=0;i<shapes;i++){const childShape=compound.getChildShape(i);if(Ammo.getPointer(childShape)===Ammo.getPointer(shape)){return i}}return null}_onInsert(parent){if(typeof Ammo==="undefined"){return}if(this._compoundParent){this.system.recreatePhysicalShapes(this);}else if(!this.entity.rigidbody){let ancestor=this.entity.parent;while(ancestor){if(ancestor.collision&&ancestor.collision.type==="compound"){if(ancestor.collision.shape.getNumChildShapes()===0){this.system.recreatePhysicalShapes(ancestor.collision);}else {this.system.recreatePhysicalShapes(this);}break}ancestor=ancestor.parent;}}}_updateCompound(){const entity=this.entity;if(entity._dirtyWorld){let dirty=entity._dirtyLocal;let parent=entity;while(parent&&!dirty){if(parent.collision&&parent.collision===this._compoundParent){break}if(parent._dirtyLocal){dirty=true;}parent=parent.parent;}if(dirty){entity.forEach(this.system.implementations.compound._updateEachDescendantTransform,entity);const bodyComponent=this._compoundParent.entity.rigidbody;if(bodyComponent){bodyComponent.activate();}}}}getShapePosition(){const pos=this.entity.getPosition();if(this._hasOffset){const rot=this.entity.getRotation();const lo=this.data.linearOffset;_quat.copy(rot).transformVector(lo,_vec3$1);return _vec3$1.add(pos)}return pos}getShapeRotation(){const rot=this.entity.getRotation();if(this._hasOffset){return _quat.copy(rot).mul(this.data.angularOffset)}return rot}onEnable(){if(this.data.type==="mesh"&&(this.data.asset||this.data.renderAsset)&&this.data.initialized){const asset=this.system.app.assets.get(this.data.asset||this.data.renderAsset);if(asset&&(!asset.resource||!this.data.shape)){this.system.recreatePhysicalShapes(this);return}}if(this.entity.rigidbody){if(this.entity.rigidbody.enabled){this.entity.rigidbody.enableSimulation();}}else if(this._compoundParent&&this!==this._compoundParent){if(this._compoundParent.shape.getNumChildShapes()===0){this.system.recreatePhysicalShapes(this._compoundParent);}else {const transform=this.system._getNodeTransform(this.entity,this._compoundParent.entity);this._compoundParent.shape.addChildShape(transform,this.data.shape);Ammo.destroy(transform);if(this._compoundParent.entity.rigidbody){this._compoundParent.entity.rigidbody.activate();}}}else if(this.entity.trigger){this.entity.trigger.enable();}}onDisable(){if(this.entity.rigidbody){this.entity.rigidbody.disableSimulation();}else if(this._compoundParent&&this!==this._compoundParent){if(!this._compoundParent.entity._destroying){this.system._removeCompoundChild(this._compoundParent,this.data.shape);if(this._compoundParent.entity.rigidbody){this._compoundParent.entity.rigidbody.activate();}}}else if(this.entity.trigger){this.entity.trigger.disable();}}onBeforeRemove(){if(this.asset){this.asset=null;}if(this.renderAsset){this.renderAsset=null;}this.entity.off("insert",this._onInsert,this);this.off();}constructor(system,entity){super(system,entity);this._compoundParent=null;this._hasOffset=false;this.entity.on("insert",this._onInsert,this);this.on("set_type",this.onSetType,this);this.on("set_convexHull",this.onSetModel,this);this.on("set_halfExtents",this.onSetHalfExtents,this);this.on("set_linearOffset",this.onSetOffset,this);this.on("set_angularOffset",this.onSetOffset,this);this.on("set_radius",this.onSetRadius,this);this.on("set_height",this.onSetHeight,this);this.on("set_axis",this.onSetAxis,this);this.on("set_asset",this.onSetAsset,this);this.on("set_renderAsset",this.onSetRenderAsset,this);this.on("set_model",this.onSetModel,this);this.on("set_render",this.onSetRender,this);}}CollisionComponent.EVENT_CONTACT="contact";CollisionComponent.EVENT_COLLISIONSTART="collisionstart";CollisionComponent.EVENT_COLLISIONEND="collisionend";CollisionComponent.EVENT_TRIGGERENTER="triggerenter";CollisionComponent.EVENT_TRIGGERLEAVE="triggerleave";class CollisionComponentData{constructor(){this.enabled=true;this.type="box";this.halfExtents=new Vec3(.5,.5,.5);this.linearOffset=new Vec3;this.angularOffset=new Quat;this.radius=.5;this.axis=1;this.height=2;this.convexHull=false;this.asset=null;this.renderAsset=null;this.checkVertexDuplicates=true;this.shape=null;this.model=null;this.render=null;this.initialized=false;}}const BODYTYPE_STATIC="static";const BODYTYPE_DYNAMIC="dynamic";const BODYTYPE_KINEMATIC="kinematic";const BODYFLAG_STATIC_OBJECT=1;const BODYFLAG_KINEMATIC_OBJECT=2;const BODYFLAG_NORESPONSE_OBJECT=4;const BODYSTATE_ACTIVE_TAG=1;const BODYSTATE_ISLAND_SLEEPING=2;const BODYSTATE_WANTS_DEACTIVATION=3;const BODYSTATE_DISABLE_DEACTIVATION=4;const BODYSTATE_DISABLE_SIMULATION=5;const BODYGROUP_NONE=0;const BODYGROUP_DEFAULT=1;const BODYGROUP_DYNAMIC=1;const BODYGROUP_STATIC=2;const BODYGROUP_KINEMATIC=4;const BODYGROUP_ENGINE_1=8;const BODYGROUP_TRIGGER=16;const BODYGROUP_ENGINE_2=32;const BODYGROUP_ENGINE_3=64;const BODYGROUP_USER_1=128;const BODYGROUP_USER_2=256;const BODYGROUP_USER_3=512;const BODYGROUP_USER_4=1024;const BODYGROUP_USER_5=2048;const BODYGROUP_USER_6=4096;const BODYGROUP_USER_7=8192;const BODYGROUP_USER_8=16384;const BODYMASK_NONE=0;const BODYMASK_ALL=65535;const BODYMASK_STATIC=2;const BODYMASK_NOT_STATIC=65535^2;const BODYMASK_NOT_STATIC_KINEMATIC=65535^(2|4);let _ammoVec1$1,_ammoQuat$1,_ammoTransform$1;class Trigger{initialize(data){const entity=this.entity;const shape=data.shape;if(shape&&typeof Ammo!=="undefined"){if(entity.trigger){entity.trigger.destroy();}const mass=1;const component=this.component;if(component){const bodyPos=component.getShapePosition();const bodyRot=component.getShapeRotation();_ammoVec1$1.setValue(bodyPos.x,bodyPos.y,bodyPos.z);_ammoQuat$1.setValue(bodyRot.x,bodyRot.y,bodyRot.z,bodyRot.w);}else {const pos=entity.getPosition();const rot=entity.getRotation();_ammoVec1$1.setValue(pos.x,pos.y,pos.z);_ammoQuat$1.setValue(rot.x,rot.y,rot.z,rot.w);}_ammoTransform$1.setOrigin(_ammoVec1$1);_ammoTransform$1.setRotation(_ammoQuat$1);const body=this.app.systems.rigidbody.createBody(mass,shape,_ammoTransform$1);body.setRestitution(0);body.setFriction(0);body.setDamping(0,0);_ammoVec1$1.setValue(0,0,0);body.setLinearFactor(_ammoVec1$1);body.setAngularFactor(_ammoVec1$1);body.setCollisionFlags(body.getCollisionFlags()|BODYFLAG_NORESPONSE_OBJECT);body.entity=entity;this.body=body;if(this.component.enabled&&entity.enabled){this.enable();}}}destroy(){const body=this.body;if(!body)return;this.disable();this.app.systems.rigidbody.destroyBody(body);}_getEntityTransform(transform){const component=this.component;if(component){const bodyPos=component.getShapePosition();const bodyRot=component.getShapeRotation();_ammoVec1$1.setValue(bodyPos.x,bodyPos.y,bodyPos.z);_ammoQuat$1.setValue(bodyRot.x,bodyRot.y,bodyRot.z,bodyRot.w);}else {const pos=this.entity.getPosition();const rot=this.entity.getRotation();_ammoVec1$1.setValue(pos.x,pos.y,pos.z);_ammoQuat$1.setValue(rot.x,rot.y,rot.z,rot.w);}transform.setOrigin(_ammoVec1$1);transform.setRotation(_ammoQuat$1);}updateTransform(){this._getEntityTransform(_ammoTransform$1);const body=this.body;body.setWorldTransform(_ammoTransform$1);body.activate();}enable(){const body=this.body;if(!body)return;const systems=this.app.systems;systems.rigidbody.addBody(body,BODYGROUP_TRIGGER,BODYMASK_NOT_STATIC^BODYGROUP_TRIGGER);systems.rigidbody._triggers.push(this);body.forceActivationState(BODYSTATE_ACTIVE_TAG);this.updateTransform();}disable(){const body=this.body;if(!body)return;const systems=this.app.systems;const idx=systems.rigidbody._triggers.indexOf(this);if(idx>-1){systems.rigidbody._triggers.splice(idx,1);}systems.rigidbody.removeBody(body);body.forceActivationState(BODYSTATE_DISABLE_SIMULATION);}constructor(app,component,data){this.entity=component.entity;this.component=component;this.app=app;if(typeof Ammo!=="undefined"&&!_ammoVec1$1){_ammoVec1$1=new Ammo.btVector3;_ammoQuat$1=new Ammo.btQuaternion;_ammoTransform$1=new Ammo.btTransform;}this.initialize(data);}}const mat4=new Mat4;const p1=new Vec3;const p2=new Vec3;const quat$1=new Quat;const tempGraphNode=new GraphNode;const _schema$h=["enabled","type","halfExtents","linearOffset","angularOffset","radius","axis","height","convexHull","asset","renderAsset","shape","model","render","checkVertexDuplicates"];class CollisionSystemImpl{beforeInitialize(component,data){data.shape=null;data.model=new Model;data.model.graph=new GraphNode;}afterInitialize(component,data){this.recreatePhysicalShapes(component);component.data.initialized=true;}reset(component,data){this.beforeInitialize(component,data);this.afterInitialize(component,data);}recreatePhysicalShapes(component){const entity=component.entity;const data=component.data;if(typeof Ammo!=="undefined"){if(entity.trigger){entity.trigger.destroy();delete entity.trigger;}if(data.shape){if(component._compoundParent){if(component!==component._compoundParent){this.system._removeCompoundChild(component._compoundParent,data.shape);}if(component._compoundParent.entity.rigidbody){component._compoundParent.entity.rigidbody.activate();}}this.destroyShape(data);}data.shape=this.createPhysicalShape(component.entity,data);const firstCompoundChild=!component._compoundParent;if(data.type==="compound"&&(!component._compoundParent||component===component._compoundParent)){component._compoundParent=component;entity.forEach(this._addEachDescendant,component);}else if(data.type!=="compound"){if(!component.rigidbody){component._compoundParent=null;let parent=entity.parent;while(parent){if(parent.collision&&parent.collision.type==="compound"){component._compoundParent=parent.collision;break}parent=parent.parent;}}}if(component._compoundParent){if(component!==component._compoundParent){if(firstCompoundChild&&component._compoundParent.shape.getNumChildShapes()===0){this.system.recreatePhysicalShapes(component._compoundParent);}else {this.system.updateCompoundChildTransform(entity,true);if(component._compoundParent.entity.rigidbody){component._compoundParent.entity.rigidbody.activate();}}}}if(entity.rigidbody){entity.rigidbody.disableSimulation();entity.rigidbody.createBody();if(entity.enabled&&entity.rigidbody.enabled){entity.rigidbody.enableSimulation();}}else if(!component._compoundParent){if(!entity.trigger){entity.trigger=new Trigger(this.system.app,component,data);}else {entity.trigger.initialize(data);}}}}createPhysicalShape(entity,data){return undefined}updateTransform(component,position,rotation,scale){if(component.entity.trigger){component.entity.trigger.updateTransform();}}destroyShape(data){if(data.shape){Ammo.destroy(data.shape);data.shape=null;}}beforeRemove(entity,component){if(component.data.shape){if(component._compoundParent&&!component._compoundParent.entity._destroying){this.system._removeCompoundChild(component._compoundParent,component.data.shape);if(component._compoundParent.entity.rigidbody){component._compoundParent.entity.rigidbody.activate();}}component._compoundParent=null;this.destroyShape(component.data);}}remove(entity,data){if(entity.rigidbody&&entity.rigidbody.body){entity.rigidbody.disableSimulation();}if(entity.trigger){entity.trigger.destroy();delete entity.trigger;}}clone(entity,clone){const src=this.system.store[entity.getGuid()];const data={enabled:src.data.enabled,type:src.data.type,halfExtents:[src.data.halfExtents.x,src.data.halfExtents.y,src.data.halfExtents.z],linearOffset:[src.data.linearOffset.x,src.data.linearOffset.y,src.data.linearOffset.z],angularOffset:[src.data.angularOffset.x,src.data.angularOffset.y,src.data.angularOffset.z,src.data.angularOffset.w],radius:src.data.radius,axis:src.data.axis,height:src.data.height,convexHull:src.data.convexHull,asset:src.data.asset,renderAsset:src.data.renderAsset,model:src.data.model,render:src.data.render,checkVertexDuplicates:src.data.checkVertexDuplicates};return this.system.addComponent(clone,data)}constructor(system){this.system=system;}}class CollisionBoxSystemImpl extends CollisionSystemImpl{createPhysicalShape(entity,data){if(typeof Ammo!=="undefined"){const he=data.halfExtents;const ammoHe=new Ammo.btVector3(he?he.x:.5,he?he.y:.5,he?he.z:.5);const shape=new Ammo.btBoxShape(ammoHe);Ammo.destroy(ammoHe);return shape}return undefined}}class CollisionSphereSystemImpl extends CollisionSystemImpl{createPhysicalShape(entity,data){if(typeof Ammo!=="undefined"){return new Ammo.btSphereShape(data.radius)}return undefined}}class CollisionCapsuleSystemImpl extends CollisionSystemImpl{createPhysicalShape(entity,data){var _data$axis,_data$radius,_data$height;const axis=(_data$axis=data.axis)!=null?_data$axis:1;const radius=(_data$radius=data.radius)!=null?_data$radius:.5;const height=Math.max(((_data$height=data.height)!=null?_data$height:2)-2*radius,0);let shape=null;if(typeof Ammo!=="undefined"){switch(axis){case 0:shape=new Ammo.btCapsuleShapeX(radius,height);break;case 1:shape=new Ammo.btCapsuleShape(radius,height);break;case 2:shape=new Ammo.btCapsuleShapeZ(radius,height);break}}return shape}}class CollisionCylinderSystemImpl extends CollisionSystemImpl{createPhysicalShape(entity,data){var _data$axis2,_data$radius2,_data$height2;const axis=(_data$axis2=data.axis)!=null?_data$axis2:1;const radius=(_data$radius2=data.radius)!=null?_data$radius2:.5;const height=(_data$height2=data.height)!=null?_data$height2:1;let halfExtents=null;let shape=null;if(typeof Ammo!=="undefined"){switch(axis){case 0:halfExtents=new Ammo.btVector3(height*.5,radius,radius);shape=new Ammo.btCylinderShapeX(halfExtents);break;case 1:halfExtents=new Ammo.btVector3(radius,height*.5,radius);shape=new Ammo.btCylinderShape(halfExtents);break;case 2:halfExtents=new Ammo.btVector3(radius,radius,height*.5);shape=new Ammo.btCylinderShapeZ(halfExtents);break}}if(halfExtents){Ammo.destroy(halfExtents);}return shape}}class CollisionConeSystemImpl extends CollisionSystemImpl{createPhysicalShape(entity,data){var _data$axis3,_data$radius3,_data$height3;const axis=(_data$axis3=data.axis)!=null?_data$axis3:1;const radius=(_data$radius3=data.radius)!=null?_data$radius3:.5;const height=(_data$height3=data.height)!=null?_data$height3:1;let shape=null;if(typeof Ammo!=="undefined"){switch(axis){case 0:shape=new Ammo.btConeShapeX(radius,height);break;case 1:shape=new Ammo.btConeShape(radius,height);break;case 2:shape=new Ammo.btConeShapeZ(radius,height);break}}return shape}}class CollisionMeshSystemImpl extends CollisionSystemImpl{beforeInitialize(component,data){}createAmmoHull(mesh,node,shape,scale){const hull=new Ammo.btConvexHullShape;const point=new Ammo.btVector3;const positions=[];mesh.getPositions(positions);for(let i=0;i<positions.length;i+=3){point.setValue(positions[i]*scale.x,positions[i+1]*scale.y,positions[i+2]*scale.z);hull.addPoint(point,false);}Ammo.destroy(point);hull.recalcLocalAabb();hull.setMargin(.01);shape.addChildShape(this.system._getNodeTransform(node),hull);}createAmmoMesh(mesh,node,shape,scale,checkDupes=true){const system=this.system;let triMesh;if(system._triMeshCache[mesh.id]){triMesh=system._triMeshCache[mesh.id];}else {const vb=mesh.vertexBuffer;const format=vb.getFormat();let stride,positions;for(let i=0;i<format.elements.length;i++){const element=format.elements[i];if(element.name===SEMANTIC_POSITION){positions=new Float32Array(vb.lock(),element.offset);stride=element.stride/4;break}}const indices=[];mesh.getIndices(indices);const numTriangles=mesh.primitive[0].count/3;const v1=new Ammo.btVector3;let i1,i2,i3;const base=mesh.primitive[0].base;triMesh=new Ammo.btTriangleMesh;system._triMeshCache[mesh.id]=triMesh;const vertexCache=new Map;const indexedArray=triMesh.getIndexedMeshArray();indexedArray.at(0).m_numTriangles=numTriangles;const sx=scale?scale.x:1;const sy=scale?scale.y:1;const sz=scale?scale.z:1;const addVertex=index=>{const x=positions[index*stride]*sx;const y=positions[index*stride+1]*sy;const z=positions[index*stride+2]*sz;let idx;if(checkDupes){const str=`${x}:${y}:${z}`;idx=vertexCache.get(str);if(idx!==undefined){return idx}v1.setValue(x,y,z);idx=triMesh.findOrAddVertex(v1,false);vertexCache.set(str,idx);}else {v1.setValue(x,y,z);idx=triMesh.findOrAddVertex(v1,false);}return idx};for(let i=0;i<numTriangles;i++){i1=addVertex(indices[base+i*3]);i2=addVertex(indices[base+i*3+1]);i3=addVertex(indices[base+i*3+2]);triMesh.addIndex(i1);triMesh.addIndex(i2);triMesh.addIndex(i3);}Ammo.destroy(v1);}const triMeshShape=new Ammo.btBvhTriangleMeshShape(triMesh,true);if(!scale){const scaling=system._getNodeScaling(node);triMeshShape.setLocalScaling(scaling);Ammo.destroy(scaling);}const transform=system._getNodeTransform(node);shape.addChildShape(transform,triMeshShape);Ammo.destroy(transform);}createPhysicalShape(entity,data){if(typeof Ammo==="undefined")return undefined;if(data.model||data.render){const shape=new Ammo.btCompoundShape;const entityTransform=entity.getWorldTransform();const scale=entityTransform.getScale();if(data.model){const meshInstances=data.model.meshInstances;for(let i=0;i<meshInstances.length;i++){this.createAmmoMesh(meshInstances[i].mesh,meshInstances[i].node,shape,null,data.checkVertexDuplicates);}const vec=new Ammo.btVector3(scale.x,scale.y,scale.z);shape.setLocalScaling(vec);Ammo.destroy(vec);}else if(data.render){const meshes=data.render.meshes;for(let i=0;i<meshes.length;i++){if(data.convexHull){this.createAmmoHull(meshes[i],tempGraphNode,shape,scale);}else {this.createAmmoMesh(meshes[i],tempGraphNode,shape,scale,data.checkVertexDuplicates);}}}return shape}return undefined}recreatePhysicalShapes(component){const data=component.data;if(data.renderAsset||data.asset){if(component.enabled&&component.entity.enabled){this.loadAsset(component,data.renderAsset||data.asset,data.renderAsset?"render":"model");return}}this.doRecreatePhysicalShape(component);}loadAsset(component,id,property){const data=component.data;const assets=this.system.app.assets;const previousPropertyValue=data[property];const onAssetFullyReady=asset=>{if(data[property]!==previousPropertyValue){return}data[property]=asset.resource;this.doRecreatePhysicalShape(component);};const loadAndHandleAsset=asset=>{asset.ready(asset=>{if(asset.data.containerAsset){const containerAsset=assets.get(asset.data.containerAsset);if(containerAsset.loaded){onAssetFullyReady(asset);}else {containerAsset.ready(()=>{onAssetFullyReady(asset);});assets.load(containerAsset);}}else {onAssetFullyReady(asset);}});assets.load(asset);};const asset=assets.get(id);if(asset){loadAndHandleAsset(asset);}else {assets.once(`add:${id}`,loadAndHandleAsset);}}doRecreatePhysicalShape(component){const entity=component.entity;const data=component.data;if(data.model||data.render){this.destroyShape(data);data.shape=this.createPhysicalShape(entity,data);if(entity.rigidbody){entity.rigidbody.disableSimulation();entity.rigidbody.createBody();if(entity.enabled&&entity.rigidbody.enabled){entity.rigidbody.enableSimulation();}}else {if(!entity.trigger){entity.trigger=new Trigger(this.system.app,component,data);}else {entity.trigger.initialize(data);}}}else {this.beforeRemove(entity,component);this.remove(entity,data);}}updateTransform(component,position,rotation,scale){if(component.shape){const entityTransform=component.entity.getWorldTransform();const worldScale=entityTransform.getScale();const previousScale=component.shape.getLocalScaling();if(worldScale.x!==previousScale.x()||worldScale.y!==previousScale.y()||worldScale.z!==previousScale.z()){this.doRecreatePhysicalShape(component);}}super.updateTransform(component,position,rotation,scale);}destroyShape(data){if(!data.shape){return}const numShapes=data.shape.getNumChildShapes();for(let i=0;i<numShapes;i++){const shape=data.shape.getChildShape(i);Ammo.destroy(shape);}Ammo.destroy(data.shape);data.shape=null;}}class CollisionCompoundSystemImpl extends CollisionSystemImpl{createPhysicalShape(entity,data){if(typeof Ammo!=="undefined"){return new Ammo.btCompoundShape}return undefined}_addEachDescendant(entity){if(!entity.collision||entity.rigidbody){return}entity.collision._compoundParent=this;if(entity!==this.entity){entity.collision.system.recreatePhysicalShapes(entity.collision);}}_updateEachDescendant(entity){if(!entity.collision){return}if(entity.collision._compoundParent!==this){return}entity.collision._compoundParent=null;if(entity!==this.entity&&!entity.rigidbody){entity.collision.system.recreatePhysicalShapes(entity.collision);}}_updateEachDescendantTransform(entity){if(!entity.collision||entity.collision._compoundParent!==this.collision._compoundParent){return}this.collision.system.updateCompoundChildTransform(entity,false);}}class CollisionComponentSystem extends ComponentSystem{initializeComponentData(component,_data,properties){properties=["type","halfExtents","radius","axis","height","convexHull","shape","model","asset","render","renderAsset","enabled","linearOffset","angularOffset","checkVertexDuplicates"];const data={};for(let i=0,len=properties.length;i<len;i++){const property=properties[i];data[property]=_data[property];}let idx;if(_data.hasOwnProperty("asset")){idx=properties.indexOf("model");if(idx!==-1){properties.splice(idx,1);}idx=properties.indexOf("render");if(idx!==-1){properties.splice(idx,1);}}else if(_data.hasOwnProperty("model")){idx=properties.indexOf("asset");if(idx!==-1){properties.splice(idx,1);}}if(!data.type){data.type=component.data.type;}component.data.type=data.type;if(Array.isArray(data.halfExtents)){data.halfExtents=new Vec3(data.halfExtents);}if(Array.isArray(data.linearOffset)){data.linearOffset=new Vec3(data.linearOffset);}if(Array.isArray(data.angularOffset)){const values=data.angularOffset;if(values.length===3){data.angularOffset=new Quat().setFromEulerAngles(values[0],values[1],values[2]);}else {data.angularOffset=new Quat(data.angularOffset);}}const impl=this._createImplementation(data.type);impl.beforeInitialize(component,data);super.initializeComponentData(component,data,properties);impl.afterInitialize(component,data);}_createImplementation(type){if(this.implementations[type]===undefined){let impl;switch(type){case"box":impl=new CollisionBoxSystemImpl(this);break;case"sphere":impl=new CollisionSphereSystemImpl(this);break;case"capsule":impl=new CollisionCapsuleSystemImpl(this);break;case"cylinder":impl=new CollisionCylinderSystemImpl(this);break;case"cone":impl=new CollisionConeSystemImpl(this);break;case"mesh":impl=new CollisionMeshSystemImpl(this);break;case"compound":impl=new CollisionCompoundSystemImpl(this);break}this.implementations[type]=impl;}return this.implementations[type]}_getImplementation(entity){return this.implementations[entity.collision.data.type]}cloneComponent(entity,clone){return this._getImplementation(entity).clone(entity,clone)}onBeforeRemove(entity,component){this.implementations[component.data.type].beforeRemove(entity,component);component.onBeforeRemove();}onRemove(entity,data){this.implementations[data.type].remove(entity,data);}updateCompoundChildTransform(entity,forceUpdate){const parentComponent=entity.collision._compoundParent;if(parentComponent===entity.collision)return;if(entity.enabled&&entity.collision.enabled&&(entity._dirtyLocal||forceUpdate)){const transform=this._getNodeTransform(entity,parentComponent.entity);const idx=parentComponent.getCompoundChildShapeIndex(entity.collision.shape);if(idx===null){parentComponent.shape.addChildShape(transform,entity.collision.data.shape);}else {parentComponent.shape.updateChildTransform(idx,transform,true);}Ammo.destroy(transform);}}_removeCompoundChild(collision,shape){if(collision.shape.getNumChildShapes()===0){return}if(collision.shape.removeChildShape){collision.shape.removeChildShape(shape);}else {const ind=collision.getCompoundChildShapeIndex(shape);if(ind!==null){collision.shape.removeChildShapeByIndex(ind);}}}onTransformChanged(component,position,rotation,scale){this.implementations[component.data.type].updateTransform(component,position,rotation,scale);}changeType(component,previousType,newType){this.implementations[previousType].beforeRemove(component.entity,component);this.implementations[previousType].remove(component.entity,component.data);this._createImplementation(newType).reset(component,component.data);}recreatePhysicalShapes(component){this.implementations[component.data.type].recreatePhysicalShapes(component);}_calculateNodeRelativeTransform(node,relative){if(node===relative){const scale=node.getWorldTransform().getScale();mat4.setScale(scale.x,scale.y,scale.z);}else {this._calculateNodeRelativeTransform(node.parent,relative);mat4.mul(node.getLocalTransform());}}_getNodeScaling(node){const wtm=node.getWorldTransform();const scl=wtm.getScale();return new Ammo.btVector3(scl.x,scl.y,scl.z)}_getNodeTransform(node,relative){let pos,rot;if(relative){this._calculateNodeRelativeTransform(node,relative);pos=p1;rot=quat$1;mat4.getTranslation(pos);rot.setFromMat4(mat4);}else {pos=node.getPosition();rot=node.getRotation();}const ammoQuat=new Ammo.btQuaternion;const transform=new Ammo.btTransform;transform.setIdentity();const origin=transform.getOrigin();const component=node.collision;if(component&&component._hasOffset){const lo=component.data.linearOffset;const ao=component.data.angularOffset;const newOrigin=p2;quat$1.copy(rot).transformVector(lo,newOrigin);newOrigin.add(pos);quat$1.copy(rot).mul(ao);origin.setValue(newOrigin.x,newOrigin.y,newOrigin.z);ammoQuat.setValue(quat$1.x,quat$1.y,quat$1.z,quat$1.w);}else {origin.setValue(pos.x,pos.y,pos.z);ammoQuat.setValue(rot.x,rot.y,rot.z,rot.w);}transform.setRotation(ammoQuat);Ammo.destroy(ammoQuat);return transform}destroy(){for(const key in this._triMeshCache){Ammo.destroy(this._triMeshCache[key]);}this._triMeshCache=null;super.destroy();}constructor(app){super(app);this.id="collision";this.ComponentType=CollisionComponent;this.DataType=CollisionComponentData;this.schema=_schema$h;this.implementations={};this._triMeshCache={};this.on("beforeremove",this.onBeforeRemove,this);this.on("remove",this.onRemove,this);}}const _vertexFormatDeviceCache=new DeviceCache;class ImageRenderable{destroy(){var _this$meshInstance,_this$unmaskMeshInsta;this.setMaterial(null);this._element.removeModelFromLayers(this.model);this.model.destroy();this.model=null;this.node=null;this.mesh=null;(_this$meshInstance=this.meshInstance)==null||_this$meshInstance.destroy();this.meshInstance=null;(_this$unmaskMeshInsta=this.unmaskMeshInstance)==null||_this$unmaskMeshInsta.destroy();this.unmaskMeshInstance=null;this._entity=null;this._element=null;}setMesh(mesh){if(!this.meshInstance)return;this.mesh=mesh;this.meshInstance.mesh=mesh;this.meshInstance.visible=!!mesh;if(this.unmaskMeshInstance){this.unmaskMeshInstance.mesh=mesh;}this.forceUpdateAabb();}setMask(mask){if(!this.meshInstance)return;if(this._entity.enabled&&this._element.enabled){this._element.removeModelFromLayers(this.model);}if(mask){this.unmaskMeshInstance=new MeshInstance(this.mesh,this.meshInstance.material,this.node);this.unmaskMeshInstance.name=`Unmask: ${this._entity.name}`;this.unmaskMeshInstance.castShadow=false;this.unmaskMeshInstance.receiveShadow=false;this.unmaskMeshInstance.pick=false;this.model.meshInstances.push(this.unmaskMeshInstance);for(const name in this.meshInstance.parameters){this.unmaskMeshInstance.setParameter(name,this.meshInstance.parameters[name].data);}}else {const idx=this.model.meshInstances.indexOf(this.unmaskMeshInstance);if(idx>=0){this.model.meshInstances.splice(idx,1);}}if(this._entity.enabled&&this._element.enabled){this._element.addModelToLayers(this.model);}if(!mask){var _this$unmaskMeshInsta2;(_this$unmaskMeshInsta2=this.unmaskMeshInstance)==null||_this$unmaskMeshInsta2.destroy();this.unmaskMeshInstance=null;}}setMaterial(material){if(!this.meshInstance)return;this.meshInstance.material=material;if(this.unmaskMeshInstance){this.unmaskMeshInstance.material=material;}}setParameter(name,value){if(!this.meshInstance)return;this.meshInstance.setParameter(name,value);if(this.unmaskMeshInstance){this.unmaskMeshInstance.setParameter(name,value);}}deleteParameter(name){if(!this.meshInstance)return;this.meshInstance.deleteParameter(name);if(this.unmaskMeshInstance){this.unmaskMeshInstance.deleteParameter(name);}}setUnmaskDrawOrder(){if(!this.meshInstance)return;const getLastChild=function getLastChild(e){let last;const c=e.children;const l=c.length;if(l){for(let i=0;i<l;i++){if(c[i].element){last=c[i];}}if(!last)return null;const child=getLastChild(last);if(child){return child}return last}return null};if(this.unmaskMeshInstance){const lastChild=getLastChild(this._entity);if(lastChild&&lastChild.element){this.unmaskMeshInstance.drawOrder=lastChild.element.drawOrder+lastChild.element.getMaskOffset();}else {this.unmaskMeshInstance.drawOrder=this.meshInstance.drawOrder+this._element.getMaskOffset();}}}setDrawOrder(drawOrder){if(!this.meshInstance){return}this.meshInstance.drawOrder=drawOrder;}setCull(cull){if(!this.meshInstance)return;const element=this._element;let visibleFn=null;if(cull&&element._isScreenSpace()){visibleFn=function(camera){return element.isVisibleForCamera(camera)};}this.meshInstance.cull=cull;this.meshInstance.isVisibleFunc=visibleFn;if(this.unmaskMeshInstance){this.unmaskMeshInstance.cull=cull;this.unmaskMeshInstance.isVisibleFunc=visibleFn;}}setScreenSpace(screenSpace){if(!this.meshInstance)return;this.meshInstance.screenSpace=screenSpace;if(this.unmaskMeshInstance){this.unmaskMeshInstance.screenSpace=screenSpace;}}setLayer(layer){if(!this.meshInstance)return;this.meshInstance.layer=layer;if(this.unmaskMeshInstance){this.unmaskMeshInstance.layer=layer;}}forceUpdateAabb(mask){if(!this.meshInstance)return;this.meshInstance._aabbVer=-1;if(this.unmaskMeshInstance){this.unmaskMeshInstance._aabbVer=-1;}}setAabbFunc(fn){if(!this.meshInstance)return;this.meshInstance._updateAabbFunc=fn;if(this.unmaskMeshInstance){this.unmaskMeshInstance._updateAabbFunc=fn;}}constructor(entity,mesh,material){this._entity=entity;this._element=entity.element;this.model=new Model;this.node=new GraphNode;this.model.graph=this.node;this.mesh=mesh;this.meshInstance=new MeshInstance(this.mesh,material,this.node);this.meshInstance.name=`ImageElement: ${entity.name}`;this.meshInstance.castShadow=false;this.meshInstance.receiveShadow=false;this._meshDirty=false;this.model.meshInstances.push(this.meshInstance);this._entity.addChild(this.model.graph);this.model._entity=this._entity;this.unmaskMeshInstance=null;}}class ImageElement{destroy(){this.textureAsset=null;this.spriteAsset=null;this.materialAsset=null;this._renderable.setMesh(this._defaultMesh);this._renderable.destroy();this._defaultMesh=null;this._element.off("resize",this._onParentResizeOrPivotChange,this);this._element.off("set:pivot",this._onParentResizeOrPivotChange,this);this._element.off("screen:set:screenspace",this._onScreenSpaceChange,this);this._element.off("set:screen",this._onScreenChange,this);this._element.off("set:draworder",this._onDrawOrderChange,this);this._element.off("screen:set:resolution",this._onResolutionChange,this);}_onResolutionChange(res){}_onParentResizeOrPivotChange(){if(this._renderable.mesh){this._updateMesh(this._renderable.mesh);}}_onScreenSpaceChange(value){this._updateMaterial(value);}_onScreenChange(screen,previous){if(screen){this._updateMaterial(screen.screen.screenSpace);}else {this._updateMaterial(false);}}_onDrawOrderChange(order){this._renderable.setDrawOrder(order);if(this.mask&&this._element.screen){this._element.screen.screen.once("syncdraworder",function(){this._renderable.setUnmaskDrawOrder();},this);}}_hasUserMaterial(){return !!this._materialAsset||!!this._material&&this._system.defaultImageMaterials.indexOf(this._material)===-1}_use9Slicing(){return this.sprite&&(this.sprite.renderMode===SPRITE_RENDERMODE_SLICED||this.sprite.renderMode===SPRITE_RENDERMODE_TILED)}_updateMaterial(screenSpace){const mask=!!this._mask;const nineSliced=!!(this.sprite&&this.sprite.renderMode===SPRITE_RENDERMODE_SLICED);const nineTiled=!!(this.sprite&&this.sprite.renderMode===SPRITE_RENDERMODE_TILED);if(!this._hasUserMaterial()){this._material=this._system.getImageElementMaterial(screenSpace,mask,nineSliced,nineTiled);}if(this._renderable){this._renderable.setCull(!this._element._isScreenSpace()||this._element._isScreenCulled());this._renderable.setMaterial(this._material);this._renderable.setScreenSpace(screenSpace);this._renderable.setLayer(screenSpace?LAYER_HUD:LAYER_WORLD);}}_createMesh(){const element=this._element;const w=element.calculatedWidth;const h=element.calculatedHeight;const r=this._rect;const device=this._system.app.graphicsDevice;const vertexData=new Float32Array([w,0,0,0,0,1,r.x+r.z,1-r.y,w,h,0,0,0,1,r.x+r.z,1-(r.y+r.w),0,0,0,0,0,1,r.x,1-r.y,0,h,0,0,0,1,r.x,1-(r.y+r.w)]);const vertexFormat=_vertexFormatDeviceCache.get(device,()=>{return new VertexFormat(device,[{semantic:SEMANTIC_POSITION,components:3,type:TYPE_FLOAT32},{semantic:SEMANTIC_NORMAL,components:3,type:TYPE_FLOAT32},{semantic:SEMANTIC_TEXCOORD0,components:2,type:TYPE_FLOAT32}])});const vertexBuffer=new VertexBuffer(device,vertexFormat,4,{data:vertexData.buffer});const mesh=new Mesh(device);mesh.vertexBuffer=vertexBuffer;mesh.primitive[0].type=PRIMITIVE_TRISTRIP;mesh.primitive[0].base=0;mesh.primitive[0].count=4;mesh.primitive[0].indexed=false;mesh.aabb.setMinMax(Vec3.ZERO,new Vec3(w,h,0));this._updateMesh(mesh);return mesh}_updateMesh(mesh){const element=this._element;let w=element.calculatedWidth;let h=element.calculatedHeight;if(element.fitMode!==FITMODE_STRETCH&&this._targetAspectRatio>0){const actualRatio=element.calculatedWidth/element.calculatedHeight;if(element.fitMode===FITMODE_CONTAIN&&actualRatio>this._targetAspectRatio||element.fitMode===FITMODE_COVER&&actualRatio<this._targetAspectRatio){w=element.calculatedHeight*this._targetAspectRatio;}else {h=element.calculatedWidth/this._targetAspectRatio;}}const screenSpace=element._isScreenSpace();this._updateMaterial(screenSpace);if(this._renderable)this._renderable.forceUpdateAabb();if(this.sprite&&(this.sprite.renderMode===SPRITE_RENDERMODE_SLICED||this.sprite.renderMode===SPRITE_RENDERMODE_TILED)){const frameData=this._sprite.atlas.frames[this._sprite.frameKeys[this._spriteFrame]];const borderWidthScale=2/frameData.rect.z;const borderHeightScale=2/frameData.rect.w;this._innerOffset.set(frameData.border.x*borderWidthScale,frameData.border.y*borderHeightScale,frameData.border.z*borderWidthScale,frameData.border.w*borderHeightScale);const tex=this.sprite.atlas.texture;this._atlasRect.set(frameData.rect.x/tex.width,frameData.rect.y/tex.height,frameData.rect.z/tex.width,frameData.rect.w/tex.height);const ppu=this._pixelsPerUnit!==null?this._pixelsPerUnit:this.sprite.pixelsPerUnit;const scaleMulX=frameData.rect.z/ppu;const scaleMulY=frameData.rect.w/ppu;this._outerScale.set(Math.max(w,this._innerOffset.x*scaleMulX),Math.max(h,this._innerOffset.y*scaleMulY));let scaleX=scaleMulX;let scaleY=scaleMulY;this._outerScale.x/=scaleMulX;this._outerScale.y/=scaleMulY;scaleX*=math.clamp(w/(this._innerOffset.x*scaleMulX),1e-4,1);scaleY*=math.clamp(h/(this._innerOffset.y*scaleMulY),1e-4,1);if(this._renderable){this._innerOffsetUniform[0]=this._innerOffset.x;this._innerOffsetUniform[1]=this._innerOffset.y;this._innerOffsetUniform[2]=this._innerOffset.z;this._innerOffsetUniform[3]=this._innerOffset.w;this._renderable.setParameter("innerOffset",this._innerOffsetUniform);this._atlasRectUniform[0]=this._atlasRect.x;this._atlasRectUniform[1]=this._atlasRect.y;this._atlasRectUniform[2]=this._atlasRect.z;this._atlasRectUniform[3]=this._atlasRect.w;this._renderable.setParameter("atlasRect",this._atlasRectUniform);this._outerScaleUniform[0]=this._outerScale.x;this._outerScaleUniform[1]=this._outerScale.y;this._renderable.setParameter("outerScale",this._outerScaleUniform);this._renderable.setAabbFunc(this._updateAabbFunc);this._renderable.node.setLocalScale(scaleX,scaleY,1);this._renderable.node.setLocalPosition((.5-element.pivot.x)*w,(.5-element.pivot.y)*h,0);}}else {const vb=mesh.vertexBuffer;const vertexDataF32=new Float32Array(vb.lock());const hp=element.pivot.x;const vp=element.pivot.y;vertexDataF32[0]=w-hp*w;vertexDataF32[1]=0-vp*h;vertexDataF32[8]=w-hp*w;vertexDataF32[9]=h-vp*h;vertexDataF32[16]=0-hp*w;vertexDataF32[17]=0-vp*h;vertexDataF32[24]=0-hp*w;vertexDataF32[25]=h-vp*h;let atlasTextureWidth=1;let atlasTextureHeight=1;let rect=this._rect;if(this._sprite&&this._sprite.frameKeys[this._spriteFrame]&&this._sprite.atlas){const frame=this._sprite.atlas.frames[this._sprite.frameKeys[this._spriteFrame]];if(frame){rect=frame.rect;atlasTextureWidth=this._sprite.atlas.texture.width;atlasTextureHeight=this._sprite.atlas.texture.height;}}vertexDataF32[6]=(rect.x+rect.z)/atlasTextureWidth;vertexDataF32[7]=1-rect.y/atlasTextureHeight;vertexDataF32[14]=(rect.x+rect.z)/atlasTextureWidth;vertexDataF32[15]=1-(rect.y+rect.w)/atlasTextureHeight;vertexDataF32[22]=rect.x/atlasTextureWidth;vertexDataF32[23]=1-rect.y/atlasTextureHeight;vertexDataF32[30]=rect.x/atlasTextureWidth;vertexDataF32[31]=1-(rect.y+rect.w)/atlasTextureHeight;vb.unlock();const min=new Vec3(0-hp*w,0-vp*h,0);const max=new Vec3(w-hp*w,h-vp*h,0);mesh.aabb.setMinMax(min,max);if(this._renderable){this._renderable.node.setLocalScale(1,1,1);this._renderable.node.setLocalPosition(0,0,0);this._renderable.setAabbFunc(null);}}this._meshDirty=false;}_updateSprite(){let nineSlice=false;let mesh=null;this._targetAspectRatio=-1;if(this._sprite&&this._sprite.atlas){mesh=this._sprite.meshes[this.spriteFrame];nineSlice=this._sprite.renderMode===SPRITE_RENDERMODE_SLICED||this._sprite.renderMode===SPRITE_RENDERMODE_TILED;const frameData=this._sprite.atlas.frames[this._sprite.frameKeys[this._spriteFrame]];if((frameData==null?void 0:frameData.rect.w)>0){this._targetAspectRatio=frameData.rect.z/frameData.rect.w;}}this.mesh=nineSlice?mesh:this._defaultMesh;this.refreshMesh();}refreshMesh(){if(this.mesh){if(!this._element._beingInitialized){this._updateMesh(this.mesh);}else {this._meshDirty=true;}}}_updateAabb(aabb){aabb.center.set(0,0,0);aabb.halfExtents.set(this._outerScale.x*.5,this._outerScale.y*.5,.001);aabb.setFromTransformedAabb(aabb,this._renderable.node.getWorldTransform());return aabb}_toggleMask(){this._element._dirtifyMask();const screenSpace=this._element._isScreenSpace();this._updateMaterial(screenSpace);this._renderable.setMask(!!this._mask);}_onMaterialLoad(asset){this.material=asset.resource;}_onMaterialAdded(asset){this._system.app.assets.off(`add:${asset.id}`,this._onMaterialAdded,this);if(this._materialAsset===asset.id){this._bindMaterialAsset(asset);}}_bindMaterialAsset(asset){if(!this._entity.enabled)return;asset.on("load",this._onMaterialLoad,this);asset.on("change",this._onMaterialChange,this);asset.on("remove",this._onMaterialRemove,this);if(asset.resource){this._onMaterialLoad(asset);}else {this._system.app.assets.load(asset);}}_unbindMaterialAsset(asset){asset.off("load",this._onMaterialLoad,this);asset.off("change",this._onMaterialChange,this);asset.off("remove",this._onMaterialRemove,this);}_onMaterialChange(){}_onMaterialRemove(){}_onTextureAdded(asset){this._system.app.assets.off(`add:${asset.id}`,this._onTextureAdded,this);if(this._textureAsset===asset.id){this._bindTextureAsset(asset);}}_bindTextureAsset(asset){if(!this._entity.enabled)return;asset.on("load",this._onTextureLoad,this);asset.on("change",this._onTextureChange,this);asset.on("remove",this._onTextureRemove,this);if(asset.resource){this._onTextureLoad(asset);}else {this._system.app.assets.load(asset);}}_unbindTextureAsset(asset){asset.off("load",this._onTextureLoad,this);asset.off("change",this._onTextureChange,this);asset.off("remove",this._onTextureRemove,this);}_onTextureLoad(asset){this.texture=asset.resource;}_onTextureChange(asset){}_onTextureRemove(asset){}_onSpriteAssetAdded(asset){this._system.app.assets.off(`add:${asset.id}`,this._onSpriteAssetAdded,this);if(this._spriteAsset===asset.id){this._bindSpriteAsset(asset);}}_bindSpriteAsset(asset){if(!this._entity.enabled)return;asset.on("load",this._onSpriteAssetLoad,this);asset.on("change",this._onSpriteAssetChange,this);asset.on("remove",this._onSpriteAssetRemove,this);if(asset.resource){this._onSpriteAssetLoad(asset);}else {this._system.app.assets.load(asset);}}_unbindSpriteAsset(asset){asset.off("load",this._onSpriteAssetLoad,this);asset.off("change",this._onSpriteAssetChange,this);asset.off("remove",this._onSpriteAssetRemove,this);if(asset.data.textureAtlasAsset){this._system.app.assets.off(`load:${asset.data.textureAtlasAsset}`,this._onTextureAtlasLoad,this);}}_onSpriteAssetLoad(asset){if(!asset||!asset.resource){this.sprite=null;}else {if(!asset.resource.atlas){const atlasAssetId=asset.data.textureAtlasAsset;if(atlasAssetId){const assets=this._system.app.assets;assets.off(`load:${atlasAssetId}`,this._onTextureAtlasLoad,this);assets.once(`load:${atlasAssetId}`,this._onTextureAtlasLoad,this);}}else {this.sprite=asset.resource;}}}_onSpriteAssetChange(asset){this._onSpriteAssetLoad(asset);}_onSpriteAssetRemove(asset){}_bindSprite(sprite){this._evtSetMeshes=sprite.on("set:meshes",this._onSpriteMeshesChange,this);sprite.on("set:pixelsPerUnit",this._onSpritePpuChange,this);sprite.on("set:atlas",this._onAtlasTextureChange,this);if(sprite.atlas){sprite.atlas.on("set:texture",this._onAtlasTextureChange,this);}}_unbindSprite(sprite){var _this$_evtSetMeshes;(_this$_evtSetMeshes=this._evtSetMeshes)==null||_this$_evtSetMeshes.off();this._evtSetMeshes=null;sprite.off("set:pixelsPerUnit",this._onSpritePpuChange,this);sprite.off("set:atlas",this._onAtlasTextureChange,this);if(sprite.atlas){sprite.atlas.off("set:texture",this._onAtlasTextureChange,this);}}_onSpriteMeshesChange(){if(this._sprite){this._spriteFrame=math.clamp(this._spriteFrame,0,this._sprite.frameKeys.length-1);}this._updateSprite();}_onSpritePpuChange(){if(this.sprite.renderMode!==SPRITE_RENDERMODE_SIMPLE&&this._pixelsPerUnit===null){this._updateSprite();}}_onAtlasTextureChange(){if(this.sprite&&this.sprite.atlas&&this.sprite.atlas.texture){this._renderable.setParameter("texture_emissiveMap",this._sprite.atlas.texture);this._renderable.setParameter("texture_opacityMap",this._sprite.atlas.texture);}else {this._renderable.deleteParameter("texture_emissiveMap");this._renderable.deleteParameter("texture_opacityMap");}}_onTextureAtlasLoad(atlasAsset){const spriteAsset=this._spriteAsset;if(spriteAsset instanceof Asset){this._onSpriteAssetLoad(spriteAsset);}else {this._onSpriteAssetLoad(this._system.app.assets.get(spriteAsset));}}onEnable(){if(this._materialAsset){const asset=this._system.app.assets.get(this._materialAsset);if(asset&&asset.resource!==this._material){this._bindMaterialAsset(asset);}}if(this._textureAsset){const asset=this._system.app.assets.get(this._textureAsset);if(asset&&asset.resource!==this._texture){this._bindTextureAsset(asset);}}if(this._spriteAsset){const asset=this._system.app.assets.get(this._spriteAsset);if(asset&&asset.resource!==this._sprite){this._bindSpriteAsset(asset);}}this._element.addModelToLayers(this._renderable.model);}onDisable(){this._element.removeModelFromLayers(this._renderable.model);}_setStencil(stencilParams){this._renderable.meshInstance.stencilFront=stencilParams;this._renderable.meshInstance.stencilBack=stencilParams;let ref=0;if(this._element.maskedBy){ref=this._element.maskedBy.element._image._maskRef;}if(this._renderable.unmaskMeshInstance){const sp=new StencilParameters({ref:ref+1,func:FUNC_EQUAL,zpass:STENCILOP_DECREMENT});this._renderable.unmaskMeshInstance.stencilFront=sp;this._renderable.unmaskMeshInstance.stencilBack=sp;}}set color(value){const r=value.r;const g=value.g;const b=value.b;if(this._color.r!==r||this._color.g!==g||this._color.b!==b){this._color.r=r;this._color.g=g;this._color.b=b;this._colorUniform[0]=r;this._colorUniform[1]=g;this._colorUniform[2]=b;this._renderable.setParameter("material_emissive",this._colorUniform);}if(this._element){this._element.fire("set:color",this._color);}}get color(){return this._color}set opacity(value){if(value!==this._color.a){this._color.a=value;this._renderable.setParameter("material_opacity",value);}if(this._element){this._element.fire("set:opacity",value);}}get opacity(){return this._color.a}set rect(value){let x,y,z,w;if(value instanceof Vec4){x=value.x;y=value.y;z=value.z;w=value.w;}else {x=value[0];y=value[1];z=value[2];w=value[3];}if(x===this._rect.x&&y===this._rect.y&&z===this._rect.z&&w===this._rect.w){return}this._rect.set(x,y,z,w);if(this._renderable.mesh){if(!this._element._beingInitialized){this._updateMesh(this._renderable.mesh);}else {this._meshDirty=true;}}}get rect(){return this._rect}_removeMaterialAssetEvents(){if(this._materialAsset){const assets=this._system.app.assets;assets.off(`add:${this._materialAsset}`,this._onMaterialAdded,this);const asset=assets.get(this._materialAsset);if(asset){asset.off("load",this._onMaterialLoad,this);asset.off("change",this._onMaterialChange,this);asset.off("remove",this._onMaterialRemove,this);}}}set material(value){if(this._material===value)return;if(!value){const screenSpace=this._element._isScreenSpace();if(this.mask){value=screenSpace?this._system.defaultScreenSpaceImageMaskMaterial:this._system.defaultImageMaskMaterial;}else {value=screenSpace?this._system.defaultScreenSpaceImageMaterial:this._system.defaultImageMaterial;}}this._material=value;if(this._materialAsset){const asset=this._system.app.assets.get(this._materialAsset);if(!asset||asset.resource!==value){this._removeMaterialAssetEvents();this._materialAsset=null;}}if(value){this._renderable.setMaterial(value);if(this._hasUserMaterial()){this._renderable.deleteParameter("material_opacity");this._renderable.deleteParameter("material_emissive");}else {this._colorUniform[0]=this._color.r;this._colorUniform[1]=this._color.g;this._colorUniform[2]=this._color.b;this._renderable.setParameter("material_emissive",this._colorUniform);this._renderable.setParameter("material_opacity",this._color.a);}}}get material(){return this._material}set materialAsset(value){const assets=this._system.app.assets;let _id=value;if(value instanceof Asset){_id=value.id;}if(this._materialAsset!==_id){this._removeMaterialAssetEvents();this._materialAsset=_id;if(this._materialAsset){const asset=assets.get(this._materialAsset);if(!asset){this._materialAsset=null;this.material=null;this._materialAsset=_id;assets.on(`add:${this._materialAsset}`,this._onMaterialAdded,this);}else {this._bindMaterialAsset(asset);}}else {this._materialAsset=null;this.material=null;this._materialAsset=_id;}}}get materialAsset(){return this._materialAsset}set texture(value){if(this._texture===value)return;if(this._textureAsset){const textureAsset=this._system.app.assets.get(this._textureAsset);if(textureAsset&&textureAsset.resource!==value){this.textureAsset=null;}}this._texture=value;if(value){if(this._spriteAsset){this.spriteAsset=null;}this._renderable.setParameter("texture_emissiveMap",this._texture);this._renderable.setParameter("texture_opacityMap",this._texture);this._colorUniform[0]=this._color.r;this._colorUniform[1]=this._color.g;this._colorUniform[2]=this._color.b;this._renderable.setParameter("material_emissive",this._colorUniform);this._renderable.setParameter("material_opacity",this._color.a);const newAspectRatio=this._texture.width/this._texture.height;if(newAspectRatio!==this._targetAspectRatio){this._targetAspectRatio=newAspectRatio;if(this._element.fitMode!==FITMODE_STRETCH){this.refreshMesh();}}}else {this._renderable.deleteParameter("texture_emissiveMap");this._renderable.deleteParameter("texture_opacityMap");this._targetAspectRatio=-1;if(this._element.fitMode!==FITMODE_STRETCH){this.refreshMesh();}}}get texture(){return this._texture}set textureAsset(value){const assets=this._system.app.assets;let _id=value;if(value instanceof Asset){_id=value.id;}if(this._textureAsset!==_id){if(this._textureAsset){assets.off(`add:${this._textureAsset}`,this._onTextureAdded,this);const _prev=assets.get(this._textureAsset);if(_prev){_prev.off("load",this._onTextureLoad,this);_prev.off("change",this._onTextureChange,this);_prev.off("remove",this._onTextureRemove,this);}}this._textureAsset=_id;if(this._textureAsset){const asset=assets.get(this._textureAsset);if(!asset){this.texture=null;assets.on(`add:${this._textureAsset}`,this._onTextureAdded,this);}else {this._bindTextureAsset(asset);}}else {this.texture=null;}}}get textureAsset(){return this._textureAsset}set spriteAsset(value){const assets=this._system.app.assets;let _id=value;if(value instanceof Asset){_id=value.id;}if(this._spriteAsset!==_id){if(this._spriteAsset){assets.off(`add:${this._spriteAsset}`,this._onSpriteAssetAdded,this);const _prev=assets.get(this._spriteAsset);if(_prev){this._unbindSpriteAsset(_prev);}}this._spriteAsset=_id;if(this._spriteAsset){const asset=assets.get(this._spriteAsset);if(!asset){this.sprite=null;assets.on(`add:${this._spriteAsset}`,this._onSpriteAssetAdded,this);}else {this._bindSpriteAsset(asset);}}else {this.sprite=null;}}if(this._element){this._element.fire("set:spriteAsset",_id);}}get spriteAsset(){return this._spriteAsset}set sprite(value){if(this._sprite===value)return;if(this._sprite){this._unbindSprite(this._sprite);}if(this._spriteAsset){const spriteAsset=this._system.app.assets.get(this._spriteAsset);if(spriteAsset&&spriteAsset.resource!==value){this.spriteAsset=null;}}this._sprite=value;if(this._sprite){this._bindSprite(this._sprite);if(this._textureAsset){this.textureAsset=null;}}if(this._sprite&&this._sprite.atlas&&this._sprite.atlas.texture){this._renderable.setParameter("texture_emissiveMap",this._sprite.atlas.texture);this._renderable.setParameter("texture_opacityMap",this._sprite.atlas.texture);}else {this._renderable.deleteParameter("texture_emissiveMap");this._renderable.deleteParameter("texture_opacityMap");}if(this._sprite){this._spriteFrame=math.clamp(this._spriteFrame,0,this._sprite.frameKeys.length-1);}this._updateSprite();}get sprite(){return this._sprite}set spriteFrame(value){const oldValue=this._spriteFrame;if(this._sprite){this._spriteFrame=math.clamp(value,0,this._sprite.frameKeys.length-1);}else {this._spriteFrame=value;}if(this._spriteFrame!==oldValue){this._updateSprite();}if(this._element){this._element.fire("set:spriteFrame",value);}}get spriteFrame(){return this._spriteFrame}set mesh(value){this._renderable.setMesh(value);if(this._defaultMesh===value){this._renderable.setAabbFunc(null);}else {this._renderable.setAabbFunc(this._updateAabbFunc);}}get mesh(){return this._renderable.mesh}set mask(value){if(this._mask!==value){this._mask=value;this._toggleMask();}}get mask(){return this._mask}set pixelsPerUnit(value){if(this._pixelsPerUnit===value)return;this._pixelsPerUnit=value;if(this._sprite&&(this._sprite.renderMode===SPRITE_RENDERMODE_SLICED||this._sprite.renderMode===SPRITE_RENDERMODE_TILED)){this._updateSprite();}}get pixelsPerUnit(){return this._pixelsPerUnit}get aabb(){if(this._renderable.meshInstance){return this._renderable.meshInstance.aabb}return null}constructor(element){this._evtSetMeshes=null;this._element=element;this._entity=element.entity;this._system=element.system;this._textureAsset=null;this._texture=null;this._materialAsset=null;this._material=null;this._spriteAsset=null;this._sprite=null;this._spriteFrame=0;this._pixelsPerUnit=null;this._targetAspectRatio=-1;this._rect=new Vec4(0,0,1,1);this._mask=false;this._maskRef=0;this._outerScale=new Vec2;this._outerScaleUniform=new Float32Array(2);this._innerOffset=new Vec4;this._innerOffsetUniform=new Float32Array(4);this._atlasRect=new Vec4;this._atlasRectUniform=new Float32Array(4);this._defaultMesh=this._createMesh();this._renderable=new ImageRenderable(this._entity,this._defaultMesh,this._material);this._color=new Color(1,1,1,1);this._colorUniform=new Float32Array([1,1,1]);this._renderable.setParameter("material_emissive",this._colorUniform);this._renderable.setParameter("material_opacity",1);this._updateAabbFunc=this._updateAabb.bind(this);this._onScreenChange(this._element.screen);this._element.on("resize",this._onParentResizeOrPivotChange,this);this._element.on("set:pivot",this._onParentResizeOrPivotChange,this);this._element.on("screen:set:screenspace",this._onScreenSpaceChange,this);this._element.on("set:screen",this._onScreenChange,this);this._element.on("set:draworder",this._onDrawOrderChange,this);this._element.on("screen:set:resolution",this._onResolutionChange,this);}}class LocalizedAsset extends EventHandler{set defaultAsset(value){const id=value instanceof Asset?value.id:value;if(this._defaultAsset===id)return;if(this._defaultAsset){this._unbindDefaultAsset();}this._defaultAsset=id;if(this._defaultAsset){this._bindDefaultAsset();}this._onSetLocale(this._app.i18n.locale);}get defaultAsset(){return this._defaultAsset}set localizedAsset(value){const id=value instanceof Asset?value.id:value;if(this._localizedAsset===id){return}if(this._localizedAsset){this._app.assets.off(`add:${this._localizedAsset}`,this._onLocalizedAssetAdd,this);this._unbindLocalizedAsset();}this._localizedAsset=id;if(this._localizedAsset){const asset=this._app.assets.get(this._localizedAsset);if(!asset){this._app.assets.once(`add:${this._localizedAsset}`,this._onLocalizedAssetAdd,this);}else {this._bindLocalizedAsset();}}}get localizedAsset(){return this._localizedAsset}set autoLoad(value){if(this._autoLoad===value)return;this._autoLoad=value;if(this._autoLoad&&this._localizedAsset){this._unbindLocalizedAsset();this._bindLocalizedAsset();}}get autoLoad(){return this._autoLoad}set disableLocalization(value){if(this._disableLocalization===value)return;this._disableLocalization=value;this._onSetLocale(this._app.i18n.locale);}get disableLocalization(){return this._disableLocalization}_bindDefaultAsset(){const asset=this._app.assets.get(this._defaultAsset);if(!asset){this._app.assets.once(`add:${this._defaultAsset}`,this._onDefaultAssetAdd,this);}else {this._onDefaultAssetAdd(asset);}}_unbindDefaultAsset(){if(!this._defaultAsset)return;this._app.assets.off(`add:${this._defaultAsset}`,this._onDefaultAssetAdd,this);const asset=this._app.assets.get(this._defaultAsset);if(!asset)return;asset.off("add:localized",this._onLocaleAdd,this);asset.off("remove:localized",this._onLocaleRemove,this);asset.off("remove",this._onDefaultAssetRemove,this);}_onDefaultAssetAdd(asset){if(this._defaultAsset!==asset.id)return;asset.on("add:localized",this._onLocaleAdd,this);asset.on("remove:localized",this._onLocaleRemove,this);asset.once("remove",this._onDefaultAssetRemove,this);}_onDefaultAssetRemove(asset){if(this._defaultAsset!==asset.id)return;asset.off("add:localized",this._onLocaleAdd,this);asset.off("remove:localized",this._onLocaleAdd,this);this._app.assets.once(`add:${this._defaultAsset}`,this._onDefaultAssetAdd,this);}_bindLocalizedAsset(){if(!this._autoLoad)return;const asset=this._app.assets.get(this._localizedAsset);if(!asset)return;asset.on("load",this._onLocalizedAssetLoad,this);asset.on("change",this._onLocalizedAssetChange,this);asset.on("remove",this._onLocalizedAssetRemove,this);if(asset.resource){this._onLocalizedAssetLoad(asset);}else {this._app.assets.load(asset);}}_unbindLocalizedAsset(){const asset=this._app.assets.get(this._localizedAsset);if(!asset)return;asset.off("load",this._onLocalizedAssetLoad,this);asset.off("change",this._onLocalizedAssetChange,this);asset.off("remove",this._onLocalizedAssetRemove,this);}_onLocalizedAssetAdd(asset){if(this._localizedAsset!==asset.id)return;this._bindLocalizedAsset();}_onLocalizedAssetLoad(asset){this.fire("load",asset);}_onLocalizedAssetChange(asset,name,newValue,oldValue){this.fire("change",asset,name,newValue,oldValue);}_onLocalizedAssetRemove(asset){if(this._localizedAsset===asset.id){this.localizedAsset=this._defaultAsset;}this.fire("remove",asset);}_onLocaleAdd(locale,assetId){if(this._app.i18n.locale!==locale)return;this._onSetLocale(locale);}_onLocaleRemove(locale,assetId){if(this._app.i18n.locale!==locale)return;this._onSetLocale(locale);}_onSetLocale(locale){if(!this._defaultAsset){this.localizedAsset=null;return}const asset=this._app.assets.get(this._defaultAsset);if(!asset||this._disableLocalization){this.localizedAsset=this._defaultAsset;return}const localizedAssetId=asset.getLocalizedAssetId(locale);if(!localizedAssetId){this.localizedAsset=this._defaultAsset;return}this.localizedAsset=localizedAssetId;}destroy(){this.defaultAsset=null;this._app.i18n.off("set:locale",this._onSetLocale,this);this.off();}constructor(app){super();this._app=app;app.i18n.on("set:locale",this._onSetLocale,this);this._autoLoad=false;this._disableLocalization=false;this._defaultAsset=null;this._localizedAsset=null;}}const FONT_MSDF="msdf";const FONT_BITMAP="bitmap";const EOF_TOKEN=0;const ERROR_TOKEN=1;const TEXT_TOKEN=2;const OPEN_BRACKET_TOKEN=3;const CLOSE_BRACKET_TOKEN=4;const EQUALS_TOKEN=5;const STRING_TOKEN=6;const IDENTIFIER_TOKEN=7;const WHITESPACE_TOKEN=8;const WHITESPACE_CHARS=" 	\n\r\v\f";const IDENTIFIER_REGEX=/[\w|/]/;class Scanner{read(){let token=this._read();while(token===WHITESPACE_TOKEN){token=this._read();}if(token!==EOF_TOKEN&&token!==ERROR_TOKEN){this._last=this._index;}return token}buf(){return this._buf}last(){return this._last}error(){return this._error}debugPrint(){const tokenStrings=["EOF","ERROR","TEXT","OPEN_BRACKET","CLOSE_BRACKET","EQUALS","STRING","IDENTIFIER","WHITESPACE"];let token=this.read();let result="";while(true){result+=`${(result.length>0?"\n":"")+tokenStrings[token]} '${this.buf().join("")}'`;if(token===EOF_TOKEN||token===ERROR_TOKEN){break}token=this.read();}return result}_read(){this._buf=[];if(this._eof()){return EOF_TOKEN}return this._mode==="text"?this._text():this._tag()}_text(){while(true){switch(this._cur){case null:return this._buf.length>0?TEXT_TOKEN:EOF_TOKEN;case"[":this._mode="tag";return this._buf.length>0?TEXT_TOKEN:this._tag();case"\\":this._next();switch(this._cur){case"[":this._store();break;default:this._output("\\");break}break;default:this._store();break}}}_tag(){switch(this._cur){case null:this._error="unexpected end of input reading tag";return ERROR_TOKEN;case"[":this._store();return OPEN_BRACKET_TOKEN;case"]":this._store();this._mode="text";return CLOSE_BRACKET_TOKEN;case"=":this._store();return EQUALS_TOKEN;case" ":case"	":case"\n":case"\r":case"\v":case"\f":return this._whitespace();case'"':return this._string();default:if(!this._isIdentifierSymbol(this._cur)){this._error="unrecognized character";return ERROR_TOKEN}return this._identifier()}}_whitespace(){this._store();while(WHITESPACE_CHARS.indexOf(this._cur)!==-1){this._store();}return WHITESPACE_TOKEN}_string(){this._next();while(true){switch(this._cur){case null:this._error="unexpected end of input reading string";return ERROR_TOKEN;case'"':this._next();return STRING_TOKEN;default:this._store();break}}}_identifier(){this._store();while(this._cur!==null&&this._isIdentifierSymbol(this._cur)){this._store();}return IDENTIFIER_TOKEN}_isIdentifierSymbol(s){return s.length===1&&s.match(IDENTIFIER_REGEX)!==null}_eof(){return this._cur===null}_next(){if(!this._eof()){this._index++;this._cur=this._index<this._symbols.length?this._symbols[this._index]:null;}return this._cur}_store(){this._buf.push(this._cur);return this._next()}_output(c){this._buf.push(c);}constructor(symbols){this._symbols=symbols;this._index=0;this._last=0;this._cur=this._symbols.length>0?this._symbols[0]:null;this._buf=[];this._mode="text";this._error=null;}}class Parser{parse(symbols,tags){while(true){const token=this._scanner.read();switch(token){case EOF_TOKEN:return true;case ERROR_TOKEN:return false;case TEXT_TOKEN:Array.prototype.push.apply(symbols,this._scanner.buf());break;case OPEN_BRACKET_TOKEN:if(!this._parseTag(symbols,tags)){return false}break;default:return false}}}error(){return `Error evaluating markup at #${this._scanner.last().toString()} (${this._scanner.error()||this._error})`}_parseTag(symbols,tags){let token=this._scanner.read();if(token!==IDENTIFIER_TOKEN){this._error="expected identifier";return false}const name=this._scanner.buf().join("");if(name[0]==="/"){for(let index=tags.length-1;index>=0;--index){if(name===`/${tags[index].name}`&&tags[index].end===null){tags[index].end=symbols.length;token=this._scanner.read();if(token!==CLOSE_BRACKET_TOKEN){this._error="expected close bracket";return false}return true}}this._error="failed to find matching tag";return false}const tag={name:name,value:null,attributes:{},start:symbols.length,end:null};token=this._scanner.read();if(token===EQUALS_TOKEN){token=this._scanner.read();if(token!==STRING_TOKEN){this._error="expected string";return false}tag.value=this._scanner.buf().join("");token=this._scanner.read();}while(true){switch(token){case CLOSE_BRACKET_TOKEN:tags.push(tag);return true;case IDENTIFIER_TOKEN:{const identifier=this._scanner.buf().join("");token=this._scanner.read();if(token!==EQUALS_TOKEN){this._error="expected equals";return false}token=this._scanner.read();if(token!==STRING_TOKEN){this._error="expected string";return false}const value=this._scanner.buf().join("");tag.attributes[identifier]=value;break}default:this._error="expected close bracket or identifier";return false}token=this._scanner.read();}}constructor(symbols){this._scanner=new Scanner(symbols);this._error=null;}}function merge(target,source){for(const key in source){if(!source.hasOwnProperty(key)){continue}const value=source[key];if(value instanceof Object){if(!target.hasOwnProperty(key)){target[key]={};}merge(target[key],source[key]);}else {target[key]=value;}}}function combineTags(tags){if(tags.length===0){return null}const result={};for(let index=0;index<tags.length;++index){const tag=tags[index];const tmp={};tmp[tag.name]={value:tag.value,attributes:tag.attributes};merge(result,tmp);}return result}function resolveMarkupTags(tags,numSymbols){if(tags.length===0){return null}const edges={};for(let index=0;index<tags.length;++index){const tag=tags[index];if(!edges.hasOwnProperty(tag.start)){edges[tag.start]={open:[tag],close:null};}else {if(edges[tag.start].open===null){edges[tag.start].open=[tag];}else {edges[tag.start].open.push(tag);}}if(!edges.hasOwnProperty(tag.end)){edges[tag.end]={open:null,close:[tag]};}else {if(edges[tag.end].close===null){edges[tag.end].close=[tag];}else {edges[tag.end].close.push(tag);}}}let tagStack=[];function removeTags(tags){tagStack=tagStack.filter(tag=>{return tags.find(t=>{return t===tag})===undefined});}function addTags(tags){for(let index=0;index<tags.length;++index){tagStack.push(tags[index]);}}const edgeKeys=Object.keys(edges).sort((a,b)=>{return a-b});const resolvedTags=[];for(let index=0;index<edgeKeys.length;++index){const edge=edges[edgeKeys[index]];if(edge.close!==null){removeTags(edge.close);}if(edge.open!==null){addTags(edge.open);}resolvedTags.push({start:edgeKeys[index],tags:combineTags(tagStack)});}const result=[];let prevTag=null;for(let index=0;index<resolvedTags.length;++index){const resolvedTag=resolvedTags[index];while(result.length<resolvedTag.start){result.push(prevTag?prevTag.tags:null);}prevTag=resolvedTag;}while(result.length<numSymbols){result.push(null);}return result}function evaluateMarkup(symbols){const parser=new Parser(symbols);const stripped_symbols=[];const tags=[];if(!parser.parse(stripped_symbols,tags)){console.warn(parser.error());return {symbols:symbols,tags:null}}const invalidTag=tags.find(t=>{return t.end===null});if(invalidTag){console.warn(`Markup error: found unclosed tag='${invalidTag.name}'`);return {symbols:symbols,tags:null}}const resolved_tags=resolveMarkupTags(tags,stripped_symbols.length);return {symbols:stripped_symbols,tags:resolved_tags}}class Markup{static evaluate(symbols){return evaluateMarkup(symbols)}}class MeshInfo{constructor(){this.count=0;this.quad=0;this.lines={};this.positions=[];this.normals=[];this.uvs=[];this.colors=[];this.indices=[];this.outlines=[];this.shadows=[];this.meshInstance=null;}}function createTextMesh(device,meshInfo){const mesh=new Mesh(device);mesh.setPositions(meshInfo.positions);mesh.setNormals(meshInfo.normals);mesh.setColors32(meshInfo.colors);mesh.setUvs(0,meshInfo.uvs);mesh.setIndices(meshInfo.indices);mesh.setVertexStream(SEMANTIC_ATTR8,meshInfo.outlines,3,undefined,TYPE_FLOAT32,false);mesh.setVertexStream(SEMANTIC_ATTR9,meshInfo.shadows,3,undefined,TYPE_FLOAT32,false);mesh.update();return mesh}const LINE_BREAK_CHAR=/^[\r\n]$/;const WHITESPACE_CHAR=/^[ \t]$/;const WORD_BOUNDARY_CHAR=/^[ \t\-]|\u200b$/;const ALPHANUMERIC_CHAR=/^[a-z0-9]$/i;const CJK_CHAR=/^[\u1100-\u11ff]|[\u3000-\u9fff\ua960-\ua97f]|[\uac00-\ud7ff]$/;const NO_LINE_BREAK_CJK_CHAR=/^[〕〉》」』】〙〗〟ヽヾーァィゥェォッャュョヮヵヶぁぃぅぇぉっゃゅょゎゕゖㇰㇱㇲㇳㇴㇵㇶㇷㇸㇹㇺㇻㇼㇽㇾㇿ々〻]$/;const CONTROL_CHARS=["​","؜","‎","‏","‪","‫","‬","‭","‮","⁦","⁧","⁨","⁩"];const CONTROL_GLYPH_DATA={width:0,height:0,xadvance:0,xoffset:0,yoffset:0};const colorTmp=new Color;const vec2Tmp=new Vec2;class TextElement{destroy(){this._setMaterial(null);if(this._model){this._element.removeModelFromLayers(this._model);this._model.destroy();this._model=null;}this._fontAsset.destroy();this.font=null;this._element.off("resize",this._onParentResize,this);this._element.off("set:screen",this._onScreenChange,this);this._element.off("screen:set:screenspace",this._onScreenSpaceChange,this);this._element.off("set:draworder",this._onDrawOrderChange,this);this._element.off("set:pivot",this._onPivotChange,this);this._system.app.i18n.off("set:locale",this._onLocaleSet,this);this._system.app.i18n.off("data:add",this._onLocalizationData,this);this._system.app.i18n.off("data:remove",this._onLocalizationData,this);}_onParentResize(width,height){if(this._noResize)return;if(this._font)this._updateText();}_onScreenChange(screen){if(screen){this._updateMaterial(screen.screen.screenSpace);}else {this._updateMaterial(false);}}_onScreenSpaceChange(value){this._updateMaterial(value);}_onDrawOrderChange(order){this._drawOrder=order;if(this._model){for(let i=0,len=this._model.meshInstances.length;i<len;i++){this._model.meshInstances[i].drawOrder=order;}}}_onPivotChange(pivot){if(this._font){this._updateText();}}_onLocaleSet(locale){if(!this._i18nKey)return;if(this.fontAsset){const asset=this._system.app.assets.get(this.fontAsset);if(!asset||!asset.resource||asset.resource!==this._font){this.font=null;}}this._resetLocalizedText();}_onLocalizationData(locale,messages){if(this._i18nKey&&messages[this._i18nKey]){this._resetLocalizedText();}}_resetLocalizedText(){this._setText(this._system.app.i18n.getText(this._i18nKey));}_setText(text){if(this.unicodeConverter){const unicodeConverterFunc=this._system.getUnicodeConverter();if(unicodeConverterFunc){text=unicodeConverterFunc(text);}else {console.warn("Element created with unicodeConverter option but no unicodeConverter function registered");}}if(this._text!==text){if(this._font){this._updateText(text);}this._text=text;}}_updateText(text){let tags;if(text===undefined)text=this._text;this._symbols=string.getSymbols(text.normalize?text.normalize("NFC"):text);if(this._symbols.length===0){this._symbols=[" "];}if(this._enableMarkup){const results=Markup.evaluate(this._symbols);this._symbols=results.symbols;tags=results.tags||[];}if(this._rtlReorder){const rtlReorderFunc=this._system.app.systems.element.getRtlReorder();if(rtlReorderFunc){const results=rtlReorderFunc(this._symbols);this._rtl=results.rtl;this._symbols=results.mapping.map(function(v){return this._symbols[v]},this);if(tags){tags=results.mapping.map(v=>{return tags[v]});}}else {console.warn("Element created with rtlReorder option but no rtlReorder function registered");}}else {this._rtl=false;}const getColorThicknessHash=(color,thickness)=>{return `${color.toString(true).toLowerCase()}:${thickness.toFixed(2)}`};const getColorOffsetHash=(color,offset)=>{return `${color.toString(true).toLowerCase()}:${offset.x.toFixed(2)}:${offset.y.toFixed(2)}`};if(tags){const paletteMap={};const outlinePaletteMap={};const shadowPaletteMap={};this._colorPalette=[Math.round(this._color.r*255),Math.round(this._color.g*255),Math.round(this._color.b*255)];this._outlinePalette=[Math.round(this._outlineColor.r*255),Math.round(this._outlineColor.g*255),Math.round(this._outlineColor.b*255),Math.round(this._outlineColor.a*255),Math.round(this._outlineThickness*255)];this._shadowPalette=[Math.round(this._shadowColor.r*255),Math.round(this._shadowColor.g*255),Math.round(this._shadowColor.b*255),Math.round(this._shadowColor.a*255),Math.round(this._shadowOffset.x*127),Math.round(this._shadowOffset.y*127)];this._symbolColors=[];this._symbolOutlineParams=[];this._symbolShadowParams=[];paletteMap[this._color.toString(false).toLowerCase()]=0;outlinePaletteMap[getColorThicknessHash(this._outlineColor,this._outlineThickness)]=0;shadowPaletteMap[getColorOffsetHash(this._shadowColor,this._shadowOffset)]=0;for(let i=0,len=this._symbols.length;i<len;++i){const tag=tags[i];let color=0;if(tag&&tag.color&&tag.color.value){const c=tag.color.value;if(c.length===7&&c[0]==="#"){const hex=c.substring(1).toLowerCase();if(paletteMap.hasOwnProperty(hex)){color=paletteMap[hex];}else {if(/^[0-9a-f]{6}$/.test(hex)){color=this._colorPalette.length/3;paletteMap[hex]=color;this._colorPalette.push(parseInt(hex.substring(0,2),16));this._colorPalette.push(parseInt(hex.substring(2,4),16));this._colorPalette.push(parseInt(hex.substring(4,6),16));}}}}this._symbolColors.push(color);let outline=0;if(tag&&tag.outline&&(tag.outline.attributes.color||tag.outline.attributes.thickness)){let _color=tag.outline.attributes.color?colorTmp.fromString(tag.outline.attributes.color):this._outlineColor;let thickness=Number(tag.outline.attributes.thickness);if(Number.isNaN(_color.r)||Number.isNaN(_color.g)||Number.isNaN(_color.b)||Number.isNaN(_color.a)){_color=this._outlineColor;}if(Number.isNaN(thickness)){thickness=this._outlineThickness;}const outlineHash=getColorThicknessHash(_color,thickness);if(outlinePaletteMap.hasOwnProperty(outlineHash)){outline=outlinePaletteMap[outlineHash];}else {outline=this._outlinePalette.length/5;outlinePaletteMap[outlineHash]=outline;this._outlinePalette.push(Math.round(_color.r*255),Math.round(_color.g*255),Math.round(_color.b*255),Math.round(_color.a*255),Math.round(thickness*255));}}this._symbolOutlineParams.push(outline);let shadow=0;if(tag&&tag.shadow&&(tag.shadow.attributes.color||tag.shadow.attributes.offset||tag.shadow.attributes.offsetX||tag.shadow.attributes.offsetY)){let _color2=tag.shadow.attributes.color?colorTmp.fromString(tag.shadow.attributes.color):this._shadowColor;const off=Number(tag.shadow.attributes.offset);const offX=Number(tag.shadow.attributes.offsetX);const offY=Number(tag.shadow.attributes.offsetY);if(Number.isNaN(_color2.r)||Number.isNaN(_color2.g)||Number.isNaN(_color2.b)||Number.isNaN(_color2.a)){_color2=this._shadowColor;}const offset=vec2Tmp.set(!Number.isNaN(offX)?offX:!Number.isNaN(off)?off:this._shadowOffset.x,!Number.isNaN(offY)?offY:!Number.isNaN(off)?off:this._shadowOffset.y);const shadowHash=getColorOffsetHash(_color2,offset);if(shadowPaletteMap.hasOwnProperty(shadowHash)){shadow=shadowPaletteMap[shadowHash];}else {shadow=this._shadowPalette.length/6;shadowPaletteMap[shadowHash]=shadow;this._shadowPalette.push(Math.round(_color2.r*255),Math.round(_color2.g*255),Math.round(_color2.b*255),Math.round(_color2.a*255),Math.round(offset.x*127),Math.round(offset.y*127));}}this._symbolShadowParams.push(shadow);}}else {this._colorPalette=[];this._symbolColors=null;this._symbolOutlineParams=null;this._symbolShadowParams=null;}this._updateMaterialEmissive();this._updateMaterialOutline();this._updateMaterialShadow();const charactersPerTexture=this._calculateCharsPerTexture();let removedModel=false;const element=this._element;const screenSpace=element._isScreenSpace();const screenCulled=element._isScreenCulled();const visibleFn=function visibleFn(camera){return element.isVisibleForCamera(camera)};for(let i=0,len=this._meshInfo.length;i<len;i++){const l=charactersPerTexture[i]||0;const meshInfo=this._meshInfo[i];if(meshInfo.count!==l){if(!removedModel){element.removeModelFromLayers(this._model);removedModel=true;}meshInfo.count=l;meshInfo.positions.length=meshInfo.normals.length=l*3*4;meshInfo.indices.length=l*3*2;meshInfo.uvs.length=l*2*4;meshInfo.colors.length=l*4*4;meshInfo.outlines.length=l*4*3;meshInfo.shadows.length=l*4*3;if(meshInfo.meshInstance){this._removeMeshInstance(meshInfo.meshInstance);}if(l===0){meshInfo.meshInstance=null;continue}for(let v=0;v<l;v++){meshInfo.indices[v*3*2+0]=v*4;meshInfo.indices[v*3*2+1]=v*4+1;meshInfo.indices[v*3*2+2]=v*4+3;meshInfo.indices[v*3*2+3]=v*4+2;meshInfo.indices[v*3*2+4]=v*4+3;meshInfo.indices[v*3*2+5]=v*4+1;meshInfo.normals[v*4*3+0]=0;meshInfo.normals[v*4*3+1]=0;meshInfo.normals[v*4*3+2]=-1;meshInfo.normals[v*4*3+3]=0;meshInfo.normals[v*4*3+4]=0;meshInfo.normals[v*4*3+5]=-1;meshInfo.normals[v*4*3+6]=0;meshInfo.normals[v*4*3+7]=0;meshInfo.normals[v*4*3+8]=-1;meshInfo.normals[v*4*3+9]=0;meshInfo.normals[v*4*3+10]=0;meshInfo.normals[v*4*3+11]=-1;}const mesh=createTextMesh(this._system.app.graphicsDevice,meshInfo);const mi=new MeshInstance(mesh,this._material,this._node);mi.name=`Text Element: ${this._entity.name}`;mi.castShadow=false;mi.receiveShadow=false;mi.cull=!screenSpace;mi.screenSpace=screenSpace;mi.drawOrder=this._drawOrder;if(screenCulled){mi.cull=true;mi.isVisibleFunc=visibleFn;}this._setTextureParams(mi,this._font.textures[i]);mi.setParameter("material_emissive",this._colorUniform);mi.setParameter("material_opacity",this._color.a);mi.setParameter("font_sdfIntensity",this._font.intensity);mi.setParameter("font_pxrange",this._getPxRange(this._font));mi.setParameter("font_textureWidth",this._font.data.info.maps[i].width);mi.setParameter("outline_color",this._outlineColorUniform);mi.setParameter("outline_thickness",this._outlineThicknessScale*this._outlineThickness);mi.setParameter("shadow_color",this._shadowColorUniform);if(this._symbolShadowParams){this._shadowOffsetUniform[0]=0;this._shadowOffsetUniform[1]=0;}else {const ratio=-this._font.data.info.maps[i].width/this._font.data.info.maps[i].height;this._shadowOffsetUniform[0]=this._shadowOffsetScale*this._shadowOffset.x;this._shadowOffsetUniform[1]=ratio*this._shadowOffsetScale*this._shadowOffset.y;}mi.setParameter("shadow_offset",this._shadowOffsetUniform);meshInfo.meshInstance=mi;this._model.meshInstances.push(mi);}}if(this._element.maskedBy){this._element._setMaskedBy(this._element.maskedBy);}if(removedModel&&this._element.enabled&&this._entity.enabled){this._element.addModelToLayers(this._model);}this._updateMeshes();this._rangeStart=0;this._rangeEnd=this._symbols.length;this._updateRenderRange();}_removeMeshInstance(meshInstance){meshInstance.destroy();const idx=this._model.meshInstances.indexOf(meshInstance);if(idx!==-1){this._model.meshInstances.splice(idx,1);}}_setMaterial(material){this._material=material;if(this._model){for(let i=0,len=this._model.meshInstances.length;i<len;i++){const mi=this._model.meshInstances[i];mi.material=material;}}}_updateMaterial(screenSpace){const element=this._element;const screenCulled=element._isScreenCulled();const visibleFn=function visibleFn(camera){return element.isVisibleForCamera(camera)};const msdf=this._font&&this._font.type===FONT_MSDF;this._material=this._system.getTextElementMaterial(screenSpace,msdf,this._enableMarkup);if(this._model){for(let i=0,len=this._model.meshInstances.length;i<len;i++){const mi=this._model.meshInstances[i];mi.cull=!screenSpace;mi.material=this._material;mi.screenSpace=screenSpace;if(screenCulled){mi.cull=true;mi.isVisibleFunc=visibleFn;}else {mi.isVisibleFunc=null;}}}}_updateMaterialEmissive(){if(this._symbolColors){this._colorUniform[0]=1;this._colorUniform[1]=1;this._colorUniform[2]=1;}else {this._colorUniform[0]=this._color.r;this._colorUniform[1]=this._color.g;this._colorUniform[2]=this._color.b;}}_updateMaterialOutline(){if(this._symbolOutlineParams){this._outlineColorUniform[0]=0;this._outlineColorUniform[1]=0;this._outlineColorUniform[2]=0;this._outlineColorUniform[3]=1;}else {this._outlineColorUniform[0]=this._outlineColor.r;this._outlineColorUniform[1]=this._outlineColor.g;this._outlineColorUniform[2]=this._outlineColor.b;this._outlineColorUniform[3]=this._outlineColor.a;}}_updateMaterialShadow(){if(this._symbolOutlineParams){this._shadowColorUniform[0]=0;this._shadowColorUniform[1]=0;this._shadowColorUniform[2]=0;this._shadowColorUniform[3]=0;}else {this._shadowColorUniform[0]=this._shadowColor.r;this._shadowColorUniform[1]=this._shadowColor.g;this._shadowColorUniform[2]=this._shadowColor.b;this._shadowColorUniform[3]=this._shadowColor.a;}}_isWordBoundary(char){return WORD_BOUNDARY_CHAR.test(char)}_isValidNextChar(nextchar){return nextchar!==null&&!NO_LINE_BREAK_CJK_CHAR.test(nextchar)}_isNextCJKBoundary(char,nextchar){return CJK_CHAR.test(char)&&(WORD_BOUNDARY_CHAR.test(nextchar)||ALPHANUMERIC_CHAR.test(nextchar))}_isNextCJKWholeWord(nextchar){return CJK_CHAR.test(nextchar)}_updateMeshes(){const json=this._font.data;const self1=this;const minFont=Math.min(this._minFontSize,this._maxFontSize);const maxFont=this._maxFontSize;const autoFit=this._shouldAutoFit();if(autoFit){this._fontSize=this._maxFontSize;}const MAGIC=32;const l=this._symbols.length;let _x=0;let _y=0;let _z=0;let _xMinusTrailingWhitespace=0;let lines=1;let wordStartX=0;let wordStartIndex=0;let lineStartIndex=0;let numWordsThisLine=0;let numCharsThisLine=0;let numBreaksThisLine=0;const splitHorizontalAnchors=Math.abs(this._element.anchor.x-this._element.anchor.z)>=1e-4;let maxLineWidth=this._element.calculatedWidth;if(this.autoWidth&&!splitHorizontalAnchors||!this._wrapLines){maxLineWidth=Number.POSITIVE_INFINITY;}let fontMinY=0;let fontMaxY=0;let char,data,quad,nextchar;function breakLine(symbols,lineBreakIndex,lineBreakX){self1._lineWidths.push(Math.abs(lineBreakX));const sliceStart=lineStartIndex>lineBreakIndex?lineBreakIndex+1:lineStartIndex;const sliceEnd=lineStartIndex>lineBreakIndex?lineStartIndex+1:lineBreakIndex;const chars=symbols.slice(sliceStart,sliceEnd);if(numBreaksThisLine){let i=chars.length;while(i--&&numBreaksThisLine>0){if(LINE_BREAK_CHAR.test(chars[i])){chars.splice(i,1);numBreaksThisLine--;}}}self1._lineContents.push(chars.join(""));_x=0;_y-=self1._scaledLineHeight;lines++;numWordsThisLine=0;numCharsThisLine=0;numBreaksThisLine=0;wordStartX=0;lineStartIndex=lineBreakIndex;}let retryUpdateMeshes=true;while(retryUpdateMeshes){retryUpdateMeshes=false;if(autoFit){this._scaledLineHeight=this._lineHeight*this._fontSize/(this._maxFontSize||1e-4);}else {this._scaledLineHeight=this._lineHeight;}this.width=0;this.height=0;this._lineWidths=[];this._lineContents=[];_x=0;_y=0;_z=0;_xMinusTrailingWhitespace=0;lines=1;wordStartX=0;wordStartIndex=0;lineStartIndex=0;numWordsThisLine=0;numCharsThisLine=0;numBreaksThisLine=0;const scale=this._fontSize/MAGIC;fontMinY=this._fontMinY*scale;fontMaxY=this._fontMaxY*scale;for(let i=0;i<this._meshInfo.length;i++){this._meshInfo[i].quad=0;this._meshInfo[i].lines={};}let color_r=255;let color_g=255;let color_b=255;let outline_color_rg=255+255*256;let outline_color_ba=255+255*256;let outline_thickness=0;let shadow_color_rg=255+255*256;let shadow_color_ba=255+255*256;let shadow_offset_xy=127+127*256;for(let i=0;i<l;i++){char=this._symbols[i];nextchar=i+1>=l?null:this._symbols[i+1];const isLineBreak=LINE_BREAK_CHAR.test(char);if(isLineBreak){numBreaksThisLine++;if(!this._wrapLines||this._maxLines<0||lines<this._maxLines){breakLine(this._symbols,i,_xMinusTrailingWhitespace);wordStartIndex=i+1;lineStartIndex=i+1;}continue}let x=0;let y=0;let advance=0;let quadsize=1;let dataScale,size;data=json.chars[char];if(!data){if(CONTROL_CHARS.indexOf(char)!==-1){data=CONTROL_GLYPH_DATA;}else {if(json.chars[" "]){data=json.chars[" "];}else {for(const key in json.chars){data=json.chars[key];break}}}}if(data){let kerning=0;if(numCharsThisLine>0){const kernTable=this._font.data.kerning;if(kernTable){const kernLeft=kernTable[string.getCodePoint(this._symbols[i-1])||0];if(kernLeft){kerning=kernLeft[string.getCodePoint(this._symbols[i])||0]||0;}}}dataScale=data.scale||1;size=(data.width+data.height)/2;quadsize=scale*size/dataScale;advance=(data.xadvance+kerning)*scale;x=(data.xoffset-kerning)*scale;y=data.yoffset*scale;}else {console.error(`Couldn't substitute missing character: '${char}'`);}const isWhitespace=WHITESPACE_CHAR.test(char);const meshInfoId=data&&data.map||0;const ratio=-this._font.data.info.maps[meshInfoId].width/this._font.data.info.maps[meshInfoId].height;const meshInfo=this._meshInfo[meshInfoId];const candidateLineWidth=_x+this._spacing*advance;if(candidateLineWidth>maxLineWidth&&numCharsThisLine>0&&!isWhitespace){if(this._maxLines<0||lines<this._maxLines){if(numWordsThisLine===0){wordStartIndex=i;breakLine(this._symbols,i,_xMinusTrailingWhitespace);}else {const backtrack=Math.max(i-wordStartIndex,0);if(this._meshInfo.length<=1){meshInfo.lines[lines-1]-=backtrack;meshInfo.quad-=backtrack;}else {const backtrackStart=wordStartIndex;const backtrackEnd=i;for(let j=backtrackStart;j<backtrackEnd;j++){const backChar=this._symbols[j];const backCharData=json.chars[backChar];const backMeshInfo=this._meshInfo[backCharData&&backCharData.map||0];backMeshInfo.lines[lines-1]-=1;backMeshInfo.quad-=1;}}i-=backtrack+1;breakLine(this._symbols,wordStartIndex,wordStartX);continue}}}quad=meshInfo.quad;meshInfo.lines[lines-1]=quad;let left=_x-x;let right=left+quadsize;const bottom=_y-y;const top=bottom+quadsize;if(this._rtl){const shift=quadsize-x-this._spacing*advance-x;left-=shift;right-=shift;}meshInfo.positions[quad*4*3+0]=left;meshInfo.positions[quad*4*3+1]=bottom;meshInfo.positions[quad*4*3+2]=_z;meshInfo.positions[quad*4*3+3]=right;meshInfo.positions[quad*4*3+4]=bottom;meshInfo.positions[quad*4*3+5]=_z;meshInfo.positions[quad*4*3+6]=right;meshInfo.positions[quad*4*3+7]=top;meshInfo.positions[quad*4*3+8]=_z;meshInfo.positions[quad*4*3+9]=left;meshInfo.positions[quad*4*3+10]=top;meshInfo.positions[quad*4*3+11]=_z;this.width=Math.max(this.width,candidateLineWidth);let fontSize;if(this._shouldAutoFitWidth()&&this.width>this._element.calculatedWidth){fontSize=Math.floor(this._element.fontSize*this._element.calculatedWidth/(this.width||1e-4));fontSize=math.clamp(fontSize,minFont,maxFont);if(fontSize!==this._element.fontSize){this._fontSize=fontSize;retryUpdateMeshes=true;break}}this.height=Math.max(this.height,fontMaxY-(_y+fontMinY));if(this._shouldAutoFitHeight()&&this.height>this._element.calculatedHeight){fontSize=math.clamp(this._fontSize-1,minFont,maxFont);if(fontSize!==this._element.fontSize){this._fontSize=fontSize;retryUpdateMeshes=true;break}}_x+=this._spacing*advance;if(!isWhitespace){_xMinusTrailingWhitespace=_x;}if(this._isWordBoundary(char)||this._isValidNextChar(nextchar)&&(this._isNextCJKBoundary(char,nextchar)||this._isNextCJKWholeWord(nextchar))){numWordsThisLine++;wordStartX=_xMinusTrailingWhitespace;wordStartIndex=i+1;}numCharsThisLine++;const uv=this._getUv(char);meshInfo.uvs[quad*4*2+0]=uv[0];meshInfo.uvs[quad*4*2+1]=1-uv[1];meshInfo.uvs[quad*4*2+2]=uv[2];meshInfo.uvs[quad*4*2+3]=1-uv[1];meshInfo.uvs[quad*4*2+4]=uv[2];meshInfo.uvs[quad*4*2+5]=1-uv[3];meshInfo.uvs[quad*4*2+6]=uv[0];meshInfo.uvs[quad*4*2+7]=1-uv[3];if(this._symbolColors){const colorIdx=this._symbolColors[i]*3;color_r=this._colorPalette[colorIdx];color_g=this._colorPalette[colorIdx+1];color_b=this._colorPalette[colorIdx+2];}meshInfo.colors[quad*4*4+0]=color_r;meshInfo.colors[quad*4*4+1]=color_g;meshInfo.colors[quad*4*4+2]=color_b;meshInfo.colors[quad*4*4+3]=255;meshInfo.colors[quad*4*4+4]=color_r;meshInfo.colors[quad*4*4+5]=color_g;meshInfo.colors[quad*4*4+6]=color_b;meshInfo.colors[quad*4*4+7]=255;meshInfo.colors[quad*4*4+8]=color_r;meshInfo.colors[quad*4*4+9]=color_g;meshInfo.colors[quad*4*4+10]=color_b;meshInfo.colors[quad*4*4+11]=255;meshInfo.colors[quad*4*4+12]=color_r;meshInfo.colors[quad*4*4+13]=color_g;meshInfo.colors[quad*4*4+14]=color_b;meshInfo.colors[quad*4*4+15]=255;if(this._symbolOutlineParams){const outlineIdx=this._symbolOutlineParams[i]*5;outline_color_rg=this._outlinePalette[outlineIdx]+this._outlinePalette[outlineIdx+1]*256;outline_color_ba=this._outlinePalette[outlineIdx+2]+this._outlinePalette[outlineIdx+3]*256;outline_thickness=this._outlinePalette[outlineIdx+4];}meshInfo.outlines[quad*4*3+0]=outline_color_rg;meshInfo.outlines[quad*4*3+1]=outline_color_ba;meshInfo.outlines[quad*4*3+2]=outline_thickness;meshInfo.outlines[quad*4*3+3]=outline_color_rg;meshInfo.outlines[quad*4*3+4]=outline_color_ba;meshInfo.outlines[quad*4*3+5]=outline_thickness;meshInfo.outlines[quad*4*3+6]=outline_color_rg;meshInfo.outlines[quad*4*3+7]=outline_color_ba;meshInfo.outlines[quad*4*3+8]=outline_thickness;meshInfo.outlines[quad*4*3+9]=outline_color_rg;meshInfo.outlines[quad*4*3+10]=outline_color_ba;meshInfo.outlines[quad*4*3+11]=outline_thickness;if(this._symbolShadowParams){const shadowIdx=this._symbolShadowParams[i]*6;shadow_color_rg=this._shadowPalette[shadowIdx]+this._shadowPalette[shadowIdx+1]*256;shadow_color_ba=this._shadowPalette[shadowIdx+2]+this._shadowPalette[shadowIdx+3]*256;shadow_offset_xy=this._shadowPalette[shadowIdx+4]+127+Math.round(ratio*this._shadowPalette[shadowIdx+5]+127)*256;}meshInfo.shadows[quad*4*3+0]=shadow_color_rg;meshInfo.shadows[quad*4*3+1]=shadow_color_ba;meshInfo.shadows[quad*4*3+2]=shadow_offset_xy;meshInfo.shadows[quad*4*3+3]=shadow_color_rg;meshInfo.shadows[quad*4*3+4]=shadow_color_ba;meshInfo.shadows[quad*4*3+5]=shadow_offset_xy;meshInfo.shadows[quad*4*3+6]=shadow_color_rg;meshInfo.shadows[quad*4*3+7]=shadow_color_ba;meshInfo.shadows[quad*4*3+8]=shadow_offset_xy;meshInfo.shadows[quad*4*3+9]=shadow_color_rg;meshInfo.shadows[quad*4*3+10]=shadow_color_ba;meshInfo.shadows[quad*4*3+11]=shadow_offset_xy;meshInfo.quad++;}if(retryUpdateMeshes){continue}if(lineStartIndex<l){breakLine(this._symbols,l,_x);}}this._noResize=true;this.autoWidth=this._autoWidth;this.autoHeight=this._autoHeight;this._noResize=false;const hp=this._element.pivot.x;const vp=this._element.pivot.y;const ha=this._alignment.x;const va=this._alignment.y;for(let i=0;i<this._meshInfo.length;i++){if(this._meshInfo[i].count===0)continue;let prevQuad=0;for(const line in this._meshInfo[i].lines){const index=this._meshInfo[i].lines[line];const lw=this._lineWidths[parseInt(line,10)];const hoffset=-hp*this._element.calculatedWidth+ha*(this._element.calculatedWidth-lw)*(this._rtl?-1:1);const voffset=(1-vp)*this._element.calculatedHeight-fontMaxY-(1-va)*(this._element.calculatedHeight-this.height);for(let _quad=prevQuad;_quad<=index;_quad++){this._meshInfo[i].positions[_quad*4*3]+=hoffset;this._meshInfo[i].positions[_quad*4*3+3]+=hoffset;this._meshInfo[i].positions[_quad*4*3+6]+=hoffset;this._meshInfo[i].positions[_quad*4*3+9]+=hoffset;this._meshInfo[i].positions[_quad*4*3+1]+=voffset;this._meshInfo[i].positions[_quad*4*3+4]+=voffset;this._meshInfo[i].positions[_quad*4*3+7]+=voffset;this._meshInfo[i].positions[_quad*4*3+10]+=voffset;}if(this._rtl){for(let _quad2=prevQuad;_quad2<=index;_quad2++){const idx=_quad2*4*3;for(let vert=0;vert<4;++vert){this._meshInfo[i].positions[idx+vert*3]=this._element.calculatedWidth-this._meshInfo[i].positions[idx+vert*3]+hoffset*2;}const tmp0=this._meshInfo[i].positions[idx+3];const tmp1=this._meshInfo[i].positions[idx+6];this._meshInfo[i].positions[idx+3]=this._meshInfo[i].positions[idx+0];this._meshInfo[i].positions[idx+6]=this._meshInfo[i].positions[idx+9];this._meshInfo[i].positions[idx+0]=tmp0;this._meshInfo[i].positions[idx+9]=tmp1;}}prevQuad=index+1;}const numVertices=this._meshInfo[i].count*4;const vertMax=this._meshInfo[i].quad*4;const it=new VertexIterator(this._meshInfo[i].meshInstance.mesh.vertexBuffer);for(let v=0;v<numVertices;v++){if(v>=vertMax){it.element[SEMANTIC_POSITION].set(0,0,0);it.element[SEMANTIC_TEXCOORD0].set(0,0);it.element[SEMANTIC_COLOR].set(0,0,0,0);it.element[SEMANTIC_ATTR8].set(0,0,0,0);it.element[SEMANTIC_ATTR9].set(0,0,0,0);}else {it.element[SEMANTIC_POSITION].set(this._meshInfo[i].positions[v*3+0],this._meshInfo[i].positions[v*3+1],this._meshInfo[i].positions[v*3+2]);it.element[SEMANTIC_TEXCOORD0].set(this._meshInfo[i].uvs[v*2+0],this._meshInfo[i].uvs[v*2+1]);it.element[SEMANTIC_COLOR].set(this._meshInfo[i].colors[v*4+0],this._meshInfo[i].colors[v*4+1],this._meshInfo[i].colors[v*4+2],this._meshInfo[i].colors[v*4+3]);it.element[SEMANTIC_ATTR8].set(this._meshInfo[i].outlines[v*3+0],this._meshInfo[i].outlines[v*3+1],this._meshInfo[i].outlines[v*3+2]);it.element[SEMANTIC_ATTR9].set(this._meshInfo[i].shadows[v*3+0],this._meshInfo[i].shadows[v*3+1],this._meshInfo[i].shadows[v*3+2]);}it.next();}it.end();this._meshInfo[i].meshInstance.mesh.aabb.compute(this._meshInfo[i].positions);this._meshInfo[i].meshInstance._aabbVer=-1;}this._aabbDirty=true;}_onFontRender(){this.font=this._font;}_onFontLoad(asset){if(this.font!==asset.resource){this.font=asset.resource;}}_onFontChange(asset,name,_new,_old){if(name==="data"){this._font.data=_new;const maps=this._font.data.info.maps.length;for(let i=0;i<maps;i++){if(!this._meshInfo[i])continue;const mi=this._meshInfo[i].meshInstance;if(mi){mi.setParameter("font_sdfIntensity",this._font.intensity);mi.setParameter("font_pxrange",this._getPxRange(this._font));mi.setParameter("font_textureWidth",this._font.data.info.maps[i].width);}}}}_onFontRemove(asset){}_setTextureParams(mi,texture){if(this._font){if(this._font.type===FONT_MSDF){mi.deleteParameter("texture_emissiveMap");mi.deleteParameter("texture_opacityMap");mi.setParameter("texture_msdfMap",texture);}else if(this._font.type===FONT_BITMAP){mi.deleteParameter("texture_msdfMap");mi.setParameter("texture_emissiveMap",texture);mi.setParameter("texture_opacityMap",texture);}}}_getPxRange(font){const keys=Object.keys(this._font.data.chars);for(let i=0;i<keys.length;i++){const char=this._font.data.chars[keys[i]];if(char.range){return (char.scale||1)*char.range}}return 2}_getUv(char){const data=this._font.data;if(!data.chars[char]){const space=" ";if(data.chars[space]){return this._getUv(space)}return [0,0,0,0]}const map=data.chars[char].map;const width=data.info.maps[map].width;const height=data.info.maps[map].height;const x=data.chars[char].x;const y=data.chars[char].y;const x1=x;const y1=y;const x2=x+data.chars[char].width;const y2=y-data.chars[char].height;const edge=1-data.chars[char].height/height;return [x1/width,edge-y1/height,x2/width,edge-y2/height]}onEnable(){this._fontAsset.autoLoad=true;if(this._model){this._element.addModelToLayers(this._model);}}onDisable(){this._fontAsset.autoLoad=false;if(this._model){this._element.removeModelFromLayers(this._model);}}_setStencil(stencilParams){if(this._model){const instances=this._model.meshInstances;for(let i=0;i<instances.length;i++){instances[i].stencilFront=stencilParams;instances[i].stencilBack=stencilParams;}}}_shouldAutoFitWidth(){return this._autoFitWidth&&!this._autoWidth}_shouldAutoFitHeight(){return this._autoFitHeight&&!this._autoHeight}_shouldAutoFit(){return this._autoFitWidth&&!this._autoWidth||this._autoFitHeight&&!this._autoHeight}_calculateCharsPerTexture(symbolIndex){const charactersPerTexture={};if(symbolIndex===undefined){symbolIndex=this._symbols.length;}for(let i=0,len=symbolIndex;i<len;i++){const char=this._symbols[i];let info=this._font.data.chars[char];if(!info){info=this._font.data.chars[" "];if(!info){info=this._font.data.chars[Object.keys(this._font.data.chars)[0]];}}const map=info.map;if(!charactersPerTexture[map]){charactersPerTexture[map]=1;}else {charactersPerTexture[map]++;}}return charactersPerTexture}_updateRenderRange(){const startChars=this._rangeStart===0?0:this._calculateCharsPerTexture(this._rangeStart);const endChars=this._rangeEnd===0?0:this._calculateCharsPerTexture(this._rangeEnd);for(let i=0,len=this._meshInfo.length;i<len;i++){const start=startChars[i]||0;const end=endChars[i]||0;const instance=this._meshInfo[i].meshInstance;if(instance){const mesh=instance.mesh;if(mesh){mesh.primitive[0].base=start*3*2;mesh.primitive[0].count=(end-start)*3*2;}}}}set text(value){this._i18nKey=null;const str=value!=null&&value.toString()||"";this._setText(str);}get text(){return this._text}set key(value){const str=value!==null?value.toString():null;if(this._i18nKey===str){return}this._i18nKey=str;if(str){this._fontAsset.disableLocalization=false;this._resetLocalizedText();}else {this._fontAsset.disableLocalization=true;}}get key(){return this._i18nKey}set color(value){const r=value.r;const g=value.g;const b=value.b;if(this._color.r===r&&this._color.g===g&&this._color.b===b){return}this._color.r=r;this._color.g=g;this._color.b=b;if(!this._model){return}if(this._symbolColors){if(this._font){this._updateText();}}else {this._colorUniform[0]=this._color.r;this._colorUniform[1]=this._color.g;this._colorUniform[2]=this._color.b;for(let i=0,len=this._model.meshInstances.length;i<len;i++){const mi=this._model.meshInstances[i];mi.setParameter("material_emissive",this._colorUniform);}}if(this._element){this._element.fire("set:color",this._color);}}get color(){return this._color}set opacity(value){if(this._color.a!==value){this._color.a=value;if(this._model){for(let i=0,len=this._model.meshInstances.length;i<len;i++){const mi=this._model.meshInstances[i];mi.setParameter("material_opacity",value);}}}if(this._element){this._element.fire("set:opacity",value);}}get opacity(){return this._color.a}set lineHeight(value){const _prev=this._lineHeight;this._lineHeight=value;this._scaledLineHeight=value;if(_prev!==value&&this._font){this._updateText();}}get lineHeight(){return this._lineHeight}set wrapLines(value){const _prev=this._wrapLines;this._wrapLines=value;if(_prev!==value&&this._font){this._updateText();}}get wrapLines(){return this._wrapLines}get lines(){return this._lineContents}set spacing(value){const _prev=this._spacing;this._spacing=value;if(_prev!==value&&this._font){this._updateText();}}get spacing(){return this._spacing}set fontSize(value){const _prev=this._fontSize;this._fontSize=value;this._originalFontSize=value;if(_prev!==value&&this._font){this._updateText();}}get fontSize(){return this._fontSize}set fontAsset(value){this._fontAsset.defaultAsset=value;}get fontAsset(){return this._fontAsset.localizedAsset}set font(value){let previousFontType;if(this._font){previousFontType=this._font.type;if(this._font.off)this._font.off("render",this._onFontRender,this);}this._font=value;this._fontMinY=0;this._fontMaxY=0;if(!value)return;const json=this._font.data;for(const charId in json.chars){const data=json.chars[charId];if(data.bounds){this._fontMinY=Math.min(this._fontMinY,data.bounds[1]);this._fontMaxY=Math.max(this._fontMaxY,data.bounds[3]);}}if(this._font.on)this._font.on("render",this._onFontRender,this);if(this._fontAsset.localizedAsset){const asset=this._system.app.assets.get(this._fontAsset.localizedAsset);if(asset.resource!==this._font){this._fontAsset.defaultAsset=null;}}if(value.type!==previousFontType){const screenSpace=this._element._isScreenSpace();this._updateMaterial(screenSpace);}for(let i=0,len=this._font.textures.length;i<len;i++){if(!this._meshInfo[i]){this._meshInfo[i]=new MeshInfo;}else {const mi=this._meshInfo[i].meshInstance;if(mi){mi.setParameter("font_sdfIntensity",this._font.intensity);mi.setParameter("font_pxrange",this._getPxRange(this._font));mi.setParameter("font_textureWidth",this._font.data.info.maps[i].width);this._setTextureParams(mi,this._font.textures[i]);}}}let removedModel=false;for(let i=this._font.textures.length;i<this._meshInfo.length;i++){if(this._meshInfo[i].meshInstance){if(!removedModel){this._element.removeModelFromLayers(this._model);removedModel=true;}this._removeMeshInstance(this._meshInfo[i].meshInstance);}}if(this._meshInfo.length>this._font.textures.length){this._meshInfo.length=this._font.textures.length;}this._updateText();}get font(){return this._font}set alignment(value){if(value instanceof Vec2){this._alignment.set(value.x,value.y);}else {this._alignment.set(value[0],value[1]);}if(this._font){this._updateText();}}get alignment(){return this._alignment}set autoWidth(value){const old=this._autoWidth;this._autoWidth=value;if(value&&Math.abs(this._element.anchor.x-this._element.anchor.z)<1e-4){this._element.width=this.width;}if(old!==value){const newFontSize=this._shouldAutoFit()?this._maxFontSize:this._originalFontSize;if(newFontSize!==this._fontSize){this._fontSize=newFontSize;if(this._font){this._updateText();}}}}get autoWidth(){return this._autoWidth}set autoHeight(value){const old=this._autoHeight;this._autoHeight=value;if(value&&Math.abs(this._element.anchor.y-this._element.anchor.w)<1e-4){this._element.height=this.height;}if(old!==value){const newFontSize=this._shouldAutoFit()?this._maxFontSize:this._originalFontSize;if(newFontSize!==this._fontSize){this._fontSize=newFontSize;if(this._font){this._updateText();}}}}get autoHeight(){return this._autoHeight}set rtlReorder(value){if(this._rtlReorder!==value){this._rtlReorder=value;if(this._font){this._updateText();}}}get rtlReorder(){return this._rtlReorder}set unicodeConverter(value){if(this._unicodeConverter!==value){this._unicodeConverter=value;this._setText(this._text);}}get unicodeConverter(){return this._unicodeConverter}get aabb(){if(this._aabbDirty){let initialized=false;for(let i=0;i<this._meshInfo.length;i++){if(!this._meshInfo[i].meshInstance)continue;if(!initialized){this._aabb.copy(this._meshInfo[i].meshInstance.aabb);initialized=true;}else {this._aabb.add(this._meshInfo[i].meshInstance.aabb);}}this._aabbDirty=false;}return this._aabb}set outlineColor(value){const r=value instanceof Color?value.r:value[0];const g=value instanceof Color?value.g:value[1];const b=value instanceof Color?value.b:value[2];const a=value instanceof Color?value.a:value[3];if(this._outlineColor.r===r&&this._outlineColor.g===g&&this._outlineColor.b===b&&this._outlineColor.a===a){return}this._outlineColor.r=r;this._outlineColor.g=g;this._outlineColor.b=b;this._outlineColor.a=a;if(!this._model){return}if(this._symbolOutlineParams){if(this._font){this._updateText();}}else {this._outlineColorUniform[0]=this._outlineColor.r;this._outlineColorUniform[1]=this._outlineColor.g;this._outlineColorUniform[2]=this._outlineColor.b;this._outlineColorUniform[3]=this._outlineColor.a;for(let i=0,len=this._model.meshInstances.length;i<len;i++){const mi=this._model.meshInstances[i];mi.setParameter("outline_color",this._outlineColorUniform);}}if(this._element){this._element.fire("set:outline",this._color);}}get outlineColor(){return this._outlineColor}set outlineThickness(value){const _prev=this._outlineThickness;this._outlineThickness=value;if(_prev!==value&&this._font){if(!this._model){return}if(this._symbolOutlineParams){if(this._font){this._updateText();}}else {for(let i=0,len=this._model.meshInstances.length;i<len;i++){const mi=this._model.meshInstances[i];mi.setParameter("outline_thickness",this._outlineThicknessScale*this._outlineThickness);}}}}get outlineThickness(){return this._outlineThickness}set shadowColor(value){const r=value instanceof Color?value.r:value[0];const g=value instanceof Color?value.g:value[1];const b=value instanceof Color?value.b:value[2];const a=value instanceof Color?value.a:value[3];if(this._shadowColor.r===r&&this._shadowColor.g===g&&this._shadowColor.b===b&&this._shadowColor.a===a){return}this._shadowColor.r=r;this._shadowColor.g=g;this._shadowColor.b=b;this._shadowColor.a=a;if(!this._model){return}if(this._symbolShadowParams){if(this._font){this._updateText();}}else {this._shadowColorUniform[0]=this._shadowColor.r;this._shadowColorUniform[1]=this._shadowColor.g;this._shadowColorUniform[2]=this._shadowColor.b;this._shadowColorUniform[3]=this._shadowColor.a;for(let i=0,len=this._model.meshInstances.length;i<len;i++){const mi=this._model.meshInstances[i];mi.setParameter("shadow_color",this._shadowColorUniform);}}}get shadowColor(){return this._shadowColor}set shadowOffset(value){const x=value instanceof Vec2?value.x:value[0],y=value instanceof Vec2?value.y:value[1];if(this._shadowOffset.x===x&&this._shadowOffset.y===y){return}this._shadowOffset.set(x,y);if(this._font&&this._model){if(this._symbolShadowParams){this._updateText();}else {for(let i=0,len=this._model.meshInstances.length;i<len;i++){const ratio=-this._font.data.info.maps[i].width/this._font.data.info.maps[i].height;this._shadowOffsetUniform[0]=this._shadowOffsetScale*this._shadowOffset.x;this._shadowOffsetUniform[1]=ratio*this._shadowOffsetScale*this._shadowOffset.y;const mi=this._model.meshInstances[i];mi.setParameter("shadow_offset",this._shadowOffsetUniform);}}}}get shadowOffset(){return this._shadowOffset}set minFontSize(value){if(this._minFontSize===value)return;this._minFontSize=value;if(this.font&&this._shouldAutoFit()){this._updateText();}}get minFontSize(){return this._minFontSize}set maxFontSize(value){if(this._maxFontSize===value)return;this._maxFontSize=value;if(this.font&&this._shouldAutoFit()){this._updateText();}}get maxFontSize(){return this._maxFontSize}set autoFitWidth(value){if(this._autoFitWidth===value)return;this._autoFitWidth=value;this._fontSize=this._shouldAutoFit()?this._maxFontSize:this._originalFontSize;if(this.font){this._updateText();}}get autoFitWidth(){return this._autoFitWidth}set autoFitHeight(value){if(this._autoFitHeight===value)return;this._autoFitHeight=value;this._fontSize=this._shouldAutoFit()?this._maxFontSize:this._originalFontSize;if(this.font){this._updateText();}}get autoFitHeight(){return this._autoFitHeight}set maxLines(value){if(this._maxLines===value)return;if(value===null&&this._maxLines===-1)return;this._maxLines=value===null?-1:value;if(this.font&&this._wrapLines){this._updateText();}}get maxLines(){return this._maxLines}set enableMarkup(value){value=!!value;if(this._enableMarkup===value)return;this._enableMarkup=value;if(this.font){this._updateText();}const screenSpace=this._element._isScreenSpace();this._updateMaterial(screenSpace);}get enableMarkup(){return this._enableMarkup}get symbols(){return this._symbols}get symbolColors(){if(this._symbolColors===null){return null}return this._symbolColors.map(function(c){return this._colorPalette.slice(c*3,c*3+3)},this)}get symbolOutlineParams(){if(this._symbolOutlineParams===null){return null}return this._symbolOutlineParams.map(function(paramId){return this._outlinePalette.slice(paramId*5,paramId*5+5)},this)}get symbolShadowParams(){if(this._symbolShadowParams===null){return null}return this._symbolShadowParams.map(function(paramId){return this._shadowPalette.slice(paramId*6,paramId*6+6)},this)}get rtl(){return this._rtl}set rangeStart(rangeStart){rangeStart=Math.max(0,Math.min(rangeStart,this._symbols.length));if(rangeStart!==this._rangeStart){this._rangeStart=rangeStart;this._updateRenderRange();}}get rangeStart(){return this._rangeStart}set rangeEnd(rangeEnd){rangeEnd=Math.max(this._rangeStart,Math.min(rangeEnd,this._symbols.length));if(rangeEnd!==this._rangeEnd){this._rangeEnd=rangeEnd;this._updateRenderRange();}}get rangeEnd(){return this._rangeEnd}constructor(element){this._element=element;this._system=element.system;this._entity=element.entity;this._text="";this._symbols=[];this._colorPalette=[];this._outlinePalette=[];this._shadowPalette=[];this._symbolColors=null;this._symbolOutlineParams=null;this._symbolShadowParams=null;this._i18nKey=null;this._fontAsset=new LocalizedAsset(this._system.app);this._fontAsset.disableLocalization=true;this._fontAsset.on("load",this._onFontLoad,this);this._fontAsset.on("change",this._onFontChange,this);this._fontAsset.on("remove",this._onFontRemove,this);this._font=null;this._color=new Color(1,1,1,1);this._colorUniform=new Float32Array(3);this._spacing=1;this._fontSize=32;this._fontMinY=0;this._fontMaxY=0;this._originalFontSize=32;this._maxFontSize=32;this._minFontSize=8;this._autoFitWidth=false;this._autoFitHeight=false;this._maxLines=-1;this._lineHeight=32;this._scaledLineHeight=32;this._wrapLines=false;this._drawOrder=0;this._alignment=new Vec2(.5,.5);this._autoWidth=true;this._autoHeight=true;this.width=0;this.height=0;this._node=new GraphNode;this._model=new Model;this._model.graph=this._node;this._entity.addChild(this._node);this._meshInfo=[];this._material=null;this._aabbDirty=true;this._aabb=new BoundingBox;this._noResize=false;this._currentMaterialType=null;this._maskedMaterialSrc=null;this._rtlReorder=false;this._unicodeConverter=false;this._rtl=false;this._outlineColor=new Color(0,0,0,1);this._outlineColorUniform=new Float32Array(4);this._outlineThicknessScale=.2;this._outlineThickness=0;this._shadowColor=new Color(0,0,0,1);this._shadowColorUniform=new Float32Array(4);this._shadowOffsetScale=.005;this._shadowOffset=new Vec2(0,0);this._shadowOffsetUniform=new Float32Array(2);this._enableMarkup=false;this._onScreenChange(this._element.screen);element.on("resize",this._onParentResize,this);element.on("set:screen",this._onScreenChange,this);element.on("screen:set:screenspace",this._onScreenSpaceChange,this);element.on("set:draworder",this._onDrawOrderChange,this);element.on("set:pivot",this._onPivotChange,this);this._system.app.i18n.on("set:locale",this._onLocaleSet,this);this._system.app.i18n.on("data:add",this._onLocalizationData,this);this._system.app.i18n.on("data:remove",this._onLocalizationData,this);this._rangeStart=0;this._rangeEnd=0;}}const position=new Vec3;const invParentWtm=new Mat4;const vecA$2=new Vec3;const vecB$2=new Vec3;const matA=new Mat4;const matB=new Mat4;const matC=new Mat4;const matD=new Mat4;class ElementComponent extends Component{get data(){const record=this.system.store[this.entity.getGuid()];return record?record.data:null}set enabled(value){const data=this.data;const oldValue=data.enabled;data.enabled=value;this.fire("set","enabled",oldValue,value);}get enabled(){return this.data.enabled}get _absLeft(){return this._localAnchor.x+this._margin.x}get _absRight(){return this._localAnchor.z-this._margin.z}get _absTop(){return this._localAnchor.w-this._margin.w}get _absBottom(){return this._localAnchor.y+this._margin.y}get _hasSplitAnchorsX(){return Math.abs(this._anchor.x-this._anchor.z)>.001}get _hasSplitAnchorsY(){return Math.abs(this._anchor.y-this._anchor.w)>.001}get aabb(){if(this._image){return this._image.aabb}if(this._text){return this._text.aabb}return null}set anchor(value){if(value instanceof Vec4){this._anchor.copy(value);}else {this._anchor.set(...value);}if(!this.entity._parent&&!this.screen){this._calculateLocalAnchors();}else {this._calculateSize(this._hasSplitAnchorsX,this._hasSplitAnchorsY);}this._anchorDirty=true;if(!this.entity._dirtyLocal){this.entity._dirtifyLocal();}this.fire("set:anchor",this._anchor);}get anchor(){return this._anchor}set batchGroupId(value){if(this._batchGroupId===value){return}if(this.entity.enabled&&this._batchGroupId>=0){var _this$system$app$batc;(_this$system$app$batc=this.system.app.batcher)==null||_this$system$app$batc.remove(BatchGroup.ELEMENT,this.batchGroupId,this.entity);}if(this.entity.enabled&&value>=0){var _this$system$app$batc2;(_this$system$app$batc2=this.system.app.batcher)==null||_this$system$app$batc2.insert(BatchGroup.ELEMENT,value,this.entity);}if(value<0&&this._batchGroupId>=0&&this.enabled&&this.entity.enabled){if(this._image&&this._image._renderable.model){this.addModelToLayers(this._image._renderable.model);}else if(this._text&&this._text._model){this.addModelToLayers(this._text._model);}}this._batchGroupId=value;}get batchGroupId(){return this._batchGroupId}set bottom(value){this._margin.y=value;const p=this.entity.getLocalPosition();const wt=this._absTop;const wb=this._localAnchor.y+value;this._setHeight(wt-wb);p.y=value+this._calculatedHeight*this._pivot.y;this.entity.setLocalPosition(p);}get bottom(){return this._margin.y}set calculatedWidth(value){this._setCalculatedWidth(value,true);}get calculatedWidth(){return this._calculatedWidth}set calculatedHeight(value){this._setCalculatedHeight(value,true);}get calculatedHeight(){return this._calculatedHeight}get canvasCorners(){if(!this._canvasCornersDirty||!this.screen||!this.screen.screen.screenSpace){return this._canvasCorners}const device=this.system.app.graphicsDevice;const screenCorners=this.screenCorners;const sx=device.canvas.clientWidth/device.width;const sy=device.canvas.clientHeight/device.height;for(let i=0;i<4;i++){this._canvasCorners[i].set(screenCorners[i].x*sx,(device.height-screenCorners[i].y)*sy);}this._canvasCornersDirty=false;return this._canvasCorners}set drawOrder(value){let priority=0;if(this.screen){priority=this.screen.screen.priority;}if(value>16777215){value=16777215;}this._drawOrder=(priority<<24)+value;this.fire("set:draworder",this._drawOrder);}get drawOrder(){return this._drawOrder}set height(value){this._height=value;if(!this._hasSplitAnchorsY){this._setCalculatedHeight(value,true);}this.fire("set:height",this._height);}get height(){return this._height}set layers(value){if(this._addedModels.length){for(let i=0;i<this._layers.length;i++){const layer=this.system.app.scene.layers.getLayerById(this._layers[i]);if(layer){for(let j=0;j<this._addedModels.length;j++){layer.removeMeshInstances(this._addedModels[j].meshInstances);}}}}this._layers=value;if(!this.enabled||!this.entity.enabled||!this._addedModels.length){return}for(let i=0;i<this._layers.length;i++){const layer=this.system.app.scene.layers.getLayerById(this._layers[i]);if(layer){for(let j=0;j<this._addedModels.length;j++){layer.addMeshInstances(this._addedModels[j].meshInstances);}}}}get layers(){return this._layers}set left(value){this._margin.x=value;const p=this.entity.getLocalPosition();const wr=this._absRight;const wl=this._localAnchor.x+value;this._setWidth(wr-wl);p.x=value+this._calculatedWidth*this._pivot.x;this.entity.setLocalPosition(p);}get left(){return this._margin.x}set margin(value){this._margin.copy(value);this._calculateSize(true,true);this.fire("set:margin",this._margin);}get margin(){return this._margin}get maskedBy(){return this._maskedBy}set pivot(value){const{pivot,margin}=this;const prevX=pivot.x;const prevY=pivot.y;if(value instanceof Vec2){pivot.copy(value);}else {pivot.set(...value);}const mx=margin.x+margin.z;const dx=pivot.x-prevX;margin.x+=mx*dx;margin.z-=mx*dx;const my=margin.y+margin.w;const dy=pivot.y-prevY;margin.y+=my*dy;margin.w-=my*dy;this._anchorDirty=true;this._cornersDirty=true;this._worldCornersDirty=true;this._calculateSize(false,false);this._flagChildrenAsDirty();this.fire("set:pivot",pivot);}get pivot(){return this._pivot}set right(value){this._margin.z=value;const p=this.entity.getLocalPosition();const wl=this._absLeft;const wr=this._localAnchor.z-value;this._setWidth(wr-wl);p.x=this._localAnchor.z-this._localAnchor.x-value-this._calculatedWidth*(1-this._pivot.x);this.entity.setLocalPosition(p);}get right(){return this._margin.z}get screenCorners(){if(!this._cornersDirty||!this.screen){return this._screenCorners}const parentBottomLeft=this.entity.parent&&this.entity.parent.element&&this.entity.parent.element.screenCorners[0];this._screenCorners[0].set(this._absLeft,this._absBottom,0);this._screenCorners[1].set(this._absRight,this._absBottom,0);this._screenCorners[2].set(this._absRight,this._absTop,0);this._screenCorners[3].set(this._absLeft,this._absTop,0);const screenSpace=this.screen.screen.screenSpace;for(let i=0;i<4;i++){this._screenTransform.transformPoint(this._screenCorners[i],this._screenCorners[i]);if(screenSpace){this._screenCorners[i].mulScalar(this.screen.screen.scale);}if(parentBottomLeft){this._screenCorners[i].add(parentBottomLeft);}}this._cornersDirty=false;this._canvasCornersDirty=true;this._worldCornersDirty=true;return this._screenCorners}get textWidth(){return this._text?this._text.width:0}get textHeight(){return this._text?this._text.height:0}set top(value){this._margin.w=value;const p=this.entity.getLocalPosition();const wb=this._absBottom;const wt=this._localAnchor.w-value;this._setHeight(wt-wb);p.y=this._localAnchor.w-this._localAnchor.y-value-this._calculatedHeight*(1-this._pivot.y);this.entity.setLocalPosition(p);}get top(){return this._margin.w}set type(value){if(value!==this._type){this._type=value;if(this._image){this._image.destroy();this._image=null;}if(this._text){this._text.destroy();this._text=null;}if(value===ELEMENTTYPE_IMAGE){this._image=new ImageElement(this);}else if(value===ELEMENTTYPE_TEXT){this._text=new TextElement(this);}}}get type(){return this._type}set useInput(value){if(this._useInput===value){return}this._useInput=value;if(this.system.app.elementInput){if(value){if(this.enabled&&this.entity.enabled){this.system.app.elementInput.addElement(this);}}else {this.system.app.elementInput.removeElement(this);}}else {if(this._useInput===true);}this.fire("set:useInput",value);}get useInput(){return this._useInput}set fitMode(value){this._fitMode=value;this._calculateSize(true,true);if(this._image){this._image.refreshMesh();}}get fitMode(){return this._fitMode}set width(value){this._width=value;if(!this._hasSplitAnchorsX){this._setCalculatedWidth(value,true);}this.fire("set:width",this._width);}get width(){return this._width}get worldCorners(){if(!this._worldCornersDirty){return this._worldCorners}if(this.screen){const screenCorners=this.screenCorners;if(!this.screen.screen.screenSpace){matA.copy(this.screen.screen._screenMatrix);matA.data[13]=-matA.data[13];matA.mul2(this.screen.getWorldTransform(),matA);for(let i=0;i<4;i++){matA.transformPoint(screenCorners[i],this._worldCorners[i]);}}}else {const localPos=this.entity.getLocalPosition();matA.setTranslate(-localPos.x,-localPos.y,-localPos.z);matB.setTRS(Vec3.ZERO,this.entity.getLocalRotation(),this.entity.getLocalScale());matC.setTranslate(localPos.x,localPos.y,localPos.z);const entity=this.entity.parent?this.entity.parent:this.entity;matD.copy(entity.getWorldTransform());matD.mul(matC).mul(matB).mul(matA);vecA$2.set(localPos.x-this.pivot.x*this.calculatedWidth,localPos.y-this.pivot.y*this.calculatedHeight,localPos.z);matD.transformPoint(vecA$2,this._worldCorners[0]);vecA$2.set(localPos.x+(1-this.pivot.x)*this.calculatedWidth,localPos.y-this.pivot.y*this.calculatedHeight,localPos.z);matD.transformPoint(vecA$2,this._worldCorners[1]);vecA$2.set(localPos.x+(1-this.pivot.x)*this.calculatedWidth,localPos.y+(1-this.pivot.y)*this.calculatedHeight,localPos.z);matD.transformPoint(vecA$2,this._worldCorners[2]);vecA$2.set(localPos.x-this.pivot.x*this.calculatedWidth,localPos.y+(1-this.pivot.y)*this.calculatedHeight,localPos.z);matD.transformPoint(vecA$2,this._worldCorners[3]);}this._worldCornersDirty=false;return this._worldCorners}set fontSize(arg){this._setValue("fontSize",arg);}get fontSize(){if(this._text){return this._text.fontSize}return null}set minFontSize(arg){this._setValue("minFontSize",arg);}get minFontSize(){if(this._text){return this._text.minFontSize}return null}set maxFontSize(arg){this._setValue("maxFontSize",arg);}get maxFontSize(){if(this._text){return this._text.maxFontSize}return null}set maxLines(arg){this._setValue("maxLines",arg);}get maxLines(){if(this._text){return this._text.maxLines}return null}set autoFitWidth(arg){this._setValue("autoFitWidth",arg);}get autoFitWidth(){if(this._text){return this._text.autoFitWidth}return null}set autoFitHeight(arg){this._setValue("autoFitHeight",arg);}get autoFitHeight(){if(this._text){return this._text.autoFitHeight}return null}set color(arg){this._setValue("color",arg);}get color(){if(this._text){return this._text.color}if(this._image){return this._image.color}return null}set font(arg){this._setValue("font",arg);}get font(){if(this._text){return this._text.font}return null}set fontAsset(arg){this._setValue("fontAsset",arg);}get fontAsset(){if(this._text&&typeof this._text.fontAsset==="number"){return this._text.fontAsset}return null}set spacing(arg){this._setValue("spacing",arg);}get spacing(){if(this._text){return this._text.spacing}return null}set lineHeight(arg){this._setValue("lineHeight",arg);}get lineHeight(){if(this._text){return this._text.lineHeight}return null}set wrapLines(arg){this._setValue("wrapLines",arg);}get wrapLines(){if(this._text){return this._text.wrapLines}return null}set lines(arg){this._setValue("lines",arg);}get lines(){if(this._text){return this._text.lines}return null}set alignment(arg){this._setValue("alignment",arg);}get alignment(){if(this._text){return this._text.alignment}return null}set autoWidth(arg){this._setValue("autoWidth",arg);}get autoWidth(){if(this._text){return this._text.autoWidth}return null}set autoHeight(arg){this._setValue("autoHeight",arg);}get autoHeight(){if(this._text){return this._text.autoHeight}return null}set rtlReorder(arg){this._setValue("rtlReorder",arg);}get rtlReorder(){if(this._text){return this._text.rtlReorder}return null}set unicodeConverter(arg){this._setValue("unicodeConverter",arg);}get unicodeConverter(){if(this._text){return this._text.unicodeConverter}return null}set text(arg){this._setValue("text",arg);}get text(){if(this._text){return this._text.text}return null}set key(arg){this._setValue("key",arg);}get key(){if(this._text){return this._text.key}return null}set texture(arg){this._setValue("texture",arg);}get texture(){if(this._image){return this._image.texture}return null}set textureAsset(arg){this._setValue("textureAsset",arg);}get textureAsset(){if(this._image){return this._image.textureAsset}return null}set material(arg){this._setValue("material",arg);}get material(){if(this._image){return this._image.material}return null}set materialAsset(arg){this._setValue("materialAsset",arg);}get materialAsset(){if(this._image){return this._image.materialAsset}return null}set sprite(arg){this._setValue("sprite",arg);}get sprite(){if(this._image){return this._image.sprite}return null}set spriteAsset(arg){this._setValue("spriteAsset",arg);}get spriteAsset(){if(this._image){return this._image.spriteAsset}return null}set spriteFrame(arg){this._setValue("spriteFrame",arg);}get spriteFrame(){if(this._image){return this._image.spriteFrame}return null}set pixelsPerUnit(arg){this._setValue("pixelsPerUnit",arg);}get pixelsPerUnit(){if(this._image){return this._image.pixelsPerUnit}return null}set opacity(arg){this._setValue("opacity",arg);}get opacity(){if(this._text){return this._text.opacity}if(this._image){return this._image.opacity}return null}set rect(arg){this._setValue("rect",arg);}get rect(){if(this._image){return this._image.rect}return null}set mask(arg){this._setValue("mask",arg);}get mask(){if(this._image){return this._image.mask}return null}set outlineColor(arg){this._setValue("outlineColor",arg);}get outlineColor(){if(this._text){return this._text.outlineColor}return null}set outlineThickness(arg){this._setValue("outlineThickness",arg);}get outlineThickness(){if(this._text){return this._text.outlineThickness}return null}set shadowColor(arg){this._setValue("shadowColor",arg);}get shadowColor(){if(this._text){return this._text.shadowColor}return null}set shadowOffset(arg){this._setValue("shadowOffset",arg);}get shadowOffset(){if(this._text){return this._text.shadowOffset}return null}set enableMarkup(arg){this._setValue("enableMarkup",arg);}get enableMarkup(){if(this._text){return this._text.enableMarkup}return null}set rangeStart(arg){this._setValue("rangeStart",arg);}get rangeStart(){if(this._text){return this._text.rangeStart}return null}set rangeEnd(arg){this._setValue("rangeEnd",arg);}get rangeEnd(){if(this._text){return this._text.rangeEnd}return null}_setValue(name,value){if(this._text){if(this._text[name]!==value){this._dirtyBatch();}this._text[name]=value;}else if(this._image){if(this._image[name]!==value){this._dirtyBatch();}this._image[name]=value;}}_patch(){this.entity._sync=this._sync;this.entity.setPosition=this._setPosition;this.entity.setLocalPosition=this._setLocalPosition;}_unpatch(){this.entity._sync=Entity.prototype._sync;this.entity.setPosition=Entity.prototype.setPosition;this.entity.setLocalPosition=Entity.prototype.setLocalPosition;}_setPosition(x,y,z){if(!this.element.screen){Entity.prototype.setPosition.call(this,x,y,z);return}if(x instanceof Vec3){position.copy(x);}else {position.set(x,y,z);}this.getWorldTransform();invParentWtm.copy(this.element._screenToWorld).invert();invParentWtm.transformPoint(position,this.localPosition);if(!this._dirtyLocal){this._dirtifyLocal();}}_setLocalPosition(x,y,z){if(x instanceof Vec3){this.localPosition.copy(x);}else {this.localPosition.set(x,y,z);}const element=this.element;const p=this.localPosition;const pvt=element._pivot;element._margin.x=p.x-element._calculatedWidth*pvt.x;element._margin.z=element._localAnchor.z-element._localAnchor.x-element._calculatedWidth-element._margin.x;element._margin.y=p.y-element._calculatedHeight*pvt.y;element._margin.w=element._localAnchor.w-element._localAnchor.y-element._calculatedHeight-element._margin.y;if(!this._dirtyLocal){this._dirtifyLocal();}}_sync(){const element=this.element;const screen=element.screen;if(screen){if(element._anchorDirty){let resx=0;let resy=0;let px=0;let py=1;if(this._parent&&this._parent.element){resx=this._parent.element.calculatedWidth;resy=this._parent.element.calculatedHeight;px=this._parent.element.pivot.x;py=this._parent.element.pivot.y;}else {const resolution=screen.screen.resolution;resx=resolution.x/screen.screen.scale;resy=resolution.y/screen.screen.scale;}element._anchorTransform.setTranslate(resx*(element.anchor.x-px),-(resy*(py-element.anchor.y)),0);element._anchorDirty=false;element._calculateLocalAnchors();}if(element._sizeDirty){element._calculateSize(false,false);}}if(this._dirtyLocal){this.localTransform.setTRS(this.localPosition,this.localRotation,this.localScale);const p=this.localPosition;const pvt=element._pivot;element._margin.x=p.x-element._calculatedWidth*pvt.x;element._margin.z=element._localAnchor.z-element._localAnchor.x-element._calculatedWidth-element._margin.x;element._margin.y=p.y-element._calculatedHeight*pvt.y;element._margin.w=element._localAnchor.w-element._localAnchor.y-element._calculatedHeight-element._margin.y;this._dirtyLocal=false;}if(!screen){if(this._dirtyWorld){element._cornersDirty=true;element._canvasCornersDirty=true;element._worldCornersDirty=true;}Entity.prototype._sync.call(this);return}if(this._dirtyWorld){if(this._parent===null){this.worldTransform.copy(this.localTransform);}else {if(this._parent.element){element._screenToWorld.mul2(this._parent.element._modelTransform,element._anchorTransform);}else {element._screenToWorld.copy(element._anchorTransform);}element._modelTransform.mul2(element._screenToWorld,this.localTransform);if(screen){element._screenToWorld.mul2(screen.screen._screenMatrix,element._screenToWorld);if(!screen.screen.screenSpace){element._screenToWorld.mul2(screen.worldTransform,element._screenToWorld);}this.worldTransform.mul2(element._screenToWorld,this.localTransform);const parentWorldTransform=element._parentWorldTransform;parentWorldTransform.setIdentity();const parent=this._parent;if(parent&&parent.element&&parent!==screen){matA.setTRS(Vec3.ZERO,parent.getLocalRotation(),parent.getLocalScale());parentWorldTransform.mul2(parent.element._parentWorldTransform,matA);}const depthOffset=vecA$2;depthOffset.set(0,0,this.localPosition.z);const pivotOffset=vecB$2;pivotOffset.set(element._absLeft+element._pivot.x*element.calculatedWidth,element._absBottom+element._pivot.y*element.calculatedHeight,0);matA.setTranslate(-pivotOffset.x,-pivotOffset.y,-pivotOffset.z);matB.setTRS(depthOffset,this.getLocalRotation(),this.getLocalScale());matC.setTranslate(pivotOffset.x,pivotOffset.y,pivotOffset.z);element._screenTransform.mul2(element._parentWorldTransform,matC).mul(matB).mul(matA);element._cornersDirty=true;element._canvasCornersDirty=true;element._worldCornersDirty=true;}else {this.worldTransform.copy(element._modelTransform);}}this._dirtyWorld=false;}}_onInsert(parent){const result=this._parseUpToScreen();this.entity._dirtifyWorld();this._updateScreen(result.screen);this._dirtifyMask();}_dirtifyMask(){let current=this.entity;while(current){const next=current.parent;if((next===null||next.screen)&&current.element){if(!this.system._prerender||!this.system._prerender.length){this.system._prerender=[];this.system.app.once("prerender",this._onPrerender,this);}const i=this.system._prerender.indexOf(this.entity);if(i>=0){this.system._prerender.splice(i,1);}const j=this.system._prerender.indexOf(current);if(j<0){this.system._prerender.push(current);}}current=next;}}_onPrerender(){for(let i=0;i<this.system._prerender.length;i++){const mask=this.system._prerender[i];if(mask.element){const depth=1;mask.element.syncMask(depth);}}this.system._prerender.length=0;}_bindScreen(screen){screen._bindElement(this);}_unbindScreen(screen){screen._unbindElement(this);}_updateScreen(screen){if(this.screen&&this.screen!==screen){this._unbindScreen(this.screen.screen);}const previousScreen=this.screen;this.screen=screen;if(this.screen){this._bindScreen(this.screen.screen);}this._calculateSize(this._hasSplitAnchorsX,this._hasSplitAnchorsY);this.fire("set:screen",this.screen,previousScreen);this._anchorDirty=true;const children=this.entity.children;for(let i=0,l=children.length;i<l;i++){if(children[i].element){children[i].element._updateScreen(screen);}}if(this.screen){this.screen.screen.syncDrawOrder();}}syncMask(depth){const result=this._parseUpToScreen();this._updateMask(result.mask,depth);}_setMaskedBy(mask){const renderableElement=this._image||this._text;if(mask){const ref=mask.element._image._maskRef;renderableElement==null||renderableElement._setStencil(new StencilParameters({ref:ref,func:FUNC_EQUAL}));this._maskedBy=mask;}else {renderableElement==null||renderableElement._setStencil(null);this._maskedBy=null;}}_updateMask(currentMask,depth){if(currentMask){this._setMaskedBy(currentMask);if(this.mask){const ref=currentMask.element._image._maskRef;const sp=new StencilParameters({ref:ref,func:FUNC_EQUAL,zpass:STENCILOP_INCREMENT});this._image._setStencil(sp);this._image._maskRef=depth;depth++;currentMask=this.entity;}const children=this.entity.children;for(let i=0,l=children.length;i<l;i++){var _children$i$element;(_children$i$element=children[i].element)==null||_children$i$element._updateMask(currentMask,depth);}if(this.mask)depth--;}else {this._setMaskedBy(null);if(this.mask){const sp=new StencilParameters({ref:depth,func:FUNC_ALWAYS,zpass:STENCILOP_REPLACE});this._image._setStencil(sp);this._image._maskRef=depth;depth++;currentMask=this.entity;}const children=this.entity.children;for(let i=0,l=children.length;i<l;i++){var _children$i$element2;(_children$i$element2=children[i].element)==null||_children$i$element2._updateMask(currentMask,depth);}if(this.mask){depth--;}}}_parseUpToScreen(){const result={screen:null,mask:null};let parent=this.entity._parent;while(parent&&!parent.screen){if(parent.element&&parent.element.mask){if(!result.mask)result.mask=parent;}parent=parent.parent;}if(parent&&parent.screen){result.screen=parent;}return result}_onScreenResize(res){this._anchorDirty=true;this._cornersDirty=true;this._worldCornersDirty=true;this._calculateSize(this._hasSplitAnchorsX,this._hasSplitAnchorsY);this.fire("screen:set:resolution",res);}_onScreenSpaceChange(){this.fire("screen:set:screenspace",this.screen.screen.screenSpace);}_onScreenRemove(){if(this.screen){if(this.screen._destroying){this.screen=null;}else {this._updateScreen(null);}}}_calculateLocalAnchors(){let resx=1e3;let resy=1e3;const parent=this.entity._parent;if(parent&&parent.element){resx=parent.element.calculatedWidth;resy=parent.element.calculatedHeight;}else if(this.screen){const res=this.screen.screen.resolution;const scale=this.screen.screen.scale;resx=res.x/scale;resy=res.y/scale;}this._localAnchor.set(this._anchor.x*resx,this._anchor.y*resy,this._anchor.z*resx,this._anchor.w*resy);}getOffsetPosition(x,y){const p=this.entity.getLocalPosition().clone();p.x+=x;p.y+=y;this._screenToWorld.transformPoint(p,p);return p}onLayersChanged(oldComp,newComp){this.addModelToLayers(this._image?this._image._renderable.model:this._text._model);oldComp.off("add",this.onLayerAdded,this);oldComp.off("remove",this.onLayerRemoved,this);newComp.on("add",this.onLayerAdded,this);newComp.on("remove",this.onLayerRemoved,this);}onLayerAdded(layer){const index=this.layers.indexOf(layer.id);if(index<0)return;if(this._image){layer.addMeshInstances(this._image._renderable.model.meshInstances);}else if(this._text){layer.addMeshInstances(this._text._model.meshInstances);}}onLayerRemoved(layer){const index=this.layers.indexOf(layer.id);if(index<0)return;if(this._image){layer.removeMeshInstances(this._image._renderable.model.meshInstances);}else if(this._text){layer.removeMeshInstances(this._text._model.meshInstances);}}onEnable(){const scene=this.system.app.scene;const layers=scene.layers;if(this._image){this._image.onEnable();}if(this._text){this._text.onEnable();}if(this._group){this._group.onEnable();}if(this.useInput&&this.system.app.elementInput){this.system.app.elementInput.addElement(this);}this._evtLayersChanged=scene.on("set:layers",this.onLayersChanged,this);if(layers){this._evtLayerAdded=layers.on("add",this.onLayerAdded,this);this._evtLayerRemoved=layers.on("remove",this.onLayerRemoved,this);}if(this._batchGroupId>=0){var _this$system$app$batc3;(_this$system$app$batc3=this.system.app.batcher)==null||_this$system$app$batc3.insert(BatchGroup.ELEMENT,this.batchGroupId,this.entity);}this.fire("enableelement");}onDisable(){var _this$_evtLayersChang;const scene=this.system.app.scene;const layers=scene.layers;(_this$_evtLayersChang=this._evtLayersChanged)==null||_this$_evtLayersChang.off();this._evtLayersChanged=null;if(layers){var _this$_evtLayerAdded,_this$_evtLayerRemove;(_this$_evtLayerAdded=this._evtLayerAdded)==null||_this$_evtLayerAdded.off();this._evtLayerAdded=null;(_this$_evtLayerRemove=this._evtLayerRemoved)==null||_this$_evtLayerRemove.off();this._evtLayerRemoved=null;}if(this._image)this._image.onDisable();if(this._text)this._text.onDisable();if(this._group)this._group.onDisable();if(this.system.app.elementInput&&this.useInput){this.system.app.elementInput.removeElement(this);}if(this._batchGroupId>=0){var _this$system$app$batc4;(_this$system$app$batc4=this.system.app.batcher)==null||_this$system$app$batc4.remove(BatchGroup.ELEMENT,this.batchGroupId,this.entity);}this.fire("disableelement");}onRemove(){this.entity.off("insert",this._onInsert,this);this._unpatch();if(this._image){this._image.destroy();}if(this._text){this._text.destroy();}if(this.system.app.elementInput&&this.useInput){this.system.app.elementInput.removeElement(this);}if(this.screen&&this.screen.screen){this._unbindScreen(this.screen.screen);this.screen.screen.syncDrawOrder();}this.off();}_calculateSize(propagateCalculatedWidth,propagateCalculatedHeight){if(!this.entity._parent&&!this.screen){return}this._calculateLocalAnchors();const newWidth=this._absRight-this._absLeft;const newHeight=this._absTop-this._absBottom;if(propagateCalculatedWidth){this._setWidth(newWidth);}else {this._setCalculatedWidth(newWidth,false);}if(propagateCalculatedHeight){this._setHeight(newHeight);}else {this._setCalculatedHeight(newHeight,false);}const p=this.entity.getLocalPosition();p.x=this._margin.x+this._calculatedWidth*this._pivot.x;p.y=this._margin.y+this._calculatedHeight*this._pivot.y;this.entity.setLocalPosition(p);this._sizeDirty=false;}_setWidth(w){this._width=w;this._setCalculatedWidth(w,false);this.fire("set:width",this._width);}_setHeight(h){this._height=h;this._setCalculatedHeight(h,false);this.fire("set:height",this._height);}_setCalculatedWidth(value,updateMargins){if(Math.abs(value-this._calculatedWidth)<=1e-4){return}this._calculatedWidth=value;this.entity._dirtifyLocal();if(updateMargins){const p=this.entity.getLocalPosition();const pvt=this._pivot;this._margin.x=p.x-this._calculatedWidth*pvt.x;this._margin.z=this._localAnchor.z-this._localAnchor.x-this._calculatedWidth-this._margin.x;}this._flagChildrenAsDirty();this.fire("set:calculatedWidth",this._calculatedWidth);this.fire("resize",this._calculatedWidth,this._calculatedHeight);}_setCalculatedHeight(value,updateMargins){if(Math.abs(value-this._calculatedHeight)<=1e-4){return}this._calculatedHeight=value;this.entity._dirtifyLocal();if(updateMargins){const p=this.entity.getLocalPosition();const pvt=this._pivot;this._margin.y=p.y-this._calculatedHeight*pvt.y;this._margin.w=this._localAnchor.w-this._localAnchor.y-this._calculatedHeight-this._margin.y;}this._flagChildrenAsDirty();this.fire("set:calculatedHeight",this._calculatedHeight);this.fire("resize",this._calculatedWidth,this._calculatedHeight);}_flagChildrenAsDirty(){const c=this.entity._children;for(let i=0,l=c.length;i<l;i++){if(c[i].element){c[i].element._anchorDirty=true;c[i].element._sizeDirty=true;}}}addModelToLayers(model){this._addedModels.push(model);for(let i=0;i<this.layers.length;i++){const layer=this.system.app.scene.layers.getLayerById(this.layers[i]);if(!layer)continue;layer.addMeshInstances(model.meshInstances);}}removeModelFromLayers(model){const idx=this._addedModels.indexOf(model);if(idx>=0){this._addedModels.splice(idx,1);}for(let i=0;i<this.layers.length;i++){const layer=this.system.app.scene.layers.getLayerById(this.layers[i]);if(!layer){continue}layer.removeMeshInstances(model.meshInstances);}}getMaskOffset(){const frame=this.system.app.frame;if(this._offsetReadAt!==frame){this._maskOffset=.5;this._offsetReadAt=frame;}const mo=this._maskOffset;this._maskOffset-=.001;return mo}isVisibleForCamera(camera){let clipL,clipR,clipT,clipB;if(this.maskedBy){const corners=this.maskedBy.element.screenCorners;clipL=Math.min(Math.min(corners[0].x,corners[1].x),Math.min(corners[2].x,corners[3].x));clipR=Math.max(Math.max(corners[0].x,corners[1].x),Math.max(corners[2].x,corners[3].x));clipB=Math.min(Math.min(corners[0].y,corners[1].y),Math.min(corners[2].y,corners[3].y));clipT=Math.max(Math.max(corners[0].y,corners[1].y),Math.max(corners[2].y,corners[3].y));}else {const sw=this.system.app.graphicsDevice.width;const sh=this.system.app.graphicsDevice.height;const cameraWidth=camera._rect.z*sw;const cameraHeight=camera._rect.w*sh;clipL=camera._rect.x*sw;clipR=clipL+cameraWidth;clipT=(1-camera._rect.y)*sh;clipB=clipT-cameraHeight;}const hitCorners=this.screenCorners;const left=Math.min(Math.min(hitCorners[0].x,hitCorners[1].x),Math.min(hitCorners[2].x,hitCorners[3].x));const right=Math.max(Math.max(hitCorners[0].x,hitCorners[1].x),Math.max(hitCorners[2].x,hitCorners[3].x));const bottom=Math.min(Math.min(hitCorners[0].y,hitCorners[1].y),Math.min(hitCorners[2].y,hitCorners[3].y));const top=Math.max(Math.max(hitCorners[0].y,hitCorners[1].y),Math.max(hitCorners[2].y,hitCorners[3].y));if(right<clipL||left>clipR||bottom>clipT||top<clipB){return false}return true}_isScreenSpace(){if(this.screen&&this.screen.screen){return this.screen.screen.screenSpace}return false}_isScreenCulled(){if(this.screen&&this.screen.screen){return this.screen.screen.cull}return false}_dirtyBatch(){if(this.batchGroupId!==-1){var _this$system$app$batc5;(_this$system$app$batc5=this.system.app.batcher)==null||_this$system$app$batc5.markGroupDirty(this.batchGroupId);}}constructor(system,entity){super(system,entity);this._evtLayersChanged=null;this._evtLayerAdded=null;this._evtLayerRemoved=null;this._beingInitialized=false;this._anchor=new Vec4;this._localAnchor=new Vec4;this._pivot=new Vec2;this._width=this._calculatedWidth=32;this._height=this._calculatedHeight=32;this._margin=new Vec4(0,0,-32,-32);this._modelTransform=new Mat4;this._screenToWorld=new Mat4;this._anchorTransform=new Mat4;this._anchorDirty=true;this._parentWorldTransform=new Mat4;this._screenTransform=new Mat4;this._screenCorners=[new Vec3,new Vec3,new Vec3,new Vec3];this._canvasCorners=[new Vec2,new Vec2,new Vec2,new Vec2];this._worldCorners=[new Vec3,new Vec3,new Vec3,new Vec3];this._cornersDirty=true;this._canvasCornersDirty=true;this._worldCornersDirty=true;this.entity.on("insert",this._onInsert,this);this._patch();this.screen=null;this._type=ELEMENTTYPE_GROUP;this._image=null;this._text=null;this._group=null;this._drawOrder=0;this._fitMode=FITMODE_STRETCH;this._useInput=false;this._layers=[LAYERID_UI];this._addedModels=[];this._batchGroupId=-1;this._offsetReadAt=0;this._maskOffset=.5;this._maskedBy=null;}}ElementComponent.EVENT_MOUSEDOWN="mousedown";ElementComponent.EVENT_MOUSEUP="mouseup";ElementComponent.EVENT_MOUSEENTER="mouseenter";ElementComponent.EVENT_MOUSELEAVE="mouseleave";ElementComponent.EVENT_MOUSEMOVE="mousemove";ElementComponent.EVENT_MOUSEWHEEL="mousewheel";ElementComponent.EVENT_CLICK="click";ElementComponent.EVENT_TOUCHSTART="touchstart";ElementComponent.EVENT_TOUCHEND="touchend";ElementComponent.EVENT_TOUCHMOVE="touchmove";ElementComponent.EVENT_TOUCHCANCEL="touchcancel";class ElementComponentData{constructor(){this.enabled=true;}}const _schema$g=["enabled"];class ElementComponentSystem extends ComponentSystem{destroy(){super.destroy();this._defaultTexture.destroy();}initializeComponentData(component,data,properties){component._beingInitialized=true;if(data.anchor!==undefined){if(data.anchor instanceof Vec4){component.anchor.copy(data.anchor);}else {component.anchor.set(data.anchor[0],data.anchor[1],data.anchor[2],data.anchor[3]);}}if(data.pivot!==undefined){if(data.pivot instanceof Vec2){component.pivot.copy(data.pivot);}else {component.pivot.set(data.pivot[0],data.pivot[1]);}}const splitHorAnchors=Math.abs(component.anchor.x-component.anchor.z)>.001;const splitVerAnchors=Math.abs(component.anchor.y-component.anchor.w)>.001;let _marginChange=false;let color;if(data.margin!==undefined){if(data.margin instanceof Vec4){component.margin.copy(data.margin);}else {component._margin.set(data.margin[0],data.margin[1],data.margin[2],data.margin[3]);}_marginChange=true;}if(data.left!==undefined){component._margin.x=data.left;_marginChange=true;}if(data.bottom!==undefined){component._margin.y=data.bottom;_marginChange=true;}if(data.right!==undefined){component._margin.z=data.right;_marginChange=true;}if(data.top!==undefined){component._margin.w=data.top;_marginChange=true;}if(_marginChange){component.margin=component._margin;}let shouldForceSetAnchor=false;if(data.width!==undefined&&!splitHorAnchors){component.width=data.width;}else if(splitHorAnchors){shouldForceSetAnchor=true;}if(data.height!==undefined&&!splitVerAnchors){component.height=data.height;}else if(splitVerAnchors){shouldForceSetAnchor=true;}if(shouldForceSetAnchor){component.anchor=component.anchor;}if(data.enabled!==undefined){component.enabled=data.enabled;}if(data.useInput!==undefined){component.useInput=data.useInput;}if(data.fitMode!==undefined){component.fitMode=data.fitMode;}component.batchGroupId=data.batchGroupId===undefined||data.batchGroupId===null?-1:data.batchGroupId;if(data.layers&&Array.isArray(data.layers)){component.layers=data.layers.slice(0);}if(data.type!==undefined){component.type=data.type;}if(component.type===ELEMENTTYPE_IMAGE){if(data.rect!==undefined){component.rect=data.rect;}if(data.color!==undefined){color=data.color;if(!(color instanceof Color)){color=new Color(data.color[0],data.color[1],data.color[2]);}component.color=color;}if(data.opacity!==undefined)component.opacity=data.opacity;if(data.textureAsset!==undefined)component.textureAsset=data.textureAsset;if(data.texture)component.texture=data.texture;if(data.spriteAsset!==undefined)component.spriteAsset=data.spriteAsset;if(data.sprite)component.sprite=data.sprite;if(data.spriteFrame!==undefined)component.spriteFrame=data.spriteFrame;if(data.pixelsPerUnit!==undefined&&data.pixelsPerUnit!==null)component.pixelsPerUnit=data.pixelsPerUnit;if(data.materialAsset!==undefined)component.materialAsset=data.materialAsset;if(data.material)component.material=data.material;if(data.mask!==undefined){component.mask=data.mask;}}else if(component.type===ELEMENTTYPE_TEXT){if(data.autoWidth!==undefined)component.autoWidth=data.autoWidth;if(data.autoHeight!==undefined)component.autoHeight=data.autoHeight;if(data.rtlReorder!==undefined)component.rtlReorder=data.rtlReorder;if(data.unicodeConverter!==undefined)component.unicodeConverter=data.unicodeConverter;if(data.text!==null&&data.text!==undefined){component.text=data.text;}else if(data.key!==null&&data.key!==undefined){component.key=data.key;}if(data.color!==undefined){color=data.color;if(!(color instanceof Color)){color=new Color(color[0],color[1],color[2]);}component.color=color;}if(data.opacity!==undefined){component.opacity=data.opacity;}if(data.spacing!==undefined)component.spacing=data.spacing;if(data.fontSize!==undefined){component.fontSize=data.fontSize;if(!data.lineHeight)component.lineHeight=data.fontSize;}if(data.lineHeight!==undefined)component.lineHeight=data.lineHeight;if(data.maxLines!==undefined)component.maxLines=data.maxLines;if(data.wrapLines!==undefined)component.wrapLines=data.wrapLines;if(data.minFontSize!==undefined)component.minFontSize=data.minFontSize;if(data.maxFontSize!==undefined)component.maxFontSize=data.maxFontSize;if(data.autoFitWidth)component.autoFitWidth=data.autoFitWidth;if(data.autoFitHeight)component.autoFitHeight=data.autoFitHeight;if(data.fontAsset!==undefined)component.fontAsset=data.fontAsset;if(data.font!==undefined)component.font=data.font;if(data.alignment!==undefined)component.alignment=data.alignment;if(data.outlineColor!==undefined)component.outlineColor=data.outlineColor;if(data.outlineThickness!==undefined)component.outlineThickness=data.outlineThickness;if(data.shadowColor!==undefined)component.shadowColor=data.shadowColor;if(data.shadowOffset!==undefined)component.shadowOffset=data.shadowOffset;if(data.enableMarkup!==undefined)component.enableMarkup=data.enableMarkup;}const result=component._parseUpToScreen();if(result.screen){component._updateScreen(result.screen);}super.initializeComponentData(component,data,properties);component._beingInitialized=false;if(component.type===ELEMENTTYPE_IMAGE&&component._image._meshDirty){component._image._updateMesh(component._image.mesh);}}onAddComponent(entity,component){entity.fire("element:add");}onRemoveComponent(entity,component){component.onRemove();}cloneComponent(entity,clone){const source=entity.element;const data={enabled:source.enabled,width:source.width,height:source.height,anchor:source.anchor.clone(),pivot:source.pivot.clone(),margin:source.margin.clone(),alignment:source.alignment&&source.alignment.clone()||source.alignment,autoWidth:source.autoWidth,autoHeight:source.autoHeight,type:source.type,rect:source.rect&&source.rect.clone()||source.rect,rtlReorder:source.rtlReorder,unicodeConverter:source.unicodeConverter,materialAsset:source.materialAsset,material:source.material,color:source.color&&source.color.clone()||source.color,opacity:source.opacity,textureAsset:source.textureAsset,texture:source.texture,spriteAsset:source.spriteAsset,sprite:source.sprite,spriteFrame:source.spriteFrame,pixelsPerUnit:source.pixelsPerUnit,spacing:source.spacing,lineHeight:source.lineHeight,wrapLines:source.wrapLines,layers:source.layers,fontSize:source.fontSize,minFontSize:source.minFontSize,maxFontSize:source.maxFontSize,autoFitWidth:source.autoFitWidth,autoFitHeight:source.autoFitHeight,maxLines:source.maxLines,fontAsset:source.fontAsset,font:source.font,useInput:source.useInput,fitMode:source.fitMode,batchGroupId:source.batchGroupId,mask:source.mask,outlineColor:source.outlineColor&&source.outlineColor.clone()||source.outlineColor,outlineThickness:source.outlineThickness,shadowColor:source.shadowColor&&source.shadowColor.clone()||source.shadowColor,shadowOffset:source.shadowOffset&&source.shadowOffset.clone()||source.shadowOffset,enableMarkup:source.enableMarkup};if(source.key!==undefined&&source.key!==null){data.key=source.key;}else {data.text=source.text;}return this.addComponent(clone,data)}getTextElementMaterial(screenSpace,msdf,textAttibutes){const hash=(screenSpace&&1<<0)|(msdf&&1<<1)|(textAttibutes&&1<<2);let material=this._defaultTextMaterials[hash];if(material){return material}let name="TextMaterial";material=new StandardMaterial;if(msdf){material.msdfMap=this._defaultTexture;material.msdfTextAttribute=textAttibutes;material.emissive.set(1,1,1);}else {name=`Bitmap${name}`;material.emissive.set(.5,.5,.5);material.emissiveMap=this._defaultTexture;material.emissiveTint=true;material.opacityMap=this._defaultTexture;material.opacityMapChannel="a";}if(screenSpace){name=`ScreenSpace${name}`;material.depthTest=false;}material.name=`default${name}`;material.useLighting=false;material.useGammaTonemap=false;material.useFog=false;material.useSkybox=false;material.diffuse.set(0,0,0);material.opacity=.5;material.blendType=BLEND_PREMULTIPLIED;material.depthWrite=false;material.emissiveVertexColor=true;material.update();this._defaultTextMaterials[hash]=material;return material}_createBaseImageMaterial(){const material=new StandardMaterial;material.diffuse.set(0,0,0);material.emissive.set(.5,.5,.5);material.emissiveMap=this._defaultTexture;material.emissiveTint=true;material.opacityMap=this._defaultTexture;material.opacityMapChannel="a";material.opacityTint=true;material.opacity=0;material.useLighting=false;material.useGammaTonemap=false;material.useFog=false;material.useSkybox=false;material.blendType=BLEND_PREMULTIPLIED;material.depthWrite=false;return material}getImageElementMaterial(screenSpace,mask,nineSliced,nineSliceTiled){if(screenSpace){if(mask){if(nineSliced){if(!this.defaultScreenSpaceImageMask9SlicedMaterial){this.defaultScreenSpaceImageMask9SlicedMaterial=this._createBaseImageMaterial();this.defaultScreenSpaceImageMask9SlicedMaterial.name="defaultScreenSpaceImageMask9SlicedMaterial";this.defaultScreenSpaceImageMask9SlicedMaterial.nineSlicedMode=SPRITE_RENDERMODE_SLICED;this.defaultScreenSpaceImageMask9SlicedMaterial.depthTest=false;this.defaultScreenSpaceImageMask9SlicedMaterial.alphaTest=1;this.defaultScreenSpaceImageMask9SlicedMaterial.redWrite=false;this.defaultScreenSpaceImageMask9SlicedMaterial.greenWrite=false;this.defaultScreenSpaceImageMask9SlicedMaterial.blueWrite=false;this.defaultScreenSpaceImageMask9SlicedMaterial.alphaWrite=false;this.defaultScreenSpaceImageMask9SlicedMaterial.update();this.defaultImageMaterials.push(this.defaultScreenSpaceImageMask9SlicedMaterial);}return this.defaultScreenSpaceImageMask9SlicedMaterial}else if(nineSliceTiled){if(!this.defaultScreenSpaceImageMask9TiledMaterial){this.defaultScreenSpaceImageMask9TiledMaterial=this.defaultScreenSpaceImage9TiledMaterial.clone();this.defaultScreenSpaceImageMask9TiledMaterial.name="defaultScreenSpaceImageMask9TiledMaterial";this.defaultScreenSpaceImageMask9TiledMaterial.nineSlicedMode=SPRITE_RENDERMODE_TILED;this.defaultScreenSpaceImageMask9TiledMaterial.depthTest=false;this.defaultScreenSpaceImageMask9TiledMaterial.alphaTest=1;this.defaultScreenSpaceImageMask9TiledMaterial.redWrite=false;this.defaultScreenSpaceImageMask9TiledMaterial.greenWrite=false;this.defaultScreenSpaceImageMask9TiledMaterial.blueWrite=false;this.defaultScreenSpaceImageMask9TiledMaterial.alphaWrite=false;this.defaultScreenSpaceImageMask9TiledMaterial.update();this.defaultImageMaterials.push(this.defaultScreenSpaceImageMask9TiledMaterial);}return this.defaultScreenSpaceImageMask9TiledMaterial}else {if(!this.defaultScreenSpaceImageMaskMaterial){this.defaultScreenSpaceImageMaskMaterial=this._createBaseImageMaterial();this.defaultScreenSpaceImageMaskMaterial.name="defaultScreenSpaceImageMaskMaterial";this.defaultScreenSpaceImageMaskMaterial.depthTest=false;this.defaultScreenSpaceImageMaskMaterial.alphaTest=1;this.defaultScreenSpaceImageMaskMaterial.redWrite=false;this.defaultScreenSpaceImageMaskMaterial.greenWrite=false;this.defaultScreenSpaceImageMaskMaterial.blueWrite=false;this.defaultScreenSpaceImageMaskMaterial.alphaWrite=false;this.defaultScreenSpaceImageMaskMaterial.update();this.defaultImageMaterials.push(this.defaultScreenSpaceImageMaskMaterial);}return this.defaultScreenSpaceImageMaskMaterial}}else {if(nineSliced){if(!this.defaultScreenSpaceImage9SlicedMaterial){this.defaultScreenSpaceImage9SlicedMaterial=this._createBaseImageMaterial();this.defaultScreenSpaceImage9SlicedMaterial.name="defaultScreenSpaceImage9SlicedMaterial";this.defaultScreenSpaceImage9SlicedMaterial.nineSlicedMode=SPRITE_RENDERMODE_SLICED;this.defaultScreenSpaceImage9SlicedMaterial.depthTest=false;this.defaultScreenSpaceImage9SlicedMaterial.update();this.defaultImageMaterials.push(this.defaultScreenSpaceImage9SlicedMaterial);}return this.defaultScreenSpaceImage9SlicedMaterial}else if(nineSliceTiled){if(!this.defaultScreenSpaceImage9TiledMaterial){this.defaultScreenSpaceImage9TiledMaterial=this._createBaseImageMaterial();this.defaultScreenSpaceImage9TiledMaterial.name="defaultScreenSpaceImage9TiledMaterial";this.defaultScreenSpaceImage9TiledMaterial.nineSlicedMode=SPRITE_RENDERMODE_TILED;this.defaultScreenSpaceImage9TiledMaterial.depthTest=false;this.defaultScreenSpaceImage9TiledMaterial.update();this.defaultImageMaterials.push(this.defaultScreenSpaceImage9TiledMaterial);}return this.defaultScreenSpaceImage9TiledMaterial}else {if(!this.defaultScreenSpaceImageMaterial){this.defaultScreenSpaceImageMaterial=this._createBaseImageMaterial();this.defaultScreenSpaceImageMaterial.name="defaultScreenSpaceImageMaterial";this.defaultScreenSpaceImageMaterial.depthTest=false;this.defaultScreenSpaceImageMaterial.update();this.defaultImageMaterials.push(this.defaultScreenSpaceImageMaterial);}return this.defaultScreenSpaceImageMaterial}}}else {if(mask){if(nineSliced){if(!this.defaultImage9SlicedMaskMaterial){this.defaultImage9SlicedMaskMaterial=this._createBaseImageMaterial();this.defaultImage9SlicedMaskMaterial.name="defaultImage9SlicedMaskMaterial";this.defaultImage9SlicedMaskMaterial.nineSlicedMode=SPRITE_RENDERMODE_SLICED;this.defaultImage9SlicedMaskMaterial.alphaTest=1;this.defaultImage9SlicedMaskMaterial.redWrite=false;this.defaultImage9SlicedMaskMaterial.greenWrite=false;this.defaultImage9SlicedMaskMaterial.blueWrite=false;this.defaultImage9SlicedMaskMaterial.alphaWrite=false;this.defaultImage9SlicedMaskMaterial.update();this.defaultImageMaterials.push(this.defaultImage9SlicedMaskMaterial);}return this.defaultImage9SlicedMaskMaterial}else if(nineSliceTiled){if(!this.defaultImage9TiledMaskMaterial){this.defaultImage9TiledMaskMaterial=this._createBaseImageMaterial();this.defaultImage9TiledMaskMaterial.name="defaultImage9TiledMaskMaterial";this.defaultImage9TiledMaskMaterial.nineSlicedMode=SPRITE_RENDERMODE_TILED;this.defaultImage9TiledMaskMaterial.alphaTest=1;this.defaultImage9TiledMaskMaterial.redWrite=false;this.defaultImage9TiledMaskMaterial.greenWrite=false;this.defaultImage9TiledMaskMaterial.blueWrite=false;this.defaultImage9TiledMaskMaterial.alphaWrite=false;this.defaultImage9TiledMaskMaterial.update();this.defaultImageMaterials.push(this.defaultImage9TiledMaskMaterial);}return this.defaultImage9TiledMaskMaterial}else {if(!this.defaultImageMaskMaterial){this.defaultImageMaskMaterial=this._createBaseImageMaterial();this.defaultImageMaskMaterial.name="defaultImageMaskMaterial";this.defaultImageMaskMaterial.alphaTest=1;this.defaultImageMaskMaterial.redWrite=false;this.defaultImageMaskMaterial.greenWrite=false;this.defaultImageMaskMaterial.blueWrite=false;this.defaultImageMaskMaterial.alphaWrite=false;this.defaultImageMaskMaterial.update();this.defaultImageMaterials.push(this.defaultImageMaskMaterial);}return this.defaultImageMaskMaterial}}else {if(nineSliced){if(!this.defaultImage9SlicedMaterial){this.defaultImage9SlicedMaterial=this._createBaseImageMaterial();this.defaultImage9SlicedMaterial.name="defaultImage9SlicedMaterial";this.defaultImage9SlicedMaterial.nineSlicedMode=SPRITE_RENDERMODE_SLICED;this.defaultImage9SlicedMaterial.update();this.defaultImageMaterials.push(this.defaultImage9SlicedMaterial);}return this.defaultImage9SlicedMaterial}else if(nineSliceTiled){if(!this.defaultImage9TiledMaterial){this.defaultImage9TiledMaterial=this._createBaseImageMaterial();this.defaultImage9TiledMaterial.name="defaultImage9TiledMaterial";this.defaultImage9TiledMaterial.nineSlicedMode=SPRITE_RENDERMODE_TILED;this.defaultImage9TiledMaterial.update();this.defaultImageMaterials.push(this.defaultImage9TiledMaterial);}return this.defaultImage9TiledMaterial}else {if(!this.defaultImageMaterial){this.defaultImageMaterial=this._createBaseImageMaterial();this.defaultImageMaterial.name="defaultImageMaterial";this.defaultImageMaterial.update();this.defaultImageMaterials.push(this.defaultImageMaterial);}return this.defaultImageMaterial}}}}registerUnicodeConverter(func){this._unicodeConverter=func;}registerRtlReorder(func){this._rtlReorder=func;}getUnicodeConverter(){return this._unicodeConverter}getRtlReorder(){return this._rtlReorder}constructor(app){super(app);this.id="element";this.ComponentType=ElementComponent;this.DataType=ElementComponentData;this.schema=_schema$g;this._unicodeConverter=null;this._rtlReorder=null;this._defaultTexture=new Texture(app.graphicsDevice,{width:1,height:1,format:PIXELFORMAT_RGBA8,name:"element-system"});const pixels=this._defaultTexture.lock();const pixelData=new Uint8Array(4);pixelData[0]=255;pixelData[1]=255;pixelData[2]=255;pixelData[3]=255;pixels.set(pixelData);this._defaultTexture.unlock();this.defaultImageMaterial=null;this.defaultImage9SlicedMaterial=null;this.defaultImage9TiledMaterial=null;this.defaultImageMaskMaterial=null;this.defaultImage9SlicedMaskMaterial=null;this.defaultImage9TiledMaskMaterial=null;this.defaultScreenSpaceImageMaterial=null;this.defaultScreenSpaceImage9SlicedMaterial=null;this.defaultScreenSpaceImage9TiledMaterial=null;this.defaultScreenSpaceImageMask9SlicedMaterial=null;this.defaultScreenSpaceImageMask9TiledMaterial=null;this.defaultScreenSpaceImageMaskMaterial=null;this._defaultTextMaterials={};this.defaultImageMaterials=[];this.on("add",this.onAddComponent,this);this.on("beforeremove",this.onRemoveComponent,this);}}const MOTION_FREE="free";const MOTION_LIMITED="limited";const MOTION_LOCKED="locked";const properties$1=["angularDampingX","angularDampingY","angularDampingZ","angularEquilibriumX","angularEquilibriumY","angularEquilibriumZ","angularLimitsX","angularLimitsY","angularLimitsZ","angularMotionX","angularMotionY","angularMotionZ","angularSpringX","angularSpringY","angularSpringZ","angularStiffnessX","angularStiffnessY","angularStiffnessZ","breakForce","enableCollision","enabled","entityA","entityB","linearDampingX","linearDampingY","linearDampingZ","linearEquilibriumX","linearEquilibriumY","linearEquilibriumZ","linearLimitsX","linearLimitsY","linearLimitsZ","linearMotionX","linearMotionY","linearMotionZ","linearSpringX","linearSpringY","linearSpringZ","linearStiffnessX","linearStiffnessY","linearStiffnessZ"];class JointComponent extends Component{set entityA(body){this._destroyConstraint();this._entityA=body;this._createConstraint();}get entityA(){return this._entityA}set entityB(body){this._destroyConstraint();this._entityB=body;this._createConstraint();}get entityB(){return this._entityB}set breakForce(force){if(this._constraint&&this._breakForce!==force){this._constraint.setBreakingImpulseThreshold(force);this._breakForce=force;}}get breakForce(){return this._breakForce}set enableCollision(enableCollision){this._destroyConstraint();this._enableCollision=enableCollision;this._createConstraint();}get enableCollision(){return this._enableCollision}set angularLimitsX(limits){if(!this._angularLimitsX.equals(limits)){this._angularLimitsX.copy(limits);this._updateAngularLimits();}}get angularLimitsX(){return this._angularLimitsX}set angularMotionX(value){if(this._angularMotionX!==value){this._angularMotionX=value;this._updateAngularLimits();}}get angularMotionX(){return this._angularMotionX}set angularLimitsY(limits){if(!this._angularLimitsY.equals(limits)){this._angularLimitsY.copy(limits);this._updateAngularLimits();}}get angularLimitsY(){return this._angularLimitsY}set angularMotionY(value){if(this._angularMotionY!==value){this._angularMotionY=value;this._updateAngularLimits();}}get angularMotionY(){return this._angularMotionY}set angularLimitsZ(limits){if(!this._angularLimitsZ.equals(limits)){this._angularLimitsZ.copy(limits);this._updateAngularLimits();}}get angularLimitsZ(){return this._angularLimitsZ}set angularMotionZ(value){if(this._angularMotionZ!==value){this._angularMotionZ=value;this._updateAngularLimits();}}get angularMotionZ(){return this._angularMotionZ}set linearLimitsX(limits){if(!this._linearLimitsX.equals(limits)){this._linearLimitsX.copy(limits);this._updateLinearLimits();}}get linearLimitsX(){return this._linearLimitsX}set linearMotionX(value){if(this._linearMotionX!==value){this._linearMotionX=value;this._updateLinearLimits();}}get linearMotionX(){return this._linearMotionX}set linearLimitsY(limits){if(!this._linearLimitsY.equals(limits)){this._linearLimitsY.copy(limits);this._updateLinearLimits();}}get linearLimitsY(){return this._linearLimitsY}set linearMotionY(value){if(this._linearMotionY!==value){this._linearMotionY=value;this._updateLinearLimits();}}get linearMotionY(){return this._linearMotionY}set linearLimitsZ(limits){if(!this._linearLimitsZ.equals(limits)){this._linearLimitsZ.copy(limits);this._updateLinearLimits();}}get linearLimitsZ(){return this._linearLimitsZ}set linearMotionZ(value){if(this._linearMotionZ!==value){this._linearMotionZ=value;this._updateLinearLimits();}}get linearMotionZ(){return this._linearMotionZ}_convertTransform(pcTransform,ammoTransform){const pos=pcTransform.getTranslation();const rot=new Quat;rot.setFromMat4(pcTransform);const ammoVec=new Ammo.btVector3(pos.x,pos.y,pos.z);const ammoQuat=new Ammo.btQuaternion(rot.x,rot.y,rot.z,rot.w);ammoTransform.setOrigin(ammoVec);ammoTransform.setRotation(ammoQuat);Ammo.destroy(ammoVec);Ammo.destroy(ammoQuat);}_updateAngularLimits(){const constraint=this._constraint;if(constraint){let lx,ly,lz,ux,uy,uz;if(this._angularMotionX===MOTION_LIMITED){lx=this._angularLimitsX.x*math.DEG_TO_RAD;ux=this._angularLimitsX.y*math.DEG_TO_RAD;}else if(this._angularMotionX===MOTION_FREE){lx=1;ux=0;}else {lx=ux=0;}if(this._angularMotionY===MOTION_LIMITED){ly=this._angularLimitsY.x*math.DEG_TO_RAD;uy=this._angularLimitsY.y*math.DEG_TO_RAD;}else if(this._angularMotionY===MOTION_FREE){ly=1;uy=0;}else {ly=uy=0;}if(this._angularMotionZ===MOTION_LIMITED){lz=this._angularLimitsZ.x*math.DEG_TO_RAD;uz=this._angularLimitsZ.y*math.DEG_TO_RAD;}else if(this._angularMotionZ===MOTION_FREE){lz=1;uz=0;}else {lz=uz=0;}const limits=new Ammo.btVector3(lx,ly,lz);constraint.setAngularLowerLimit(limits);limits.setValue(ux,uy,uz);constraint.setAngularUpperLimit(limits);Ammo.destroy(limits);}}_updateLinearLimits(){const constraint=this._constraint;if(constraint){let lx,ly,lz,ux,uy,uz;if(this._linearMotionX===MOTION_LIMITED){lx=this._linearLimitsX.x;ux=this._linearLimitsX.y;}else if(this._linearMotionX===MOTION_FREE){lx=1;ux=0;}else {lx=ux=0;}if(this._linearMotionY===MOTION_LIMITED){ly=this._linearLimitsY.x;uy=this._linearLimitsY.y;}else if(this._linearMotionY===MOTION_FREE){ly=1;uy=0;}else {ly=uy=0;}if(this._linearMotionZ===MOTION_LIMITED){lz=this._linearLimitsZ.x;uz=this._linearLimitsZ.y;}else if(this._linearMotionZ===MOTION_FREE){lz=1;uz=0;}else {lz=uz=0;}const limits=new Ammo.btVector3(lx,ly,lz);constraint.setLinearLowerLimit(limits);limits.setValue(ux,uy,uz);constraint.setLinearUpperLimit(limits);Ammo.destroy(limits);}}_createConstraint(){if(this._entityA&&this._entityA.rigidbody){this._destroyConstraint();const mat=new Mat4;const bodyA=this._entityA.rigidbody.body;bodyA.activate();const jointWtm=this.entity.getWorldTransform();const entityAWtm=this._entityA.getWorldTransform();const invEntityAWtm=entityAWtm.clone().invert();mat.mul2(invEntityAWtm,jointWtm);const frameA=new Ammo.btTransform;this._convertTransform(mat,frameA);if(this._entityB&&this._entityB.rigidbody){const bodyB=this._entityB.rigidbody.body;bodyB.activate();const entityBWtm=this._entityB.getWorldTransform();const invEntityBWtm=entityBWtm.clone().invert();mat.mul2(invEntityBWtm,jointWtm);const frameB=new Ammo.btTransform;this._convertTransform(mat,frameB);this._constraint=new Ammo.btGeneric6DofSpringConstraint(bodyA,bodyB,frameA,frameB,!this._enableCollision);Ammo.destroy(frameB);}else {this._constraint=new Ammo.btGeneric6DofSpringConstraint(bodyA,frameA,!this._enableCollision);}Ammo.destroy(frameA);const axis=["X","Y","Z","X","Y","Z"];for(let i=0;i<6;i++){const type=i<3?"_linear":"_angular";this._constraint.enableSpring(i,this[`${type}Spring${axis[i]}`]);this._constraint.setDamping(i,this[`${type}Damping${axis[i]}`]);this._constraint.setEquilibriumPoint(i,this[`${type}Equilibrium${axis[i]}`]);this._constraint.setStiffness(i,this[`${type}Stiffness${axis[i]}`]);}this._constraint.setBreakingImpulseThreshold(this._breakForce);this._updateLinearLimits();this._updateAngularLimits();const app=this.system.app;const dynamicsWorld=app.systems.rigidbody.dynamicsWorld;dynamicsWorld.addConstraint(this._constraint,!this._enableCollision);}}_destroyConstraint(){if(this._constraint){const app=this.system.app;const dynamicsWorld=app.systems.rigidbody.dynamicsWorld;dynamicsWorld.removeConstraint(this._constraint);Ammo.destroy(this._constraint);this._constraint=null;}}initFromData(data){for(const prop of properties$1){if(data.hasOwnProperty(prop)){if(data[prop]instanceof Vec2){this[`_${prop}`].copy(data[prop]);}else {this[`_${prop}`]=data[prop];}}}this._createConstraint();}onEnable(){this._createConstraint();}onDisable(){this._destroyConstraint();}_onSetEnabled(prop,old,value){}_onBeforeRemove(){this.fire("remove");}constructor(system,entity){super(system,entity);this._constraint=null;this._entityA=null;this._entityB=null;this._breakForce=34e37;this._enableCollision=true;this._linearMotionX=MOTION_LOCKED;this._linearLimitsX=new Vec2(0,0);this._linearSpringX=false;this._linearStiffnessX=0;this._linearDampingX=1;this._linearEquilibriumX=0;this._linearMotionY=MOTION_LOCKED;this._linearLimitsY=new Vec2(0,0);this._linearSpringY=false;this._linearStiffnessY=0;this._linearDampingY=1;this._linearEquilibriumY=0;this._linearMotionZ=MOTION_LOCKED;this._linearLimitsZ=new Vec2(0,0);this._linearSpringZ=false;this._linearStiffnessZ=0;this._linearDampingZ=1;this._linearEquilibriumZ=0;this._angularMotionX=MOTION_LOCKED;this._angularLimitsX=new Vec2(0,0);this._angularSpringX=false;this._angularStiffnessX=0;this._angularDampingX=1;this._angularEquilibriumX=0;this._angularMotionY=MOTION_LOCKED;this._angularLimitsY=new Vec2(0,0);this._angularSpringY=false;this._angularStiffnessY=0;this._angularDampingY=1;this._angularEquilibriumY=0;this._angularMotionZ=MOTION_LOCKED;this._angularLimitsZ=new Vec2(0,0);this._angularSpringZ=false;this._angularEquilibriumZ=0;this._angularDampingZ=1;this._angularStiffnessZ=0;this.on("set_enabled",this._onSetEnabled,this);}}const functionMap={Damping:"setDamping",Equilibrium:"setEquilibriumPoint",Spring:"enableSpring",Stiffness:"setStiffness"};["linear","angular"].forEach(type=>{["Damping","Equilibrium","Spring","Stiffness"].forEach(name=>{["X","Y","Z"].forEach(axis=>{const prop=type+name+axis;const propInternal=`_${prop}`;let index=type==="linear"?0:3;if(axis==="Y")index+=1;if(axis==="Z")index+=2;Object.defineProperty(JointComponent.prototype,prop,{get:function(){return this[propInternal]},set:function(value){if(this[propInternal]!==value){this[propInternal]=value;this._constraint[functionMap[name]](index,value);}}});});});});class JointComponentData{constructor(){this.enabled=true;}}const _schema$f=["enabled"];class JointComponentSystem extends ComponentSystem{initializeComponentData(component,data,properties){component.initFromData(data);}constructor(app){super(app);this.id="joint";this.app=app;this.ComponentType=JointComponent;this.DataType=JointComponentData;this.schema=_schema$f;}}Component._buildAccessors(JointComponent.prototype,_schema$f);class LayoutChildComponent extends Component{set minWidth(value){if(value!==this._minWidth){this._minWidth=value;this.fire("resize");}}get minWidth(){return this._minWidth}set minHeight(value){if(value!==this._minHeight){this._minHeight=value;this.fire("resize");}}get minHeight(){return this._minHeight}set maxWidth(value){if(value!==this._maxWidth){this._maxWidth=value;this.fire("resize");}}get maxWidth(){return this._maxWidth}set maxHeight(value){if(value!==this._maxHeight){this._maxHeight=value;this.fire("resize");}}get maxHeight(){return this._maxHeight}set fitWidthProportion(value){if(value!==this._fitWidthProportion){this._fitWidthProportion=value;this.fire("resize");}}get fitWidthProportion(){return this._fitWidthProportion}set fitHeightProportion(value){if(value!==this._fitHeightProportion){this._fitHeightProportion=value;this.fire("resize");}}get fitHeightProportion(){return this._fitHeightProportion}set excludeFromLayout(value){if(value!==this._excludeFromLayout){this._excludeFromLayout=value;this.fire("resize");}}get excludeFromLayout(){return this._excludeFromLayout}constructor(system,entity){super(system,entity);this._minWidth=0;this._minHeight=0;this._maxWidth=null;this._maxHeight=null;this._fitWidthProportion=0;this._fitHeightProportion=0;this._excludeFromLayout=false;}}class LayoutChildComponentData{constructor(){this.enabled=true;}}const _schema$e=["enabled"];class LayoutChildComponentSystem extends ComponentSystem{initializeComponentData(component,data,properties){if(data.enabled!==undefined)component.enabled=data.enabled;if(data.minWidth!==undefined)component.minWidth=data.minWidth;if(data.minHeight!==undefined)component.minHeight=data.minHeight;if(data.maxWidth!==undefined)component.maxWidth=data.maxWidth;if(data.maxHeight!==undefined)component.maxHeight=data.maxHeight;if(data.fitWidthProportion!==undefined)component.fitWidthProportion=data.fitWidthProportion;if(data.fitHeightProportion!==undefined)component.fitHeightProportion=data.fitHeightProportion;if(data.excludeFromLayout!==undefined)component.excludeFromLayout=data.excludeFromLayout;super.initializeComponentData(component,data,properties);}cloneComponent(entity,clone){const layoutChild=entity.layoutchild;return this.addComponent(clone,{enabled:layoutChild.enabled,minWidth:layoutChild.minWidth,minHeight:layoutChild.minHeight,maxWidth:layoutChild.maxWidth,maxHeight:layoutChild.maxHeight,fitWidthProportion:layoutChild.fitWidthProportion,fitHeightProportion:layoutChild.fitHeightProportion,excludeFromLayout:layoutChild.excludeFromLayout})}constructor(app){super(app);this.id="layoutchild";this.ComponentType=LayoutChildComponent;this.DataType=LayoutChildComponentData;this.schema=_schema$e;}}Component._buildAccessors(LayoutChildComponent.prototype,_schema$e);const FITTING_NONE=0;const FITTING_STRETCH=1;const FITTING_SHRINK=2;const FITTING_BOTH=3;const AXIS_MAPPINGS={};AXIS_MAPPINGS[ORIENTATION_HORIZONTAL]={axis:"x",size:"width",calculatedSize:"calculatedWidth",minSize:"minWidth",maxSize:"maxWidth",fitting:"widthFitting",fittingProportion:"fitWidthProportion"};AXIS_MAPPINGS[ORIENTATION_VERTICAL]={axis:"y",size:"height",calculatedSize:"calculatedHeight",minSize:"minHeight",maxSize:"maxHeight",fitting:"heightFitting",fittingProportion:"fitHeightProportion"};const OPPOSITE_ORIENTATION={};OPPOSITE_ORIENTATION[ORIENTATION_HORIZONTAL]=ORIENTATION_VERTICAL;OPPOSITE_ORIENTATION[ORIENTATION_VERTICAL]=ORIENTATION_HORIZONTAL;const PROPERTY_DEFAULTS={minWidth:0,minHeight:0,maxWidth:Number.POSITIVE_INFINITY,maxHeight:Number.POSITIVE_INFINITY,width:null,height:null,fitWidthProportion:0,fitHeightProportion:0};const FITTING_ACTION={NONE:"NONE",APPLY_STRETCHING:"APPLY_STRETCHING",APPLY_SHRINKING:"APPLY_SHRINKING"};const availableSpace=new Vec2;function createCalculator(orientation){let options;const a=AXIS_MAPPINGS[orientation];const b=AXIS_MAPPINGS[OPPOSITE_ORIENTATION[orientation]];function minExtentA(element,size){return -size[a.size]*element.pivot[a.axis]}function minExtentB(element,size){return -size[b.size]*element.pivot[b.axis]}function maxExtentA(element,size){return size[a.size]*(1-element.pivot[a.axis])}function calculateAll(allElements,layoutOptions){allElements=allElements.filter(shouldIncludeInLayout);options=layoutOptions;availableSpace.x=options.containerSize.x-options.padding.x-options.padding.z;availableSpace.y=options.containerSize.y-options.padding.y-options.padding.w;resetAnchors(allElements);const lines=reverseLinesIfRequired(splitLines(allElements));const sizes=calculateSizesOnAxisB(lines,calculateSizesOnAxisA(lines));const positions=calculateBasePositions(lines,sizes);applyAlignmentAndPadding(lines,sizes,positions);applySizesAndPositions(lines,sizes,positions);return createLayoutInfo(lines)}function shouldIncludeInLayout(element){const layoutChildComponent=element.entity.layoutchild;return !layoutChildComponent||!layoutChildComponent.enabled||!layoutChildComponent.excludeFromLayout}function resetAnchors(allElements){for(let i=0;i<allElements.length;++i){const element=allElements[i];const anchor=element.anchor;if(anchor.x!==0||anchor.y!==0||anchor.z!==0||anchor.w!==0){element.anchor=Vec4.ZERO;}}}function splitLines(allElements){if(!options.wrap){return [allElements]}const lines=[[]];const sizes=getElementSizeProperties(allElements);let runningSize=0;const allowOverrun=options[a.fitting]===FITTING_SHRINK;for(let i=0;i<allElements.length;++i){if(lines[lines.length-1].length>0){runningSize+=options.spacing[a.axis];}const idealElementSize=sizes[i][a.size];runningSize+=idealElementSize;if(!allowOverrun&&runningSize>availableSpace[a.axis]&&lines[lines.length-1].length!==0){runningSize=idealElementSize;lines.push([]);}lines[lines.length-1].push(allElements[i]);if(allowOverrun&&runningSize>availableSpace[a.axis]&&i!==allElements.length-1){runningSize=0;lines.push([]);}}return lines}function reverseLinesIfRequired(lines){const reverseAxisA=options.orientation===ORIENTATION_HORIZONTAL&&options.reverseX||options.orientation===ORIENTATION_VERTICAL&&options.reverseY;const reverseAxisB=options.orientation===ORIENTATION_HORIZONTAL&&options.reverseY||options.orientation===ORIENTATION_VERTICAL&&options.reverseX;if(reverseAxisA){for(let lineIndex=0;lineIndex<lines.length;++lineIndex){if(reverseAxisA){lines[lineIndex].reverse();}}}if(reverseAxisB){lines.reverse();}return lines}function calculateSizesOnAxisA(lines){const sizesAllLines=[];for(let lineIndex=0;lineIndex<lines.length;++lineIndex){const line=lines[lineIndex];const sizesThisLine=getElementSizeProperties(line);const idealRequiredSpace=calculateTotalSpace(sizesThisLine,a);const fittingAction=determineFittingAction(options[a.fitting],idealRequiredSpace,availableSpace[a.axis]);if(fittingAction===FITTING_ACTION.APPLY_STRETCHING){stretchSizesToFitContainer(sizesThisLine,idealRequiredSpace,a);}else if(fittingAction===FITTING_ACTION.APPLY_SHRINKING){shrinkSizesToFitContainer(sizesThisLine,idealRequiredSpace,a);}sizesAllLines.push(sizesThisLine);}return sizesAllLines}function calculateSizesOnAxisB(lines,sizesAllLines){const largestElementsForEachLine=[];const largestSizesForEachLine=[];for(let lineIndex=0;lineIndex<lines.length;++lineIndex){const line=lines[lineIndex];line.largestElement=null;line.largestSize={width:Number.NEGATIVE_INFINITY,height:Number.NEGATIVE_INFINITY};for(let elementIndex=0;elementIndex<line.length;++elementIndex){const sizesThisElement=sizesAllLines[lineIndex][elementIndex];if(sizesThisElement[b.size]>line.largestSize[b.size]){line.largestElement=line[elementIndex];line.largestSize=sizesThisElement;}}largestElementsForEachLine.push(line.largestElement);largestSizesForEachLine.push(line.largestSize);}const idealRequiredSpace=calculateTotalSpace(largestSizesForEachLine,b);const fittingAction=determineFittingAction(options[b.fitting],idealRequiredSpace,availableSpace[b.axis]);if(fittingAction===FITTING_ACTION.APPLY_STRETCHING){stretchSizesToFitContainer(largestSizesForEachLine,idealRequiredSpace,b);}else if(fittingAction===FITTING_ACTION.APPLY_SHRINKING){shrinkSizesToFitContainer(largestSizesForEachLine,idealRequiredSpace,b);}for(let lineIndex=0;lineIndex<lines.length;++lineIndex){const line=lines[lineIndex];for(let elementIndex=0;elementIndex<line.length;++elementIndex){const sizesForThisElement=sizesAllLines[lineIndex][elementIndex];const currentSize=sizesForThisElement[b.size];const availableSize=lines.length===1?availableSpace[b.axis]:line.largestSize[b.size];const elementFittingAction=determineFittingAction(options[b.fitting],currentSize,availableSize);if(elementFittingAction===FITTING_ACTION.APPLY_STRETCHING){sizesForThisElement[b.size]=Math.min(availableSize,sizesForThisElement[b.maxSize]);}else if(elementFittingAction===FITTING_ACTION.APPLY_SHRINKING){sizesForThisElement[b.size]=Math.max(availableSize,sizesForThisElement[b.minSize]);}}}return sizesAllLines}function determineFittingAction(fittingMode,currentSize,availableSize){switch(fittingMode){case FITTING_NONE:return FITTING_ACTION.NONE;case FITTING_STRETCH:if(currentSize<availableSize){return FITTING_ACTION.APPLY_STRETCHING}return FITTING_ACTION.NONE;case FITTING_SHRINK:if(currentSize>=availableSize){return FITTING_ACTION.APPLY_SHRINKING}return FITTING_ACTION.NONE;case FITTING_BOTH:if(currentSize<availableSize){return FITTING_ACTION.APPLY_STRETCHING}return FITTING_ACTION.APPLY_SHRINKING;default:throw new Error(`Unrecognized fitting mode: ${fittingMode}`)}}function calculateTotalSpace(sizes,axis){const totalSizes=sumValues(sizes,axis.size);const totalSpacing=(sizes.length-1)*options.spacing[axis.axis];return totalSizes+totalSpacing}function stretchSizesToFitContainer(sizesThisLine,idealRequiredSpace,axis){const ascendingMaxSizeOrder=getTraversalOrder(sizesThisLine,axis.maxSize);const fittingProportions=getNormalizedValues(sizesThisLine,axis.fittingProportion);const fittingProportionSums=createSumArray(fittingProportions,ascendingMaxSizeOrder);let remainingUndershoot=availableSpace[axis.axis]-idealRequiredSpace;for(let i=0;i<sizesThisLine.length;++i){const index=ascendingMaxSizeOrder[i];const targetIncrease=calculateAdjustment(index,remainingUndershoot,fittingProportions,fittingProportionSums);const targetSize=sizesThisLine[index][axis.size]+targetIncrease;const maxSize=sizesThisLine[index][axis.maxSize];const actualSize=Math.min(targetSize,maxSize);sizesThisLine[index][axis.size]=actualSize;const actualIncrease=Math.max(targetSize-actualSize,0);const appliedIncrease=targetIncrease-actualIncrease;remainingUndershoot-=appliedIncrease;}}function shrinkSizesToFitContainer(sizesThisLine,idealRequiredSpace,axis){const descendingMinSizeOrder=getTraversalOrder(sizesThisLine,axis.minSize,true);const fittingProportions=getNormalizedValues(sizesThisLine,axis.fittingProportion);const inverseFittingProportions=invertNormalizedValues(fittingProportions);const inverseFittingProportionSums=createSumArray(inverseFittingProportions,descendingMinSizeOrder);let remainingOvershoot=idealRequiredSpace-availableSpace[axis.axis];for(let i=0;i<sizesThisLine.length;++i){const index=descendingMinSizeOrder[i];const targetReduction=calculateAdjustment(index,remainingOvershoot,inverseFittingProportions,inverseFittingProportionSums);const targetSize=sizesThisLine[index][axis.size]-targetReduction;const minSize=sizesThisLine[index][axis.minSize];const actualSize=Math.max(targetSize,minSize);sizesThisLine[index][axis.size]=actualSize;const actualReduction=Math.max(actualSize-targetSize,0);const appliedReduction=targetReduction-actualReduction;remainingOvershoot-=appliedReduction;}}function calculateAdjustment(index,remainingAdjustment,fittingProportions,fittingProportionSums){const proportion=fittingProportions[index];const sumOfRemainingProportions=fittingProportionSums[index];if(Math.abs(proportion)<1e-5&&Math.abs(sumOfRemainingProportions)<1e-5){return remainingAdjustment}return remainingAdjustment*proportion/sumOfRemainingProportions}function calculateBasePositions(lines,sizes){const cursor={};cursor[a.axis]=0;cursor[b.axis]=0;lines[a.size]=Number.NEGATIVE_INFINITY;const positionsAllLines=[];for(let lineIndex=0;lineIndex<lines.length;++lineIndex){const line=lines[lineIndex];if(line.length===0){positionsAllLines.push([]);continue}const positionsThisLine=[];const sizesThisLine=sizes[lineIndex];for(let elementIndex=0;elementIndex<line.length;++elementIndex){const element=line[elementIndex];const sizesThisElement=sizesThisLine[elementIndex];cursor[b.axis]-=minExtentB(element,sizesThisElement);cursor[a.axis]-=minExtentA(element,sizesThisElement);positionsThisLine[elementIndex]={};positionsThisLine[elementIndex][a.axis]=cursor[a.axis];positionsThisLine[elementIndex][b.axis]=cursor[b.axis];cursor[b.axis]+=minExtentB(element,sizesThisElement);cursor[a.axis]+=maxExtentA(element,sizesThisElement)+options.spacing[a.axis];}line[a.size]=cursor[a.axis]-options.spacing[a.axis];line[b.size]=line.largestSize[b.size];lines[a.size]=Math.max(lines[a.size],line[a.size]);cursor[a.axis]=0;cursor[b.axis]+=line[b.size]+options.spacing[b.axis];positionsAllLines.push(positionsThisLine);}lines[b.size]=cursor[b.axis]-options.spacing[b.axis];return positionsAllLines}function applyAlignmentAndPadding(lines,sizes,positions){const alignmentA=options.alignment[a.axis];const alignmentB=options.alignment[b.axis];const paddingA=options.padding[a.axis];const paddingB=options.padding[b.axis];for(let lineIndex=0;lineIndex<lines.length;++lineIndex){const line=lines[lineIndex];const sizesThisLine=sizes[lineIndex];const positionsThisLine=positions[lineIndex];const axisAOffset=(availableSpace[a.axis]-line[a.size])*alignmentA+paddingA;const axisBOffset=(availableSpace[b.axis]-lines[b.size])*alignmentB+paddingB;for(let elementIndex=0;elementIndex<line.length;++elementIndex){const withinLineAxisBOffset=(line[b.size]-sizesThisLine[elementIndex][b.size])*options.alignment[b.axis];positionsThisLine[elementIndex][a.axis]+=axisAOffset;positionsThisLine[elementIndex][b.axis]+=axisBOffset+withinLineAxisBOffset;}}}function applySizesAndPositions(lines,sizes,positions){for(let lineIndex=0;lineIndex<lines.length;++lineIndex){const line=lines[lineIndex];const sizesThisLine=sizes[lineIndex];const positionsThisLine=positions[lineIndex];for(let elementIndex=0;elementIndex<line.length;++elementIndex){const element=line[elementIndex];element[a.calculatedSize]=sizesThisLine[elementIndex][a.size];element[b.calculatedSize]=sizesThisLine[elementIndex][b.size];if(options.orientation===ORIENTATION_HORIZONTAL){element.entity.setLocalPosition(positionsThisLine[elementIndex][a.axis],positionsThisLine[elementIndex][b.axis],element.entity.getLocalPosition().z);}else {element.entity.setLocalPosition(positionsThisLine[elementIndex][b.axis],positionsThisLine[elementIndex][a.axis],element.entity.getLocalPosition().z);}}}}function createLayoutInfo(lines){const layoutWidth=lines.width;const layoutHeight=lines.height;const xOffset=(availableSpace.x-layoutWidth)*options.alignment.x+options.padding.x;const yOffset=(availableSpace.y-layoutHeight)*options.alignment.y+options.padding.y;return {bounds:new Vec4(xOffset,yOffset,layoutWidth,layoutHeight)}}function getElementSizeProperties(elements){const sizeProperties=[];for(let i=0;i<elements.length;++i){const element=elements[i];const minWidth=Math.max(getProperty(element,"minWidth"),0);const minHeight=Math.max(getProperty(element,"minHeight"),0);const maxWidth=Math.max(getProperty(element,"maxWidth"),minWidth);const maxHeight=Math.max(getProperty(element,"maxHeight"),minHeight);const width=clamp(getProperty(element,"width"),minWidth,maxWidth);const height=clamp(getProperty(element,"height"),minHeight,maxHeight);const fitWidthProportion=getProperty(element,"fitWidthProportion");const fitHeightProportion=getProperty(element,"fitHeightProportion");sizeProperties.push({minWidth:minWidth,minHeight:minHeight,maxWidth:maxWidth,maxHeight:maxHeight,width:width,height:height,fitWidthProportion:fitWidthProportion,fitHeightProportion:fitHeightProportion});}return sizeProperties}function getProperty(element,propertyName){const layoutChildComponent=element.entity.layoutchild;if(layoutChildComponent&&layoutChildComponent.enabled&&layoutChildComponent[propertyName]!==undefined&&layoutChildComponent[propertyName]!==null){return layoutChildComponent[propertyName]}else if(element[propertyName]!==undefined){return element[propertyName]}return PROPERTY_DEFAULTS[propertyName]}function clamp(value,min,max){return Math.min(Math.max(value,min),max)}function sumValues(items,propertyName){return items.reduce((accumulator,current)=>{return accumulator+current[propertyName]},0)}function getNormalizedValues(items,propertyName){const sum=sumValues(items,propertyName);const normalizedValues=[];const numItems=items.length;if(sum===0){for(let i=0;i<numItems;++i){normalizedValues.push(1/numItems);}}else {for(let i=0;i<numItems;++i){normalizedValues.push(items[i][propertyName]/sum);}}return normalizedValues}function invertNormalizedValues(values){if(values.length===1){return [1]}const invertedValues=[];const numValues=values.length;for(let i=0;i<numValues;++i){invertedValues.push((1-values[i])/(numValues-1));}return invertedValues}function getTraversalOrder(items,orderBy,descending){items.forEach(assignIndex);return items.slice().sort((itemA,itemB)=>{return descending?itemB[orderBy]-itemA[orderBy]:itemA[orderBy]-itemB[orderBy]}).map(getIndex)}function assignIndex(item,index){item.index=index;}function getIndex(item){return item.index}function createSumArray(values,order){const sumArray=[];sumArray[order[values.length-1]]=values[order[values.length-1]];for(let i=values.length-2;i>=0;--i){sumArray[order[i]]=sumArray[order[i+1]]+values[order[i]];}return sumArray}return calculateAll}const CALCULATE_FNS={};CALCULATE_FNS[ORIENTATION_HORIZONTAL]=createCalculator(ORIENTATION_HORIZONTAL);CALCULATE_FNS[ORIENTATION_VERTICAL]=createCalculator(ORIENTATION_VERTICAL);class LayoutCalculator{calculateLayout(elements,options){const calculateFn=CALCULATE_FNS[options.orientation];if(!calculateFn){throw new Error(`Unrecognized orientation value: ${options.orientation}`)}else {return calculateFn(elements,options)}}}function getElement(entity){return entity.element}function isEnabledAndHasEnabledElement(entity){return entity.enabled&&entity.element&&entity.element.enabled}class LayoutGroupComponent extends Component{set orientation(value){if(value!==this._orientation){this._orientation=value;this._scheduleReflow();}}get orientation(){return this._orientation}set reverseX(value){if(value!==this._reverseX){this._reverseX=value;this._scheduleReflow();}}get reverseX(){return this._reverseX}set reverseY(value){if(value!==this._reverseY){this._reverseY=value;this._scheduleReflow();}}get reverseY(){return this._reverseY}set alignment(value){if(!value.equals(this._alignment)){this._alignment.copy(value);this._scheduleReflow();}}get alignment(){return this._alignment}set padding(value){if(!value.equals(this._padding)){this._padding.copy(value);this._scheduleReflow();}}get padding(){return this._padding}set spacing(value){if(!value.equals(this._spacing)){this._spacing.copy(value);this._scheduleReflow();}}get spacing(){return this._spacing}set widthFitting(value){if(value!==this._widthFitting){this._widthFitting=value;this._scheduleReflow();}}get widthFitting(){return this._widthFitting}set heightFitting(value){if(value!==this._heightFitting){this._heightFitting=value;this._scheduleReflow();}}get heightFitting(){return this._heightFitting}set wrap(value){if(value!==this._wrap){this._wrap=value;this._scheduleReflow();}}get wrap(){return this._wrap}_isSelfOrChild(entity){return entity===this.entity||this.entity.children.indexOf(entity)!==-1}_listenForReflowEvents(target,onOff){if(target.element){target.element[onOff]("enableelement",this._scheduleReflow,this);target.element[onOff]("disableelement",this._scheduleReflow,this);target.element[onOff]("resize",this._scheduleReflow,this);target.element[onOff]("set:pivot",this._scheduleReflow,this);}if(target.layoutchild){target.layoutchild[onOff]("set_enabled",this._scheduleReflow,this);target.layoutchild[onOff]("resize",this._scheduleReflow,this);}}_onElementOrLayoutComponentAdd(entity){if(this._isSelfOrChild(entity)){this._listenForReflowEvents(entity,"on");this._scheduleReflow();}}_onElementOrLayoutComponentRemove(entity){if(this._isSelfOrChild(entity)){this._listenForReflowEvents(entity,"off");this._scheduleReflow();}}_onChildInsert(child){this._listenForReflowEvents(child,"on");this._scheduleReflow();}_onChildRemove(child){this._listenForReflowEvents(child,"off");this._scheduleReflow();}_scheduleReflow(){if(this.enabled&&this.entity&&this.entity.enabled&&!this._isPerformingReflow){this.system.scheduleReflow(this);}}reflow(){const container=getElement(this.entity);const elements=this.entity.children.filter(isEnabledAndHasEnabledElement).map(getElement);if(!container||elements.length===0){return}const containerWidth=Math.max(container.calculatedWidth,0);const containerHeight=Math.max(container.calculatedHeight,0);const options={orientation:this._orientation,reverseX:this._reverseX,reverseY:this._reverseY,alignment:this._alignment,padding:this._padding,spacing:this._spacing,widthFitting:this._widthFitting,heightFitting:this._heightFitting,wrap:this._wrap,containerSize:new Vec2(containerWidth,containerHeight)};this._isPerformingReflow=true;const layoutInfo=this._layoutCalculator.calculateLayout(elements,options);this._isPerformingReflow=false;this.fire("reflow",layoutInfo);}onEnable(){this._scheduleReflow();}onRemove(){this.entity.off("childinsert",this._onChildInsert,this);this.entity.off("childremove",this._onChildRemove,this);this._listenForReflowEvents(this.entity,"off");this.entity.children.forEach(child=>{this._listenForReflowEvents(child,"off");});this.system.app.systems.element.off("add",this._onElementOrLayoutComponentAdd,this);this.system.app.systems.element.off("beforeremove",this._onElementOrLayoutComponentRemove,this);this.system.app.systems.layoutchild.off("add",this._onElementOrLayoutComponentAdd,this);this.system.app.systems.layoutchild.off("beforeremove",this._onElementOrLayoutComponentRemove,this);}constructor(system,entity){super(system,entity);this._orientation=ORIENTATION_HORIZONTAL;this._reverseX=false;this._reverseY=true;this._alignment=new Vec2(0,1);this._padding=new Vec4;this._spacing=new Vec2;this._widthFitting=FITTING_NONE;this._heightFitting=FITTING_NONE;this._wrap=false;this._layoutCalculator=new LayoutCalculator;this._listenForReflowEvents(this.entity,"on");this.entity.children.forEach(child=>{this._listenForReflowEvents(child,"on");});this.entity.on("childinsert",this._onChildInsert,this);this.entity.on("childremove",this._onChildRemove,this);system.app.systems.element.on("add",this._onElementOrLayoutComponentAdd,this);system.app.systems.element.on("beforeremove",this._onElementOrLayoutComponentRemove,this);system.app.systems.layoutchild.on("add",this._onElementOrLayoutComponentAdd,this);system.app.systems.layoutchild.on("beforeremove",this._onElementOrLayoutComponentRemove,this);}}class LayoutGroupComponentData{constructor(){this.enabled=true;}}const _schema$d=["enabled"];const MAX_ITERATIONS=100;class LayoutGroupComponentSystem extends ComponentSystem{initializeComponentData(component,data,properties){if(data.enabled!==undefined)component.enabled=data.enabled;if(data.orientation!==undefined)component.orientation=data.orientation;if(data.reverseX!==undefined)component.reverseX=data.reverseX;if(data.reverseY!==undefined)component.reverseY=data.reverseY;if(data.alignment!==undefined){component.alignment=Array.isArray(data.alignment)?new Vec2(data.alignment):data.alignment;}if(data.padding!==undefined){component.padding=Array.isArray(data.padding)?new Vec4(data.padding):data.padding;}if(data.spacing!==undefined){component.spacing=Array.isArray(data.spacing)?new Vec2(data.spacing):data.spacing;}if(data.widthFitting!==undefined)component.widthFitting=data.widthFitting;if(data.heightFitting!==undefined)component.heightFitting=data.heightFitting;if(data.wrap!==undefined)component.wrap=data.wrap;super.initializeComponentData(component,data,properties);}cloneComponent(entity,clone){const layoutGroup=entity.layoutgroup;return this.addComponent(clone,{enabled:layoutGroup.enabled,orientation:layoutGroup.orientation,reverseX:layoutGroup.reverseX,reverseY:layoutGroup.reverseY,alignment:layoutGroup.alignment,padding:layoutGroup.padding,spacing:layoutGroup.spacing,widthFitting:layoutGroup.widthFitting,heightFitting:layoutGroup.heightFitting,wrap:layoutGroup.wrap})}scheduleReflow(component){if(this._reflowQueue.indexOf(component)===-1){this._reflowQueue.push(component);}}_onPostUpdate(){this._processReflowQueue();}_processReflowQueue(){if(this._reflowQueue.length===0){return}let iterationCount=0;while(this._reflowQueue.length>0){const queue=this._reflowQueue.slice();this._reflowQueue.length=0;queue.sort((componentA,componentB)=>{return componentA.entity.graphDepth-componentB.entity.graphDepth});for(let i=0;i<queue.length;++i){queue[i].reflow();}if(++iterationCount>=MAX_ITERATIONS){console.warn("Max reflow iterations limit reached, bailing.");break}}}_onRemoveComponent(entity,component){component.onRemove();}destroy(){super.destroy();this.app.systems.off("postUpdate",this._onPostUpdate,this);}constructor(app){super(app);this.id="layoutgroup";this.ComponentType=LayoutGroupComponent;this.DataType=LayoutGroupComponentData;this.schema=_schema$d;this._reflowQueue=[];this.on("beforeremove",this._onRemoveComponent,this);this.app.systems.on("postUpdate",this._onPostUpdate,this);}}Component._buildAccessors(LayoutGroupComponent.prototype,_schema$d);const shapePrimitives=[];function getShapePrimitive(device,type){let primData=null;for(let i=0;i<shapePrimitives.length;i++){if(shapePrimitives[i].type===type&&shapePrimitives[i].device===device){primData=shapePrimitives[i].primData;}}if(!primData){let mesh,area;switch(type){case"box":mesh=Mesh.fromGeometry(device,new BoxGeometry);area={x:2,y:2,z:2,uv:2/3};break;case"capsule":mesh=Mesh.fromGeometry(device,new CapsuleGeometry({radius:.5,height:2}));area={x:Math.PI*2,y:Math.PI,z:Math.PI*2,uv:1/3+1/3/3*2};break;case"cone":mesh=Mesh.fromGeometry(device,new ConeGeometry({baseRadius:.5,peakRadius:0,height:1}));area={x:2.54,y:2.54,z:2.54,uv:1/3+1/3/3};break;case"cylinder":mesh=Mesh.fromGeometry(device,new CylinderGeometry({radius:.5,height:1}));area={x:Math.PI,y:.79*2,z:Math.PI,uv:1/3+1/3/3*2};break;case"plane":mesh=Mesh.fromGeometry(device,new PlaneGeometry({halfExtents:new Vec2(.5,.5),widthSegments:1,lengthSegments:1}));area={x:0,y:1,z:0,uv:1};break;case"sphere":mesh=Mesh.fromGeometry(device,new SphereGeometry({radius:.5}));area={x:Math.PI,y:Math.PI,z:Math.PI,uv:1};break;case"torus":mesh=Mesh.fromGeometry(device,new TorusGeometry({tubeRadius:.2,ringRadius:.3}));area={x:Math.PI*.5*.5-Math.PI*.1*.1,y:.4,z:.4,uv:1};break;default:throw new Error(`Invalid primitive type: ${type}`)}mesh.incRefCount();primData={mesh:mesh,area:area};shapePrimitives.push({type:type,device:device,primData:primData});}return primData}class ModelComponent extends Component{set meshInstances(value){if(!this._model){return}this._model.meshInstances=value;}get meshInstances(){if(!this._model){return null}return this._model.meshInstances}set customAabb(value){this._customAabb=value;if(this._model){const mi=this._model.meshInstances;if(mi){for(let i=0;i<mi.length;i++){mi[i].setCustomAabb(this._customAabb);}}}}get customAabb(){return this._customAabb}set type(value){if(this._type===value)return;this._area=null;this._type=value;if(value==="asset"){if(this._asset!==null){this._bindModelAsset(this._asset);}else {this.model=null;}}else {const primData=getShapePrimitive(this.system.app.graphicsDevice,value);this._area=primData.area;const mesh=primData.mesh;const node=new GraphNode;const model=new Model;model.graph=node;model.meshInstances=[new MeshInstance(mesh,this._material,node)];this.model=model;this._asset=null;}}get type(){return this._type}set asset(value){const assets=this.system.app.assets;let _id=value;if(value instanceof Asset){_id=value.id;}if(this._asset!==_id){if(this._asset){assets.off(`add:${this._asset}`,this._onModelAssetAdded,this);const _prev=assets.get(this._asset);if(_prev){this._unbindModelAsset(_prev);}}this._asset=_id;if(this._asset){const asset=assets.get(this._asset);if(!asset){this.model=null;assets.on(`add:${this._asset}`,this._onModelAssetAdded,this);}else {this._bindModelAsset(asset);}}else {this.model=null;}}}get asset(){return this._asset}set model(value){if(this._model===value){return}if(value&&value._immutable){return}if(this._model){this._model._immutable=false;this.removeModelFromLayers();this._model.getGraph().destroy();delete this._model._entity;if(this._clonedModel){this._model.destroy();this._clonedModel=false;}}this._model=value;if(this._model){this._model._immutable=true;const meshInstances=this._model.meshInstances;for(let i=0;i<meshInstances.length;i++){meshInstances[i].castShadow=this._castShadows;meshInstances[i].receiveShadow=this._receiveShadows;meshInstances[i].setCustomAabb(this._customAabb);}this.lightmapped=this._lightmapped;this.entity.addChild(this._model.graph);if(this.enabled&&this.entity.enabled){this.addModelToLayers();}this._model._entity=this.entity;if(this.entity.animation){this.entity.animation.setModel(this._model);}if(this.entity.anim){this.entity.anim.rebind();}if(this.type==="asset"){this.mapping=this._mapping;}else {this._unsetMaterialEvents();}}}get model(){return this._model}set lightmapped(value){if(value!==this._lightmapped){this._lightmapped=value;if(this._model){const mi=this._model.meshInstances;for(let i=0;i<mi.length;i++){mi[i].setLightmapped(value);}}}}get lightmapped(){return this._lightmapped}set castShadows(value){if(this._castShadows===value)return;const model=this._model;if(model){const layers=this.layers;const scene=this.system.app.scene;if(this._castShadows&&!value){for(let i=0;i<layers.length;i++){const layer=this.system.app.scene.layers.getLayerById(this.layers[i]);if(!layer)continue;layer.removeShadowCasters(model.meshInstances);}}const meshInstances=model.meshInstances;for(let i=0;i<meshInstances.length;i++){meshInstances[i].castShadow=value;}if(!this._castShadows&&value){for(let i=0;i<layers.length;i++){const layer=scene.layers.getLayerById(layers[i]);if(!layer)continue;layer.addShadowCasters(model.meshInstances);}}}this._castShadows=value;}get castShadows(){return this._castShadows}set receiveShadows(value){if(this._receiveShadows===value)return;this._receiveShadows=value;if(this._model){const meshInstances=this._model.meshInstances;for(let i=0,len=meshInstances.length;i<len;i++){meshInstances[i].receiveShadow=value;}}}get receiveShadows(){return this._receiveShadows}set castShadowsLightmap(value){this._castShadowsLightmap=value;}get castShadowsLightmap(){return this._castShadowsLightmap}set lightmapSizeMultiplier(value){this._lightmapSizeMultiplier=value;}get lightmapSizeMultiplier(){return this._lightmapSizeMultiplier}set layers(value){const layers=this.system.app.scene.layers;if(this.meshInstances){for(let i=0;i<this._layers.length;i++){const layer=layers.getLayerById(this._layers[i]);if(!layer)continue;layer.removeMeshInstances(this.meshInstances);}}this._layers.length=0;for(let i=0;i<value.length;i++){this._layers[i]=value[i];}if(!this.enabled||!this.entity.enabled||!this.meshInstances)return;for(let i=0;i<this._layers.length;i++){const layer=layers.getLayerById(this._layers[i]);if(!layer)continue;layer.addMeshInstances(this.meshInstances);}}get layers(){return this._layers}set batchGroupId(value){if(this._batchGroupId===value)return;if(this.entity.enabled&&this._batchGroupId>=0){var _this$system$app$batc;(_this$system$app$batc=this.system.app.batcher)==null||_this$system$app$batc.remove(BatchGroup.MODEL,this.batchGroupId,this.entity);}if(this.entity.enabled&&value>=0){var _this$system$app$batc2;(_this$system$app$batc2=this.system.app.batcher)==null||_this$system$app$batc2.insert(BatchGroup.MODEL,value,this.entity);}if(value<0&&this._batchGroupId>=0&&this.enabled&&this.entity.enabled){this.addModelToLayers();}this._batchGroupId=value;}get batchGroupId(){return this._batchGroupId}set materialAsset(value){let _id=value;if(value instanceof Asset){_id=value.id;}const assets=this.system.app.assets;if(_id!==this._materialAsset){if(this._materialAsset){assets.off(`add:${this._materialAsset}`,this._onMaterialAssetAdd,this);const _prev=assets.get(this._materialAsset);if(_prev){this._unbindMaterialAsset(_prev);}}this._materialAsset=_id;if(this._materialAsset){const asset=assets.get(this._materialAsset);if(!asset){this._setMaterial(this.system.defaultMaterial);assets.on(`add:${this._materialAsset}`,this._onMaterialAssetAdd,this);}else {this._bindMaterialAsset(asset);}}else {this._setMaterial(this.system.defaultMaterial);}}}get materialAsset(){return this._materialAsset}set material(value){if(this._material===value){return}this.materialAsset=null;this._setMaterial(value);}get material(){return this._material}set mapping(value){if(this._type!=="asset"){return}this._unsetMaterialEvents();if(!value){value={};}this._mapping=value;if(!this._model)return;const meshInstances=this._model.meshInstances;const modelAsset=this.asset?this.system.app.assets.get(this.asset):null;const assetMapping=modelAsset?modelAsset.data.mapping:null;let asset=null;for(let i=0,len=meshInstances.length;i<len;i++){if(value[i]!==undefined){if(value[i]){asset=this.system.app.assets.get(value[i]);this._loadAndSetMeshInstanceMaterial(asset,meshInstances[i],i);}else {meshInstances[i].material=this.system.defaultMaterial;}}else if(assetMapping){if(assetMapping[i]&&(assetMapping[i].material||assetMapping[i].path)){if(assetMapping[i].material!==undefined){asset=this.system.app.assets.get(assetMapping[i].material);}else if(assetMapping[i].path!==undefined){const url=this._getMaterialAssetUrl(assetMapping[i].path);if(url){asset=this.system.app.assets.getByUrl(url);}}this._loadAndSetMeshInstanceMaterial(asset,meshInstances[i],i);}else {meshInstances[i].material=this.system.defaultMaterial;}}}}get mapping(){return this._mapping}addModelToLayers(){const layers=this.system.app.scene.layers;for(let i=0;i<this._layers.length;i++){const layer=layers.getLayerById(this._layers[i]);if(layer){layer.addMeshInstances(this.meshInstances);}}}removeModelFromLayers(){const layers=this.system.app.scene.layers;for(let i=0;i<this._layers.length;i++){const layer=layers.getLayerById(this._layers[i]);if(!layer)continue;layer.removeMeshInstances(this.meshInstances);}}onRemoveChild(){if(this._model){this.removeModelFromLayers();}}onInsertChild(){if(this._model&&this.enabled&&this.entity.enabled){this.addModelToLayers();}}onRemove(){this.asset=null;this.model=null;this.materialAsset=null;this._unsetMaterialEvents();this.entity.off("remove",this.onRemoveChild,this);this.entity.off("insert",this.onInsertChild,this);}onLayersChanged(oldComp,newComp){this.addModelToLayers();oldComp.off("add",this.onLayerAdded,this);oldComp.off("remove",this.onLayerRemoved,this);newComp.on("add",this.onLayerAdded,this);newComp.on("remove",this.onLayerRemoved,this);}onLayerAdded(layer){const index=this.layers.indexOf(layer.id);if(index<0)return;layer.addMeshInstances(this.meshInstances);}onLayerRemoved(layer){const index=this.layers.indexOf(layer.id);if(index<0)return;layer.removeMeshInstances(this.meshInstances);}_setMaterialEvent(index,event,id,handler){const evt=`${event}:${id}`;this.system.app.assets.on(evt,handler,this);if(!this._materialEvents){this._materialEvents=[];}if(!this._materialEvents[index]){this._materialEvents[index]={};}this._materialEvents[index][evt]={id:id,handler:handler};}_unsetMaterialEvents(){const assets=this.system.app.assets;const events=this._materialEvents;if(!events){return}for(let i=0,len=events.length;i<len;i++){if(!events[i])continue;const evt=events[i];for(const key in evt){assets.off(key,evt[key].handler,this);}}this._materialEvents=null;}_getAssetByIdOrPath(idOrPath){let asset=null;const isPath=isNaN(parseInt(idOrPath,10));if(!isPath){asset=this.system.app.assets.get(idOrPath);}else if(this.asset){const url=this._getMaterialAssetUrl(idOrPath);if(url){asset=this.system.app.assets.getByUrl(url);}}return asset}_getMaterialAssetUrl(path){if(!this.asset)return null;const modelAsset=this.system.app.assets.get(this.asset);return modelAsset?modelAsset.getAbsoluteUrl(path):null}_loadAndSetMeshInstanceMaterial(materialAsset,meshInstance,index){const assets=this.system.app.assets;if(!materialAsset){return}if(materialAsset.resource){meshInstance.material=materialAsset.resource;this._setMaterialEvent(index,"remove",materialAsset.id,function(){meshInstance.material=this.system.defaultMaterial;});}else {this._setMaterialEvent(index,"load",materialAsset.id,function(asset){meshInstance.material=asset.resource;this._setMaterialEvent(index,"remove",materialAsset.id,function(){meshInstance.material=this.system.defaultMaterial;});});if(this.enabled&&this.entity.enabled){assets.load(materialAsset);}}}onEnable(){const app=this.system.app;const scene=app.scene;const layers=scene==null?void 0:scene.layers;this._evtLayersChanged=scene.on("set:layers",this.onLayersChanged,this);if(layers){this._evtLayerAdded=layers.on("add",this.onLayerAdded,this);this._evtLayerRemoved=layers.on("remove",this.onLayerRemoved,this);}const isAsset=this._type==="asset";let asset;if(this._model){this.addModelToLayers();}else if(isAsset&&this._asset){asset=app.assets.get(this._asset);if(asset&&asset.resource!==this._model){this._bindModelAsset(asset);}}if(this._materialAsset){asset=app.assets.get(this._materialAsset);if(asset&&asset.resource!==this._material){this._bindMaterialAsset(asset);}}if(isAsset){if(this._mapping){for(const index in this._mapping){if(this._mapping[index]){asset=this._getAssetByIdOrPath(this._mapping[index]);if(asset&&!asset.resource){app.assets.load(asset);}}}}}if(this._batchGroupId>=0){var _app$batcher;(_app$batcher=app.batcher)==null||_app$batcher.insert(BatchGroup.MODEL,this.batchGroupId,this.entity);}}onDisable(){var _this$_evtLayersChang;const app=this.system.app;const scene=app.scene;const layers=scene.layers;(_this$_evtLayersChang=this._evtLayersChanged)==null||_this$_evtLayersChang.off();this._evtLayersChanged=null;if(layers){var _this$_evtLayerAdded,_this$_evtLayerRemove;(_this$_evtLayerAdded=this._evtLayerAdded)==null||_this$_evtLayerAdded.off();this._evtLayerAdded=null;(_this$_evtLayerRemove=this._evtLayerRemoved)==null||_this$_evtLayerRemove.off();this._evtLayerRemoved=null;}if(this._batchGroupId>=0){var _app$batcher2;(_app$batcher2=app.batcher)==null||_app$batcher2.remove(BatchGroup.MODEL,this.batchGroupId,this.entity);}if(this._model){this.removeModelFromLayers();}}hide(){if(this._model){const instances=this._model.meshInstances;for(let i=0,l=instances.length;i<l;i++){instances[i].visible=false;}}}show(){if(this._model){const instances=this._model.meshInstances;for(let i=0,l=instances.length;i<l;i++){instances[i].visible=true;}}}_bindMaterialAsset(asset){asset.on("load",this._onMaterialAssetLoad,this);asset.on("unload",this._onMaterialAssetUnload,this);asset.on("remove",this._onMaterialAssetRemove,this);asset.on("change",this._onMaterialAssetChange,this);if(asset.resource){this._onMaterialAssetLoad(asset);}else {if(!this.enabled||!this.entity.enabled)return;this.system.app.assets.load(asset);}}_unbindMaterialAsset(asset){asset.off("load",this._onMaterialAssetLoad,this);asset.off("unload",this._onMaterialAssetUnload,this);asset.off("remove",this._onMaterialAssetRemove,this);asset.off("change",this._onMaterialAssetChange,this);}_onMaterialAssetAdd(asset){this.system.app.assets.off(`add:${asset.id}`,this._onMaterialAssetAdd,this);if(this._materialAsset===asset.id){this._bindMaterialAsset(asset);}}_onMaterialAssetLoad(asset){this._setMaterial(asset.resource);}_onMaterialAssetUnload(asset){this._setMaterial(this.system.defaultMaterial);}_onMaterialAssetRemove(asset){this._onMaterialAssetUnload(asset);}_onMaterialAssetChange(asset){}_bindModelAsset(asset){this._unbindModelAsset(asset);asset.on("load",this._onModelAssetLoad,this);asset.on("unload",this._onModelAssetUnload,this);asset.on("change",this._onModelAssetChange,this);asset.on("remove",this._onModelAssetRemove,this);if(asset.resource){this._onModelAssetLoad(asset);}else {if(!this.enabled||!this.entity.enabled)return;this.system.app.assets.load(asset);}}_unbindModelAsset(asset){asset.off("load",this._onModelAssetLoad,this);asset.off("unload",this._onModelAssetUnload,this);asset.off("change",this._onModelAssetChange,this);asset.off("remove",this._onModelAssetRemove,this);}_onModelAssetAdded(asset){this.system.app.assets.off(`add:${asset.id}`,this._onModelAssetAdded,this);if(asset.id===this._asset){this._bindModelAsset(asset);}}_onModelAssetLoad(asset){this.model=asset.resource.clone();this._clonedModel=true;}_onModelAssetUnload(asset){this.model=null;}_onModelAssetChange(asset,attr,_new,_old){if(attr==="data"){this.mapping=this._mapping;}}_onModelAssetRemove(asset){this.model=null;}_setMaterial(material){if(this._material===material){return}this._material=material;const model=this._model;if(model&&this._type!=="asset"){const meshInstances=model.meshInstances;for(let i=0,len=meshInstances.length;i<len;i++){meshInstances[i].material=material;}}}constructor(system,entity){super(system,entity);this._type="asset";this._asset=null;this._model=null;this._mapping={};this._castShadows=true;this._receiveShadows=true;this._materialAsset=null;this._material=void 0;this._castShadowsLightmap=true;this._lightmapped=false;this._lightmapSizeMultiplier=1;this.isStatic=false;this._layers=[LAYERID_WORLD];this._batchGroupId=-1;this._customAabb=null;this._area=null;this._materialEvents=null;this._clonedModel=false;this._evtLayersChanged=null;this._evtLayerAdded=null;this._evtLayerRemoved=null;this._material=system.defaultMaterial;entity.on("remove",this.onRemoveChild,this);entity.on("removehierarchy",this.onRemoveChild,this);entity.on("insert",this.onInsertChild,this);entity.on("inserthierarchy",this.onInsertChild,this);}}class ModelComponentData{constructor(){this.enabled=true;}}const _schema$c=["enabled"];class ModelComponentSystem extends ComponentSystem{initializeComponentData(component,_data,properties){properties=["material","materialAsset","asset","castShadows","receiveShadows","castShadowsLightmap","lightmapped","lightmapSizeMultiplier","type","mapping","layers","isStatic","batchGroupId"];if(_data.batchGroupId===null||_data.batchGroupId===undefined){_data.batchGroupId=-1;}if(_data.layers&&_data.layers.length){_data.layers=_data.layers.slice(0);}for(let i=0;i<properties.length;i++){if(_data.hasOwnProperty(properties[i])){component[properties[i]]=_data[properties[i]];}}if(_data.aabbCenter&&_data.aabbHalfExtents){component.customAabb=new BoundingBox(new Vec3(_data.aabbCenter),new Vec3(_data.aabbHalfExtents));}super.initializeComponentData(component,_data,["enabled"]);}cloneComponent(entity,clone){const data={type:entity.model.type,asset:entity.model.asset,castShadows:entity.model.castShadows,receiveShadows:entity.model.receiveShadows,castShadowsLightmap:entity.model.castShadowsLightmap,lightmapped:entity.model.lightmapped,lightmapSizeMultiplier:entity.model.lightmapSizeMultiplier,isStatic:entity.model.isStatic,enabled:entity.model.enabled,layers:entity.model.layers,batchGroupId:entity.model.batchGroupId,mapping:extend({},entity.model.mapping)};let materialAsset=entity.model.materialAsset;if(!(materialAsset instanceof Asset)&&materialAsset!=null){materialAsset=this.app.assets.get(materialAsset);}const material=entity.model.material;if(!material||material===this.defaultMaterial||!materialAsset||material===materialAsset.resource){data.materialAsset=materialAsset;}const component=this.addComponent(clone,data);if(entity.model.model&&entity.model.type==="asset"&&!entity.model.asset){component.model=entity.model.model.clone();component._clonedModel=true;}if(!data.materialAsset){component.material=material;}if(entity.model.model){const meshInstances=entity.model.model.meshInstances;const meshInstancesClone=component.model.meshInstances;for(let i=0;i<meshInstances.length;i++){meshInstancesClone[i].mask=meshInstances[i].mask;meshInstancesClone[i].material=meshInstances[i].material;meshInstancesClone[i].layer=meshInstances[i].layer;meshInstancesClone[i].receiveShadow=meshInstances[i].receiveShadow;}}if(entity.model.customAabb){component.customAabb=entity.model.customAabb.clone();}return component}onRemove(entity,component){component.onRemove();}constructor(app){super(app);this.id="model";this.ComponentType=ModelComponent;this.DataType=ModelComponentData;this.schema=_schema$c;this.defaultMaterial=getDefaultMaterial(app.graphicsDevice);this.on("beforeremove",this.onRemove,this);}}Component._buildAccessors(ModelComponent.prototype,_schema$c);const SIMPLE_PROPERTIES=["emitterExtents","emitterRadius","emitterExtentsInner","emitterRadiusInner","loop","initialVelocity","animSpeed","normalMap","particleNormal"];const COMPLEX_PROPERTIES=["numParticles","lifetime","rate","rate2","startAngle","startAngle2","lighting","halfLambert","intensity","wrap","wrapBounds","depthWrite","noFog","sort","stretch","alignToMotion","preWarm","emitterShape","animTilesX","animTilesY","animStartFrame","animNumFrames","animNumAnimations","animIndex","randomizeAnimIndex","animLoop","colorMap","localSpace","screenSpace","orientation"];const GRAPH_PROPERTIES=["scaleGraph","scaleGraph2","colorGraph","colorGraph2","alphaGraph","alphaGraph2","velocityGraph","velocityGraph2","localVelocityGraph","localVelocityGraph2","rotationSpeedGraph","rotationSpeedGraph2","radialSpeedGraph","radialSpeedGraph2"];const ASSET_PROPERTIES=["colorMapAsset","normalMapAsset","meshAsset","renderAsset"];let depthLayer;class ParticleSystemComponent extends Component{get data(){const record=this.system.store[this.entity.getGuid()];return record?record.data:null}set enabled(arg){this._setValue("enabled",arg);}get enabled(){return this.data.enabled}set autoPlay(arg){this._setValue("autoPlay",arg);}get autoPlay(){return this.data.autoPlay}set numParticles(arg){this._setValue("numParticles",arg);}get numParticles(){return this.data.numParticles}set lifetime(arg){this._setValue("lifetime",arg);}get lifetime(){return this.data.lifetime}set rate(arg){this._setValue("rate",arg);}get rate(){return this.data.rate}set rate2(arg){this._setValue("rate2",arg);}get rate2(){return this.data.rate2}set startAngle(arg){this._setValue("startAngle",arg);}get startAngle(){return this.data.startAngle}set startAngle2(arg){this._setValue("startAngle2",arg);}get startAngle2(){return this.data.startAngle2}set loop(arg){this._setValue("loop",arg);}get loop(){return this.data.loop}set preWarm(arg){this._setValue("preWarm",arg);}get preWarm(){return this.data.preWarm}set lighting(arg){this._setValue("lighting",arg);}get lighting(){return this.data.lighting}set halfLambert(arg){this._setValue("halfLambert",arg);}get halfLambert(){return this.data.halfLambert}set intensity(arg){this._setValue("intensity",arg);}get intensity(){return this.data.intensity}set depthWrite(arg){this._setValue("depthWrite",arg);}get depthWrite(){return this.data.depthWrite}set noFog(arg){this._setValue("noFog",arg);}get noFog(){return this.data.noFog}set depthSoftening(arg){this._setValue("depthSoftening",arg);}get depthSoftening(){return this.data.depthSoftening}set sort(arg){this._setValue("sort",arg);}get sort(){return this.data.sort}set blendType(arg){this._setValue("blendType",arg);}get blendType(){return this.data.blendType}set stretch(arg){this._setValue("stretch",arg);}get stretch(){return this.data.stretch}set alignToMotion(arg){this._setValue("alignToMotion",arg);}get alignToMotion(){return this.data.alignToMotion}set emitterShape(arg){this._setValue("emitterShape",arg);}get emitterShape(){return this.data.emitterShape}set emitterExtents(arg){this._setValue("emitterExtents",arg);}get emitterExtents(){return this.data.emitterExtents}set emitterExtentsInner(arg){this._setValue("emitterExtentsInner",arg);}get emitterExtentsInner(){return this.data.emitterExtentsInner}set emitterRadius(arg){this._setValue("emitterRadius",arg);}get emitterRadius(){return this.data.emitterRadius}set emitterRadiusInner(arg){this._setValue("emitterRadiusInner",arg);}get emitterRadiusInner(){return this.data.emitterRadiusInner}set initialVelocity(arg){this._setValue("initialVelocity",arg);}get initialVelocity(){return this.data.initialVelocity}set wrap(arg){this._setValue("wrap",arg);}get wrap(){return this.data.wrap}set wrapBounds(arg){this._setValue("wrapBounds",arg);}get wrapBounds(){return this.data.wrapBounds}set localSpace(arg){this._setValue("localSpace",arg);}get localSpace(){return this.data.localSpace}set screenSpace(arg){this._setValue("screenSpace",arg);}get screenSpace(){return this.data.screenSpace}set colorMapAsset(arg){this._setValue("colorMapAsset",arg);}get colorMapAsset(){return this.data.colorMapAsset}set normalMapAsset(arg){this._setValue("normalMapAsset",arg);}get normalMapAsset(){return this.data.normalMapAsset}set mesh(arg){this._setValue("mesh",arg);}get mesh(){return this.data.mesh}set meshAsset(arg){this._setValue("meshAsset",arg);}get meshAsset(){return this.data.meshAsset}set renderAsset(arg){this._setValue("renderAsset",arg);}get renderAsset(){return this.data.renderAsset}set orientation(arg){this._setValue("orientation",arg);}get orientation(){return this.data.orientation}set particleNormal(arg){this._setValue("particleNormal",arg);}get particleNormal(){return this.data.particleNormal}set localVelocityGraph(arg){this._setValue("localVelocityGraph",arg);}get localVelocityGraph(){return this.data.localVelocityGraph}set localVelocityGraph2(arg){this._setValue("localVelocityGraph2",arg);}get localVelocityGraph2(){return this.data.localVelocityGraph2}set velocityGraph(arg){this._setValue("velocityGraph",arg);}get velocityGraph(){return this.data.velocityGraph}set velocityGraph2(arg){this._setValue("velocityGraph2",arg);}get velocityGraph2(){return this.data.velocityGraph2}set rotationSpeedGraph(arg){this._setValue("rotationSpeedGraph",arg);}get rotationSpeedGraph(){return this.data.rotationSpeedGraph}set rotationSpeedGraph2(arg){this._setValue("rotationSpeedGraph2",arg);}get rotationSpeedGraph2(){return this.data.rotationSpeedGraph2}set radialSpeedGraph(arg){this._setValue("radialSpeedGraph",arg);}get radialSpeedGraph(){return this.data.radialSpeedGraph}set radialSpeedGraph2(arg){this._setValue("radialSpeedGraph2",arg);}get radialSpeedGraph2(){return this.data.radialSpeedGraph2}set scaleGraph(arg){this._setValue("scaleGraph",arg);}get scaleGraph(){return this.data.scaleGraph}set scaleGraph2(arg){this._setValue("scaleGraph2",arg);}get scaleGraph2(){return this.data.scaleGraph2}set colorGraph(arg){this._setValue("colorGraph",arg);}get colorGraph(){return this.data.colorGraph}set colorGraph2(arg){this._setValue("colorGraph2",arg);}get colorGraph2(){return this.data.colorGraph2}set alphaGraph(arg){this._setValue("alphaGraph",arg);}get alphaGraph(){return this.data.alphaGraph}set alphaGraph2(arg){this._setValue("alphaGraph2",arg);}get alphaGraph2(){return this.data.alphaGraph2}set colorMap(arg){this._setValue("colorMap",arg);}get colorMap(){return this.data.colorMap}set normalMap(arg){this._setValue("normalMap",arg);}get normalMap(){return this.data.normalMap}set animTilesX(arg){this._setValue("animTilesX",arg);}get animTilesX(){return this.data.animTilesX}set animTilesY(arg){this._setValue("animTilesY",arg);}get animTilesY(){return this.data.animTilesY}set animStartFrame(arg){this._setValue("animStartFrame",arg);}get animStartFrame(){return this.data.animStartFrame}set animNumFrames(arg){this._setValue("animNumFrames",arg);}get animNumFrames(){return this.data.animNumFrames}set animNumAnimations(arg){this._setValue("animNumAnimations",arg);}get animNumAnimations(){return this.data.animNumAnimations}set animIndex(arg){this._setValue("animIndex",arg);}get animIndex(){return this.data.animIndex}set randomizeAnimIndex(arg){this._setValue("randomizeAnimIndex",arg);}get randomizeAnimIndex(){return this.data.randomizeAnimIndex}set animSpeed(arg){this._setValue("animSpeed",arg);}get animSpeed(){return this.data.animSpeed}set animLoop(arg){this._setValue("animLoop",arg);}get animLoop(){return this.data.animLoop}set layers(arg){this._setValue("layers",arg);}get layers(){return this.data.layers}set drawOrder(drawOrder){this._drawOrder=drawOrder;if(this.emitter){this.emitter.drawOrder=drawOrder;}}get drawOrder(){return this._drawOrder}_setValue(name,value){const data=this.data;const oldValue=data[name];data[name]=value;this.fire("set",name,oldValue,value);}addMeshInstanceToLayers(){if(!this.emitter)return;for(let i=0;i<this.layers.length;i++){const layer=this.system.app.scene.layers.getLayerById(this.layers[i]);if(!layer)continue;layer.addMeshInstances([this.emitter.meshInstance]);this.emitter._layer=layer;}}removeMeshInstanceFromLayers(){if(!this.emitter)return;for(let i=0;i<this.layers.length;i++){const layer=this.system.app.scene.layers.getLayerById(this.layers[i]);if(!layer)continue;layer.removeMeshInstances([this.emitter.meshInstance]);}}onSetLayers(name,oldValue,newValue){if(!this.emitter)return;for(let i=0;i<oldValue.length;i++){const layer=this.system.app.scene.layers.getLayerById(oldValue[i]);if(!layer)continue;layer.removeMeshInstances([this.emitter.meshInstance]);}if(!this.enabled||!this.entity.enabled)return;for(let i=0;i<newValue.length;i++){const layer=this.system.app.scene.layers.getLayerById(newValue[i]);if(!layer)continue;layer.addMeshInstances([this.emitter.meshInstance]);}}onLayersChanged(oldComp,newComp){this.addMeshInstanceToLayers();oldComp.off("add",this.onLayerAdded,this);oldComp.off("remove",this.onLayerRemoved,this);newComp.on("add",this.onLayerAdded,this);newComp.on("remove",this.onLayerRemoved,this);}onLayerAdded(layer){if(!this.emitter)return;const index=this.layers.indexOf(layer.id);if(index<0)return;layer.addMeshInstances([this.emitter.meshInstance]);}onLayerRemoved(layer){if(!this.emitter)return;const index=this.layers.indexOf(layer.id);if(index<0)return;layer.removeMeshInstances([this.emitter.meshInstance]);}_bindColorMapAsset(asset){asset.on("load",this._onColorMapAssetLoad,this);asset.on("unload",this._onColorMapAssetUnload,this);asset.on("remove",this._onColorMapAssetRemove,this);asset.on("change",this._onColorMapAssetChange,this);if(asset.resource){this._onColorMapAssetLoad(asset);}else {if(!this.enabled||!this.entity.enabled)return;this.system.app.assets.load(asset);}}_unbindColorMapAsset(asset){asset.off("load",this._onColorMapAssetLoad,this);asset.off("unload",this._onColorMapAssetUnload,this);asset.off("remove",this._onColorMapAssetRemove,this);asset.off("change",this._onColorMapAssetChange,this);}_onColorMapAssetLoad(asset){this.colorMap=asset.resource;}_onColorMapAssetUnload(asset){this.colorMap=null;}_onColorMapAssetRemove(asset){this._onColorMapAssetUnload(asset);}_onColorMapAssetChange(asset){}onSetColorMapAsset(name,oldValue,newValue){const assets=this.system.app.assets;if(oldValue){const asset=assets.get(oldValue);if(asset){this._unbindColorMapAsset(asset);}}if(newValue){if(newValue instanceof Asset){this.data.colorMapAsset=newValue.id;newValue=newValue.id;}const asset=assets.get(newValue);if(asset){this._bindColorMapAsset(asset);}else {assets.once(`add:${newValue}`,asset=>{this._bindColorMapAsset(asset);});}}else {this.colorMap=null;}}_bindNormalMapAsset(asset){asset.on("load",this._onNormalMapAssetLoad,this);asset.on("unload",this._onNormalMapAssetUnload,this);asset.on("remove",this._onNormalMapAssetRemove,this);asset.on("change",this._onNormalMapAssetChange,this);if(asset.resource){this._onNormalMapAssetLoad(asset);}else {if(!this.enabled||!this.entity.enabled)return;this.system.app.assets.load(asset);}}_unbindNormalMapAsset(asset){asset.off("load",this._onNormalMapAssetLoad,this);asset.off("unload",this._onNormalMapAssetUnload,this);asset.off("remove",this._onNormalMapAssetRemove,this);asset.off("change",this._onNormalMapAssetChange,this);}_onNormalMapAssetLoad(asset){this.normalMap=asset.resource;}_onNormalMapAssetUnload(asset){this.normalMap=null;}_onNormalMapAssetRemove(asset){this._onNormalMapAssetUnload(asset);}_onNormalMapAssetChange(asset){}onSetNormalMapAsset(name,oldValue,newValue){const assets=this.system.app.assets;if(oldValue){const asset=assets.get(oldValue);if(asset){this._unbindNormalMapAsset(asset);}}if(newValue){if(newValue instanceof Asset){this.data.normalMapAsset=newValue.id;newValue=newValue.id;}const asset=assets.get(newValue);if(asset){this._bindNormalMapAsset(asset);}else {assets.once(`add:${newValue}`,asset=>{this._bindNormalMapAsset(asset);});}}else {this.normalMap=null;}}_bindMeshAsset(asset){asset.on("load",this._onMeshAssetLoad,this);asset.on("unload",this._onMeshAssetUnload,this);asset.on("remove",this._onMeshAssetRemove,this);asset.on("change",this._onMeshAssetChange,this);if(asset.resource){this._onMeshAssetLoad(asset);}else {if(!this.enabled||!this.entity.enabled)return;this.system.app.assets.load(asset);}}_unbindMeshAsset(asset){asset.off("load",this._onMeshAssetLoad,this);asset.off("unload",this._onMeshAssetUnload,this);asset.off("remove",this._onMeshAssetRemove,this);asset.off("change",this._onMeshAssetChange,this);}_onMeshAssetLoad(asset){this._onMeshChanged(asset.resource);}_onMeshAssetUnload(asset){this.mesh=null;}_onMeshAssetRemove(asset){this._onMeshAssetUnload(asset);}_onMeshAssetChange(asset){}onSetMeshAsset(name,oldValue,newValue){const assets=this.system.app.assets;if(oldValue){const asset=assets.get(oldValue);if(asset){this._unbindMeshAsset(asset);}}if(newValue){if(newValue instanceof Asset){this.data.meshAsset=newValue.id;newValue=newValue.id;}const asset=assets.get(newValue);if(asset){this._bindMeshAsset(asset);}}else {this._onMeshChanged(null);}}onSetMesh(name,oldValue,newValue){if(!newValue||newValue instanceof Asset||typeof newValue==="number"){this.meshAsset=newValue;}else {this._onMeshChanged(newValue);}}_onMeshChanged(mesh){if(mesh&&!(mesh instanceof Mesh)){if(mesh.meshInstances[0]){mesh=mesh.meshInstances[0].mesh;}else {mesh=null;}}this.data.mesh=mesh;if(this.emitter){this.emitter.mesh=mesh;this.emitter.resetMaterial();this.rebuild();}}onSetRenderAsset(name,oldValue,newValue){const assets=this.system.app.assets;if(oldValue){const asset=assets.get(oldValue);if(asset){this._unbindRenderAsset(asset);}}if(newValue){if(newValue instanceof Asset){this.data.renderAsset=newValue.id;newValue=newValue.id;}const asset=assets.get(newValue);if(asset){this._bindRenderAsset(asset);}}else {this._onRenderChanged(null);}}_bindRenderAsset(asset){asset.on("load",this._onRenderAssetLoad,this);asset.on("unload",this._onRenderAssetUnload,this);asset.on("remove",this._onRenderAssetRemove,this);if(asset.resource){this._onRenderAssetLoad(asset);}else {if(!this.enabled||!this.entity.enabled)return;this.system.app.assets.load(asset);}}_unbindRenderAsset(asset){var _this$_evtSetMeshes;asset.off("load",this._onRenderAssetLoad,this);asset.off("unload",this._onRenderAssetUnload,this);asset.off("remove",this._onRenderAssetRemove,this);(_this$_evtSetMeshes=this._evtSetMeshes)==null||_this$_evtSetMeshes.off();this._evtSetMeshes=null;}_onRenderAssetLoad(asset){this._onRenderChanged(asset.resource);}_onRenderAssetUnload(asset){this._onRenderChanged(null);}_onRenderAssetRemove(asset){this._onRenderAssetUnload(asset);}_onRenderChanged(render){var _this$_evtSetMeshes2;if(!render){this._onMeshChanged(null);return}(_this$_evtSetMeshes2=this._evtSetMeshes)==null||_this$_evtSetMeshes2.off();this._evtSetMeshes=render.on("set:meshes",this._onRenderSetMeshes,this);if(render.meshes){this._onRenderSetMeshes(render.meshes);}}_onRenderSetMeshes(meshes){this._onMeshChanged(meshes&&meshes[0]);}onSetLoop(name,oldValue,newValue){if(this.emitter){this.emitter[name]=newValue;this.emitter.resetTime();}}onSetBlendType(name,oldValue,newValue){if(this.emitter){this.emitter[name]=newValue;this.emitter.material.blendType=newValue;this.emitter.resetMaterial();this.rebuild();}}_requestDepth(){if(this._requestedDepth)return;if(!depthLayer)depthLayer=this.system.app.scene.layers.getLayerById(LAYERID_DEPTH);if(depthLayer){depthLayer.incrementCounter();this._requestedDepth=true;}}_releaseDepth(){if(!this._requestedDepth)return;if(depthLayer){depthLayer.decrementCounter();this._requestedDepth=false;}}onSetDepthSoftening(name,oldValue,newValue){if(oldValue!==newValue){if(newValue){if(this.enabled&&this.entity.enabled)this._requestDepth();if(this.emitter)this.emitter[name]=newValue;}else {if(this.enabled&&this.entity.enabled)this._releaseDepth();if(this.emitter)this.emitter[name]=newValue;}if(this.emitter){this.reset();this.emitter.resetMaterial();this.rebuild();}}}onSetSimpleProperty(name,oldValue,newValue){if(this.emitter){this.emitter[name]=newValue;this.emitter.resetMaterial();}}onSetComplexProperty(name,oldValue,newValue){if(this.emitter){this.emitter[name]=newValue;this.emitter.resetMaterial();this.rebuild();this.reset();}}onSetGraphProperty(name,oldValue,newValue){if(this.emitter){this.emitter[name]=newValue;this.emitter.rebuildGraphs();this.emitter.resetMaterial();}}onEnable(){const scene=this.system.app.scene;const layers=scene.layers;const data=this.data;for(let i=0,len=ASSET_PROPERTIES.length;i<len;i++){let asset=data[ASSET_PROPERTIES[i]];if(asset){if(!(asset instanceof Asset)){const id=parseInt(asset,10);if(id>=0){asset=this.system.app.assets.get(asset);}else {continue}}if(asset&&!asset.resource){this.system.app.assets.load(asset);}}}if(this.system.app.graphicsDevice.disableParticleSystem){return}if(!this.emitter){let mesh=data.mesh;if(!(mesh instanceof Mesh)){mesh=null;}this.emitter=new ParticleEmitter(this.system.app.graphicsDevice,{numParticles:data.numParticles,emitterExtents:data.emitterExtents,emitterExtentsInner:data.emitterExtentsInner,emitterRadius:data.emitterRadius,emitterRadiusInner:data.emitterRadiusInner,emitterShape:data.emitterShape,initialVelocity:data.initialVelocity,wrap:data.wrap,localSpace:data.localSpace,screenSpace:data.screenSpace,wrapBounds:data.wrapBounds,lifetime:data.lifetime,rate:data.rate,rate2:data.rate2,orientation:data.orientation,particleNormal:data.particleNormal,animTilesX:data.animTilesX,animTilesY:data.animTilesY,animStartFrame:data.animStartFrame,animNumFrames:data.animNumFrames,animNumAnimations:data.animNumAnimations,animIndex:data.animIndex,randomizeAnimIndex:data.randomizeAnimIndex,animSpeed:data.animSpeed,animLoop:data.animLoop,startAngle:data.startAngle,startAngle2:data.startAngle2,scaleGraph:data.scaleGraph,scaleGraph2:data.scaleGraph2,colorGraph:data.colorGraph,colorGraph2:data.colorGraph2,alphaGraph:data.alphaGraph,alphaGraph2:data.alphaGraph2,localVelocityGraph:data.localVelocityGraph,localVelocityGraph2:data.localVelocityGraph2,velocityGraph:data.velocityGraph,velocityGraph2:data.velocityGraph2,rotationSpeedGraph:data.rotationSpeedGraph,rotationSpeedGraph2:data.rotationSpeedGraph2,radialSpeedGraph:data.radialSpeedGraph,radialSpeedGraph2:data.radialSpeedGraph2,colorMap:data.colorMap,normalMap:data.normalMap,loop:data.loop,preWarm:data.preWarm,sort:data.sort,stretch:data.stretch,alignToMotion:data.alignToMotion,lighting:data.lighting,halfLambert:data.halfLambert,intensity:data.intensity,depthSoftening:data.depthSoftening,scene:this.system.app.scene,mesh:mesh,depthWrite:data.depthWrite,noFog:data.noFog,node:this.entity,blendType:data.blendType});this.emitter.meshInstance.node=this.entity;this.emitter.drawOrder=this.drawOrder;if(!data.autoPlay){this.pause();this.emitter.meshInstance.visible=false;}}if(this.emitter.colorMap){this.addMeshInstanceToLayers();}this._evtLayersChanged=scene.on("set:layers",this.onLayersChanged,this);if(layers){this._evtLayerAdded=layers.on("add",this.onLayerAdded,this);this._evtLayerRemoved=layers.on("remove",this.onLayerRemoved,this);}if(this.enabled&&this.entity.enabled&&data.depthSoftening){this._requestDepth();}}onDisable(){var _this$_evtLayersChang;const scene=this.system.app.scene;const layers=scene.layers;(_this$_evtLayersChang=this._evtLayersChanged)==null||_this$_evtLayersChang.off();this._evtLayersChanged=null;if(layers){var _this$_evtLayerAdded,_this$_evtLayerRemove;(_this$_evtLayerAdded=this._evtLayerAdded)==null||_this$_evtLayerAdded.off();this._evtLayerAdded=null;(_this$_evtLayerRemove=this._evtLayerRemoved)==null||_this$_evtLayerRemove.off();this._evtLayerRemoved=null;}if(this.emitter){this.removeMeshInstanceFromLayers();if(this.data.depthSoftening)this._releaseDepth();this.emitter.camera=null;}}onBeforeRemove(){if(this.enabled){this.enabled=false;}if(this.emitter){this.emitter.destroy();this.emitter=null;}for(let i=0;i<ASSET_PROPERTIES.length;i++){const prop=ASSET_PROPERTIES[i];if(this.data[prop]){this[prop]=null;}}this.off();}reset(){if(this.emitter){this.emitter.reset();}}stop(){if(this.emitter){this.emitter.loop=false;this.emitter.resetTime();this.emitter.addTime(0,true);}}pause(){this.data.paused=true;}unpause(){this.data.paused=false;}play(){this.data.paused=false;if(this.emitter){this.emitter.meshInstance.visible=true;this.emitter.loop=this.data.loop;this.emitter.resetTime();}}isPlaying(){if(this.data.paused){return false}if(this.emitter&&this.emitter.loop){return true}return Date.now()<=this.emitter.endTime}rebuild(){const enabled=this.enabled;this.enabled=false;if(this.emitter){this.emitter.rebuild();this.emitter.meshInstance.node=this.entity;}this.enabled=enabled;}constructor(system,entity){super(system,entity);this._requestedDepth=false;this._drawOrder=0;this._evtLayersChanged=null;this._evtLayerAdded=null;this._evtLayerRemoved=null;this._evtSetMeshes=null;this.on("set_colorMapAsset",this.onSetColorMapAsset,this);this.on("set_normalMapAsset",this.onSetNormalMapAsset,this);this.on("set_meshAsset",this.onSetMeshAsset,this);this.on("set_mesh",this.onSetMesh,this);this.on("set_renderAsset",this.onSetRenderAsset,this);this.on("set_loop",this.onSetLoop,this);this.on("set_blendType",this.onSetBlendType,this);this.on("set_depthSoftening",this.onSetDepthSoftening,this);this.on("set_layers",this.onSetLayers,this);SIMPLE_PROPERTIES.forEach(prop=>{this.on(`set_${prop}`,this.onSetSimpleProperty,this);});COMPLEX_PROPERTIES.forEach(prop=>{this.on(`set_${prop}`,this.onSetComplexProperty,this);});GRAPH_PROPERTIES.forEach(prop=>{this.on(`set_${prop}`,this.onSetGraphProperty,this);});}}class ParticleSystemComponentData{constructor(){this.numParticles=1;this.rate=1;this.rate2=null;this.startAngle=0;this.startAngle2=null;this.lifetime=50;this.emitterExtents=new Vec3;this.emitterExtentsInner=new Vec3;this.emitterRadius=0;this.emitterRadiusInner=0;this.emitterShape=EMITTERSHAPE_BOX;this.initialVelocity=0;this.wrap=false;this.wrapBounds=new Vec3;this.localSpace=false;this.screenSpace=false;this.colorMap=null;this.colorMapAsset=null;this.normalMap=null;this.normalMapAsset=null;this.loop=true;this.preWarm=false;this.sort=0;this.mode=PARTICLEMODE_GPU;this.scene=null;this.lighting=false;this.halfLambert=false;this.intensity=1;this.stretch=0;this.alignToMotion=false;this.depthSoftening=0;this.renderAsset=null;this.meshAsset=null;this.mesh=null;this.depthWrite=false;this.noFog=false;this.orientation=PARTICLEORIENTATION_SCREEN;this.particleNormal=new Vec3(0,1,0);this.animTilesX=1;this.animTilesY=1;this.animStartFrame=0;this.animNumFrames=1;this.animNumAnimations=1;this.animIndex=0;this.randomizeAnimIndex=false;this.animSpeed=1;this.animLoop=true;this.scaleGraph=null;this.scaleGraph2=null;this.colorGraph=null;this.colorGraph2=null;this.alphaGraph=null;this.alphaGraph2=null;this.localVelocityGraph=null;this.localVelocityGraph2=null;this.velocityGraph=null;this.velocityGraph2=null;this.rotationSpeedGraph=null;this.rotationSpeedGraph2=null;this.radialSpeedGraph=null;this.radialSpeedGraph2=null;this.blendType=BLEND_NORMAL;this.enabled=true;this.paused=false;this.autoPlay=true;this.layers=[LAYERID_WORLD];}}const _schema$b=["enabled","autoPlay","numParticles","lifetime","rate","rate2","startAngle","startAngle2","loop","preWarm","lighting","halfLambert","intensity","depthWrite","noFog","depthSoftening","sort","blendType","stretch","alignToMotion","emitterShape","emitterExtents","emitterExtentsInner","emitterRadius","emitterRadiusInner","initialVelocity","wrap","wrapBounds","localSpace","screenSpace","colorMapAsset","normalMapAsset","mesh","meshAsset","renderAsset","orientation","particleNormal","localVelocityGraph","localVelocityGraph2","velocityGraph","velocityGraph2","rotationSpeedGraph","rotationSpeedGraph2","radialSpeedGraph","radialSpeedGraph2","scaleGraph","scaleGraph2","colorGraph","colorGraph2","alphaGraph","alphaGraph2","colorMap","normalMap","animTilesX","animTilesY","animStartFrame","animNumFrames","animNumAnimations","animIndex","randomizeAnimIndex","animSpeed","animLoop","layers"];class ParticleSystemComponentSystem extends ComponentSystem{initializeComponentData(component,_data,properties){const data={};properties=[];const types=this.propertyTypes;if(_data.mesh instanceof Asset||typeof _data.mesh==="number"){_data.meshAsset=_data.mesh;delete _data.mesh;}for(const prop in _data){if(_data.hasOwnProperty(prop)){properties.push(prop);data[prop]=_data[prop];}if(types[prop]==="vec3"){if(Array.isArray(data[prop])){data[prop]=new Vec3(data[prop][0],data[prop][1],data[prop][2]);}}else if(types[prop]==="curve"){if(!(data[prop]instanceof Curve)){const t=data[prop].type;data[prop]=new Curve(data[prop].keys);data[prop].type=t;}}else if(types[prop]==="curveset"){if(!(data[prop]instanceof CurveSet)){const t=data[prop].type;data[prop]=new CurveSet(data[prop].keys);data[prop].type=t;}}if(data.layers&&Array.isArray(data.layers)){data.layers=data.layers.slice(0);}}super.initializeComponentData(component,data,properties);}cloneComponent(entity,clone){const source=entity.particlesystem.data;const schema=this.schema;const data={};for(let i=0,len=schema.length;i<len;i++){const prop=schema[i];let sourceProp=source[prop];if(sourceProp instanceof Vec3||sourceProp instanceof Curve||sourceProp instanceof CurveSet){sourceProp=sourceProp.clone();data[prop]=sourceProp;}else if(prop==="layers"){data.layers=source.layers.slice(0);}else {if(sourceProp!==null&&sourceProp!==undefined){data[prop]=sourceProp;}}}return this.addComponent(clone,data)}onUpdate(dt){const components=this.store;let numSteps;const stats=this.app.stats.particles;const composition=this.app.scene.layers;for(let i=0;i<composition.layerList.length;i++){composition.layerList[i].requiresLightCube=false;}for(const id in components){if(components.hasOwnProperty(id)){const component=components[id];const entity=component.entity;const data=component.data;if(data.enabled&&entity.enabled){const emitter=entity.particlesystem.emitter;if(!(emitter!=null&&emitter.meshInstance.visible))continue;if(emitter.lighting){const layers=data.layers;for(let i=0;i<layers.length;i++){const layer=composition.getLayerById(layers[i]);if(layer){layer.requiresLightCube=true;}}}if(!data.paused){emitter.simTime+=dt;if(emitter.simTime>emitter.fixedTimeStep){numSteps=Math.floor(emitter.simTime/emitter.fixedTimeStep);emitter.simTime-=numSteps*emitter.fixedTimeStep;}if(numSteps){numSteps=Math.min(numSteps,emitter.maxSubSteps);for(let i=0;i<numSteps;i++){emitter.addTime(emitter.fixedTimeStep,false);}stats._updatesPerFrame+=numSteps;stats._frameTime+=emitter._addTimeTime;emitter._addTimeTime=0;}emitter.finishFrame();}}}}}onBeforeRemove(entity,component){component.onBeforeRemove();}destroy(){super.destroy();this.app.systems.off("update",this.onUpdate,this);}constructor(app){super(app);this.id="particlesystem";this.ComponentType=ParticleSystemComponent;this.DataType=ParticleSystemComponentData;this.schema=_schema$b;this.propertyTypes={emitterExtents:"vec3",emitterExtentsInner:"vec3",particleNormal:"vec3",wrapBounds:"vec3",localVelocityGraph:"curveset",localVelocityGraph2:"curveset",velocityGraph:"curveset",velocityGraph2:"curveset",colorGraph:"curveset",colorGraph2:"curveset",alphaGraph:"curve",alphaGraph2:"curve",rotationSpeedGraph:"curve",rotationSpeedGraph2:"curve",radialSpeedGraph:"curve",radialSpeedGraph2:"curve",scaleGraph:"curve",scaleGraph2:"curve"};this.on("beforeremove",this.onBeforeRemove,this);this.app.systems.on("update",this.onUpdate,this);}}class SkinInstanceCachedObject extends RefCountedObject{constructor(skin,skinInstance){super();this.skin=skin;this.skinInstance=skinInstance;}}class SkinInstanceCache{static createCachedSkinInstance(skin,rootBone,entity){let skinInst=SkinInstanceCache.getCachedSkinInstance(skin,rootBone);if(!skinInst){skinInst=new SkinInstance(skin);skinInst.resolve(rootBone,entity);SkinInstanceCache.addCachedSkinInstance(skin,rootBone,skinInst);}return skinInst}static getCachedSkinInstance(skin,rootBone){let skinInstance=null;const cachedObjArray=SkinInstanceCache._skinInstanceCache.get(rootBone);if(cachedObjArray){const cachedObj=cachedObjArray.find(element=>element.skin===skin);if(cachedObj){cachedObj.incRefCount();skinInstance=cachedObj.skinInstance;}}return skinInstance}static addCachedSkinInstance(skin,rootBone,skinInstance){let cachedObjArray=SkinInstanceCache._skinInstanceCache.get(rootBone);if(!cachedObjArray){cachedObjArray=[];SkinInstanceCache._skinInstanceCache.set(rootBone,cachedObjArray);}let cachedObj=cachedObjArray.find(element=>element.skin===skin);if(!cachedObj){cachedObj=new SkinInstanceCachedObject(skin,skinInstance);cachedObjArray.push(cachedObj);}cachedObj.incRefCount();}static removeCachedSkinInstance(skinInstance){if(skinInstance){const rootBone=skinInstance.rootBone;if(rootBone){const cachedObjArray=SkinInstanceCache._skinInstanceCache.get(rootBone);if(cachedObjArray){const cachedObjIndex=cachedObjArray.findIndex(element=>element.skinInstance===skinInstance);if(cachedObjIndex>=0){const cachedObj=cachedObjArray[cachedObjIndex];cachedObj.decRefCount();if(cachedObj.refCount===0){cachedObjArray.splice(cachedObjIndex,1);if(!cachedObjArray.length){SkinInstanceCache._skinInstanceCache.delete(rootBone);}if(skinInstance){skinInstance.destroy();cachedObj.skinInstance=null;}}}}}}}}SkinInstanceCache._skinInstanceCache=new Map;class AssetReference{set id(value){if(this.url)throw Error("Can't set id and url");this._unbind();this._id=value;this.asset=this._registry.get(this._id);this._bind();}get id(){return this._id}set url(value){if(this.id)throw Error("Can't set id and url");this._unbind();this._url=value;this.asset=this._registry.getByUrl(this._url);this._bind();}get url(){return this._url}_bind(){if(this.id){if(this._onAssetLoad)this._evtLoadById=this._registry.on(`load:${this.id}`,this._onLoad,this);if(this._onAssetAdd)this._evtAddById=this._registry.once(`add:${this.id}`,this._onAdd,this);if(this._onAssetRemove)this._evtRemoveById=this._registry.on(`remove:${this.id}`,this._onRemove,this);if(this._onAssetUnload)this._evtUnloadById=this._registry.on(`unload:${this.id}`,this._onUnload,this);}if(this.url){if(this._onAssetLoad)this._evtLoadByUrl=this._registry.on(`load:url:${this.url}`,this._onLoad,this);if(this._onAssetAdd)this._evtAddByUrl=this._registry.once(`add:url:${this.url}`,this._onAdd,this);if(this._onAssetRemove)this._evtRemoveByUrl=this._registry.on(`remove:url:${this.url}`,this._onRemove,this);}}_unbind(){if(this.id){var _this$_evtLoadById,_this$_evtAddById,_this$_evtRemoveById,_this$_evtUnloadById;(_this$_evtLoadById=this._evtLoadById)==null||_this$_evtLoadById.off();this._evtLoadById=null;(_this$_evtAddById=this._evtAddById)==null||_this$_evtAddById.off();this._evtAddById=null;(_this$_evtRemoveById=this._evtRemoveById)==null||_this$_evtRemoveById.off();this._evtRemoveById=null;(_this$_evtUnloadById=this._evtUnloadById)==null||_this$_evtUnloadById.off();this._evtUnloadById=null;}if(this.url){var _this$_evtLoadByUrl,_this$_evtAddByUrl,_this$_evtRemoveByUrl;(_this$_evtLoadByUrl=this._evtLoadByUrl)==null||_this$_evtLoadByUrl.off();this._evtLoadByUrl=null;(_this$_evtAddByUrl=this._evtAddByUrl)==null||_this$_evtAddByUrl.off();this._evtAddByUrl=null;(_this$_evtRemoveByUrl=this._evtRemoveByUrl)==null||_this$_evtRemoveByUrl.off();this._evtRemoveByUrl=null;}}_onLoad(asset){this._onAssetLoad.call(this._scope,this.propertyName,this.parent,asset);}_onAdd(asset){this.asset=asset;this._onAssetAdd.call(this._scope,this.propertyName,this.parent,asset);}_onRemove(asset){this._onAssetRemove.call(this._scope,this.propertyName,this.parent,asset);this.asset=null;}_onUnload(asset){this._onAssetUnload.call(this._scope,this.propertyName,this.parent,asset);}constructor(propertyName,parent,registry,callbacks,scope){this._evtLoadById=null;this._evtUnloadById=null;this._evtAddById=null;this._evtRemoveById=null;this._evtLoadByUrl=null;this._evtAddByUrl=null;this._evtRemoveByUrl=null;this.propertyName=propertyName;this.parent=parent;this._scope=scope;this._registry=registry;this.id=null;this.url=null;this.asset=null;this._onAssetLoad=callbacks.load;this._onAssetAdd=callbacks.add;this._onAssetRemove=callbacks.remove;this._onAssetUnload=callbacks.unload;}}class RenderComponent extends Component{set renderStyle(renderStyle){if(this._renderStyle!==renderStyle){this._renderStyle=renderStyle;MeshInstance._prepareRenderStyleForArray(this._meshInstances,renderStyle);}}get renderStyle(){return this._renderStyle}set customAabb(value){this._customAabb=value;const mi=this._meshInstances;if(mi){for(let i=0;i<mi.length;i++){mi[i].setCustomAabb(this._customAabb);}}}get customAabb(){return this._customAabb}set type(value){if(this._type!==value){this._area=null;this._type=value;this.destroyMeshInstances();if(value!=="asset"){let material=this._material;if(!material||material===this.system.defaultMaterial){material=this._materialReferences[0]&&this._materialReferences[0].asset&&this._materialReferences[0].asset.resource;}const primData=getShapePrimitive(this.system.app.graphicsDevice,value);this._area=primData.area;this.meshInstances=[new MeshInstance(primData.mesh,material||this.system.defaultMaterial,this.entity)];}}}get type(){return this._type}set meshInstances(value){this.destroyMeshInstances();this._meshInstances=value;if(this._meshInstances){const mi=this._meshInstances;for(let i=0;i<mi.length;i++){if(!mi[i].node){mi[i].node=this.entity;}mi[i].castShadow=this._castShadows;mi[i].receiveShadow=this._receiveShadows;mi[i].renderStyle=this._renderStyle;mi[i].setLightmapped(this._lightmapped);mi[i].setCustomAabb(this._customAabb);}if(this.enabled&&this.entity.enabled){this.addToLayers();}}}get meshInstances(){return this._meshInstances}set lightmapped(value){if(value!==this._lightmapped){this._lightmapped=value;const mi=this._meshInstances;if(mi){for(let i=0;i<mi.length;i++){mi[i].setLightmapped(value);}}}}get lightmapped(){return this._lightmapped}set castShadows(value){if(this._castShadows!==value){const mi=this._meshInstances;if(mi){const layers=this.layers;const scene=this.system.app.scene;if(this._castShadows&&!value){for(let i=0;i<layers.length;i++){const layer=scene.layers.getLayerById(this.layers[i]);if(layer){layer.removeShadowCasters(mi);}}}for(let i=0;i<mi.length;i++){mi[i].castShadow=value;}if(!this._castShadows&&value){for(let i=0;i<layers.length;i++){const layer=scene.layers.getLayerById(layers[i]);if(layer){layer.addShadowCasters(mi);}}}}this._castShadows=value;}}get castShadows(){return this._castShadows}set receiveShadows(value){if(this._receiveShadows!==value){this._receiveShadows=value;const mi=this._meshInstances;if(mi){for(let i=0;i<mi.length;i++){mi[i].receiveShadow=value;}}}}get receiveShadows(){return this._receiveShadows}set castShadowsLightmap(value){this._castShadowsLightmap=value;}get castShadowsLightmap(){return this._castShadowsLightmap}set lightmapSizeMultiplier(value){this._lightmapSizeMultiplier=value;}get lightmapSizeMultiplier(){return this._lightmapSizeMultiplier}set layers(value){const layers=this.system.app.scene.layers;let layer;if(this._meshInstances){for(let i=0;i<this._layers.length;i++){layer=layers.getLayerById(this._layers[i]);if(layer){layer.removeMeshInstances(this._meshInstances);}}}this._layers.length=0;for(let i=0;i<value.length;i++){this._layers[i]=value[i];}if(!this.enabled||!this.entity.enabled||!this._meshInstances)return;for(let i=0;i<this._layers.length;i++){layer=layers.getLayerById(this._layers[i]);if(layer){layer.addMeshInstances(this._meshInstances);}}}get layers(){return this._layers}set batchGroupId(value){if(this._batchGroupId!==value){if(this.entity.enabled&&this._batchGroupId>=0){var _this$system$app$batc;(_this$system$app$batc=this.system.app.batcher)==null||_this$system$app$batc.remove(BatchGroup.RENDER,this.batchGroupId,this.entity);}if(this.entity.enabled&&value>=0){var _this$system$app$batc2;(_this$system$app$batc2=this.system.app.batcher)==null||_this$system$app$batc2.insert(BatchGroup.RENDER,value,this.entity);}if(value<0&&this._batchGroupId>=0&&this.enabled&&this.entity.enabled){this.addToLayers();}this._batchGroupId=value;}}get batchGroupId(){return this._batchGroupId}set material(value){if(this._material!==value){this._material=value;if(this._meshInstances&&this._type!=="asset"){for(let i=0;i<this._meshInstances.length;i++){this._meshInstances[i].material=value;}}}}get material(){return this._material}set materialAssets(value=[]){if(this._materialReferences.length>value.length){for(let i=value.length;i<this._materialReferences.length;i++){this._materialReferences[i].id=null;}this._materialReferences.length=value.length;}for(let i=0;i<value.length;i++){if(!this._materialReferences[i]){this._materialReferences.push(new AssetReference(i,this,this.system.app.assets,{add:this._onMaterialAdded,load:this._onMaterialLoad,remove:this._onMaterialRemove,unload:this._onMaterialUnload},this));}if(value[i]){const id=value[i]instanceof Asset?value[i].id:value[i];if(this._materialReferences[i].id!==id){this._materialReferences[i].id=id;}if(this._materialReferences[i].asset){this._onMaterialAdded(i,this,this._materialReferences[i].asset);}}else {this._materialReferences[i].id=null;if(this._meshInstances[i]){this._meshInstances[i].material=this.system.defaultMaterial;}}}}get materialAssets(){return this._materialReferences.map(ref=>{return ref.id})}set asset(value){const id=value instanceof Asset?value.id:value;if(this._assetReference.id===id)return;if(this._assetReference.asset&&this._assetReference.asset.resource){this._onRenderAssetRemove();}this._assetReference.id=id;if(this._assetReference.asset){this._onRenderAssetAdded();}}get asset(){return this._assetReference.id}assignAsset(asset){const id=asset instanceof Asset?asset.id:asset;this._assetReference.id=id;}set rootBone(value){if(this._rootBone!==value){const isString=typeof value==="string";if(this._rootBone&&isString&&this._rootBone.getGuid()===value){return}if(this._rootBone){this._clearSkinInstances();}if(value instanceof GraphNode){this._rootBone=value;}else if(isString){this._rootBone=this.system.app.getEntityFromIndex(value)||null;if(!this._rootBone);}else {this._rootBone=null;}if(this._rootBone){this._cloneSkinInstances();}}}get rootBone(){return this._rootBone}destroyMeshInstances(){const meshInstances=this._meshInstances;if(meshInstances){this.removeFromLayers();this._clearSkinInstances();for(let i=0;i<meshInstances.length;i++){meshInstances[i].destroy();}this._meshInstances.length=0;}}addToLayers(){const layers=this.system.app.scene.layers;for(let i=0;i<this._layers.length;i++){const layer=layers.getLayerById(this._layers[i]);if(layer){layer.addMeshInstances(this._meshInstances);}}}removeFromLayers(){if(this._meshInstances&&this._meshInstances.length){const layers=this.system.app.scene.layers;for(let i=0;i<this._layers.length;i++){const layer=layers.getLayerById(this._layers[i]);if(layer){layer.removeMeshInstances(this._meshInstances);}}}}onRemoveChild(){this.removeFromLayers();}onInsertChild(){if(this._meshInstances&&this.enabled&&this.entity.enabled){this.addToLayers();}}onRemove(){this.destroyMeshInstances();this.asset=null;this.materialAsset=null;this._assetReference.id=null;for(let i=0;i<this._materialReferences.length;i++){this._materialReferences[i].id=null;}this.entity.off("remove",this.onRemoveChild,this);this.entity.off("insert",this.onInsertChild,this);}onLayersChanged(oldComp,newComp){this.addToLayers();oldComp.off("add",this.onLayerAdded,this);oldComp.off("remove",this.onLayerRemoved,this);newComp.on("add",this.onLayerAdded,this);newComp.on("remove",this.onLayerRemoved,this);}onLayerAdded(layer){const index=this.layers.indexOf(layer.id);if(index<0)return;layer.addMeshInstances(this._meshInstances);}onLayerRemoved(layer){const index=this.layers.indexOf(layer.id);if(index<0)return;layer.removeMeshInstances(this._meshInstances);}onEnable(){const app=this.system.app;const scene=app.scene;const layers=scene.layers;if(this._rootBone){this._cloneSkinInstances();}this._evtLayersChanged=scene.on("set:layers",this.onLayersChanged,this);if(layers){this._evtLayerAdded=layers.on("add",this.onLayerAdded,this);this._evtLayerRemoved=layers.on("remove",this.onLayerRemoved,this);}const isAsset=this._type==="asset";if(this._meshInstances&&this._meshInstances.length){this.addToLayers();}else if(isAsset&&this.asset){this._onRenderAssetAdded();}for(let i=0;i<this._materialReferences.length;i++){if(this._materialReferences[i].asset){this.system.app.assets.load(this._materialReferences[i].asset);}}if(this._batchGroupId>=0){var _app$batcher;(_app$batcher=app.batcher)==null||_app$batcher.insert(BatchGroup.RENDER,this.batchGroupId,this.entity);}}onDisable(){var _this$_evtLayersChang;const app=this.system.app;const scene=app.scene;const layers=scene.layers;(_this$_evtLayersChang=this._evtLayersChanged)==null||_this$_evtLayersChang.off();this._evtLayersChanged=null;if(this._rootBone){this._clearSkinInstances();}if(layers){var _this$_evtLayerAdded,_this$_evtLayerRemove;(_this$_evtLayerAdded=this._evtLayerAdded)==null||_this$_evtLayerAdded.off();this._evtLayerAdded=null;(_this$_evtLayerRemove=this._evtLayerRemoved)==null||_this$_evtLayerRemove.off();this._evtLayerRemoved=null;}if(this._batchGroupId>=0){var _app$batcher2;(_app$batcher2=app.batcher)==null||_app$batcher2.remove(BatchGroup.RENDER,this.batchGroupId,this.entity);}this.removeFromLayers();}hide(){if(this._meshInstances){for(let i=0;i<this._meshInstances.length;i++){this._meshInstances[i].visible=false;}}}show(){if(this._meshInstances){for(let i=0;i<this._meshInstances.length;i++){this._meshInstances[i].visible=true;}}}_onRenderAssetAdded(){if(!this._assetReference.asset)return;if(this._assetReference.asset.resource){this._onRenderAssetLoad();}else if(this.enabled&&this.entity.enabled){this.system.app.assets.load(this._assetReference.asset);}}_onRenderAssetLoad(){this.destroyMeshInstances();if(this._assetReference.asset){var _this$_evtSetMeshes;const render=this._assetReference.asset.resource;(_this$_evtSetMeshes=this._evtSetMeshes)==null||_this$_evtSetMeshes.off();this._evtSetMeshes=render.on("set:meshes",this._onSetMeshes,this);if(render.meshes){this._onSetMeshes(render.meshes);}}}_onSetMeshes(meshes){this._cloneMeshes(meshes);}_clearSkinInstances(){for(let i=0;i<this._meshInstances.length;i++){const meshInstance=this._meshInstances[i];SkinInstanceCache.removeCachedSkinInstance(meshInstance.skinInstance);meshInstance.skinInstance=null;}}_cloneSkinInstances(){if(this._meshInstances.length&&this._rootBone instanceof GraphNode){for(let i=0;i<this._meshInstances.length;i++){const meshInstance=this._meshInstances[i];const mesh=meshInstance.mesh;if(mesh.skin&&!meshInstance.skinInstance){meshInstance.skinInstance=SkinInstanceCache.createCachedSkinInstance(mesh.skin,this._rootBone,this.entity);}}}}_cloneMeshes(meshes){if(meshes&&meshes.length){const meshInstances=[];for(let i=0;i<meshes.length;i++){const mesh=meshes[i];const material=this._materialReferences[i]&&this._materialReferences[i].asset&&this._materialReferences[i].asset.resource;const meshInst=new MeshInstance(mesh,material||this.system.defaultMaterial,this.entity);meshInstances.push(meshInst);if(mesh.morph){meshInst.morphInstance=new MorphInstance(mesh.morph);}}this.meshInstances=meshInstances;this._cloneSkinInstances();}}_onRenderAssetUnload(){if(this._type==="asset"){this.destroyMeshInstances();}}_onRenderAssetRemove(){var _this$_evtSetMeshes2;(_this$_evtSetMeshes2=this._evtSetMeshes)==null||_this$_evtSetMeshes2.off();this._evtSetMeshes=null;this._onRenderAssetUnload();}_onMaterialAdded(index,component,asset){if(asset.resource){this._onMaterialLoad(index,component,asset);}else {if(this.enabled&&this.entity.enabled){this.system.app.assets.load(asset);}}}_updateMainMaterial(index,material){if(index===0){this.material=material;}}_onMaterialLoad(index,component,asset){if(this._meshInstances[index]){this._meshInstances[index].material=asset.resource;}this._updateMainMaterial(index,asset.resource);}_onMaterialRemove(index,component,asset){if(this._meshInstances[index]){this._meshInstances[index].material=this.system.defaultMaterial;}this._updateMainMaterial(index,this.system.defaultMaterial);}_onMaterialUnload(index,component,asset){if(this._meshInstances[index]){this._meshInstances[index].material=this.system.defaultMaterial;}this._updateMainMaterial(index,this.system.defaultMaterial);}resolveDuplicatedEntityReferenceProperties(oldRender,duplicatedIdsMap){if(oldRender.rootBone){this.rootBone=duplicatedIdsMap[oldRender.rootBone.getGuid()];}}constructor(system,entity){super(system,entity);this._type="asset";this._castShadows=true;this._receiveShadows=true;this._castShadowsLightmap=true;this._lightmapped=false;this._lightmapSizeMultiplier=1;this.isStatic=false;this._batchGroupId=-1;this._layers=[LAYERID_WORLD];this._renderStyle=RENDERSTYLE_SOLID;this._meshInstances=[];this._customAabb=null;this._area=null;this._assetReference=void 0;this._materialReferences=[];this._material=void 0;this._rootBone=null;this._evtLayersChanged=null;this._evtLayerAdded=null;this._evtLayerRemoved=null;this._evtSetMeshes=null;this._assetReference=new AssetReference("asset",this,system.app.assets,{add:this._onRenderAssetAdded,load:this._onRenderAssetLoad,remove:this._onRenderAssetRemove,unload:this._onRenderAssetUnload},this);this._material=system.defaultMaterial;entity.on("remove",this.onRemoveChild,this);entity.on("removehierarchy",this.onRemoveChild,this);entity.on("insert",this.onInsertChild,this);entity.on("inserthierarchy",this.onInsertChild,this);}}class RenderComponentData{constructor(){this.enabled=true;}}const _schema$a=["enabled"];const _properties$1=["material","meshInstances","asset","materialAssets","castShadows","receiveShadows","castShadowsLightmap","lightmapped","lightmapSizeMultiplier","renderStyle","type","layers","isStatic","batchGroupId","rootBone"];class RenderComponentSystem extends ComponentSystem{initializeComponentData(component,_data,properties){if(_data.batchGroupId===null||_data.batchGroupId===undefined){_data.batchGroupId=-1;}if(_data.layers&&_data.layers.length){_data.layers=_data.layers.slice(0);}for(let i=0;i<_properties$1.length;i++){if(_data.hasOwnProperty(_properties$1[i])){component[_properties$1[i]]=_data[_properties$1[i]];}}if(_data.aabbCenter&&_data.aabbHalfExtents){component.customAabb=new BoundingBox(new Vec3(_data.aabbCenter),new Vec3(_data.aabbHalfExtents));}super.initializeComponentData(component,_data,_schema$a);}cloneComponent(entity,clone){const data={};for(let i=0;i<_properties$1.length;i++){data[_properties$1[i]]=entity.render[_properties$1[i]];}data.enabled=entity.render.enabled;delete data.meshInstances;const component=this.addComponent(clone,data);const srcMeshInstances=entity.render.meshInstances;const meshes=srcMeshInstances.map(mi=>mi.mesh);component._onSetMeshes(meshes);for(let m=0;m<srcMeshInstances.length;m++){component.meshInstances[m].material=srcMeshInstances[m].material;}if(entity.render.customAabb){component.customAabb=entity.render.customAabb.clone();}return component}onRemove(entity,component){component.onRemove();}constructor(app){super(app);this.id="render";this.ComponentType=RenderComponent;this.DataType=RenderComponentData;this.schema=_schema$a;this.defaultMaterial=getDefaultMaterial(app.graphicsDevice);this.on("beforeremove",this.onRemove,this);}}Component._buildAccessors(RenderComponent.prototype,_schema$a);class ObjectPool{_resize(size){if(size>this._pool.length){for(let i=this._pool.length;i<size;i++){this._pool[i]=new this._constructor;}}}allocate(){if(this._count>=this._pool.length){this._resize(this._pool.length*2);}return this._pool[this._count++]}freeAll(){this._count=0;}constructor(constructorFunc,size){this._constructor=void 0;this._pool=[];this._count=0;this._constructor=constructorFunc;this._resize(size);}}let _ammoTransform;let _ammoVec1,_ammoVec2,_ammoQuat;const _quat1=new Quat;const _quat2=new Quat;const _vec3=new Vec3;class RigidBodyComponent extends Component{static onLibraryLoaded(){if(typeof Ammo!=="undefined"){_ammoTransform=new Ammo.btTransform;_ammoVec1=new Ammo.btVector3;_ammoVec2=new Ammo.btVector3;_ammoQuat=new Ammo.btQuaternion;}}static onAppDestroy(){Ammo.destroy(_ammoTransform);Ammo.destroy(_ammoVec1);Ammo.destroy(_ammoVec2);Ammo.destroy(_ammoQuat);_ammoTransform=null;_ammoVec1=null;_ammoVec2=null;_ammoQuat=null;}set angularDamping(damping){if(this._angularDamping!==damping){this._angularDamping=damping;if(this._body){this._body.setDamping(this._linearDamping,damping);}}}get angularDamping(){return this._angularDamping}set angularFactor(factor){if(!this._angularFactor.equals(factor)){this._angularFactor.copy(factor);if(this._body&&this._type===BODYTYPE_DYNAMIC){_ammoVec1.setValue(factor.x,factor.y,factor.z);this._body.setAngularFactor(_ammoVec1);}}}get angularFactor(){return this._angularFactor}set angularVelocity(velocity){if(this._body&&this._type===BODYTYPE_DYNAMIC){this._body.activate();_ammoVec1.setValue(velocity.x,velocity.y,velocity.z);this._body.setAngularVelocity(_ammoVec1);this._angularVelocity.copy(velocity);}}get angularVelocity(){if(this._body&&this._type===BODYTYPE_DYNAMIC){const velocity=this._body.getAngularVelocity();this._angularVelocity.set(velocity.x(),velocity.y(),velocity.z());}return this._angularVelocity}set body(body){if(this._body!==body){this._body=body;if(body&&this._simulationEnabled){body.activate();}}}get body(){return this._body}set friction(friction){if(this._friction!==friction){this._friction=friction;if(this._body){this._body.setFriction(friction);}}}get friction(){return this._friction}set group(group){if(this._group!==group){this._group=group;if(this.enabled&&this.entity.enabled){this.disableSimulation();this.enableSimulation();}}}get group(){return this._group}set linearDamping(damping){if(this._linearDamping!==damping){this._linearDamping=damping;if(this._body){this._body.setDamping(damping,this._angularDamping);}}}get linearDamping(){return this._linearDamping}set linearFactor(factor){if(!this._linearFactor.equals(factor)){this._linearFactor.copy(factor);if(this._body&&this._type===BODYTYPE_DYNAMIC){_ammoVec1.setValue(factor.x,factor.y,factor.z);this._body.setLinearFactor(_ammoVec1);}}}get linearFactor(){return this._linearFactor}set linearVelocity(velocity){if(this._body&&this._type===BODYTYPE_DYNAMIC){this._body.activate();_ammoVec1.setValue(velocity.x,velocity.y,velocity.z);this._body.setLinearVelocity(_ammoVec1);this._linearVelocity.copy(velocity);}}get linearVelocity(){if(this._body&&this._type===BODYTYPE_DYNAMIC){const velocity=this._body.getLinearVelocity();this._linearVelocity.set(velocity.x(),velocity.y(),velocity.z());}return this._linearVelocity}set mask(mask){if(this._mask!==mask){this._mask=mask;if(this.enabled&&this.entity.enabled){this.disableSimulation();this.enableSimulation();}}}get mask(){return this._mask}set mass(mass){if(this._mass!==mass){this._mass=mass;if(this._body&&this._type===BODYTYPE_DYNAMIC){const enabled=this.enabled&&this.entity.enabled;if(enabled){this.disableSimulation();}this._body.getCollisionShape().calculateLocalInertia(mass,_ammoVec1);this._body.setMassProps(mass,_ammoVec1);this._body.updateInertiaTensor();if(enabled){this.enableSimulation();}}}}get mass(){return this._mass}set restitution(restitution){if(this._restitution!==restitution){this._restitution=restitution;if(this._body){this._body.setRestitution(restitution);}}}get restitution(){return this._restitution}set rollingFriction(friction){if(this._rollingFriction!==friction){this._rollingFriction=friction;if(this._body){this._body.setRollingFriction(friction);}}}get rollingFriction(){return this._rollingFriction}set type(type){if(this._type!==type){this._type=type;this.disableSimulation();switch(type){case BODYTYPE_DYNAMIC:this._group=BODYGROUP_DYNAMIC;this._mask=BODYMASK_ALL;break;case BODYTYPE_KINEMATIC:this._group=BODYGROUP_KINEMATIC;this._mask=BODYMASK_ALL;break;case BODYTYPE_STATIC:default:this._group=BODYGROUP_STATIC;this._mask=BODYMASK_NOT_STATIC;break}this.createBody();}}get type(){return this._type}createBody(){const entity=this.entity;let shape;if(entity.collision){shape=entity.collision.shape;if(entity.trigger){entity.trigger.destroy();delete entity.trigger;}}if(shape){if(this._body){this.system.removeBody(this._body);this.system.destroyBody(this._body);this._body=null;}const mass=this._type===BODYTYPE_DYNAMIC?this._mass:0;this._getEntityTransform(_ammoTransform);const body=this.system.createBody(mass,shape,_ammoTransform);body.setRestitution(this._restitution);body.setFriction(this._friction);body.setRollingFriction(this._rollingFriction);body.setDamping(this._linearDamping,this._angularDamping);if(this._type===BODYTYPE_DYNAMIC){const linearFactor=this._linearFactor;_ammoVec1.setValue(linearFactor.x,linearFactor.y,linearFactor.z);body.setLinearFactor(_ammoVec1);const angularFactor=this._angularFactor;_ammoVec1.setValue(angularFactor.x,angularFactor.y,angularFactor.z);body.setAngularFactor(_ammoVec1);}else if(this._type===BODYTYPE_KINEMATIC){body.setCollisionFlags(body.getCollisionFlags()|BODYFLAG_KINEMATIC_OBJECT);body.setActivationState(BODYSTATE_DISABLE_DEACTIVATION);}body.entity=entity;this.body=body;if(this.enabled&&entity.enabled){this.enableSimulation();}}}isActive(){return this._body?this._body.isActive():false}activate(){if(this._body){this._body.activate();}}enableSimulation(){const entity=this.entity;if(entity.collision&&entity.collision.enabled&&!this._simulationEnabled){const body=this._body;if(body){this.system.addBody(body,this._group,this._mask);switch(this._type){case BODYTYPE_DYNAMIC:this.system._dynamic.push(this);body.forceActivationState(BODYSTATE_ACTIVE_TAG);this.syncEntityToBody();break;case BODYTYPE_KINEMATIC:this.system._kinematic.push(this);body.forceActivationState(BODYSTATE_DISABLE_DEACTIVATION);break;case BODYTYPE_STATIC:body.forceActivationState(BODYSTATE_ACTIVE_TAG);this.syncEntityToBody();break}if(entity.collision.type==="compound"){this.system._compounds.push(entity.collision);}body.activate();this._simulationEnabled=true;}}}disableSimulation(){const body=this._body;if(body&&this._simulationEnabled){const system=this.system;let idx=system._compounds.indexOf(this.entity.collision);if(idx>-1){system._compounds.splice(idx,1);}idx=system._dynamic.indexOf(this);if(idx>-1){system._dynamic.splice(idx,1);}idx=system._kinematic.indexOf(this);if(idx>-1){system._kinematic.splice(idx,1);}system.removeBody(body);body.forceActivationState(BODYSTATE_DISABLE_SIMULATION);this._simulationEnabled=false;}}applyForce(x,y,z,px,py,pz){const body=this._body;if(body){body.activate();if(x instanceof Vec3){_ammoVec1.setValue(x.x,x.y,x.z);}else {_ammoVec1.setValue(x,y,z);}if(y instanceof Vec3){_ammoVec2.setValue(y.x,y.y,y.z);}else if(px!==undefined){_ammoVec2.setValue(px,py,pz);}else {_ammoVec2.setValue(0,0,0);}body.applyForce(_ammoVec1,_ammoVec2);}}applyTorque(x,y,z){const body=this._body;if(body){body.activate();if(x instanceof Vec3){_ammoVec1.setValue(x.x,x.y,x.z);}else {_ammoVec1.setValue(x,y,z);}body.applyTorque(_ammoVec1);}}applyImpulse(x,y,z,px,py,pz){const body=this._body;if(body){body.activate();if(x instanceof Vec3){_ammoVec1.setValue(x.x,x.y,x.z);}else {_ammoVec1.setValue(x,y,z);}if(y instanceof Vec3){_ammoVec2.setValue(y.x,y.y,y.z);}else if(px!==undefined){_ammoVec2.setValue(px,py,pz);}else {_ammoVec2.setValue(0,0,0);}body.applyImpulse(_ammoVec1,_ammoVec2);}}applyTorqueImpulse(x,y,z){const body=this._body;if(body){body.activate();if(x instanceof Vec3){_ammoVec1.setValue(x.x,x.y,x.z);}else {_ammoVec1.setValue(x,y,z);}body.applyTorqueImpulse(_ammoVec1);}}isStatic(){return this._type===BODYTYPE_STATIC}isStaticOrKinematic(){return this._type===BODYTYPE_STATIC||this._type===BODYTYPE_KINEMATIC}isKinematic(){return this._type===BODYTYPE_KINEMATIC}_getEntityTransform(transform){const entity=this.entity;const component=entity.collision;if(component){const bodyPos=component.getShapePosition();const bodyRot=component.getShapeRotation();_ammoVec1.setValue(bodyPos.x,bodyPos.y,bodyPos.z);_ammoQuat.setValue(bodyRot.x,bodyRot.y,bodyRot.z,bodyRot.w);}else {const pos=entity.getPosition();const rot=entity.getRotation();_ammoVec1.setValue(pos.x,pos.y,pos.z);_ammoQuat.setValue(rot.x,rot.y,rot.z,rot.w);}transform.setOrigin(_ammoVec1);transform.setRotation(_ammoQuat);}syncEntityToBody(){const body=this._body;if(body){this._getEntityTransform(_ammoTransform);body.setWorldTransform(_ammoTransform);if(this._type===BODYTYPE_KINEMATIC){const motionState=body.getMotionState();if(motionState){motionState.setWorldTransform(_ammoTransform);}}body.activate();}}_updateDynamic(){const body=this._body;if(body.isActive()){const motionState=body.getMotionState();if(motionState){const entity=this.entity;motionState.getWorldTransform(_ammoTransform);const p=_ammoTransform.getOrigin();const q=_ammoTransform.getRotation();const component=entity.collision;if(component&&component._hasOffset){const lo=component.data.linearOffset;const ao=component.data.angularOffset;const invertedAo=_quat2.copy(ao).invert();const entityRot=_quat1.set(q.x(),q.y(),q.z(),q.w()).mul(invertedAo);entityRot.transformVector(lo,_vec3);entity.setPosition(p.x()-_vec3.x,p.y()-_vec3.y,p.z()-_vec3.z);entity.setRotation(entityRot);}else {entity.setPosition(p.x(),p.y(),p.z());entity.setRotation(q.x(),q.y(),q.z(),q.w());}}}}_updateKinematic(){const motionState=this._body.getMotionState();if(motionState){this._getEntityTransform(_ammoTransform);motionState.setWorldTransform(_ammoTransform);}}teleport(x,y,z,rx,ry,rz){if(x instanceof Vec3){this.entity.setPosition(x);}else {this.entity.setPosition(x,y,z);}if(y instanceof Quat){this.entity.setRotation(y);}else if(y instanceof Vec3){this.entity.setEulerAngles(y);}else if(rx!==undefined){this.entity.setEulerAngles(rx,ry,rz);}this.syncEntityToBody();}onEnable(){if(!this._body){this.createBody();}this.enableSimulation();}onDisable(){this.disableSimulation();}constructor(system,entity){super(system,entity);this._angularDamping=0;this._angularFactor=new Vec3(1,1,1);this._angularVelocity=new Vec3;this._body=null;this._friction=.5;this._group=BODYGROUP_STATIC;this._linearDamping=0;this._linearFactor=new Vec3(1,1,1);this._linearVelocity=new Vec3;this._mask=BODYMASK_NOT_STATIC;this._mass=1;this._restitution=0;this._rollingFriction=0;this._simulationEnabled=false;this._type=BODYTYPE_STATIC;}}RigidBodyComponent.EVENT_CONTACT="contact";RigidBodyComponent.EVENT_COLLISIONSTART="collisionstart";RigidBodyComponent.EVENT_COLLISIONEND="collisionend";RigidBodyComponent.EVENT_TRIGGERENTER="triggerenter";RigidBodyComponent.EVENT_TRIGGERLEAVE="triggerleave";class RigidBodyComponentData{constructor(){this.enabled=true;}}let ammoRayStart,ammoRayEnd;class RaycastResult{constructor(entity,point,normal,hitFraction){this.entity=void 0;this.point=void 0;this.normal=void 0;this.hitFraction=void 0;this.entity=entity;this.point=point;this.normal=normal;this.hitFraction=hitFraction;}}class SingleContactResult{constructor(a,b,contactPoint){this.a=void 0;this.b=void 0;this.impulse=void 0;this.localPointA=void 0;this.localPointB=void 0;this.pointA=void 0;this.pointB=void 0;this.normal=void 0;if(arguments.length!==0){this.a=a;this.b=b;this.impulse=contactPoint.impulse;this.localPointA=contactPoint.localPoint;this.localPointB=contactPoint.localPointOther;this.pointA=contactPoint.point;this.pointB=contactPoint.pointOther;this.normal=contactPoint.normal;}else {this.a=null;this.b=null;this.impulse=0;this.localPointA=new Vec3;this.localPointB=new Vec3;this.pointA=new Vec3;this.pointB=new Vec3;this.normal=new Vec3;}}}class ContactPoint{constructor(localPoint=new Vec3,localPointOther=new Vec3,point=new Vec3,pointOther=new Vec3,normal=new Vec3,impulse=0){this.localPoint=void 0;this.localPointOther=void 0;this.point=void 0;this.pointOther=void 0;this.normal=void 0;this.impulse=void 0;this.localPoint=localPoint;this.localPointOther=localPointOther;this.point=point;this.pointOther=pointOther;this.normal=normal;this.impulse=impulse;}}class ContactResult{constructor(other,contacts){this.other=void 0;this.contacts=void 0;this.other=other;this.contacts=contacts;}}const _schema$9=["enabled"];class RigidBodyComponentSystem extends ComponentSystem{onLibraryLoaded(){if(typeof Ammo!=="undefined"){this.collisionConfiguration=new Ammo.btDefaultCollisionConfiguration;this.dispatcher=new Ammo.btCollisionDispatcher(this.collisionConfiguration);this.overlappingPairCache=new Ammo.btDbvtBroadphase;this.solver=new Ammo.btSequentialImpulseConstraintSolver;this.dynamicsWorld=new Ammo.btDiscreteDynamicsWorld(this.dispatcher,this.overlappingPairCache,this.solver,this.collisionConfiguration);if(this.dynamicsWorld.setInternalTickCallback){const checkForCollisionsPointer=Ammo.addFunction(this._checkForCollisions.bind(this),"vif");this.dynamicsWorld.setInternalTickCallback(checkForCollisionsPointer);}ammoRayStart=new Ammo.btVector3;ammoRayEnd=new Ammo.btVector3;RigidBodyComponent.onLibraryLoaded();this.contactPointPool=new ObjectPool(ContactPoint,1);this.contactResultPool=new ObjectPool(ContactResult,1);this.singleContactResultPool=new ObjectPool(SingleContactResult,1);this.app.systems.on("update",this.onUpdate,this);}else {this.app.systems.off("update",this.onUpdate,this);}}initializeComponentData(component,data,properties){const props=["mass","linearDamping","angularDamping","linearFactor","angularFactor","friction","rollingFriction","restitution","type","group","mask"];for(const property of props){if(data.hasOwnProperty(property)){const value=data[property];if(Array.isArray(value)){component[property]=new Vec3(value[0],value[1],value[2]);}else {component[property]=value;}}}super.initializeComponentData(component,data,["enabled"]);}cloneComponent(entity,clone){const rigidbody=entity.rigidbody;const data={enabled:rigidbody.enabled,mass:rigidbody.mass,linearDamping:rigidbody.linearDamping,angularDamping:rigidbody.angularDamping,linearFactor:[rigidbody.linearFactor.x,rigidbody.linearFactor.y,rigidbody.linearFactor.z],angularFactor:[rigidbody.angularFactor.x,rigidbody.angularFactor.y,rigidbody.angularFactor.z],friction:rigidbody.friction,rollingFriction:rigidbody.rollingFriction,restitution:rigidbody.restitution,type:rigidbody.type,group:rigidbody.group,mask:rigidbody.mask};return this.addComponent(clone,data)}onBeforeRemove(entity,component){if(component.enabled){component.enabled=false;}if(component.body){this.destroyBody(component.body);component.body=null;}}addBody(body,group,mask){if(group!==undefined&&mask!==undefined){this.dynamicsWorld.addRigidBody(body,group,mask);}else {this.dynamicsWorld.addRigidBody(body);}}removeBody(body){this.dynamicsWorld.removeRigidBody(body);}createBody(mass,shape,transform){const localInertia=new Ammo.btVector3(0,0,0);if(mass!==0){shape.calculateLocalInertia(mass,localInertia);}const motionState=new Ammo.btDefaultMotionState(transform);const bodyInfo=new Ammo.btRigidBodyConstructionInfo(mass,motionState,shape,localInertia);const body=new Ammo.btRigidBody(bodyInfo);Ammo.destroy(bodyInfo);Ammo.destroy(localInertia);return body}destroyBody(body){const motionState=body.getMotionState();if(motionState){Ammo.destroy(motionState);}Ammo.destroy(body);}raycastFirst(start,end,options={}){if(options.filterTags||options.filterCallback){options.sort=true;return this.raycastAll(start,end,options)[0]||null}let result=null;ammoRayStart.setValue(start.x,start.y,start.z);ammoRayEnd.setValue(end.x,end.y,end.z);const rayCallback=new Ammo.ClosestRayResultCallback(ammoRayStart,ammoRayEnd);if(typeof options.filterCollisionGroup==="number"){rayCallback.set_m_collisionFilterGroup(options.filterCollisionGroup);}if(typeof options.filterCollisionMask==="number"){rayCallback.set_m_collisionFilterMask(options.filterCollisionMask);}this.dynamicsWorld.rayTest(ammoRayStart,ammoRayEnd,rayCallback);if(rayCallback.hasHit()){const collisionObj=rayCallback.get_m_collisionObject();const body=Ammo.castObject(collisionObj,Ammo.btRigidBody);if(body){const point=rayCallback.get_m_hitPointWorld();const normal=rayCallback.get_m_hitNormalWorld();result=new RaycastResult(body.entity,new Vec3(point.x(),point.y(),point.z()),new Vec3(normal.x(),normal.y(),normal.z()),rayCallback.get_m_closestHitFraction());}}Ammo.destroy(rayCallback);return result}raycastAll(start,end,options={}){const results=[];ammoRayStart.setValue(start.x,start.y,start.z);ammoRayEnd.setValue(end.x,end.y,end.z);const rayCallback=new Ammo.AllHitsRayResultCallback(ammoRayStart,ammoRayEnd);if(typeof options.filterCollisionGroup==="number"){rayCallback.set_m_collisionFilterGroup(options.filterCollisionGroup);}if(typeof options.filterCollisionMask==="number"){rayCallback.set_m_collisionFilterMask(options.filterCollisionMask);}this.dynamicsWorld.rayTest(ammoRayStart,ammoRayEnd,rayCallback);if(rayCallback.hasHit()){const collisionObjs=rayCallback.get_m_collisionObjects();const points=rayCallback.get_m_hitPointWorld();const normals=rayCallback.get_m_hitNormalWorld();const hitFractions=rayCallback.get_m_hitFractions();const numHits=collisionObjs.size();for(let i=0;i<numHits;i++){const body=Ammo.castObject(collisionObjs.at(i),Ammo.btRigidBody);if(body&&body.entity){if(options.filterTags&&!body.entity.tags.has(...options.filterTags)||options.filterCallback&&!options.filterCallback(body.entity)){continue}const point=points.at(i);const normal=normals.at(i);const result=new RaycastResult(body.entity,new Vec3(point.x(),point.y(),point.z()),new Vec3(normal.x(),normal.y(),normal.z()),hitFractions.at(i));results.push(result);}}if(options.sort){results.sort((a,b)=>a.hitFraction-b.hitFraction);}}Ammo.destroy(rayCallback);return results}_storeCollision(entity,other){let isNewCollision=false;const guid=entity.getGuid();this.collisions[guid]=this.collisions[guid]||{others:[],entity:entity};if(this.collisions[guid].others.indexOf(other)<0){this.collisions[guid].others.push(other);isNewCollision=true;}this.frameCollisions[guid]=this.frameCollisions[guid]||{others:[],entity:entity};this.frameCollisions[guid].others.push(other);return isNewCollision}_createContactPointFromAmmo(contactPoint){const localPointA=contactPoint.get_m_localPointA();const localPointB=contactPoint.get_m_localPointB();const positionWorldOnA=contactPoint.getPositionWorldOnA();const positionWorldOnB=contactPoint.getPositionWorldOnB();const normalWorldOnB=contactPoint.get_m_normalWorldOnB();const contact=this.contactPointPool.allocate();contact.localPoint.set(localPointA.x(),localPointA.y(),localPointA.z());contact.localPointOther.set(localPointB.x(),localPointB.y(),localPointB.z());contact.point.set(positionWorldOnA.x(),positionWorldOnA.y(),positionWorldOnA.z());contact.pointOther.set(positionWorldOnB.x(),positionWorldOnB.y(),positionWorldOnB.z());contact.normal.set(normalWorldOnB.x(),normalWorldOnB.y(),normalWorldOnB.z());contact.impulse=contactPoint.getAppliedImpulse();return contact}_createReverseContactPointFromAmmo(contactPoint){const localPointA=contactPoint.get_m_localPointA();const localPointB=contactPoint.get_m_localPointB();const positionWorldOnA=contactPoint.getPositionWorldOnA();const positionWorldOnB=contactPoint.getPositionWorldOnB();const normalWorldOnB=contactPoint.get_m_normalWorldOnB();const contact=this.contactPointPool.allocate();contact.localPointOther.set(localPointA.x(),localPointA.y(),localPointA.z());contact.localPoint.set(localPointB.x(),localPointB.y(),localPointB.z());contact.pointOther.set(positionWorldOnA.x(),positionWorldOnA.y(),positionWorldOnA.z());contact.point.set(positionWorldOnB.x(),positionWorldOnB.y(),positionWorldOnB.z());contact.normal.set(normalWorldOnB.x(),normalWorldOnB.y(),normalWorldOnB.z());contact.impulse=contactPoint.getAppliedImpulse();return contact}_createSingleContactResult(a,b,contactPoint){const result=this.singleContactResultPool.allocate();result.a=a;result.b=b;result.localPointA=contactPoint.localPoint;result.localPointB=contactPoint.localPointOther;result.pointA=contactPoint.point;result.pointB=contactPoint.pointOther;result.normal=contactPoint.normal;result.impulse=contactPoint.impulse;return result}_createContactResult(other,contacts){const result=this.contactResultPool.allocate();result.other=other;result.contacts=contacts;return result}_cleanOldCollisions(){for(const guid in this.collisions){if(this.collisions.hasOwnProperty(guid)){const frameCollision=this.frameCollisions[guid];const collision=this.collisions[guid];const entity=collision.entity;const entityCollision=entity.collision;const entityRigidbody=entity.rigidbody;const others=collision.others;const length=others.length;let i=length;while(i--){const other=others[i];if(!frameCollision||frameCollision.others.indexOf(other)<0){others.splice(i,1);if(entity.trigger){if(entityCollision){entityCollision.fire("triggerleave",other);}if(other.rigidbody){other.rigidbody.fire("triggerleave",entity);}}else if(!other.trigger){if(entityRigidbody){entityRigidbody.fire("collisionend",other);}if(entityCollision){entityCollision.fire("collisionend",other);}}}}if(others.length===0){delete this.collisions[guid];}}}}_hasContactEvent(entity){const c=entity.collision;if(c&&(c.hasEvent("collisionstart")||c.hasEvent("collisionend")||c.hasEvent("contact"))){return true}const r=entity.rigidbody;return r&&(r.hasEvent("collisionstart")||r.hasEvent("collisionend")||r.hasEvent("contact"))}_checkForCollisions(world,timeStep){const dynamicsWorld=Ammo.wrapPointer(world,Ammo.btDynamicsWorld);const dispatcher=dynamicsWorld.getDispatcher();const numManifolds=dispatcher.getNumManifolds();this.frameCollisions={};for(let i=0;i<numManifolds;i++){const manifold=dispatcher.getManifoldByIndexInternal(i);const body0=manifold.getBody0();const body1=manifold.getBody1();const wb0=Ammo.castObject(body0,Ammo.btRigidBody);const wb1=Ammo.castObject(body1,Ammo.btRigidBody);const e0=wb0.entity;const e1=wb1.entity;if(!e0||!e1){continue}const flags0=wb0.getCollisionFlags();const flags1=wb1.getCollisionFlags();const numContacts=manifold.getNumContacts();const forwardContacts=[];const reverseContacts=[];let newCollision;if(numContacts>0){if(flags0&BODYFLAG_NORESPONSE_OBJECT||flags1&BODYFLAG_NORESPONSE_OBJECT){const e0Events=e0.collision&&(e0.collision.hasEvent("triggerenter")||e0.collision.hasEvent("triggerleave"));const e1Events=e1.collision&&(e1.collision.hasEvent("triggerenter")||e1.collision.hasEvent("triggerleave"));const e0BodyEvents=e0.rigidbody&&(e0.rigidbody.hasEvent("triggerenter")||e0.rigidbody.hasEvent("triggerleave"));const e1BodyEvents=e1.rigidbody&&(e1.rigidbody.hasEvent("triggerenter")||e1.rigidbody.hasEvent("triggerleave"));if(e0Events){newCollision=this._storeCollision(e0,e1);if(newCollision&&!(flags1&BODYFLAG_NORESPONSE_OBJECT)){e0.collision.fire("triggerenter",e1);}}if(e1Events){newCollision=this._storeCollision(e1,e0);if(newCollision&&!(flags0&BODYFLAG_NORESPONSE_OBJECT)){e1.collision.fire("triggerenter",e0);}}if(e0BodyEvents){if(!newCollision){newCollision=this._storeCollision(e1,e0);}if(newCollision){e0.rigidbody.fire("triggerenter",e1);}}if(e1BodyEvents){if(!newCollision){newCollision=this._storeCollision(e0,e1);}if(newCollision){e1.rigidbody.fire("triggerenter",e0);}}}else {const e0Events=this._hasContactEvent(e0);const e1Events=this._hasContactEvent(e1);const globalEvents=this.hasEvent("contact");if(globalEvents||e0Events||e1Events){for(let j=0;j<numContacts;j++){const btContactPoint=manifold.getContactPoint(j);const contactPoint=this._createContactPointFromAmmo(btContactPoint);if(e0Events||e1Events){forwardContacts.push(contactPoint);const reverseContactPoint=this._createReverseContactPointFromAmmo(btContactPoint);reverseContacts.push(reverseContactPoint);}if(globalEvents){const result=this._createSingleContactResult(e0,e1,contactPoint);this.fire("contact",result);}}if(e0Events){const forwardResult=this._createContactResult(e1,forwardContacts);newCollision=this._storeCollision(e0,e1);if(e0.collision){e0.collision.fire("contact",forwardResult);if(newCollision){e0.collision.fire("collisionstart",forwardResult);}}if(e0.rigidbody){e0.rigidbody.fire("contact",forwardResult);if(newCollision){e0.rigidbody.fire("collisionstart",forwardResult);}}}if(e1Events){const reverseResult=this._createContactResult(e0,reverseContacts);newCollision=this._storeCollision(e1,e0);if(e1.collision){e1.collision.fire("contact",reverseResult);if(newCollision){e1.collision.fire("collisionstart",reverseResult);}}if(e1.rigidbody){e1.rigidbody.fire("contact",reverseResult);if(newCollision){e1.rigidbody.fire("collisionstart",reverseResult);}}}}}}}this._cleanOldCollisions();this.contactPointPool.freeAll();this.contactResultPool.freeAll();this.singleContactResultPool.freeAll();}onUpdate(dt){let i,len;this._gravityFloat32[0]=this.gravity.x;this._gravityFloat32[1]=this.gravity.y;this._gravityFloat32[2]=this.gravity.z;const gravity=this.dynamicsWorld.getGravity();if(gravity.x()!==this._gravityFloat32[0]||gravity.y()!==this._gravityFloat32[1]||gravity.z()!==this._gravityFloat32[2]){gravity.setValue(this.gravity.x,this.gravity.y,this.gravity.z);this.dynamicsWorld.setGravity(gravity);}const triggers=this._triggers;for(i=0,len=triggers.length;i<len;i++){triggers[i].updateTransform();}const compounds=this._compounds;for(i=0,len=compounds.length;i<len;i++){compounds[i]._updateCompound();}const kinematic=this._kinematic;for(i=0,len=kinematic.length;i<len;i++){kinematic[i]._updateKinematic();}this.dynamicsWorld.stepSimulation(dt,this.maxSubSteps,this.fixedTimeStep);const dynamic=this._dynamic;for(i=0,len=dynamic.length;i<len;i++){dynamic[i]._updateDynamic();}if(!this.dynamicsWorld.setInternalTickCallback){this._checkForCollisions(Ammo.getPointer(this.dynamicsWorld),dt);}}destroy(){super.destroy();this.app.systems.off("update",this.onUpdate,this);if(typeof Ammo!=="undefined"){Ammo.destroy(this.dynamicsWorld);Ammo.destroy(this.solver);Ammo.destroy(this.overlappingPairCache);Ammo.destroy(this.dispatcher);Ammo.destroy(this.collisionConfiguration);Ammo.destroy(ammoRayStart);Ammo.destroy(ammoRayEnd);this.dynamicsWorld=null;this.solver=null;this.overlappingPairCache=null;this.dispatcher=null;this.collisionConfiguration=null;ammoRayStart=null;ammoRayEnd=null;RigidBodyComponent.onAppDestroy();}}constructor(app){super(app);this.maxSubSteps=10;this.fixedTimeStep=1/60;this.gravity=new Vec3(0,-9.81,0);this._gravityFloat32=new Float32Array(3);this._dynamic=[];this._kinematic=[];this._triggers=[];this._compounds=[];this.id="rigidbody";this._stats=app.stats.frame;this.ComponentType=RigidBodyComponent;this.DataType=RigidBodyComponentData;this.contactPointPool=null;this.contactResultPool=null;this.singleContactResultPool=null;this.schema=_schema$9;this.collisions={};this.frameCollisions={};this.on("beforeremove",this.onBeforeRemove,this);}}RigidBodyComponentSystem.EVENT_CONTACT="contact";Component._buildAccessors(RigidBodyComponent.prototype,_schema$9);const SCALEMODE_NONE="none";const SCALEMODE_BLEND="blend";const _transform=new Mat4;class ScreenComponent extends Component{syncDrawOrder(){this.system.queueDrawOrderSync(this.entity.getGuid(),this._processDrawOrderSync,this);}_recurseDrawOrderSync(e,i){if(!(e instanceof Entity)){return i}if(e.element){const prevDrawOrder=e.element.drawOrder;e.element.drawOrder=i++;if(e.element._batchGroupId>=0&&prevDrawOrder!==e.element.drawOrder){var _this$system$app$batc;(_this$system$app$batc=this.system.app.batcher)==null||_this$system$app$batc.markGroupDirty(e.element._batchGroupId);}}if(e.particlesystem){e.particlesystem.drawOrder=i++;}const children=e.children;for(let j=0;j<children.length;j++){i=this._recurseDrawOrderSync(children[j],i);}return i}_processDrawOrderSync(){const i=1;this._recurseDrawOrderSync(this.entity,i);this.fire("syncdraworder");}_calcProjectionMatrix(){const w=this._resolution.x/this.scale;const h=this._resolution.y/this.scale;const left=0;const right=w;const bottom=-h;const top=0;const near=1;const far=-1;this._screenMatrix.setOrtho(left,right,bottom,top,near,far);if(!this._screenSpace){_transform.setScale(.5*w,.5*h,1);this._screenMatrix.mul2(_transform,this._screenMatrix);}}_updateScale(){this.scale=this._calcScale(this._resolution,this.referenceResolution);}_calcScale(resolution,referenceResolution){const lx=Math.log2((resolution.x||1)/referenceResolution.x);const ly=Math.log2((resolution.y||1)/referenceResolution.y);return Math.pow(2,lx*(1-this._scaleBlend)+ly*this._scaleBlend)}_onResize(width,height){if(this._screenSpace){this._resolution.set(width,height);this.resolution=this._resolution;}}_bindElement(element){this._elements.add(element);}_unbindElement(element){this._elements.delete(element);}onRemove(){this.system.app.graphicsDevice.off("resizecanvas",this._onResize,this);this.fire("remove");this._elements.forEach(element=>element._onScreenRemove());this._elements.clear();this.off();}set resolution(value){if(!this._screenSpace){this._resolution.set(value.x,value.y);}else {this._resolution.set(this.system.app.graphicsDevice.width,this.system.app.graphicsDevice.height);}this._updateScale();this._calcProjectionMatrix();if(!this.entity._dirtyLocal){this.entity._dirtifyLocal();}this.fire("set:resolution",this._resolution);this._elements.forEach(element=>element._onScreenResize(this._resolution));}get resolution(){return this._resolution}set referenceResolution(value){this._referenceResolution.set(value.x,value.y);this._updateScale();this._calcProjectionMatrix();if(!this.entity._dirtyLocal){this.entity._dirtifyLocal();}this.fire("set:referenceresolution",this._resolution);this._elements.forEach(element=>element._onScreenResize(this._resolution));}get referenceResolution(){if(this._scaleMode===SCALEMODE_NONE){return this._resolution}return this._referenceResolution}set screenSpace(value){this._screenSpace=value;if(this._screenSpace){this._resolution.set(this.system.app.graphicsDevice.width,this.system.app.graphicsDevice.height);}this.resolution=this._resolution;if(!this.entity._dirtyLocal){this.entity._dirtifyLocal();}this.fire("set:screenspace",this._screenSpace);this._elements.forEach(element=>element._onScreenSpaceChange());}get screenSpace(){return this._screenSpace}set scaleMode(value){if(value!==SCALEMODE_NONE&&value!==SCALEMODE_BLEND){value=SCALEMODE_NONE;}if(!this._screenSpace&&value!==SCALEMODE_NONE){value=SCALEMODE_NONE;}this._scaleMode=value;this.resolution=this._resolution;this.fire("set:scalemode",this._scaleMode);}get scaleMode(){return this._scaleMode}set scaleBlend(value){this._scaleBlend=value;this._updateScale();this._calcProjectionMatrix();if(!this.entity._dirtyLocal){this.entity._dirtifyLocal();}this.fire("set:scaleblend",this._scaleBlend);this._elements.forEach(element=>element._onScreenResize(this._resolution));}get scaleBlend(){return this._scaleBlend}set priority(value){if(value>255){value=255;}if(this._priority===value){return}this._priority=value;this.syncDrawOrder();}get priority(){return this._priority}constructor(system,entity){super(system,entity);this._resolution=new Vec2(640,320);this._referenceResolution=new Vec2(640,320);this._scaleMode=SCALEMODE_NONE;this.scale=1;this._scaleBlend=.5;this._priority=0;this._screenSpace=false;this.cull=this._screenSpace;this._screenMatrix=new Mat4;this._elements=new Set;system.app.graphicsDevice.on("resizecanvas",this._onResize,this);}}class ScreenComponentData{constructor(){this.enabled=true;}}const _schema$8=["enabled"];class ScreenComponentSystem extends ComponentSystem{initializeComponentData(component,data,properties){if(data.priority!==undefined)component.priority=data.priority;if(data.screenSpace!==undefined)component.screenSpace=data.screenSpace;component.cull=component.screenSpace;if(data.scaleMode!==undefined)component.scaleMode=data.scaleMode;if(data.scaleBlend!==undefined)component.scaleBlend=data.scaleBlend;if(data.resolution!==undefined){if(data.resolution instanceof Vec2){component._resolution.copy(data.resolution);}else {component._resolution.set(data.resolution[0],data.resolution[1]);}component.resolution=component._resolution;}if(data.referenceResolution!==undefined){if(data.referenceResolution instanceof Vec2){component._referenceResolution.copy(data.referenceResolution);}else {component._referenceResolution.set(data.referenceResolution[0],data.referenceResolution[1]);}component.referenceResolution=component._referenceResolution;}component.syncDrawOrder();super.initializeComponentData(component,data,properties);}destroy(){super.destroy();this.app.graphicsDevice.off("resizecanvas",this._onResize,this);this.app.systems.off("update",this._onUpdate,this);}_onUpdate(dt){const components=this.store;for(const id in components){if(components[id].entity.screen.update)components[id].entity.screen.update(dt);}}_onResize(width,height){this.windowResolution.x=width;this.windowResolution.y=height;}cloneComponent(entity,clone){const screen=entity.screen;return this.addComponent(clone,{enabled:screen.enabled,screenSpace:screen.screenSpace,scaleMode:screen.scaleMode,resolution:screen.resolution.clone(),referenceResolution:screen.referenceResolution.clone()})}onRemoveComponent(entity,component){component.onRemove();}processDrawOrderSyncQueue(){const list=this._drawOrderSyncQueue.list();for(let i=0;i<list.length;i++){const item=list[i];item.callback.call(item.scope);}this._drawOrderSyncQueue.clear();}queueDrawOrderSync(id,fn,scope){if(!this._drawOrderSyncQueue.list().length){this.app.once("prerender",this.processDrawOrderSyncQueue,this);}if(!this._drawOrderSyncQueue.has(id)){this._drawOrderSyncQueue.push(id,{callback:fn,scope:scope});}}constructor(app){super(app);this.id="screen";this.ComponentType=ScreenComponent;this.DataType=ScreenComponentData;this.schema=_schema$8;this.windowResolution=new Vec2;this._drawOrderSyncQueue=new IndexedList;this.app.graphicsDevice.on("resizecanvas",this._onResize,this);this.app.systems.on("update",this._onUpdate,this);this.on("beforeremove",this.onRemoveComponent,this);}}Component._buildAccessors(ScreenComponent.prototype,_schema$8);class ScriptLegacyComponent extends Component{send(name,functionName){const args=Array.prototype.slice.call(arguments,2);const instances=this.entity.script.instances;let fn;if(instances&&instances[name]){fn=instances[name].instance[functionName];if(fn){return fn.apply(instances[name].instance,args)}}return undefined}onEnable(){if(this.data.areScriptsLoaded&&!this.system.preloading){if(!this.data.initialized){this.system._initializeScriptComponent(this);}else {this.system._enableScriptComponent(this);}if(!this.data.postInitialized){this.system._postInitializeScriptComponent(this);}}}onDisable(){this.system._disableScriptComponent(this);}onSetScripts(name,oldValue,newValue){if(!this.system._inTools||this.runInTools){if(this._updateScriptAttributes(oldValue,newValue)){return}if(this.enabled){this.system._disableScriptComponent(this);}this.system._destroyScriptComponent(this);this.data.areScriptsLoaded=false;const scripts=newValue;const urls=scripts.map(s=>{return s.url});if(this._loadFromCache(urls)){return}this._loadScripts(urls);}}_updateScriptAttributes(oldValue,newValue){let onlyUpdateAttributes=true;if(oldValue.length!==newValue.length){onlyUpdateAttributes=false;}else {for(let i=0,len=newValue.length;i<len;i++){if(oldValue[i].url!==newValue[i].url){onlyUpdateAttributes=false;break}}}if(onlyUpdateAttributes){for(const key in this.instances){if(this.instances.hasOwnProperty(key)){this.system._updateAccessors(this.entity,this.instances[key]);}}}return onlyUpdateAttributes}_loadFromCache(urls){const cached=[];const prefix=this.system.app._scriptPrefix||"";const regex=/^https?:\/\//i;for(let i=0,len=urls.length;i<len;i++){let url=urls[i];if(!regex.test(url)){url=path.join(prefix,url);}const type=this.system.app.loader.getFromCache(url,"script");if(!type){return false}cached.push(type);}for(let i=0,len=cached.length;i<len;i++){const ScriptType=cached[i];if(ScriptType===true){continue}if(ScriptType&&this.entity.script){if(!this.entity.script.instances[ScriptType._pcScriptName]){const instance=new ScriptType(this.entity);this.system._preRegisterInstance(this.entity,urls[i],ScriptType._pcScriptName,instance);}}}if(this.data){this.data.areScriptsLoaded=true;}if(!this.system.preloading){this.system.onInitialize(this.entity);this.system.onPostInitialize(this.entity);}return true}_loadScripts(urls){let count=urls.length;const prefix=this.system.app._scriptPrefix||"";urls.forEach(url=>{let _url=null;let _unprefixed=null;if(url.toLowerCase().startsWith("http://")||url.toLowerCase().startsWith("https://")){_unprefixed=url;_url=url;}else {_unprefixed=url;_url=path.join(prefix,url);}this.system.app.loader.load(_url,"script",(err,ScriptType)=>{count--;if(!err){if(ScriptType&&this.entity.script){if(!this.entity.script.instances[ScriptType._pcScriptName]){const instance=new ScriptType(this.entity);this.system._preRegisterInstance(this.entity,_unprefixed,ScriptType._pcScriptName,instance);}}}else {console.error(err);}if(count===0){this.data.areScriptsLoaded=true;if(!this.system.preloading){this.system.onInitialize(this.entity);this.system.onPostInitialize(this.entity);}}});});}constructor(system,entity){super(system,entity);this.on("set_scripts",this.onSetScripts,this);}}class ScriptLegacyComponentData{constructor(){this.scripts=[];this.enabled=true;this.instances={};this._instances={};this.runInTools=false;this.attributes={};this.initialized=false;this.postInitialized=false;this.areScriptsLoaded=false;}}const _schema$7=["enabled","scripts","instances","runInTools"];const INITIALIZE="initialize";const POST_INITIALIZE="postInitialize";const UPDATE="update";const POST_UPDATE="postUpdate";const FIXED_UPDATE="fixedUpdate";const TOOLS_UPDATE="toolsUpdate";const ON_ENABLE="onEnable";const ON_DISABLE="onDisable";class ScriptLegacyComponentSystem extends ComponentSystem{initializeComponentData(component,data,properties){properties=["runInTools","enabled","scripts"];if(data.scripts&&data.scripts.length){data.scripts.forEach(script=>{if(script.attributes&&Array.isArray(script.attributes)){const dict={};for(let i=0;i<script.attributes.length;i++){dict[script.attributes[i].name]=script.attributes[i];}script.attributes=dict;}});}super.initializeComponentData(component,data,properties);}cloneComponent(entity,clone){const src=this.store[entity.getGuid()];const data={runInTools:src.data.runInTools,scripts:[],enabled:src.data.enabled};const scripts=src.data.scripts;for(let i=0,len=scripts.length;i<len;i++){const attributes=scripts[i].attributes;if(attributes){delete scripts[i].attributes;}data.scripts.push(extend({},scripts[i]));if(attributes){data.scripts[i].attributes=this._cloneAttributes(attributes);scripts[i].attributes=attributes;}}return this.addComponent(clone,data)}onBeforeRemove(entity,component){if(component.enabled){this._disableScriptComponent(component);}this._destroyScriptComponent(component);}onInitialize(root){this._registerInstances(root);if(root.enabled){if(root.script&&root.script.enabled){this._initializeScriptComponent(root.script);}const children=root._children;for(let i=0,len=children.length;i<len;i++){if(children[i]instanceof Entity){this.onInitialize(children[i]);}}}}onPostInitialize(root){if(root.enabled){if(root.script&&root.script.enabled){this._postInitializeScriptComponent(root.script);}const children=root._children;for(let i=0,len=children.length;i<len;i++){if(children[i]instanceof Entity){this.onPostInitialize(children[i]);}}}}_callInstancesMethod(script,method){const instances=script.data.instances;for(const name in instances){if(instances.hasOwnProperty(name)){const instance=instances[name].instance;if(instance[method]){instance[method]();}}}}_initializeScriptComponent(script){this._callInstancesMethod(script,INITIALIZE);script.data.initialized=true;if(script.enabled&&script.entity.enabled){this._enableScriptComponent(script);}}_enableScriptComponent(script){this._callInstancesMethod(script,ON_ENABLE);}_disableScriptComponent(script){this._callInstancesMethod(script,ON_DISABLE);}_destroyScriptComponent(script){const instances=script.data.instances;for(const name in instances){if(instances.hasOwnProperty(name)){const instance=instances[name].instance;if(instance.destroy){instance.destroy();}if(instance.update){const index=this.instancesWithUpdate.indexOf(instance);if(index>=0){this.instancesWithUpdate.splice(index,1);}}if(instance.fixedUpdate){const index=this.instancesWithFixedUpdate.indexOf(instance);if(index>=0){this.instancesWithFixedUpdate.splice(index,1);}}if(instance.postUpdate){const index=this.instancesWithPostUpdate.indexOf(instance);if(index>=0){this.instancesWithPostUpdate.splice(index,1);}}if(instance.toolsUpdate){const index=this.instancesWithToolsUpdate.indexOf(instance);if(index>=0){this.instancesWithToolsUpdate.splice(index,1);}}if(script.instances[name].instance===script[name]){delete script[name];}delete script.instances[name];}}}_postInitializeScriptComponent(script){this._callInstancesMethod(script,POST_INITIALIZE);script.data.postInitialized=true;}_updateInstances(method,updateList,dt){for(let i=0,len=updateList.length;i<len;i++){const item=updateList[i];if(item&&item.entity&&item.entity.enabled&&item.entity.script.enabled){item[method](dt);}}}onUpdate(dt){this._updateInstances(UPDATE,this.instancesWithUpdate,dt);}onFixedUpdate(dt){this._updateInstances(FIXED_UPDATE,this.instancesWithFixedUpdate,dt);}onPostUpdate(dt){this._updateInstances(POST_UPDATE,this.instancesWithPostUpdate,dt);}onToolsUpdate(dt){this._updateInstances(TOOLS_UPDATE,this.instancesWithToolsUpdate,dt);}broadcast(name,functionName){const args=Array.prototype.slice.call(arguments,2);const dataStore=this.store;for(const id in dataStore){if(dataStore.hasOwnProperty(id)){const data=dataStore[id].data;if(data.instances[name]){const fn=data.instances[name].instance[functionName];if(fn){fn.apply(data.instances[name].instance,args);}}}}}_preRegisterInstance(entity,url,name,instance){if(entity.script){entity.script.data._instances=entity.script.data._instances||{};if(entity.script.data._instances[name]){throw Error(`Script name collision '${name}'. Scripts from '${url}' and '${entity.script.data._instances[name].url}' {${entity.getGuid()}}`)}entity.script.data._instances[name]={url:url,name:name,instance:instance};}}_registerInstances(entity){if(entity.script){if(entity.script.data._instances){entity.script.instances=entity.script.data._instances;for(const instanceName in entity.script.instances){const preRegistered=entity.script.instances[instanceName];const instance=preRegistered.instance;events.attach(instance);if(instance.update){this.instancesWithUpdate.push(instance);}if(instance.fixedUpdate){this.instancesWithFixedUpdate.push(instance);}if(instance.postUpdate){this.instancesWithPostUpdate.push(instance);}if(instance.toolsUpdate){this.instancesWithToolsUpdate.push(instance);}if(entity.script.scripts){this._createAccessors(entity,preRegistered);}if(entity.script[instanceName]){throw Error(`Script with name '${instanceName}' is already attached to Script Component`)}else {entity.script[instanceName]=instance;}}delete entity.script.data._instances;}}const children=entity._children;for(let i=0,len=children.length;i<len;i++){if(children[i]instanceof Entity){this._registerInstances(children[i]);}}}_cloneAttributes(attributes){const result={};for(const key in attributes){if(!attributes.hasOwnProperty(key)){continue}if(attributes[key].type!=="entity"){result[key]=extend({},attributes[key]);}else {const val=attributes[key].value;delete attributes[key].value;result[key]=extend({},attributes[key]);result[key].value=val;attributes[key].value=val;}}return result}_createAccessors(entity,instance){const len=entity.script.scripts.length;const url=instance.url;for(let i=0;i<len;i++){const script=entity.script.scripts[i];if(script.url===url){const attributes=script.attributes;if(script.name&&attributes){for(const key in attributes){if(attributes.hasOwnProperty(key)){this._createAccessor(attributes[key],instance);}}entity.script.data.attributes[script.name]=this._cloneAttributes(attributes);}break}}}_createAccessor(attribute,instance){const self1=this;attribute={name:attribute.name,value:attribute.value,type:attribute.type};this._convertAttributeValue(attribute);Object.defineProperty(instance.instance,attribute.name,{get:function(){return attribute.value},set:function(value){const oldValue=attribute.value;attribute.value=value;self1._convertAttributeValue(attribute);instance.instance.fire("set",attribute.name,oldValue,attribute.value);},configurable:true});}_updateAccessors(entity,instance){const len=entity.script.scripts.length;const url=instance.url;for(let i=0;i<len;i++){const scriptComponent=entity.script;const script=scriptComponent.scripts[i];if(script.url===url){const name=script.name;const attributes=script.attributes;if(name){if(attributes){for(const key in attributes){if(attributes.hasOwnProperty(key)){this._createAccessor(attributes[key],instance);}}}const previousAttributes=scriptComponent.data.attributes[name];if(previousAttributes){for(const key in previousAttributes){const oldAttribute=previousAttributes[key];if(!(key in attributes)){delete instance.instance[oldAttribute.name];}else {if(attributes[key].value!==oldAttribute.value){if(instance.instance.onAttributeChanged){instance.instance.onAttributeChanged(oldAttribute.name,oldAttribute.value,attributes[key].value);}}}}}if(attributes){scriptComponent.data.attributes[name]=this._cloneAttributes(attributes);}else {delete scriptComponent.data.attributes[name];}}break}}}_convertAttributeValue(attribute){if(attribute.type==="rgb"||attribute.type==="rgba"){if(Array.isArray(attribute.value)){attribute.value=attribute.value.length===3?new Color(attribute.value[0],attribute.value[1],attribute.value[2]):new Color(attribute.value[0],attribute.value[1],attribute.value[2],attribute.value[3]);}}else if(attribute.type==="vec2"){if(Array.isArray(attribute.value)){attribute.value=new Vec2(attribute.value[0],attribute.value[1]);}}else if(attribute.type==="vec3"||attribute.type==="vector"){if(Array.isArray(attribute.value)){attribute.value=new Vec3(attribute.value[0],attribute.value[1],attribute.value[2]);}}else if(attribute.type==="vec4"){if(Array.isArray(attribute.value)){attribute.value=new Vec4(attribute.value[0],attribute.value[1],attribute.value[2],attribute.value[3]);}}else if(attribute.type==="entity"){if(attribute.value!==null&&typeof attribute.value==="string"){attribute.value=this.app.root.findByGuid(attribute.value);}}else if(attribute.type==="curve"||attribute.type==="colorcurve"){const curveType=attribute.value.keys[0]instanceof Array?CurveSet:Curve;attribute.value=new curveType(attribute.value.keys);attribute.value.type=attribute.value.type;}}destroy(){super.destroy();this.app.systems.off(INITIALIZE,this.onInitialize,this);this.app.systems.off(POST_INITIALIZE,this.onPostInitialize,this);this.app.systems.off(UPDATE,this.onUpdate,this);this.app.systems.off(FIXED_UPDATE,this.onFixedUpdate,this);this.app.systems.off(POST_UPDATE,this.onPostUpdate,this);this.app.systems.off(TOOLS_UPDATE,this.onToolsUpdate,this);}constructor(app){super(app);this.id="script";this.ComponentType=ScriptLegacyComponent;this.DataType=ScriptLegacyComponentData;this.schema=_schema$7;this.preloading=false;this.instancesWithUpdate=[];this.instancesWithFixedUpdate=[];this.instancesWithPostUpdate=[];this.instancesWithToolsUpdate=[];this.on("beforeremove",this.onBeforeRemove,this);this.app.systems.on(INITIALIZE,this.onInitialize,this);this.app.systems.on(POST_INITIALIZE,this.onPostInitialize,this);this.app.systems.on(UPDATE,this.onUpdate,this);this.app.systems.on(FIXED_UPDATE,this.onFixedUpdate,this);this.app.systems.on(POST_UPDATE,this.onPostUpdate,this);this.app.systems.on(TOOLS_UPDATE,this.onToolsUpdate,this);}}Component._buildAccessors(ScriptLegacyComponent.prototype,_schema$7);const _inputScreenPosition=new Vec2;const _inputWorldPosition=new Vec3;const _ray=new Ray;const _plane=new Plane;const _normal=new Vec3;const _point=new Vec3;const _entityRotation=new Quat;const OPPOSITE_AXIS={x:"y",y:"x"};class ElementDragHelper extends EventHandler{_toggleLifecycleListeners(onOrOff){this._element[onOrOff]("mousedown",this._onMouseDownOrTouchStart,this);this._element[onOrOff]("touchstart",this._onMouseDownOrTouchStart,this);this._element[onOrOff]("selectstart",this._onMouseDownOrTouchStart,this);}_toggleDragListeners(onOrOff){const isOn=onOrOff==="on";if(this._hasDragListeners&&isOn){return}if(this._app.mouse){this._element[onOrOff]("mousemove",this._onMove,this);this._element[onOrOff]("mouseup",this._onMouseUpOrTouchEnd,this);}if(platform.touch){this._element[onOrOff]("touchmove",this._onMove,this);this._element[onOrOff]("touchend",this._onMouseUpOrTouchEnd,this);this._element[onOrOff]("touchcancel",this._onMouseUpOrTouchEnd,this);}this._element[onOrOff]("selectmove",this._onMove,this);this._element[onOrOff]("selectend",this._onMouseUpOrTouchEnd,this);this._hasDragListeners=isOn;}_onMouseDownOrTouchStart(event){if(this._element&&!this._isDragging&&this.enabled){this._dragCamera=event.camera;this._calculateDragScale();const currentMousePosition=this._screenToLocal(event);if(currentMousePosition){this._toggleDragListeners("on");this._isDragging=true;this._dragStartMousePosition.copy(currentMousePosition);this._dragStartHandlePosition.copy(this._element.entity.getLocalPosition());this.fire("drag:start");}}}_onMouseUpOrTouchEnd(){if(this._isDragging){this._isDragging=false;this._toggleDragListeners("off");this.fire("drag:end");}}_screenToLocal(event){if(event.inputSource){_ray.set(event.inputSource.getOrigin(),event.inputSource.getDirection());}else {this._determineInputPosition(event);this._chooseRayOriginAndDirection();}_normal.copy(this._element.entity.forward).mulScalar(-1);_plane.setFromPointNormal(this._element.entity.getPosition(),_normal);if(_plane.intersectsRay(_ray,_point)){_entityRotation.copy(this._element.entity.getRotation()).invert().transformVector(_point,_point);_point.mul(this._dragScale);return _point}return null}_determineInputPosition(event){const devicePixelRatio=this._app.graphicsDevice.maxPixelRatio;if(typeof event.x!=="undefined"&&typeof event.y!=="undefined"){_inputScreenPosition.x=event.x*devicePixelRatio;_inputScreenPosition.y=event.y*devicePixelRatio;}else if(event.changedTouches){_inputScreenPosition.x=event.changedTouches[0].x*devicePixelRatio;_inputScreenPosition.y=event.changedTouches[0].y*devicePixelRatio;}else {console.warn("Could not determine position from input event");}}_chooseRayOriginAndDirection(){if(this._element.screen&&this._element.screen.screen.screenSpace){_ray.origin.set(_inputScreenPosition.x,-_inputScreenPosition.y,0);_ray.direction.copy(Vec3.FORWARD);}else {_inputWorldPosition.copy(this._dragCamera.screenToWorld(_inputScreenPosition.x,_inputScreenPosition.y,1));_ray.origin.copy(this._dragCamera.entity.getPosition());_ray.direction.copy(_inputWorldPosition).sub(_ray.origin).normalize();}}_calculateDragScale(){let current=this._element.entity.parent;const screen=this._element.screen&&this._element.screen.screen;const isWithin2DScreen=screen&&screen.screenSpace;const screenScale=isWithin2DScreen?screen.scale:1;const dragScale=this._dragScale;dragScale.set(screenScale,screenScale,screenScale);while(current){dragScale.mul(current.getLocalScale());current=current.parent;if(isWithin2DScreen&&current.screen){break}}dragScale.x=1/dragScale.x;dragScale.y=1/dragScale.y;dragScale.z=0;}_onMove(event){const{_element:element,_deltaMousePosition:deltaMousePosition,_deltaHandlePosition:deltaHandlePosition,_axis:axis}=this;if(element&&this._isDragging&&this.enabled&&element.enabled&&element.entity.enabled){const currentMousePosition=this._screenToLocal(event);if(currentMousePosition){deltaMousePosition.sub2(currentMousePosition,this._dragStartMousePosition);deltaHandlePosition.add2(this._dragStartHandlePosition,deltaMousePosition);if(axis){const currentPosition=element.entity.getLocalPosition();const constrainedAxis=OPPOSITE_AXIS[axis];deltaHandlePosition[constrainedAxis]=currentPosition[constrainedAxis];}element.entity.setLocalPosition(deltaHandlePosition);this.fire("drag:move",deltaHandlePosition);}}}destroy(){this._toggleLifecycleListeners("off");this._toggleDragListeners("off");}set enabled(value){this._enabled=value;}get enabled(){return this._enabled}get isDragging(){return this._isDragging}constructor(element,axis){super();if(!element||!(element instanceof ElementComponent)){throw new Error("Element was null or not an ElementComponent")}if(axis&&axis!=="x"&&axis!=="y"){throw new Error(`Unrecognized axis: ${axis}`)}this._element=element;this._app=element.system.app;this._axis=axis||null;this._enabled=true;this._dragScale=new Vec3;this._dragStartMousePosition=new Vec3;this._dragStartHandlePosition=new Vec3;this._deltaMousePosition=new Vec3;this._deltaHandlePosition=new Vec3;this._isDragging=false;this._toggleLifecycleListeners("on");}}ElementDragHelper.EVENT_DRAGSTART="drag:start";ElementDragHelper.EVENT_DRAGEND="drag:end";ElementDragHelper.EVENT_DRAGMOVE="drag:move";const SCROLL_MODE_CLAMP=0;const SCROLL_MODE_BOUNCE=1;const SCROLL_MODE_INFINITE=2;const SCROLLBAR_VISIBILITY_SHOW_ALWAYS=0;const SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED=1;const _tempScrollValue=new Vec2;class ScrollViewComponent extends Component{get data(){const record=this.system.store[this.entity.getGuid()];return record?record.data:null}set enabled(arg){this._setValue("enabled",arg);}get enabled(){return this.data.enabled}set horizontal(arg){this._setValue("horizontal",arg);}get horizontal(){return this.data.horizontal}set vertical(arg){this._setValue("vertical",arg);}get vertical(){return this.data.vertical}set scrollMode(arg){this._setValue("scrollMode",arg);}get scrollMode(){return this.data.scrollMode}set bounceAmount(arg){this._setValue("bounceAmount",arg);}get bounceAmount(){return this.data.bounceAmount}set friction(arg){this._setValue("friction",arg);}get friction(){return this.data.friction}set dragThreshold(arg){this._setValue("dragThreshold",arg);}get dragThreshold(){return this.data.dragThreshold}set useMouseWheel(arg){this._setValue("useMouseWheel",arg);}get useMouseWheel(){return this.data.useMouseWheel}set mouseWheelSensitivity(arg){this._setValue("mouseWheelSensitivity",arg);}get mouseWheelSensitivity(){return this.data.mouseWheelSensitivity}set horizontalScrollbarVisibility(arg){this._setValue("horizontalScrollbarVisibility",arg);}get horizontalScrollbarVisibility(){return this.data.horizontalScrollbarVisibility}set verticalScrollbarVisibility(arg){this._setValue("verticalScrollbarVisibility",arg);}get verticalScrollbarVisibility(){return this.data.verticalScrollbarVisibility}set viewportEntity(arg){if(this._viewportEntity===arg){return}const isString=typeof arg==="string";if(this._viewportEntity&&isString&&this._viewportEntity.getGuid()===arg){return}if(this._viewportEntity){this._viewportEntityUnsubscribe();}if(arg instanceof GraphNode){this._viewportEntity=arg;}else if(isString){this._viewportEntity=this.system.app.getEntityFromIndex(arg)||null;}else {this._viewportEntity=null;}if(this._viewportEntity){this._viewportEntitySubscribe();}if(this._viewportEntity){this.data.viewportEntity=this._viewportEntity.getGuid();}else if(isString&&arg){this.data.viewportEntity=arg;}}get viewportEntity(){return this._viewportEntity}set contentEntity(arg){if(this._contentEntity===arg){return}const isString=typeof arg==="string";if(this._contentEntity&&isString&&this._contentEntity.getGuid()===arg){return}if(this._contentEntity){this._contentEntityUnsubscribe();}if(arg instanceof GraphNode){this._contentEntity=arg;}else if(isString){this._contentEntity=this.system.app.getEntityFromIndex(arg)||null;}else {this._contentEntity=null;}if(this._contentEntity){this._contentEntitySubscribe();}if(this._contentEntity){this.data.contentEntity=this._contentEntity.getGuid();}else if(isString&&arg){this.data.contentEntity=arg;}}get contentEntity(){return this._contentEntity}set horizontalScrollbarEntity(arg){if(this._horizontalScrollbarEntity===arg){return}const isString=typeof arg==="string";if(this._horizontalScrollbarEntity&&isString&&this._horizontalScrollbarEntity.getGuid()===arg){return}if(this._horizontalScrollbarEntity){this._horizontalScrollbarEntityUnsubscribe();}if(arg instanceof GraphNode){this._horizontalScrollbarEntity=arg;}else if(isString){this._horizontalScrollbarEntity=this.system.app.getEntityFromIndex(arg)||null;}else {this._horizontalScrollbarEntity=null;}this._scrollbarEntities[ORIENTATION_HORIZONTAL]=this._horizontalScrollbarEntity;if(this._horizontalScrollbarEntity){this._horizontalScrollbarEntitySubscribe();}if(this._horizontalScrollbarEntity){this.data.horizontalScrollbarEntity=this._horizontalScrollbarEntity.getGuid();}else if(isString&&arg){this.data.horizontalScrollbarEntity=arg;}}get horizontalScrollbarEntity(){return this._horizontalScrollbarEntity}set verticalScrollbarEntity(arg){if(this._verticalScrollbarEntity===arg){return}const isString=typeof arg==="string";if(this._verticalScrollbarEntity&&isString&&this._verticalScrollbarEntity.getGuid()===arg){return}if(this._verticalScrollbarEntity){this._verticalScrollbarEntityUnsubscribe();}if(arg instanceof GraphNode){this._verticalScrollbarEntity=arg;}else if(isString){this._verticalScrollbarEntity=this.system.app.getEntityFromIndex(arg)||null;}else {this._verticalScrollbarEntity=null;}this._scrollbarEntities[ORIENTATION_VERTICAL]=this._verticalScrollbarEntity;if(this._verticalScrollbarEntity){this._verticalScrollbarEntitySubscribe();}if(this._verticalScrollbarEntity){this.data.verticalScrollbarEntity=this._verticalScrollbarEntity.getGuid();}else if(isString&&arg){this.data.verticalScrollbarEntity=arg;}}get verticalScrollbarEntity(){return this._verticalScrollbarEntity}set scroll(value){this._onSetScroll(value.x,value.y);}get scroll(){return this._scroll}_setValue(name,value){const data=this.data;const oldValue=data[name];data[name]=value;this.fire("set",name,oldValue,value);}_toggleLifecycleListeners(onOrOff){this[onOrOff]("set_horizontal",this._onSetHorizontalScrollingEnabled,this);this[onOrOff]("set_vertical",this._onSetVerticalScrollingEnabled,this);this.entity[onOrOff]("element:add",this._onElementComponentAdd,this);}_toggleElementListeners(onOrOff){if(this.entity.element){if(onOrOff==="on"&&this._hasElementListeners){return}this.entity.element[onOrOff]("resize",this._syncAll,this);this.entity.element[onOrOff](EVENT_MOUSEWHEEL,this._onMouseWheel,this);this._hasElementListeners=onOrOff==="on";}}_onElementComponentAdd(entity){this._evtElementRemove=this.entity.element.once("beforeremove",this._onElementComponentRemove,this);this._toggleElementListeners("on");}_onElementComponentRemove(entity){var _this$_evtElementRemo;(_this$_evtElementRemo=this._evtElementRemove)==null||_this$_evtElementRemo.off();this._evtElementRemove=null;this._toggleElementListeners("off");}_viewportEntitySubscribe(){this._evtViewportEntityElementAdd=this._viewportEntity.on("element:add",this._onViewportElementGain,this);if(this._viewportEntity.element){this._onViewportElementGain();}}_viewportEntityUnsubscribe(){var _this$_evtViewportEnt,_this$_viewportEntity;(_this$_evtViewportEnt=this._evtViewportEntityElementAdd)==null||_this$_evtViewportEnt.off();this._evtViewportEntityElementAdd=null;if((_this$_viewportEntity=this._viewportEntity)!=null&&_this$_viewportEntity.element){this._onViewportElementLose();}}_viewportEntityElementSubscribe(){const element=this._viewportEntity.element;this._evtViewportElementRemove=element.once("beforeremove",this._onViewportElementLose,this);this._evtViewportResize=element.on("resize",this._syncAll,this);}_viewportEntityElementUnsubscribe(){var _this$_evtViewportEle,_this$_evtViewportRes;(_this$_evtViewportEle=this._evtViewportElementRemove)==null||_this$_evtViewportEle.off();this._evtViewportElementRemove=null;(_this$_evtViewportRes=this._evtViewportResize)==null||_this$_evtViewportRes.off();this._evtViewportResize=null;}_onViewportElementGain(){this._viewportEntityElementSubscribe();this._syncAll();}_onViewportElementLose(){this._viewportEntityElementUnsubscribe();}_contentEntitySubscribe(){this._evtContentEntityElementAdd=this._contentEntity.on("element:add",this._onContentElementGain,this);if(this._contentEntity.element){this._onContentElementGain();}}_contentEntityUnsubscribe(){var _this$_evtContentEnti,_this$_contentEntity;(_this$_evtContentEnti=this._evtContentEntityElementAdd)==null||_this$_evtContentEnti.off();this._evtContentEntityElementAdd=null;if((_this$_contentEntity=this._contentEntity)!=null&&_this$_contentEntity.element){this._onContentElementLose();}}_contentEntityElementSubscribe(){const element=this._contentEntity.element;this._evtContentElementRemove=element.once("beforeremove",this._onContentElementLose,this);this._evtContentResize=element.on("resize",this._syncAll,this);}_contentEntityElementUnsubscribe(){var _this$_evtContentElem,_this$_evtContentResi;(_this$_evtContentElem=this._evtContentElementRemove)==null||_this$_evtContentElem.off();this._evtContentElementRemove=null;(_this$_evtContentResi=this._evtContentResize)==null||_this$_evtContentResi.off();this._evtContentResize=null;}_onContentElementGain(){this._contentEntityElementSubscribe();this._destroyDragHelper();this._contentDragHelper=new ElementDragHelper(this._contentEntity.element);this._contentDragHelper.on("drag:start",this._onContentDragStart,this);this._contentDragHelper.on("drag:end",this._onContentDragEnd,this);this._contentDragHelper.on("drag:move",this._onContentDragMove,this);this._prevContentSizes[ORIENTATION_HORIZONTAL]=null;this._prevContentSizes[ORIENTATION_VERTICAL]=null;this._syncAll();}_onContentElementLose(){this._contentEntityElementUnsubscribe();this._destroyDragHelper();}_onContentDragStart(){if(this._contentEntity&&this.enabled&&this.entity.enabled){this._dragStartPosition.copy(this._contentEntity.getLocalPosition());}}_onContentDragEnd(){this._prevContentDragPosition=null;this._enableContentInput();}_onContentDragMove(position){if(this._contentEntity&&this.enabled&&this.entity.enabled){this._wasDragged=true;this._setScrollFromContentPosition(position);this._setVelocityFromContentPositionDelta(position);if(!this._disabledContentInput){const dx=position.x-this._dragStartPosition.x;const dy=position.y-this._dragStartPosition.y;if(Math.abs(dx)>this.dragThreshold||Math.abs(dy)>this.dragThreshold){this._disableContentInput();}}}}_horizontalScrollbarEntitySubscribe(){this._evtHorizontalScrollbarAdd=this._horizontalScrollbarEntity.on("scrollbar:add",this._onHorizontalScrollbarGain,this);if(this._horizontalScrollbarEntity.scrollbar){this._onHorizontalScrollbarGain();}}_verticalScrollbarEntitySubscribe(){this._evtVerticalScrollbarAdd=this._verticalScrollbarEntity.on("scrollbar:add",this._onVerticalScrollbarGain,this);if(this._verticalScrollbarEntity.scrollbar){this._onVerticalScrollbarGain();}}_horizontalScrollbarEntityUnsubscribe(){var _this$_evtHorizontalS;(_this$_evtHorizontalS=this._evtHorizontalScrollbarAdd)==null||_this$_evtHorizontalS.off();this._evtHorizontalScrollbarAdd=null;if(this._horizontalScrollbarEntity.scrollbar){this._onHorizontalScrollbarLose();}}_verticalScrollbarEntityUnsubscribe(){var _this$_evtVerticalScr;(_this$_evtVerticalScr=this._evtVerticalScrollbarAdd)==null||_this$_evtVerticalScr.off();this._evtVerticalScrollbarAdd=null;if(this._verticalScrollbarEntity.scrollbar){this._onVerticalScrollbarLose();}}_onSetHorizontalScrollbarValue(scrollValueX){if(!this._scrollbarUpdateFlags[ORIENTATION_HORIZONTAL]&&this.enabled&&this.entity.enabled){this._onSetScroll(scrollValueX,null);}}_onSetVerticalScrollbarValue(scrollValueY){if(!this._scrollbarUpdateFlags[ORIENTATION_VERTICAL]&&this.enabled&&this.entity.enabled){this._onSetScroll(null,scrollValueY);}}_onHorizontalScrollbarGain(){var _this$_horizontalScro;const scrollbar=(_this$_horizontalScro=this._horizontalScrollbarEntity)==null?void 0:_this$_horizontalScro.scrollbar;this._evtHorizontalScrollbarRemove=scrollbar.on("beforeremove",this._onHorizontalScrollbarLose,this);this._evtHorizontalScrollbarValue=scrollbar.on("set:value",this._onSetHorizontalScrollbarValue,this);this._syncScrollbarEnabledState(ORIENTATION_HORIZONTAL);this._syncScrollbarPosition(ORIENTATION_HORIZONTAL);}_onVerticalScrollbarGain(){var _this$_verticalScroll;const scrollbar=(_this$_verticalScroll=this._verticalScrollbarEntity)==null?void 0:_this$_verticalScroll.scrollbar;this._evtVerticalScrollbarRemove=scrollbar.on("beforeremove",this._onVerticalScrollbarLose,this);this._evtVerticalScrollbarValue=scrollbar.on("set:value",this._onSetVerticalScrollbarValue,this);this._syncScrollbarEnabledState(ORIENTATION_VERTICAL);this._syncScrollbarPosition(ORIENTATION_VERTICAL);}_onHorizontalScrollbarLose(){var _this$_evtHorizontalS2,_this$_evtHorizontalS3;(_this$_evtHorizontalS2=this._evtHorizontalScrollbarRemove)==null||_this$_evtHorizontalS2.off();this._evtHorizontalScrollbarRemove=null;(_this$_evtHorizontalS3=this._evtHorizontalScrollbarValue)==null||_this$_evtHorizontalS3.off();this._evtHorizontalScrollbarValue=null;}_onVerticalScrollbarLose(){var _this$_evtVerticalScr2,_this$_evtVerticalScr3;(_this$_evtVerticalScr2=this._evtVerticalScrollbarRemove)==null||_this$_evtVerticalScr2.off();this._evtVerticalScrollbarRemove=null;(_this$_evtVerticalScr3=this._evtVerticalScrollbarValue)==null||_this$_evtVerticalScr3.off();this._evtVerticalScrollbarValue=null;}_onSetHorizontalScrollingEnabled(){this._syncScrollbarEnabledState(ORIENTATION_HORIZONTAL);}_onSetVerticalScrollingEnabled(){this._syncScrollbarEnabledState(ORIENTATION_VERTICAL);}_onSetScroll(x,y,resetVelocity){if(resetVelocity!==false){this._velocity.set(0,0,0);}const xChanged=this._updateAxis(x,"x",ORIENTATION_HORIZONTAL);const yChanged=this._updateAxis(y,"y",ORIENTATION_VERTICAL);if(xChanged||yChanged){this.fire("set:scroll",this._scroll);}}_updateAxis(scrollValue,axis,orientation){const hasChanged=scrollValue!==null&&Math.abs(scrollValue-this._scroll[axis])>1e-5;if(hasChanged||this._isDragging()||scrollValue===0){this._scroll[axis]=this._determineNewScrollValue(scrollValue,axis,orientation);this._syncContentPosition(orientation);this._syncScrollbarPosition(orientation);}return hasChanged}_determineNewScrollValue(scrollValue,axis,orientation){if(!this._getScrollingEnabled(orientation)){return this._scroll[axis]}switch(this.scrollMode){case SCROLL_MODE_CLAMP:return math.clamp(scrollValue,0,this._getMaxScrollValue(orientation));case SCROLL_MODE_BOUNCE:this._setVelocityFromOvershoot(scrollValue,axis,orientation);return scrollValue;case SCROLL_MODE_INFINITE:return scrollValue;default:console.warn(`Unhandled scroll mode:${this.scrollMode}`);return scrollValue}}_syncAll(){this._syncContentPosition(ORIENTATION_HORIZONTAL);this._syncContentPosition(ORIENTATION_VERTICAL);this._syncScrollbarPosition(ORIENTATION_HORIZONTAL);this._syncScrollbarPosition(ORIENTATION_VERTICAL);this._syncScrollbarEnabledState(ORIENTATION_HORIZONTAL);this._syncScrollbarEnabledState(ORIENTATION_VERTICAL);}_syncContentPosition(orientation){if(!this._contentEntity){return}const axis=this._getAxis(orientation);const sign=this._getSign(orientation);const prevContentSize=this._prevContentSizes[orientation];const currContentSize=this._getContentSize(orientation);if(prevContentSize!==null&&Math.abs(prevContentSize-currContentSize)>1e-4){const prevMaxOffset=this._getMaxOffset(orientation,prevContentSize);const currMaxOffset=this._getMaxOffset(orientation,currContentSize);if(currMaxOffset===0){this._scroll[axis]=1;}else {this._scroll[axis]=math.clamp(this._scroll[axis]*prevMaxOffset/currMaxOffset,0,1);}}const offset=this._scroll[axis]*this._getMaxOffset(orientation);const contentPosition=this._contentEntity.getLocalPosition();contentPosition[axis]=offset*sign;this._contentEntity.setLocalPosition(contentPosition);this._prevContentSizes[orientation]=currContentSize;}_syncScrollbarPosition(orientation){const scrollbarEntity=this._scrollbarEntities[orientation];if(!(scrollbarEntity!=null&&scrollbarEntity.scrollbar)){return}const axis=this._getAxis(orientation);this._scrollbarUpdateFlags[orientation]=true;scrollbarEntity.scrollbar.value=this._scroll[axis];scrollbarEntity.scrollbar.handleSize=this._getScrollbarHandleSize(axis,orientation);this._scrollbarUpdateFlags[orientation]=false;}_syncScrollbarEnabledState(orientation){const entity=this._scrollbarEntities[orientation];if(!entity){return}const isScrollingEnabled=this._getScrollingEnabled(orientation);const requestedVisibility=this._getScrollbarVisibility(orientation);switch(requestedVisibility){case SCROLLBAR_VISIBILITY_SHOW_ALWAYS:entity.enabled=isScrollingEnabled;return;case SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED:entity.enabled=isScrollingEnabled&&this._contentIsLargerThanViewport(orientation);return;default:console.warn(`Unhandled scrollbar visibility:${requestedVisibility}`);entity.enabled=isScrollingEnabled;}}_contentIsLargerThanViewport(orientation){return this._getContentSize(orientation)>this._getViewportSize(orientation)}_contentPositionToScrollValue(contentPosition){const maxOffsetH=this._getMaxOffset(ORIENTATION_HORIZONTAL);const maxOffsetV=this._getMaxOffset(ORIENTATION_VERTICAL);if(maxOffsetH===0){_tempScrollValue.x=0;}else {_tempScrollValue.x=contentPosition.x/maxOffsetH;}if(maxOffsetV===0){_tempScrollValue.y=0;}else {_tempScrollValue.y=contentPosition.y/-maxOffsetV;}return _tempScrollValue}_getMaxOffset(orientation,contentSize){contentSize=contentSize===undefined?this._getContentSize(orientation):contentSize;const viewportSize=this._getViewportSize(orientation);if(contentSize<viewportSize){return -this._getViewportSize(orientation)}return viewportSize-contentSize}_getMaxScrollValue(orientation){return this._contentIsLargerThanViewport(orientation)?1:0}_getScrollbarHandleSize(axis,orientation){const viewportSize=this._getViewportSize(orientation);const contentSize=this._getContentSize(orientation);if(Math.abs(contentSize)<.001){return 1}const handleSize=Math.min(viewportSize/contentSize,1);const overshoot=this._toOvershoot(this._scroll[axis],orientation);if(overshoot===0){return handleSize}return handleSize/(1+Math.abs(overshoot))}_getViewportSize(orientation){return this._getSize(orientation,this._viewportEntity)}_getContentSize(orientation){return this._getSize(orientation,this._contentEntity)}_getSize(orientation,entity){if(entity!=null&&entity.element){return entity.element[this._getCalculatedDimension(orientation)]}return 0}_getScrollingEnabled(orientation){if(orientation===ORIENTATION_HORIZONTAL){return this.horizontal}else if(orientation===ORIENTATION_VERTICAL){return this.vertical}return undefined}_getScrollbarVisibility(orientation){if(orientation===ORIENTATION_HORIZONTAL){return this.horizontalScrollbarVisibility}else if(orientation===ORIENTATION_VERTICAL){return this.verticalScrollbarVisibility}return undefined}_getSign(orientation){return orientation===ORIENTATION_HORIZONTAL?1:-1}_getAxis(orientation){return orientation===ORIENTATION_HORIZONTAL?"x":"y"}_getCalculatedDimension(orientation){return orientation===ORIENTATION_HORIZONTAL?"calculatedWidth":"calculatedHeight"}_destroyDragHelper(){if(this._contentDragHelper){this._contentDragHelper.destroy();}}onUpdate(){if(this._contentEntity){this._updateVelocity();this._syncScrollbarEnabledState(ORIENTATION_HORIZONTAL);this._syncScrollbarEnabledState(ORIENTATION_VERTICAL);}}_updateVelocity(){if(!this._isDragging()){if(this.scrollMode===SCROLL_MODE_BOUNCE){if(this._hasOvershoot("x",ORIENTATION_HORIZONTAL)){this._setVelocityFromOvershoot(this.scroll.x,"x",ORIENTATION_HORIZONTAL);}if(this._hasOvershoot("y",ORIENTATION_VERTICAL)){this._setVelocityFromOvershoot(this.scroll.y,"y",ORIENTATION_VERTICAL);}}if(Math.abs(this._velocity.x)>1e-4||Math.abs(this._velocity.y)>1e-4){const position=this._contentEntity.getLocalPosition();position.x+=this._velocity.x;position.y+=this._velocity.y;this._contentEntity.setLocalPosition(position);this._setScrollFromContentPosition(position);}this._velocity.x*=1-this.friction;this._velocity.y*=1-this.friction;}}_hasOvershoot(axis,orientation){return Math.abs(this._toOvershoot(this.scroll[axis],orientation))>.001}_toOvershoot(scrollValue,orientation){const maxScrollValue=this._getMaxScrollValue(orientation);if(scrollValue<0){return scrollValue}else if(scrollValue>maxScrollValue){return scrollValue-maxScrollValue}return 0}_setVelocityFromOvershoot(scrollValue,axis,orientation){const overshootValue=this._toOvershoot(scrollValue,orientation);const overshootPixels=overshootValue*this._getMaxOffset(orientation)*this._getSign(orientation);if(Math.abs(overshootPixels)>0){this._velocity[axis]=-overshootPixels/(this.bounceAmount*50+1);}}_setVelocityFromContentPositionDelta(position){if(this._prevContentDragPosition){this._velocity.sub2(position,this._prevContentDragPosition);this._prevContentDragPosition.copy(position);}else {this._velocity.set(0,0,0);this._prevContentDragPosition=position.clone();}}_setScrollFromContentPosition(position){let scrollValue=this._contentPositionToScrollValue(position);if(this._isDragging()){scrollValue=this._applyScrollValueTension(scrollValue);}this._onSetScroll(scrollValue.x,scrollValue.y,false);}_applyScrollValueTension(scrollValue){const factor=1;let max=this._getMaxScrollValue(ORIENTATION_HORIZONTAL);let overshoot=this._toOvershoot(scrollValue.x,ORIENTATION_HORIZONTAL);if(overshoot>0){scrollValue.x=max+factor*Math.log10(1+overshoot);}else if(overshoot<0){scrollValue.x=-factor*Math.log10(1-overshoot);}max=this._getMaxScrollValue(ORIENTATION_VERTICAL);overshoot=this._toOvershoot(scrollValue.y,ORIENTATION_VERTICAL);if(overshoot>0){scrollValue.y=max+factor*Math.log10(1+overshoot);}else if(overshoot<0){scrollValue.y=-factor*Math.log10(1-overshoot);}return scrollValue}_isDragging(){return this._contentDragHelper&&this._contentDragHelper.isDragging}_setScrollbarComponentsEnabled(enabled){var _this$_horizontalScro2,_this$_verticalScroll2;if((_this$_horizontalScro2=this._horizontalScrollbarEntity)!=null&&_this$_horizontalScro2.scrollbar){this._horizontalScrollbarEntity.scrollbar.enabled=enabled;}if((_this$_verticalScroll2=this._verticalScrollbarEntity)!=null&&_this$_verticalScroll2.scrollbar){this._verticalScrollbarEntity.scrollbar.enabled=enabled;}}_setContentDraggingEnabled(enabled){if(this._contentDragHelper){this._contentDragHelper.enabled=enabled;}}_onMouseWheel(event){var _this$_contentEntity2;if(!this.useMouseWheel||!((_this$_contentEntity2=this._contentEntity)!=null&&_this$_contentEntity2.element)){return}const wheelEvent=event.event;const normalizedDeltaX=wheelEvent.deltaX/this._contentEntity.element.calculatedWidth*this.mouseWheelSensitivity.x;const normalizedDeltaY=wheelEvent.deltaY/this._contentEntity.element.calculatedHeight*this.mouseWheelSensitivity.y;const scrollX=math.clamp(this._scroll.x+normalizedDeltaX,0,this._getMaxScrollValue(ORIENTATION_HORIZONTAL));const scrollY=math.clamp(this._scroll.y+normalizedDeltaY,0,this._getMaxScrollValue(ORIENTATION_VERTICAL));this.scroll=new Vec2(scrollX,scrollY);}_enableContentInput(){while(this._disabledContentInputEntities.length){const e=this._disabledContentInputEntities.pop();if(e.element){e.element.useInput=true;}}this._disabledContentInput=false;}_disableContentInput(){const _disableInput=e=>{if(e.element&&e.element.useInput){this._disabledContentInputEntities.push(e);e.element.useInput=false;}const children=e.children;for(let i=0,l=children.length;i<l;i++){_disableInput(children[i]);}};if(this._contentEntity){const children=this._contentEntity.children;for(let i=0,l=children.length;i<l;i++){_disableInput(children[i]);}}this._disabledContentInput=true;}onEnable(){this._setScrollbarComponentsEnabled(true);this._setContentDraggingEnabled(true);this._syncAll();}onDisable(){this._setScrollbarComponentsEnabled(false);this._setContentDraggingEnabled(false);}onRemove(){this._toggleLifecycleListeners("off");this._toggleElementListeners("off");this._destroyDragHelper();}resolveDuplicatedEntityReferenceProperties(oldScrollView,duplicatedIdsMap){if(oldScrollView.viewportEntity){this.viewportEntity=duplicatedIdsMap[oldScrollView.viewportEntity.getGuid()];}if(oldScrollView.contentEntity){this.contentEntity=duplicatedIdsMap[oldScrollView.contentEntity.getGuid()];}if(oldScrollView.horizontalScrollbarEntity){this.horizontalScrollbarEntity=duplicatedIdsMap[oldScrollView.horizontalScrollbarEntity.getGuid()];}if(oldScrollView.verticalScrollbarEntity){this.verticalScrollbarEntity=duplicatedIdsMap[oldScrollView.verticalScrollbarEntity.getGuid()];}}constructor(system,entity){super(system,entity);this._viewportEntity=null;this._contentEntity=null;this._horizontalScrollbarEntity=null;this._verticalScrollbarEntity=null;this._evtElementRemove=null;this._evtViewportElementRemove=null;this._evtViewportResize=null;this._evtContentEntityElementAdd=null;this._evtContentElementRemove=null;this._evtContentResize=null;this._evtHorizontalScrollbarAdd=null;this._evtHorizontalScrollbarRemove=null;this._evtHorizontalScrollbarValue=null;this._evtVerticalScrollbarAdd=null;this._evtVerticalScrollbarRemove=null;this._evtVerticalScrollbarValue=null;this._scrollbarUpdateFlags={};this._scrollbarEntities={};this._prevContentSizes={};this._prevContentSizes[ORIENTATION_HORIZONTAL]=null;this._prevContentSizes[ORIENTATION_VERTICAL]=null;this._scroll=new Vec2;this._velocity=new Vec3;this._dragStartPosition=new Vec3;this._disabledContentInput=false;this._disabledContentInputEntities=[];this._toggleLifecycleListeners("on");this._toggleElementListeners("on");}}ScrollViewComponent.EVENT_SETSCROLL="set:scroll";const DEFAULT_DRAG_THRESHOLD$1=10;class ScrollViewComponentData{constructor(){this.enabled=true;this.horizontal=void 0;this.vertical=void 0;this.scrollMode=void 0;this.bounceAmount=void 0;this.friction=void 0;this.dragThreshold=DEFAULT_DRAG_THRESHOLD$1;this.useMouseWheel=true;this.mouseWheelSensitivity=new Vec2(1,1);this.horizontalScrollbarVisibility=0;this.verticalScrollbarVisibility=0;this.viewportEntity=null;this.contentEntity=null;this.horizontalScrollbarEntity=null;this.verticalScrollbarEntity=null;}}const _schema$6=[{name:"enabled",type:"boolean"},{name:"horizontal",type:"boolean"},{name:"vertical",type:"boolean"},{name:"scrollMode",type:"number"},{name:"bounceAmount",type:"number"},{name:"friction",type:"number"},{name:"dragThreshold",type:"number"},{name:"useMouseWheel",type:"boolean"},{name:"mouseWheelSensitivity",type:"vec2"},{name:"horizontalScrollbarVisibility",type:"number"},{name:"verticalScrollbarVisibility",type:"number"}];const DEFAULT_DRAG_THRESHOLD=10;class ScrollViewComponentSystem extends ComponentSystem{initializeComponentData(component,data,properties){if(data.dragThreshold===undefined){data.dragThreshold=DEFAULT_DRAG_THRESHOLD;}if(data.useMouseWheel===undefined){data.useMouseWheel=true;}if(data.mouseWheelSensitivity===undefined){data.mouseWheelSensitivity=new Vec2(1,1);}super.initializeComponentData(component,data,_schema$6);component.viewportEntity=data.viewportEntity;component.contentEntity=data.contentEntity;component.horizontalScrollbarEntity=data.horizontalScrollbarEntity;component.verticalScrollbarEntity=data.verticalScrollbarEntity;}onUpdate(dt){const components=this.store;for(const id in components){const entity=components[id].entity;const component=entity.scrollview;if(component.enabled&&entity.enabled){component.onUpdate();}}}_onRemoveComponent(entity,component){component.onRemove();}destroy(){super.destroy();this.app.systems.off("update",this.onUpdate,this);}constructor(app){super(app);this.id="scrollview";this.ComponentType=ScrollViewComponent;this.DataType=ScrollViewComponentData;this.schema=_schema$6;this.on("beforeremove",this._onRemoveComponent,this);this.app.systems.on("update",this.onUpdate,this);}}class ScrollbarComponent extends Component{get data(){const record=this.system.store[this.entity.getGuid()];return record?record.data:null}set enabled(arg){this._setValue("enabled",arg);}get enabled(){return this.data.enabled}set orientation(arg){this._setValue("orientation",arg);}get orientation(){return this.data.orientation}set value(arg){this._setValue("value",arg);}get value(){return this.data.value}set handleSize(arg){this._setValue("handleSize",arg);}get handleSize(){return this.data.handleSize}set handleEntity(arg){if(this._handleEntity===arg){return}const isString=typeof arg==="string";if(this._handleEntity&&isString&&this._handleEntity.getGuid()===arg){return}if(this._handleEntity){this._handleEntityUnsubscribe();}if(arg instanceof GraphNode){this._handleEntity=arg;}else if(isString){this._handleEntity=this.system.app.getEntityFromIndex(arg)||null;}else {this._handleEntity=null;}if(this._handleEntity){this._handleEntitySubscribe();}if(this._handleEntity){this.data.handleEntity=this._handleEntity.getGuid();}else if(isString&&arg){this.data.handleEntity=arg;}}get handleEntity(){return this._handleEntity}_setValue(name,value){const data=this.data;const oldValue=data[name];data[name]=value;this.fire("set",name,oldValue,value);}_toggleLifecycleListeners(onOrOff){this[onOrOff]("set_value",this._onSetValue,this);this[onOrOff]("set_handleSize",this._onSetHandleSize,this);this[onOrOff]("set_orientation",this._onSetOrientation,this);}_handleEntitySubscribe(){this._evtHandleEntityElementAdd=this._handleEntity.on("element:add",this._onHandleElementGain,this);if(this._handleEntity.element){this._onHandleElementGain();}}_handleEntityUnsubscribe(){var _this$_evtHandleEntit,_this$_handleEntity;(_this$_evtHandleEntit=this._evtHandleEntityElementAdd)==null||_this$_evtHandleEntit.off();this._evtHandleEntityElementAdd=null;if((_this$_handleEntity=this._handleEntity)!=null&&_this$_handleEntity.element){this._onHandleElementLose();}}_handleEntityElementSubscribe(){const element=this._handleEntity.element;const handles=this._evtHandleEntityChanges;handles.push(element.once("beforeremove",this._onHandleElementLose,this));handles.push(element.on("set:anchor",this._onSetHandleAlignment,this));handles.push(element.on("set:margin",this._onSetHandleAlignment,this));handles.push(element.on("set:pivot",this._onSetHandleAlignment,this));}_handleEntityElementUnsubscribe(){for(let i=0;i<this._evtHandleEntityChanges.length;i++){this._evtHandleEntityChanges[i].off();}this._evtHandleEntityChanges.length=0;}_onHandleElementGain(){this._handleEntityElementSubscribe();this._destroyDragHelper();this._handleDragHelper=new ElementDragHelper(this._handleEntity.element,this._getAxis());this._handleDragHelper.on("drag:move",this._onHandleDrag,this);this._updateHandlePositionAndSize();}_onHandleElementLose(){this._handleEntityElementUnsubscribe();this._destroyDragHelper();}_onHandleDrag(position){if(this._handleEntity&&this.enabled&&this.entity.enabled){this.value=this._handlePositionToScrollValue(position[this._getAxis()]);}}_onSetValue(name,oldValue,newValue){if(Math.abs(newValue-oldValue)>1e-5){this.data.value=math.clamp(newValue,0,1);this._updateHandlePositionAndSize();this.fire("set:value",this.data.value);}}_onSetHandleSize(name,oldValue,newValue){if(Math.abs(newValue-oldValue)>1e-5){this.data.handleSize=math.clamp(newValue,0,1);this._updateHandlePositionAndSize();}}_onSetHandleAlignment(){this._updateHandlePositionAndSize();}_onSetOrientation(name,oldValue,newValue){var _this$_handleEntity2;if(newValue!==oldValue&&(_this$_handleEntity2=this._handleEntity)!=null&&_this$_handleEntity2.element){this._handleEntity.element[this._getOppositeDimension()]=0;}}_updateHandlePositionAndSize(){const handleEntity=this._handleEntity;const handleElement=handleEntity==null?void 0:handleEntity.element;if(handleEntity){const position=handleEntity.getLocalPosition();position[this._getAxis()]=this._getHandlePosition();handleEntity.setLocalPosition(position);}if(handleElement){handleElement[this._getDimension()]=this._getHandleLength();}}_handlePositionToScrollValue(handlePosition){return handlePosition*this._getSign()/this._getUsableTrackLength()}_scrollValueToHandlePosition(value){return value*this._getSign()*this._getUsableTrackLength()}_getUsableTrackLength(){return Math.max(this._getTrackLength()-this._getHandleLength(),.001)}_getTrackLength(){if(this.entity.element){return this.orientation===ORIENTATION_HORIZONTAL?this.entity.element.calculatedWidth:this.entity.element.calculatedHeight}return 0}_getHandleLength(){return this._getTrackLength()*this.handleSize}_getHandlePosition(){return this._scrollValueToHandlePosition(this.value)}_getSign(){return this.orientation===ORIENTATION_HORIZONTAL?1:-1}_getAxis(){return this.orientation===ORIENTATION_HORIZONTAL?"x":"y"}_getDimension(){return this.orientation===ORIENTATION_HORIZONTAL?"width":"height"}_getOppositeDimension(){return this.orientation===ORIENTATION_HORIZONTAL?"height":"width"}_destroyDragHelper(){if(this._handleDragHelper){this._handleDragHelper.destroy();}}_setHandleDraggingEnabled(enabled){if(this._handleDragHelper){this._handleDragHelper.enabled=enabled;}}onEnable(){this._setHandleDraggingEnabled(true);}onDisable(){this._setHandleDraggingEnabled(false);}onRemove(){this._destroyDragHelper();this._toggleLifecycleListeners("off");}resolveDuplicatedEntityReferenceProperties(oldScrollbar,duplicatedIdsMap){if(oldScrollbar.handleEntity){this.handleEntity=duplicatedIdsMap[oldScrollbar.handleEntity.getGuid()];}}constructor(system,entity){super(system,entity);this._handleEntity=null;this._evtHandleEntityElementAdd=null;this._evtHandleEntityChanges=[];this._toggleLifecycleListeners("on");}}ScrollbarComponent.EVENT_SETVALUE="set:value";class ScrollbarComponentData{constructor(){this.enabled=true;this.orientation=ORIENTATION_HORIZONTAL;this.value=0;this.handleSize=0;this.handleEntity=null;}}const _schema$5=[{name:"enabled",type:"boolean"},{name:"orientation",type:"number"},{name:"value",type:"number"},{name:"handleSize",type:"number"}];class ScrollbarComponentSystem extends ComponentSystem{initializeComponentData(component,data,properties){super.initializeComponentData(component,data,_schema$5);component.handleEntity=data.handleEntity;}_onAddComponent(entity){entity.fire("scrollbar:add");}_onRemoveComponent(entity,component){component.onRemove();}constructor(app){super(app);this.id="scrollbar";this.ComponentType=ScrollbarComponent;this.DataType=ScrollbarComponentData;this.schema=_schema$5;this.on("add",this._onAddComponent,this);this.on("beforeremove",this._onRemoveComponent,this);}}const instanceOptions={volume:0,pitch:0,loop:false,startTime:0,duration:0,position:new Vec3,maxDistance:0,refDistance:0,rollOffFactor:0,distanceModel:0,onPlay:null,onPause:null,onResume:null,onStop:null,onEnd:null};class SoundSlot extends EventHandler{play(){if(!this.overlap){this.stop();}if(!this.isLoaded&&!this._hasAsset()){return undefined}const instance=this._createInstance();this.instances.push(instance);if(!this.isLoaded){const onLoad=function onLoad(sound){const playWhenLoaded=instance._playWhenLoaded;instance.sound=sound;if(playWhenLoaded){instance.play();}};this.off("load",onLoad);this.once("load",onLoad);this.load();}else {instance.play();}return instance}pause(){let paused=false;const instances=this.instances;for(let i=0,len=instances.length;i<len;i++){if(instances[i].pause()){paused=true;}}return paused}resume(){let resumed=false;const instances=this.instances;for(let i=0,len=instances.length;i<len;i++){if(instances[i].resume()){resumed=true;}}return resumed}stop(){let stopped=false;const instances=this.instances;let i=instances.length;while(i--){instances[i].stop();stopped=true;}instances.length=0;return stopped}load(){if(!this._hasAsset()){return}const asset=this._assets.get(this._asset);if(!asset){this._assets.off(`add:${this._asset}`,this._onAssetAdd,this);this._assets.once(`add:${this._asset}`,this._onAssetAdd,this);return}asset.off("remove",this._onAssetRemoved,this);asset.on("remove",this._onAssetRemoved,this);if(!asset.resource){asset.off("load",this._onAssetLoad,this);asset.once("load",this._onAssetLoad,this);this._assets.load(asset);return}this.fire("load",asset.resource);}setExternalNodes(firstNode,lastNode){if(!firstNode){console.error("The firstNode must have a valid AudioNode");return}if(!lastNode){lastNode=firstNode;}this._firstNode=firstNode;this._lastNode=lastNode;if(!this._overlap){const instances=this.instances;for(let i=0,len=instances.length;i<len;i++){instances[i].setExternalNodes(firstNode,lastNode);}}}clearExternalNodes(){this._firstNode=null;this._lastNode=null;if(!this._overlap){const instances=this.instances;for(let i=0,len=instances.length;i<len;i++){instances[i].clearExternalNodes();}}}getExternalNodes(){return [this._firstNode,this._lastNode]}_hasAsset(){return this._asset!=null}_createInstance(){let instance=null;const component=this._component;let sound=null;if(this._hasAsset()){const asset=this._assets.get(this._asset);if(asset){sound=asset.resource;}}const data=instanceOptions;data.volume=this._volume*component.volume;data.pitch=this._pitch*component.pitch;data.loop=this._loop;data.startTime=this._startTime;data.duration=this._duration;data.onPlay=this._onInstancePlayHandler;data.onPause=this._onInstancePauseHandler;data.onResume=this._onInstanceResumeHandler;data.onStop=this._onInstanceStopHandler;data.onEnd=this._onInstanceEndHandler;if(component.positional){data.position.copy(component.entity.getPosition());data.maxDistance=component.maxDistance;data.refDistance=component.refDistance;data.rollOffFactor=component.rollOffFactor;data.distanceModel=component.distanceModel;instance=new SoundInstance3d(this._manager,sound,data);}else {instance=new SoundInstance(this._manager,sound,data);}if(this._firstNode){instance.setExternalNodes(this._firstNode,this._lastNode);}return instance}_onInstancePlay(instance){this.fire("play",instance);this._component.fire("play",this,instance);}_onInstancePause(instance){this.fire("pause",instance);this._component.fire("pause",this,instance);}_onInstanceResume(instance){this.fire("resume",instance);this._component.fire("resume",this,instance);}_onInstanceStop(instance){const idx=this.instances.indexOf(instance);if(idx!==-1){this.instances.splice(idx,1);}this.fire("stop",instance);this._component.fire("stop",this,instance);}_onInstanceEnd(instance){const idx=this.instances.indexOf(instance);if(idx!==-1){this.instances.splice(idx,1);}this.fire("end",instance);this._component.fire("end",this,instance);}_onAssetAdd(asset){this.load();}_onAssetLoad(asset){this.load();}_onAssetRemoved(asset){asset.off("remove",this._onAssetRemoved,this);this._assets.off(`add:${asset.id}`,this._onAssetAdd,this);this.stop();}updatePosition(position){const instances=this.instances;for(let i=0,len=instances.length;i<len;i++){instances[i].position=position;}}set asset(value){const old=this._asset;if(old){this._assets.off(`add:${old}`,this._onAssetAdd,this);const oldAsset=this._assets.get(old);if(oldAsset){oldAsset.off("remove",this._onAssetRemoved,this);}}this._asset=value;if(this._asset instanceof Asset){this._asset=this._asset.id;}if(this._hasAsset()&&this._component.enabled&&this._component.entity.enabled){this.load();}}get asset(){return this._asset}set autoPlay(value){this._autoPlay=!!value;}get autoPlay(){return this._autoPlay}set duration(value){this._duration=Math.max(0,Number(value)||0)||null;if(!this._overlap){const instances=this.instances;for(let i=0,len=instances.length;i<len;i++){instances[i].duration=this._duration;}}}get duration(){let assetDuration=0;if(this._hasAsset()){const asset=this._assets.get(this._asset);assetDuration=asset!=null&&asset.resource?asset.resource.duration:0;}if(this._duration!=null){return this._duration%(assetDuration||1)}return assetDuration}get isLoaded(){if(this._hasAsset()){const asset=this._assets.get(this._asset);if(asset){return !!asset.resource}}return false}get isPaused(){const instances=this.instances;const len=instances.length;if(len===0){return false}for(let i=0;i<len;i++){if(!instances[i].isPaused){return false}}return true}get isPlaying(){const instances=this.instances;for(let i=0,len=instances.length;i<len;i++){if(instances[i].isPlaying){return true}}return false}get isStopped(){const instances=this.instances;for(let i=0,len=instances.length;i<len;i++){if(!instances[i].isStopped){return false}}return true}set loop(value){this._loop=!!value;const instances=this.instances;for(let i=0,len=instances.length;i<len;i++){instances[i].loop=this._loop;}}get loop(){return this._loop}set overlap(value){this._overlap=!!value;}get overlap(){return this._overlap}set pitch(value){this._pitch=Math.max(Number(value)||0,.01);if(!this._overlap){const instances=this.instances;for(let i=0,len=instances.length;i<len;i++){instances[i].pitch=this.pitch*this._component.pitch;}}}get pitch(){return this._pitch}set startTime(value){this._startTime=Math.max(0,Number(value)||0);if(!this._overlap){const instances=this.instances;for(let i=0,len=instances.length;i<len;i++){instances[i].startTime=this._startTime;}}}get startTime(){return this._startTime}set volume(value){this._volume=math.clamp(Number(value)||0,0,1);if(!this._overlap){const instances=this.instances;for(let i=0,len=instances.length;i<len;i++){instances[i].volume=this._volume*this._component.volume;}}}get volume(){return this._volume}constructor(component,name="Untitled",options={}){super();this.name=void 0;this.instances=[];this._component=component;this._assets=component.system.app.assets;this._manager=component.system.manager;this.name=name;this._volume=options.volume!==undefined?math.clamp(Number(options.volume)||0,0,1):1;this._pitch=options.pitch!==undefined?Math.max(.01,Number(options.pitch)||0):1;this._loop=!!(options.loop!==undefined?options.loop:false);this._duration=options.duration>0?options.duration:null;this._startTime=Math.max(0,Number(options.startTime)||0);this._overlap=!!options.overlap;this._autoPlay=!!options.autoPlay;this._firstNode=null;this._lastNode=null;this._asset=options.asset;if(this._asset instanceof Asset){this._asset=this._asset.id;}this._onInstancePlayHandler=this._onInstancePlay.bind(this);this._onInstancePauseHandler=this._onInstancePause.bind(this);this._onInstanceResumeHandler=this._onInstanceResume.bind(this);this._onInstanceStopHandler=this._onInstanceStop.bind(this);this._onInstanceEndHandler=this._onInstanceEnd.bind(this);}}SoundSlot.EVENT_PLAY="play";SoundSlot.EVENT_PAUSE="pause";SoundSlot.EVENT_RESUME="resume";SoundSlot.EVENT_STOP="stop";SoundSlot.EVENT_LOAD="load";class SoundComponent extends Component{_updateSoundInstances(property,value,isFactor){const slots=this._slots;for(const key in slots){const slot=slots[key];if(!slot.overlap){const instances=slot.instances;for(let i=0,len=instances.length;i<len;i++){instances[i][property]=isFactor?slot[property]*value:value;}}}}set distanceModel(value){this._distanceModel=value;this._updateSoundInstances("distanceModel",value,false);}get distanceModel(){return this._distanceModel}set maxDistance(value){this._maxDistance=value;this._updateSoundInstances("maxDistance",value,false);}get maxDistance(){return this._maxDistance}set refDistance(value){this._refDistance=value;this._updateSoundInstances("refDistance",value,false);}get refDistance(){return this._refDistance}set rollOffFactor(value){this._rollOffFactor=value;this._updateSoundInstances("rollOffFactor",value,false);}get rollOffFactor(){return this._rollOffFactor}set pitch(value){this._pitch=value;this._updateSoundInstances("pitch",value,true);}get pitch(){return this._pitch}set volume(value){this._volume=value;this._updateSoundInstances("volume",value,true);}get volume(){return this._volume}set positional(newValue){this._positional=newValue;const slots=this._slots;for(const key in slots){const slot=slots[key];if(!slot.overlap){const instances=slot.instances;const oldLength=instances.length;for(let i=oldLength-1;i>=0;i--){const isPlaying=instances[i].isPlaying||instances[i].isSuspended;const currentTime=instances[i].currentTime;if(isPlaying){instances[i].stop();}const instance=slot._createInstance();if(isPlaying){instance.play();instance.currentTime=currentTime;}instances.push(instance);}}}}get positional(){return this._positional}set slots(newValue){const oldValue=this._slots;if(oldValue){for(const key in oldValue){oldValue[key].stop();}}const slots={};for(const key in newValue){if(!(newValue[key]instanceof SoundSlot)){if(newValue[key].name){slots[newValue[key].name]=new SoundSlot(this,newValue[key].name,newValue[key]);}}else {slots[newValue[key].name]=newValue[key];}}this._slots=slots;if(this.enabled&&this.entity.enabled){this.onEnable();}}get slots(){return this._slots}onEnable(){if(this.system._inTools){return}const slots=this._slots;const playingBeforeDisable=this._playingBeforeDisable;for(const key in slots){const slot=slots[key];if(slot.autoPlay&&slot.isStopped){slot.play();}else if(playingBeforeDisable[key]){slot.resume();}else if(!slot.isLoaded){slot.load();}}}onDisable(){const slots=this._slots;const playingBeforeDisable={};for(const key in slots){if(!slots[key].overlap){if(slots[key].isPlaying){slots[key].pause();playingBeforeDisable[key]=true;}}}this._playingBeforeDisable=playingBeforeDisable;}onRemove(){this.off();}addSlot(name,options){const slots=this._slots;if(slots[name]){return null}const slot=new SoundSlot(this,name,options);slots[name]=slot;if(slot.autoPlay&&this.enabled&&this.entity.enabled){slot.play();}return slot}removeSlot(name){const slots=this._slots;if(slots[name]){slots[name].stop();delete slots[name];}}slot(name){return this._slots[name]}_getSlotProperty(name,property){if(!this.enabled||!this.entity.enabled){return undefined}const slot=this._slots[name];if(!slot){return undefined}return slot[property]}isPlaying(name){return this._getSlotProperty(name,"isPlaying")||false}isLoaded(name){return this._getSlotProperty(name,"isLoaded")||false}isPaused(name){return this._getSlotProperty(name,"isPaused")||false}isStopped(name){return this._getSlotProperty(name,"isStopped")||false}play(name){if(!this.enabled||!this.entity.enabled){return null}const slot=this._slots[name];if(!slot){return null}return slot.play()}pause(name){const slots=this._slots;if(name){const slot=slots[name];if(!slot){return}slot.pause();}else {for(const key in slots){slots[key].pause();}}}resume(name){const slots=this._slots;if(name){const slot=slots[name];if(!slot){return}if(slot.isPaused){slot.resume();}}else {for(const key in slots){slots[key].resume();}}}stop(name){const slots=this._slots;if(name){const slot=slots[name];if(!slot){return}slot.stop();}else {for(const key in slots){slots[key].stop();}}}constructor(system,entity){super(system,entity);this._volume=1;this._pitch=1;this._positional=true;this._refDistance=1;this._maxDistance=1e4;this._rollOffFactor=1;this._distanceModel=DISTANCE_LINEAR;this._slots={};this._playingBeforeDisable={};}}SoundComponent.EVENT_PLAY="play";SoundComponent.EVENT_PAUSE="pause";SoundComponent.EVENT_RESUME="resume";SoundComponent.EVENT_STOP="stop";SoundComponent.EVENT_END="end";class SoundComponentData{constructor(){this.enabled=true;}}const _schema$4=["enabled"];class SoundComponentSystem extends ComponentSystem{set volume(volume){this.manager.volume=volume;}get volume(){return this.manager.volume}get context(){if(!hasAudioContext()){return null}return this.manager.context}initializeComponentData(component,data,properties){properties=["volume","pitch","positional","refDistance","maxDistance","rollOffFactor","distanceModel","slots"];for(let i=0;i<properties.length;i++){if(data.hasOwnProperty(properties[i])){component[properties[i]]=data[properties[i]];}}super.initializeComponentData(component,data,["enabled"]);}cloneComponent(entity,clone){const srcComponent=entity.sound;const srcSlots=srcComponent.slots;const slots={};for(const key in srcSlots){const srcSlot=srcSlots[key];slots[key]={name:srcSlot.name,volume:srcSlot.volume,pitch:srcSlot.pitch,loop:srcSlot.loop,duration:srcSlot.duration,startTime:srcSlot.startTime,overlap:srcSlot.overlap,autoPlay:srcSlot.autoPlay,asset:srcSlot.asset};}const cloneData={distanceModel:srcComponent.distanceModel,enabled:srcComponent.enabled,maxDistance:srcComponent.maxDistance,pitch:srcComponent.pitch,positional:srcComponent.positional,refDistance:srcComponent.refDistance,rollOffFactor:srcComponent.rollOffFactor,slots:slots,volume:srcComponent.volume};return this.addComponent(clone,cloneData)}onUpdate(dt){const store=this.store;for(const id in store){if(store.hasOwnProperty(id)){const item=store[id];const entity=item.entity;if(entity.enabled){const component=entity.sound;if(component.enabled&&component.positional){const position=entity.getPosition();const slots=component.slots;for(const key in slots){slots[key].updatePosition(position);}}}}}}onBeforeRemove(entity,component){const slots=component.slots;for(const key in slots){if(!slots[key].overlap){slots[key].stop();}}component.onRemove();}destroy(){super.destroy();this.app.systems.off("update",this.onUpdate,this);}constructor(app){super(app);this.id="sound";this.ComponentType=SoundComponent;this.DataType=SoundComponentData;this.schema=_schema$4;this.manager=app.soundManager;this.app.systems.on("update",this.onUpdate,this);this.on("beforeremove",this.onBeforeRemove,this);}}Component._buildAccessors(SoundComponent.prototype,_schema$4);const SPRITETYPE_SIMPLE="simple";const SPRITETYPE_ANIMATED="animated";class SpriteAnimationClip extends EventHandler{get duration(){if(this._sprite){const fps=this.fps||Number.MIN_VALUE;return this._sprite.frameKeys.length/Math.abs(fps)}return 0}set frame(value){this._setFrame(value);const fps=this.fps||Number.MIN_VALUE;this._setTime(this._frame/fps);}get frame(){return this._frame}get isPaused(){return this._paused}get isPlaying(){return this._playing}set sprite(value){if(this._sprite){var _this$_evtSetMeshes;(_this$_evtSetMeshes=this._evtSetMeshes)==null||_this$_evtSetMeshes.off();this._evtSetMeshes=null;this._sprite.off("set:pixelsPerUnit",this._onSpritePpuChanged,this);this._sprite.off("set:atlas",this._onSpriteMeshesChange,this);if(this._sprite.atlas){this._sprite.atlas.off("set:texture",this._onSpriteMeshesChange,this);}}this._sprite=value;if(this._sprite){this._evtSetMeshes=this._sprite.on("set:meshes",this._onSpriteMeshesChange,this);this._sprite.on("set:pixelsPerUnit",this._onSpritePpuChanged,this);this._sprite.on("set:atlas",this._onSpriteMeshesChange,this);if(this._sprite.atlas){this._sprite.atlas.on("set:texture",this._onSpriteMeshesChange,this);}}if(this._component.currentClip===this){let mi;if(!value||!value.atlas){mi=this._component._meshInstance;if(mi){mi.deleteParameter("texture_emissiveMap");mi.deleteParameter("texture_opacityMap");}this._component._hideModel();}else {if(value.atlas.texture){mi=this._component._meshInstance;if(mi){mi.setParameter("texture_emissiveMap",value.atlas.texture);mi.setParameter("texture_opacityMap",value.atlas.texture);}if(this._component.enabled&&this._component.entity.enabled){this._component._showModel();}}if(this.time&&this.fps){this.time=this.time;}else {this.frame=this.frame;}}}}get sprite(){return this._sprite}set spriteAsset(value){const assets=this._component.system.app.assets;let id=value;if(value instanceof Asset){id=value.id;}if(this._spriteAsset!==id){if(this._spriteAsset){const prev=assets.get(this._spriteAsset);if(prev){this._unbindSpriteAsset(prev);}}this._spriteAsset=id;if(this._spriteAsset){const asset=assets.get(this._spriteAsset);if(!asset){this.sprite=null;assets.on(`add:${this._spriteAsset}`,this._onSpriteAssetAdded,this);}else {this._bindSpriteAsset(asset);}}else {this.sprite=null;}}}get spriteAsset(){return this._spriteAsset}set time(value){this._setTime(value);if(this._sprite){this.frame=Math.min(this._sprite.frameKeys.length-1,Math.floor(this._time*Math.abs(this.fps)));}else {this.frame=0;}}get time(){return this._time}_onSpriteAssetAdded(asset){this._component.system.app.assets.off(`add:${asset.id}`,this._onSpriteAssetAdded,this);if(this._spriteAsset===asset.id){this._bindSpriteAsset(asset);}}_bindSpriteAsset(asset){asset.on("load",this._onSpriteAssetLoad,this);asset.on("remove",this._onSpriteAssetRemove,this);if(asset.resource){this._onSpriteAssetLoad(asset);}else {this._component.system.app.assets.load(asset);}}_unbindSpriteAsset(asset){if(!asset){return}asset.off("load",this._onSpriteAssetLoad,this);asset.off("remove",this._onSpriteAssetRemove,this);if(asset.resource&&!asset.resource.atlas){this._component.system.app.assets.off(`load:${asset.data.textureAtlasAsset}`,this._onTextureAtlasLoad,this);}}_onSpriteAssetLoad(asset){if(!asset.resource){this.sprite=null;}else {if(!asset.resource.atlas){const atlasAssetId=asset.data.textureAtlasAsset;const assets=this._component.system.app.assets;assets.off(`load:${atlasAssetId}`,this._onTextureAtlasLoad,this);assets.once(`load:${atlasAssetId}`,this._onTextureAtlasLoad,this);}else {this.sprite=asset.resource;}}}_onTextureAtlasLoad(atlasAsset){const spriteAsset=this._spriteAsset;if(spriteAsset instanceof Asset){this._onSpriteAssetLoad(spriteAsset);}else {this._onSpriteAssetLoad(this._component.system.app.assets.get(spriteAsset));}}_onSpriteAssetRemove(asset){this.sprite=null;}_onSpriteMeshesChange(){if(this._component.currentClip===this){this._component._showFrame(this.frame);}}_onSpritePpuChanged(){if(this._component.currentClip===this){if(this.sprite.renderMode!==SPRITE_RENDERMODE_SIMPLE){this._component._showFrame(this.frame);}}}_update(dt){if(this.fps===0)return;if(!this._playing||this._paused||!this._sprite)return;const dir=this.fps<0?-1:1;const time=this._time+dt*this._component.speed*dir;const duration=this.duration;const end=time>duration||time<0;this._setTime(time);let frame=this.frame;if(this._sprite){frame=Math.floor(this._sprite.frameKeys.length*this._time/duration);}else {frame=0;}if(frame!==this._frame){this._setFrame(frame);}if(end){if(this.loop){this.fire("loop");this._component.fire("loop",this);}else {this._playing=false;this._paused=false;this.fire("end");this._component.fire("end",this);}}}_setTime(value){this._time=value;const duration=this.duration;if(this._time<0){if(this.loop){this._time=this._time%duration+duration;}else {this._time=0;}}else if(this._time>duration){if(this.loop){this._time%=duration;}else {this._time=duration;}}}_setFrame(value){if(this._sprite){this._frame=math.clamp(value,0,this._sprite.frameKeys.length-1);}else {this._frame=value;}if(this._component.currentClip===this){this._component._showFrame(this._frame);}}_destroy(){if(this._spriteAsset){const assets=this._component.system.app.assets;this._unbindSpriteAsset(assets.get(this._spriteAsset));}if(this._sprite){this.sprite=null;}if(this._spriteAsset){this.spriteAsset=null;}}play(){if(this._playing){return}this._playing=true;this._paused=false;this.frame=0;this.fire("play");this._component.fire("play",this);}pause(){if(!this._playing||this._paused){return}this._paused=true;this.fire("pause");this._component.fire("pause",this);}resume(){if(!this._paused)return;this._paused=false;this.fire("resume");this._component.fire("resume",this);}stop(){if(!this._playing)return;this._playing=false;this._paused=false;this._time=0;this.frame=0;this.fire("stop");this._component.fire("stop",this);}constructor(component,data){super();this._evtSetMeshes=null;this._component=component;this._frame=0;this._sprite=null;this._spriteAsset=null;this.spriteAsset=data.spriteAsset;this.name=data.name;this.fps=data.fps||0;this.loop=data.loop||false;this._playing=false;this._paused=false;this._time=0;}}SpriteAnimationClip.EVENT_PLAY="play";SpriteAnimationClip.EVENT_PAUSE="pause";SpriteAnimationClip.EVENT_RESUME="resume";SpriteAnimationClip.EVENT_STOP="stop";SpriteAnimationClip.EVENT_END="end";SpriteAnimationClip.EVENT_LOOP="loop";const PARAM_EMISSIVE_MAP="texture_emissiveMap";const PARAM_OPACITY_MAP="texture_opacityMap";const PARAM_EMISSIVE="material_emissive";const PARAM_OPACITY="material_opacity";const PARAM_INNER_OFFSET="innerOffset";const PARAM_OUTER_SCALE="outerScale";const PARAM_ATLAS_RECT="atlasRect";class SpriteComponent extends Component{set type(value){if(this._type===value){return}this._type=value;if(this._type===SPRITETYPE_SIMPLE){this.stop();this._currentClip=this._defaultClip;if(this.enabled&&this.entity.enabled){this._currentClip.frame=this.frame;if(this._currentClip.sprite){this._showModel();}else {this._hideModel();}}}else if(this._type===SPRITETYPE_ANIMATED){this.stop();if(this._autoPlayClip){this._tryAutoPlay();}if(this._currentClip&&this._currentClip.isPlaying&&this.enabled&&this.entity.enabled){this._showModel();}else {this._hideModel();}}}get type(){return this._type}set frame(value){this._currentClip.frame=value;}get frame(){return this._currentClip.frame}set spriteAsset(value){this._defaultClip.spriteAsset=value;}get spriteAsset(){return this._defaultClip._spriteAsset}set sprite(value){this._currentClip.sprite=value;}get sprite(){return this._currentClip.sprite}set material(value){this._material=value;if(this._meshInstance){this._meshInstance.material=value;}}get material(){return this._material}set color(value){this._color.r=value.r;this._color.g=value.g;this._color.b=value.b;if(this._meshInstance){this._colorUniform[0]=this._color.r;this._colorUniform[1]=this._color.g;this._colorUniform[2]=this._color.b;this._meshInstance.setParameter(PARAM_EMISSIVE,this._colorUniform);}}get color(){return this._color}set opacity(value){this._color.a=value;if(this._meshInstance){this._meshInstance.setParameter(PARAM_OPACITY,value);}}get opacity(){return this._color.a}set clips(value){if(!value){for(const name in this._clips){this.removeClip(name);}return}for(const name in this._clips){let found=false;for(const key in value){if(value[key].name===name){found=true;this._clips[name].fps=value[key].fps;this._clips[name].loop=value[key].loop;if(value[key].hasOwnProperty("sprite")){this._clips[name].sprite=value[key].sprite;}else if(value[key].hasOwnProperty("spriteAsset")){this._clips[name].spriteAsset=value[key].spriteAsset;}break}}if(!found){this.removeClip(name);}}for(const key in value){if(this._clips[value[key].name])continue;this.addClip(value[key]);}if(this._autoPlayClip){this._tryAutoPlay();}if(!this._currentClip||!this._currentClip.sprite){this._hideModel();}}get clips(){return this._clips}get currentClip(){return this._currentClip}set speed(value){this._speed=value;}get speed(){return this._speed}set flipX(value){if(this._flipX===value)return;this._flipX=value;this._updateTransform();}get flipX(){return this._flipX}set flipY(value){if(this._flipY===value)return;this._flipY=value;this._updateTransform();}get flipY(){return this._flipY}set width(value){if(value===this._width)return;this._width=value;this._outerScale.x=this._width;if(this.sprite&&(this.sprite.renderMode===SPRITE_RENDERMODE_TILED||this.sprite.renderMode===SPRITE_RENDERMODE_SLICED)){this._updateTransform();}}get width(){return this._width}set height(value){if(value===this._height)return;this._height=value;this._outerScale.y=this.height;if(this.sprite&&(this.sprite.renderMode===SPRITE_RENDERMODE_TILED||this.sprite.renderMode===SPRITE_RENDERMODE_SLICED)){this._updateTransform();}}get height(){return this._height}set batchGroupId(value){if(this._batchGroupId===value){return}const prev=this._batchGroupId;this._batchGroupId=value;if(this.entity.enabled&&prev>=0){var _this$system$app$batc;(_this$system$app$batc=this.system.app.batcher)==null||_this$system$app$batc.remove(BatchGroup.SPRITE,prev,this.entity);}if(this.entity.enabled&&value>=0){var _this$system$app$batc2;(_this$system$app$batc2=this.system.app.batcher)==null||_this$system$app$batc2.insert(BatchGroup.SPRITE,value,this.entity);}else {if(prev>=0){if(this._currentClip&&this._currentClip.sprite&&this.enabled&&this.entity.enabled){this._showModel();}}}}get batchGroupId(){return this._batchGroupId}set autoPlayClip(value){this._autoPlayClip=value instanceof SpriteAnimationClip?value.name:value;this._tryAutoPlay();}get autoPlayClip(){return this._autoPlayClip}set drawOrder(value){this._drawOrder=value;if(this._meshInstance){this._meshInstance.drawOrder=value;}}get drawOrder(){return this._drawOrder}set layers(value){if(this._addedModel){this._hideModel();}this._layers=value;if(!this._meshInstance){return}if(this.enabled&&this.entity.enabled){this._showModel();}}get layers(){return this._layers}get aabb(){if(this._meshInstance){return this._meshInstance.aabb}return null}onEnable(){const app=this.system.app;const scene=app.scene;const layers=scene.layers;this._evtLayersChanged=scene.on("set:layers",this._onLayersChanged,this);if(layers){this._evtLayerAdded=layers.on("add",this._onLayerAdded,this);this._evtLayerRemoved=layers.on("remove",this._onLayerRemoved,this);}this._showModel();if(this._autoPlayClip){this._tryAutoPlay();}if(this._batchGroupId>=0){var _app$batcher;(_app$batcher=app.batcher)==null||_app$batcher.insert(BatchGroup.SPRITE,this._batchGroupId,this.entity);}}onDisable(){var _this$_evtLayersChang;const app=this.system.app;const scene=app.scene;const layers=scene.layers;(_this$_evtLayersChang=this._evtLayersChanged)==null||_this$_evtLayersChang.off();this._evtLayersChanged=null;if(layers){var _this$_evtLayerAdded,_this$_evtLayerRemove;(_this$_evtLayerAdded=this._evtLayerAdded)==null||_this$_evtLayerAdded.off();this._evtLayerAdded=null;(_this$_evtLayerRemove=this._evtLayerRemoved)==null||_this$_evtLayerRemove.off();this._evtLayerRemoved=null;}this.stop();this._hideModel();if(this._batchGroupId>=0){var _app$batcher2;(_app$batcher2=app.batcher)==null||_app$batcher2.remove(BatchGroup.SPRITE,this._batchGroupId,this.entity);}}onDestroy(){var _this$_node;this._currentClip=null;if(this._defaultClip){this._defaultClip._destroy();this._defaultClip=null;}for(const key in this._clips){this._clips[key]._destroy();}this._clips=null;this._hideModel();this._model=null;(_this$_node=this._node)==null||_this$_node.remove();this._node=null;if(this._meshInstance){this._meshInstance.material=null;this._meshInstance.mesh=null;this._meshInstance=null;}}_showModel(){if(this._addedModel)return;if(!this._meshInstance)return;const meshInstances=[this._meshInstance];for(let i=0,len=this._layers.length;i<len;i++){const layer=this.system.app.scene.layers.getLayerById(this._layers[i]);if(layer){layer.addMeshInstances(meshInstances);}}this._addedModel=true;}_hideModel(){if(!this._addedModel||!this._meshInstance)return;const meshInstances=[this._meshInstance];for(let i=0,len=this._layers.length;i<len;i++){const layer=this.system.app.scene.layers.getLayerById(this._layers[i]);if(layer){layer.removeMeshInstances(meshInstances);}}this._addedModel=false;}_showFrame(frame){if(!this.sprite)return;const mesh=this.sprite.meshes[frame];if(!mesh){if(this._meshInstance){this._meshInstance.mesh=null;this._meshInstance.visible=false;}return}let material;if(this.sprite.renderMode===SPRITE_RENDERMODE_SLICED){material=this.system.default9SlicedMaterialSlicedMode;}else if(this.sprite.renderMode===SPRITE_RENDERMODE_TILED){material=this.system.default9SlicedMaterialTiledMode;}else {material=this.system.defaultMaterial;}if(!this._meshInstance){this._meshInstance=new MeshInstance(mesh,this._material,this._node);this._meshInstance.castShadow=false;this._meshInstance.receiveShadow=false;this._meshInstance.drawOrder=this._drawOrder;this._model.meshInstances.push(this._meshInstance);this._colorUniform[0]=this._color.r;this._colorUniform[1]=this._color.g;this._colorUniform[2]=this._color.b;this._meshInstance.setParameter(PARAM_EMISSIVE,this._colorUniform);this._meshInstance.setParameter(PARAM_OPACITY,this._color.a);if(this.enabled&&this.entity.enabled){this._showModel();}}if(this._meshInstance.material!==material){this._meshInstance.material=material;}if(this._meshInstance.mesh!==mesh){this._meshInstance.mesh=mesh;this._meshInstance.visible=true;this._meshInstance._aabbVer=-1;}if(this.sprite.atlas&&this.sprite.atlas.texture){this._meshInstance.setParameter(PARAM_EMISSIVE_MAP,this.sprite.atlas.texture);this._meshInstance.setParameter(PARAM_OPACITY_MAP,this.sprite.atlas.texture);}else {this._meshInstance.deleteParameter(PARAM_EMISSIVE_MAP);this._meshInstance.deleteParameter(PARAM_OPACITY_MAP);}if(this.sprite.atlas&&(this.sprite.renderMode===SPRITE_RENDERMODE_SLICED||this.sprite.renderMode===SPRITE_RENDERMODE_TILED)){this._meshInstance._updateAabbFunc=this._updateAabbFunc;const frameData=this.sprite.atlas.frames[this.sprite.frameKeys[frame]];if(frameData){const borderWidthScale=2/frameData.rect.z;const borderHeightScale=2/frameData.rect.w;this._innerOffset.set(frameData.border.x*borderWidthScale,frameData.border.y*borderHeightScale,frameData.border.z*borderWidthScale,frameData.border.w*borderHeightScale);const tex=this.sprite.atlas.texture;this._atlasRect.set(frameData.rect.x/tex.width,frameData.rect.y/tex.height,frameData.rect.z/tex.width,frameData.rect.w/tex.height);}else {this._innerOffset.set(0,0,0,0);}this._innerOffsetUniform[0]=this._innerOffset.x;this._innerOffsetUniform[1]=this._innerOffset.y;this._innerOffsetUniform[2]=this._innerOffset.z;this._innerOffsetUniform[3]=this._innerOffset.w;this._meshInstance.setParameter(PARAM_INNER_OFFSET,this._innerOffsetUniform);this._atlasRectUniform[0]=this._atlasRect.x;this._atlasRectUniform[1]=this._atlasRect.y;this._atlasRectUniform[2]=this._atlasRect.z;this._atlasRectUniform[3]=this._atlasRect.w;this._meshInstance.setParameter(PARAM_ATLAS_RECT,this._atlasRectUniform);}else {this._meshInstance._updateAabbFunc=null;}this._updateTransform();}_updateTransform(){let scaleX=this.flipX?-1:1;let scaleY=this.flipY?-1:1;let posX=0;let posY=0;if(this.sprite&&(this.sprite.renderMode===SPRITE_RENDERMODE_SLICED||this.sprite.renderMode===SPRITE_RENDERMODE_TILED)){let w=1;let h=1;if(this.sprite.atlas){const frameData=this.sprite.atlas.frames[this.sprite.frameKeys[this.frame]];if(frameData){w=frameData.rect.z;h=frameData.rect.w;posX=(.5-frameData.pivot.x)*this._width;posY=(.5-frameData.pivot.y)*this._height;}}const scaleMulX=w/this.sprite.pixelsPerUnit;const scaleMulY=h/this.sprite.pixelsPerUnit;this._outerScale.set(Math.max(this._width,this._innerOffset.x*scaleMulX),Math.max(this._height,this._innerOffset.y*scaleMulY));scaleX*=scaleMulX;scaleY*=scaleMulY;this._outerScale.x/=scaleMulX;this._outerScale.y/=scaleMulY;scaleX*=math.clamp(this._width/(this._innerOffset.x*scaleMulX),1e-4,1);scaleY*=math.clamp(this._height/(this._innerOffset.y*scaleMulY),1e-4,1);if(this._meshInstance){this._outerScaleUniform[0]=this._outerScale.x;this._outerScaleUniform[1]=this._outerScale.y;this._meshInstance.setParameter(PARAM_OUTER_SCALE,this._outerScaleUniform);}}this._node.setLocalScale(scaleX,scaleY,1);this._node.setLocalPosition(posX,posY,0);}_updateAabb(aabb){aabb.center.set(0,0,0);aabb.halfExtents.set(this._outerScale.x*.5,this._outerScale.y*.5,.001);aabb.setFromTransformedAabb(aabb,this._node.getWorldTransform());return aabb}_tryAutoPlay(){if(!this._autoPlayClip)return;if(this.type!==SPRITETYPE_ANIMATED)return;const clip=this._clips[this._autoPlayClip];if(clip&&!clip.isPlaying&&(!this._currentClip||!this._currentClip.isPlaying)){if(this.enabled&&this.entity.enabled){this.play(clip.name);}}}_onLayersChanged(oldComp,newComp){oldComp.off("add",this.onLayerAdded,this);oldComp.off("remove",this.onLayerRemoved,this);newComp.on("add",this.onLayerAdded,this);newComp.on("remove",this.onLayerRemoved,this);if(this.enabled&&this.entity.enabled){this._showModel();}}_onLayerAdded(layer){const index=this.layers.indexOf(layer.id);if(index<0)return;if(this._addedModel&&this.enabled&&this.entity.enabled&&this._meshInstance){layer.addMeshInstances([this._meshInstance]);}}_onLayerRemoved(layer){if(!this._meshInstance)return;const index=this.layers.indexOf(layer.id);if(index<0)return;layer.removeMeshInstances([this._meshInstance]);}removeModelFromLayers(){for(let i=0;i<this.layers.length;i++){const layer=this.system.app.scene.layers.getLayerById(this.layers[i]);if(!layer)continue;layer.removeMeshInstances([this._meshInstance]);}}addClip(data){const clip=new SpriteAnimationClip(this,{name:data.name,fps:data.fps,loop:data.loop,spriteAsset:data.spriteAsset});this._clips[data.name]=clip;if(clip.name&&clip.name===this._autoPlayClip){this._tryAutoPlay();}return clip}removeClip(name){delete this._clips[name];}clip(name){return this._clips[name]}play(name){const clip=this._clips[name];const current=this._currentClip;if(current&&current!==clip){current._playing=false;}this._currentClip=clip;if(this._currentClip){this._currentClip=clip;this._currentClip.play();}return clip}pause(){if(this._currentClip===this._defaultClip)return;if(this._currentClip.isPlaying){this._currentClip.pause();}}resume(){if(this._currentClip===this._defaultClip)return;if(this._currentClip.isPaused){this._currentClip.resume();}}stop(){if(this._currentClip===this._defaultClip)return;this._currentClip.stop();}constructor(system,entity){super(system,entity);this._evtLayersChanged=null;this._evtLayerAdded=null;this._evtLayerRemoved=null;this._type=SPRITETYPE_SIMPLE;this._material=system.defaultMaterial;this._color=new Color(1,1,1,1);this._colorUniform=new Float32Array(3);this._speed=1;this._flipX=false;this._flipY=false;this._width=1;this._height=1;this._drawOrder=0;this._layers=[LAYERID_WORLD];this._outerScale=new Vec2(1,1);this._outerScaleUniform=new Float32Array(2);this._innerOffset=new Vec4;this._innerOffsetUniform=new Float32Array(4);this._atlasRect=new Vec4;this._atlasRectUniform=new Float32Array(4);this._batchGroupId=-1;this._batchGroup=null;this._node=new GraphNode;this._model=new Model;this._model.graph=this._node;this._meshInstance=null;entity.addChild(this._model.graph);this._model._entity=entity;this._updateAabbFunc=this._updateAabb.bind(this);this._addedModel=false;this._autoPlayClip=null;this._clips={};this._defaultClip=new SpriteAnimationClip(this,{name:this.entity.name,fps:0,loop:false,spriteAsset:null});this._currentClip=this._defaultClip;}}SpriteComponent.EVENT_PLAY="play";SpriteComponent.EVENT_PAUSE="pause";SpriteComponent.EVENT_RESUME="resume";SpriteComponent.EVENT_STOP="stop";SpriteComponent.EVENT_END="end";SpriteComponent.EVENT_LOOP="loop";class SpriteComponentData{constructor(){this.enabled=true;}}const _schema$3=["enabled"];class SpriteComponentSystem extends ComponentSystem{set defaultMaterial(material){this._defaultMaterial=material;}get defaultMaterial(){if(!this._defaultMaterial){const texture=new Texture(this.app.graphicsDevice,{width:1,height:1,format:PIXELFORMAT_RGBA8,name:"sprite"});const pixels=new Uint8Array(texture.lock());pixels[0]=pixels[1]=pixels[2]=pixels[3]=255;texture.unlock();const material=new StandardMaterial;material.diffuse.set(0,0,0);material.emissive.set(.5,.5,.5);material.emissiveMap=texture;material.emissiveTint=true;material.opacityMap=texture;material.opacityMapChannel="a";material.opacityTint=true;material.opacity=0;material.useLighting=false;material.useGammaTonemap=false;material.useFog=false;material.useSkybox=false;material.blendType=BLEND_PREMULTIPLIED;material.depthWrite=false;material.pixelSnap=false;material.cull=CULLFACE_NONE;material.update();this._defaultTexture=texture;this._defaultMaterial=material;}return this._defaultMaterial}set default9SlicedMaterialSlicedMode(material){this._default9SlicedMaterialSlicedMode=material;}get default9SlicedMaterialSlicedMode(){if(!this._default9SlicedMaterialSlicedMode){const material=this.defaultMaterial.clone();material.nineSlicedMode=SPRITE_RENDERMODE_SLICED;material.update();this._default9SlicedMaterialSlicedMode=material;}return this._default9SlicedMaterialSlicedMode}set default9SlicedMaterialTiledMode(material){this._default9SlicedMaterialTiledMode=material;}get default9SlicedMaterialTiledMode(){if(!this._default9SlicedMaterialTiledMode){const material=this.defaultMaterial.clone();material.nineSlicedMode=SPRITE_RENDERMODE_TILED;material.update();this._default9SlicedMaterialTiledMode=material;}return this._default9SlicedMaterialTiledMode}destroy(){super.destroy();this.app.systems.off("update",this.onUpdate,this);if(this._defaultTexture){this._defaultTexture.destroy();this._defaultTexture=null;}}initializeComponentData(component,data,properties){if(data.enabled!==undefined){component.enabled=data.enabled;}component.type=data.type;if(data.layers&&Array.isArray(data.layers)){component.layers=data.layers.slice(0);}if(data.drawOrder!==undefined){component.drawOrder=data.drawOrder;}if(data.color!==undefined){if(data.color instanceof Color){var _data$opacity;component.color.set(data.color.r,data.color.g,data.color.b,(_data$opacity=data.opacity)!=null?_data$opacity:1);}else {var _data$opacity2;component.color.set(data.color[0],data.color[1],data.color[2],(_data$opacity2=data.opacity)!=null?_data$opacity2:1);}component.color=component.color;}if(data.opacity!==undefined){component.opacity=data.opacity;}if(data.flipX!==undefined){component.flipX=data.flipX;}if(data.flipY!==undefined){component.flipY=data.flipY;}if(data.width!==undefined){component.width=data.width;}if(data.height!==undefined){component.height=data.height;}if(data.spriteAsset!==undefined){component.spriteAsset=data.spriteAsset;}if(data.sprite){component.sprite=data.sprite;}if(data.frame!==undefined){component.frame=data.frame;}if(data.clips){for(const name in data.clips){component.addClip(data.clips[name]);}}if(data.speed!==undefined){component.speed=data.speed;}if(data.autoPlayClip){component.autoPlayClip=data.autoPlayClip;}component.batchGroupId=data.batchGroupId===undefined||data.batchGroupId===null?-1:data.batchGroupId;super.initializeComponentData(component,data,properties);}cloneComponent(entity,clone){const source=entity.sprite;return this.addComponent(clone,{enabled:source.enabled,type:source.type,spriteAsset:source.spriteAsset,sprite:source.sprite,width:source.width,height:source.height,frame:source.frame,color:source.color.clone(),opacity:source.opacity,flipX:source.flipX,flipY:source.flipY,speed:source.speed,clips:source.clips,autoPlayClip:source.autoPlayClip,batchGroupId:source.batchGroupId,drawOrder:source.drawOrder,layers:source.layers.slice(0)})}onUpdate(dt){const components=this.store;for(const id in components){if(components.hasOwnProperty(id)){const component=components[id];if(component.data.enabled&&component.entity.enabled){const sprite=component.entity.sprite;if(sprite._currentClip){sprite._currentClip._update(dt);}}}}}onBeforeRemove(entity,component){component.onDestroy();}constructor(app){super(app);this.id="sprite";this.ComponentType=SpriteComponent;this.DataType=SpriteComponentData;this.schema=_schema$3;this._defaultTexture=null;this._defaultMaterial=null;this._default9SlicedMaterialSlicedMode=null;this._default9SlicedMaterialTiledMode=null;this.app.systems.on("update",this.onUpdate,this);this.on("beforeremove",this.onBeforeRemove,this);}}Component._buildAccessors(SpriteComponent.prototype,_schema$3);class ZoneComponent extends Component{set size(data){if(data instanceof Vec3){this._size.copy(data);}else if(data instanceof Array&&data.length>=3){this.size.set(data[0],data[1],data[2]);}}get size(){return this._size}onEnable(){this._checkState();}onDisable(){this._checkState();}_onSetEnabled(prop,old,value){this._checkState();}_checkState(){const state=this.enabled&&this.entity.enabled;if(state===this._oldState){return}this._oldState=state;this.fire("enable");this.fire("state",this.enabled);}_onBeforeRemove(){this.fire("remove");}constructor(system,entity){super(system,entity);this._oldState=true;this._size=new Vec3;this.on("set_enabled",this._onSetEnabled,this);}}ZoneComponent.EVENT_ENABLE="enable";ZoneComponent.EVENT_DISABLE="disable";ZoneComponent.EVENT_STATE="state";ZoneComponent.EVENT_REMOVE="remove";class ZoneComponentData{constructor(){this.enabled=true;}}const _schema$2=["enabled"];class ZoneComponentSystem extends ComponentSystem{initializeComponentData(component,data,properties){component.enabled=data.hasOwnProperty("enabled")?!!data.enabled:true;if(data.size){if(data.size instanceof Vec3){component.size.copy(data.size);}else if(data.size instanceof Array&&data.size.length>=3){component.size.set(data.size[0],data.size[1],data.size[2]);}}}cloneComponent(entity,clone){const data={size:entity.zone.size};return this.addComponent(clone,data)}_onBeforeRemove(entity,component){component._onBeforeRemove();}constructor(app){super(app);this.id="zone";this.ComponentType=ZoneComponent;this.DataType=ZoneComponentData;this.schema=_schema$2;this.on("beforeremove",this._onBeforeRemove,this);}}Component._buildAccessors(ZoneComponent.prototype,_schema$2);class PostEffectEntry{constructor(effect,inputTarget){this.effect=effect;this.inputTarget=inputTarget;this.outputTarget=null;this.name=effect.constructor.name;}}class PostEffectQueue{_allocateColorBuffer(format,name){var _renderTarget$width,_renderTarget$height;const rect=this.camera.rect;const renderTarget=this.destinationRenderTarget;const device=this.app.graphicsDevice;const width=Math.floor(rect.z*((_renderTarget$width=renderTarget==null?void 0:renderTarget.width)!=null?_renderTarget$width:device.width));const height=Math.floor(rect.w*((_renderTarget$height=renderTarget==null?void 0:renderTarget.height)!=null?_renderTarget$height:device.height));const colorBuffer=new Texture(device,{name:name,format:format,width:width,height:height,mipmaps:false,minFilter:FILTER_NEAREST,magFilter:FILTER_NEAREST,addressU:ADDRESS_CLAMP_TO_EDGE,addressV:ADDRESS_CLAMP_TO_EDGE});return colorBuffer}_createOffscreenTarget(useDepth,hdr){const device=this.app.graphicsDevice;const format=hdr&&device.getRenderableHdrFormat([PIXELFORMAT_RGBA16F,PIXELFORMAT_RGBA32F],true)||PIXELFORMAT_RGBA8;const name=`${this.camera.entity.name}-posteffect-${this.effects.length}`;const colorBuffer=this._allocateColorBuffer(format,name);return new RenderTarget({colorBuffer:colorBuffer,depth:useDepth,stencil:useDepth&&this.app.graphicsDevice.supportsStencil,samples:useDepth?device.samples:1})}_resizeOffscreenTarget(rt){const format=rt.colorBuffer.format;const name=rt.colorBuffer.name;rt.destroyFrameBuffers();rt.destroyTextureBuffers();rt._colorBuffer=this._allocateColorBuffer(format,name);rt._colorBuffers=[rt._colorBuffer];}_destroyOffscreenTarget(rt){rt.destroyTextureBuffers();rt.destroy();}addEffect(effect){const effects=this.effects;const isFirstEffect=effects.length===0;const inputTarget=this._createOffscreenTarget(isFirstEffect,effect.hdr);const newEntry=new PostEffectEntry(effect,inputTarget);effects.push(newEntry);this._sourceTarget=newEntry.inputTarget;if(effects.length>1){effects[effects.length-2].outputTarget=newEntry.inputTarget;}this._newPostEffect=effect;if(effect.needsDepthBuffer){this._requestDepthMap();}this.enable();this._newPostEffect=undefined;}removeEffect(effect){let index=-1;for(let i=0,len=this.effects.length;i<len;i++){if(this.effects[i].effect===effect){index=i;break}}if(index>=0){if(index>0){this.effects[index-1].outputTarget=index+1<this.effects.length?this.effects[index+1].inputTarget:null;}else {if(this.effects.length>1){if(!this.effects[1].inputTarget._depth){this._destroyOffscreenTarget(this.effects[1].inputTarget);this.effects[1].inputTarget=this._createOffscreenTarget(true,this.effects[1].hdr);this._sourceTarget=this.effects[1].inputTarget;}this.camera.renderTarget=this.effects[1].inputTarget;}}this._destroyOffscreenTarget(this.effects[index].inputTarget);this.effects.splice(index,1);}if(this.enabled){if(effect.needsDepthBuffer){this._releaseDepthMap();}}if(this.effects.length===0){this.disable();}}_requestDepthMaps(){for(let i=0,len=this.effects.length;i<len;i++){const effect=this.effects[i].effect;if(this._newPostEffect===effect){continue}if(effect.needsDepthBuffer){this._requestDepthMap();}}}_releaseDepthMaps(){for(let i=0,len=this.effects.length;i<len;i++){const effect=this.effects[i].effect;if(effect.needsDepthBuffer){this._releaseDepthMap();}}}_requestDepthMap(){const depthLayer=this.app.scene.layers.getLayerById(LAYERID_DEPTH);if(depthLayer){depthLayer.incrementCounter();this.camera.requestSceneDepthMap(true);}}_releaseDepthMap(){const depthLayer=this.app.scene.layers.getLayerById(LAYERID_DEPTH);if(depthLayer){depthLayer.decrementCounter();this.camera.requestSceneDepthMap(false);}}destroy(){for(let i=0,len=this.effects.length;i<len;i++){this.effects[i].inputTarget.destroy();}this.effects.length=0;this.disable();}enable(){if(!this.enabled&&this.effects.length){this.enabled=true;this._requestDepthMaps();this.app.graphicsDevice.on("resizecanvas",this._onCanvasResized,this);this.destinationRenderTarget=this.camera.renderTarget;this.camera.renderTarget=this.effects[0].inputTarget;this.camera.onPostprocessing=()=>{if(this.enabled){let rect=null;const len=this.effects.length;if(len){for(let i=0;i<len;i++){const fx=this.effects[i];let destTarget=fx.outputTarget;if(i===len-1){rect=this.camera.rect;if(this.destinationRenderTarget){destTarget=this.destinationRenderTarget;}}fx.effect.render(fx.inputTarget,destTarget,rect);}}}};}}disable(){if(this.enabled){this.enabled=false;this.app.graphicsDevice.off("resizecanvas",this._onCanvasResized,this);this._releaseDepthMaps();this._destroyOffscreenTarget(this._sourceTarget);this.camera.renderTarget=null;this.camera.onPostprocessing=null;}}_onCanvasResized(width,height){var _renderTarget$width2,_renderTarget$height2;const rect=this.camera.rect;const renderTarget=this.destinationRenderTarget;width=(_renderTarget$width2=renderTarget==null?void 0:renderTarget.width)!=null?_renderTarget$width2:width;height=(_renderTarget$height2=renderTarget==null?void 0:renderTarget.height)!=null?_renderTarget$height2:height;this.camera.camera.aspectRatio=width*rect.z/(height*rect.w);this.resizeRenderTargets();}resizeRenderTargets(){var _renderTarget$width3,_renderTarget$height3;const device=this.app.graphicsDevice;const renderTarget=this.destinationRenderTarget;const width=(_renderTarget$width3=renderTarget==null?void 0:renderTarget.width)!=null?_renderTarget$width3:device.width;const height=(_renderTarget$height3=renderTarget==null?void 0:renderTarget.height)!=null?_renderTarget$height3:device.height;const rect=this.camera.rect;const desiredWidth=Math.floor(rect.z*width);const desiredHeight=Math.floor(rect.w*height);const effects=this.effects;for(let i=0,len=effects.length;i<len;i++){const fx=effects[i];if(fx.inputTarget.width!==desiredWidth||fx.inputTarget.height!==desiredHeight){this._resizeOffscreenTarget(fx.inputTarget);}}}onCameraRectChanged(name,oldValue,newValue){if(this.enabled){this.resizeRenderTargets();}}constructor(app,camera){this.app=app;this.camera=camera;this.destinationRenderTarget=null;this.effects=[];this.enabled=false;this.depthTarget=null;camera.on("set:rect",this.onCameraRectChanged,this);}}class CameraComponent extends Component{setShaderPass(name){const shaderPass=ShaderPass.get(this.system.app.graphicsDevice);const shaderPassInfo=name?shaderPass.allocate(name,{isForward:true}):null;this._camera.shaderPassInfo=shaderPassInfo;return shaderPassInfo.index}getShaderPass(){var _this$_camera$shaderP;return (_this$_camera$shaderP=this._camera.shaderPassInfo)==null?void 0:_this$_camera$shaderP.name}set renderPasses(passes){this._camera.renderPasses=passes;}get renderPasses(){return this._camera.renderPasses}set aperture(value){this._camera.aperture=value;}get aperture(){return this._camera.aperture}set aspectRatio(value){this._camera.aspectRatio=value;}get aspectRatio(){return this._camera.aspectRatio}set aspectRatioMode(value){this._camera.aspectRatioMode=value;}get aspectRatioMode(){return this._camera.aspectRatioMode}set calculateProjection(value){this._camera.calculateProjection=value;}get calculateProjection(){return this._camera.calculateProjection}set calculateTransform(value){this._camera.calculateTransform=value;}get calculateTransform(){return this._camera.calculateTransform}get camera(){return this._camera}set clearColor(value){this._camera.clearColor=value;}get clearColor(){return this._camera.clearColor}set clearColorBuffer(value){this._camera.clearColorBuffer=value;this.dirtyLayerCompositionCameras();}get clearColorBuffer(){return this._camera.clearColorBuffer}set clearDepthBuffer(value){this._camera.clearDepthBuffer=value;this.dirtyLayerCompositionCameras();}get clearDepthBuffer(){return this._camera.clearDepthBuffer}set clearStencilBuffer(value){this._camera.clearStencilBuffer=value;this.dirtyLayerCompositionCameras();}get clearStencilBuffer(){return this._camera.clearStencilBuffer}set cullFaces(value){this._camera.cullFaces=value;}get cullFaces(){return this._camera.cullFaces}set disablePostEffectsLayer(layer){this._disablePostEffectsLayer=layer;this.dirtyLayerCompositionCameras();}get disablePostEffectsLayer(){return this._disablePostEffectsLayer}set farClip(value){this._camera.farClip=value;}get farClip(){return this._camera.farClip}set flipFaces(value){this._camera.flipFaces=value;}get flipFaces(){return this._camera.flipFaces}set fov(value){this._camera.fov=value;}get fov(){return this._camera.fov}get frustum(){return this._camera.frustum}set frustumCulling(value){this._camera.frustumCulling=value;}get frustumCulling(){return this._camera.frustumCulling}set horizontalFov(value){this._camera.horizontalFov=value;}get horizontalFov(){return this._camera.horizontalFov}set layers(newValue){const layers=this._camera.layers;for(let i=0;i<layers.length;i++){const layer=this.system.app.scene.layers.getLayerById(layers[i]);if(!layer)continue;layer.removeCamera(this);}this._camera.layers=newValue;if(!this.enabled||!this.entity.enabled)return;for(let i=0;i<newValue.length;i++){const layer=this.system.app.scene.layers.getLayerById(newValue[i]);if(!layer)continue;layer.addCamera(this);}}get layers(){return this._camera.layers}get layersSet(){return this._camera.layersSet}set jitter(value){this._camera.jitter=value;}get jitter(){return this._camera.jitter}set nearClip(value){this._camera.nearClip=value;}get nearClip(){return this._camera.nearClip}set orthoHeight(value){this._camera.orthoHeight=value;}get orthoHeight(){return this._camera.orthoHeight}get postEffects(){return this._postEffects}get postEffectsEnabled(){return this._postEffects.enabled}set priority(newValue){this._priority=newValue;this.dirtyLayerCompositionCameras();}get priority(){return this._priority}set projection(value){this._camera.projection=value;}get projection(){return this._camera.projection}get projectionMatrix(){return this._camera.projectionMatrix}set rect(value){this._camera.rect=value;this.fire("set:rect",this._camera.rect);}get rect(){return this._camera.rect}set renderSceneColorMap(value){if(value&&!this._sceneColorMapRequested){this.requestSceneColorMap(true);this._sceneColorMapRequested=true;}else if(this._sceneColorMapRequested){this.requestSceneColorMap(false);this._sceneColorMapRequested=false;}}get renderSceneColorMap(){return this._renderSceneColorMap>0}set renderSceneDepthMap(value){if(value&&!this._sceneDepthMapRequested){this.requestSceneDepthMap(true);this._sceneDepthMapRequested=true;}else if(this._sceneDepthMapRequested){this.requestSceneDepthMap(false);this._sceneDepthMapRequested=false;}}get renderSceneDepthMap(){return this._renderSceneDepthMap>0}set renderTarget(value){this._camera.renderTarget=value;this.dirtyLayerCompositionCameras();}get renderTarget(){return this._camera.renderTarget}set scissorRect(value){this._camera.scissorRect=value;}get scissorRect(){return this._camera.scissorRect}set sensitivity(value){this._camera.sensitivity=value;}get sensitivity(){return this._camera.sensitivity}set shutter(value){this._camera.shutter=value;}get shutter(){return this._camera.shutter}get viewMatrix(){return this._camera.viewMatrix}_enableDepthLayer(value){const hasDepthLayer=this.layers.find(layerId=>layerId===LAYERID_DEPTH);if(hasDepthLayer){const depthLayer=this.system.app.scene.layers.getLayerById(LAYERID_DEPTH);if(value){depthLayer==null||depthLayer.incrementCounter();}else {depthLayer==null||depthLayer.decrementCounter();}}else if(value){return false}return true}requestSceneColorMap(enabled){this._renderSceneColorMap+=enabled?1:-1;this._enableDepthLayer(enabled);this.camera._enableRenderPassColorGrab(this.system.app.graphicsDevice,this.renderSceneColorMap);}requestSceneDepthMap(enabled){this._renderSceneDepthMap+=enabled?1:-1;this._enableDepthLayer(enabled);this.camera._enableRenderPassDepthGrab(this.system.app.graphicsDevice,this.system.app.renderer,this.renderSceneDepthMap);}dirtyLayerCompositionCameras(){const layerComp=this.system.app.scene.layers;layerComp._dirty=true;}screenToWorld(screenx,screeny,cameraz,worldCoord){const device=this.system.app.graphicsDevice;const w=device.clientRect.width;const h=device.clientRect.height;return this._camera.screenToWorld(screenx,screeny,cameraz,w,h,worldCoord)}worldToScreen(worldCoord,screenCoord){const device=this.system.app.graphicsDevice;const w=device.clientRect.width;const h=device.clientRect.height;return this._camera.worldToScreen(worldCoord,w,h,screenCoord)}onAppPrerender(){this._camera._viewMatDirty=true;this._camera._viewProjMatDirty=true;}addCameraToLayers(){const layers=this.layers;for(let i=0;i<layers.length;i++){const layer=this.system.app.scene.layers.getLayerById(layers[i]);if(layer){layer.addCamera(this);}}}removeCameraFromLayers(){const layers=this.layers;for(let i=0;i<layers.length;i++){const layer=this.system.app.scene.layers.getLayerById(layers[i]);if(layer){layer.removeCamera(this);}}}onLayersChanged(oldComp,newComp){this.addCameraToLayers();oldComp.off("add",this.onLayerAdded,this);oldComp.off("remove",this.onLayerRemoved,this);newComp.on("add",this.onLayerAdded,this);newComp.on("remove",this.onLayerRemoved,this);}onLayerAdded(layer){const index=this.layers.indexOf(layer.id);if(index<0)return;layer.addCamera(this);}onLayerRemoved(layer){const index=this.layers.indexOf(layer.id);if(index<0)return;layer.removeCamera(this);}onEnable(){var _this$_evtLayersChang;const scene=this.system.app.scene;const layers=scene.layers;this.system.addCamera(this);(_this$_evtLayersChang=this._evtLayersChanged)==null||_this$_evtLayersChang.off();this._evtLayersChanged=scene.on("set:layers",this.onLayersChanged,this);if(layers){var _this$_evtLayerAdded,_this$_evtLayerRemove;(_this$_evtLayerAdded=this._evtLayerAdded)==null||_this$_evtLayerAdded.off();this._evtLayerAdded=layers.on("add",this.onLayerAdded,this);(_this$_evtLayerRemove=this._evtLayerRemoved)==null||_this$_evtLayerRemove.off();this._evtLayerRemoved=layers.on("remove",this.onLayerRemoved,this);}if(this.enabled&&this.entity.enabled){this.addCameraToLayers();}this.postEffects.enable();}onDisable(){var _this$_evtLayersChang2;const scene=this.system.app.scene;const layers=scene.layers;this.postEffects.disable();this.removeCameraFromLayers();(_this$_evtLayersChang2=this._evtLayersChanged)==null||_this$_evtLayersChang2.off();this._evtLayersChanged=null;if(layers){var _this$_evtLayerAdded2,_this$_evtLayerRemove2;(_this$_evtLayerAdded2=this._evtLayerAdded)==null||_this$_evtLayerAdded2.off();this._evtLayerAdded=null;(_this$_evtLayerRemove2=this._evtLayerRemoved)==null||_this$_evtLayerRemove2.off();this._evtLayerRemoved=null;}this.system.removeCamera(this);}onRemove(){this.onDisable();this.off();this.camera.destroy();}calculateAspectRatio(rt){const device=this.system.app.graphicsDevice;const width=rt?rt.width:device.width;const height=rt?rt.height:device.height;return width*this.rect.z/(height*this.rect.w)}frameUpdate(rt){if(this.aspectRatioMode===ASPECT_AUTO){this.aspectRatio=this.calculateAspectRatio(rt);}}startXr(type,spaceType,options){this.system.app.xr.start(this,type,spaceType,options);}endXr(callback){if(!this._camera.xr){if(callback)callback(new Error("Camera is not in XR"));return}this._camera.xr.end(callback);}copy(source){this.aperture=source.aperture;this.aspectRatio=source.aspectRatio;this.aspectRatioMode=source.aspectRatioMode;this.calculateProjection=source.calculateProjection;this.calculateTransform=source.calculateTransform;this.clearColor=source.clearColor;this.clearColorBuffer=source.clearColorBuffer;this.clearDepthBuffer=source.clearDepthBuffer;this.clearStencilBuffer=source.clearStencilBuffer;this.cullFaces=source.cullFaces;this.disablePostEffectsLayer=source.disablePostEffectsLayer;this.farClip=source.farClip;this.flipFaces=source.flipFaces;this.fov=source.fov;this.frustumCulling=source.frustumCulling;this.horizontalFov=source.horizontalFov;this.layers=source.layers;this.nearClip=source.nearClip;this.orthoHeight=source.orthoHeight;this.priority=source.priority;this.projection=source.projection;this.rect=source.rect;this.renderTarget=source.renderTarget;this.scissorRect=source.scissorRect;this.sensitivity=source.sensitivity;this.shutter=source.shutter;}constructor(system,entity){super(system,entity);this.onPostprocessing=null;this.onPreRender=null;this.onPostRender=null;this._renderSceneDepthMap=0;this._renderSceneColorMap=0;this._sceneDepthMapRequested=false;this._sceneColorMapRequested=false;this._priority=0;this._disablePostEffectsLayer=LAYERID_UI;this._camera=new Camera;this._evtLayersChanged=null;this._evtLayerAdded=null;this._evtLayerRemoved=null;this._camera.node=entity;this._postEffects=new PostEffectQueue(system.app,this);}}class CameraComponentData{constructor(){this.enabled=true;}}const _schema$1=["enabled"];class CameraComponentSystem extends ComponentSystem{initializeComponentData(component,data,properties){properties=["aspectRatio","aspectRatioMode","calculateProjection","calculateTransform","clearColor","clearColorBuffer","clearDepthBuffer","clearStencilBuffer","renderSceneColorMap","renderSceneDepthMap","cullFaces","farClip","flipFaces","fov","frustumCulling","horizontalFov","layers","renderTarget","nearClip","orthoHeight","projection","priority","rect","scissorRect","aperture","shutter","sensitivity"];for(let i=0;i<properties.length;i++){const property=properties[i];if(data.hasOwnProperty(property)){const value=data[property];switch(property){case"rect":case"scissorRect":if(Array.isArray(value)){component[property]=new Vec4(value[0],value[1],value[2],value[3]);}else {component[property]=value;}break;case"clearColor":if(Array.isArray(value)){component[property]=new Color(value[0],value[1],value[2],value[3]);}else {component[property]=value;}break;default:component[property]=value;break}}}super.initializeComponentData(component,data,["enabled"]);}cloneComponent(entity,clone){const c=entity.camera;return this.addComponent(clone,{aspectRatio:c.aspectRatio,aspectRatioMode:c.aspectRatioMode,calculateProjection:c.calculateProjection,calculateTransform:c.calculateTransform,clearColor:c.clearColor,clearColorBuffer:c.clearColorBuffer,clearDepthBuffer:c.clearDepthBuffer,clearStencilBuffer:c.clearStencilBuffer,renderSceneDepthMap:c.renderSceneDepthMap,renderSceneColorMap:c.renderSceneColorMap,cullFaces:c.cullFaces,enabled:c.enabled,farClip:c.farClip,flipFaces:c.flipFaces,fov:c.fov,frustumCulling:c.frustumCulling,horizontalFov:c.horizontalFov,layers:c.layers,renderTarget:c.renderTarget,nearClip:c.nearClip,orthoHeight:c.orthoHeight,projection:c.projection,priority:c.priority,rect:c.rect,scissorRect:c.scissorRect,aperture:c.aperture,sensitivity:c.sensitivity,shutter:c.shutter})}onBeforeRemove(entity,component){this.removeCamera(component);component.onRemove();}onUpdate(dt){}onAppPrerender(){for(let i=0,len=this.cameras.length;i<len;i++){this.cameras[i].onAppPrerender();}}addCamera(camera){this.cameras.push(camera);sortPriority(this.cameras);}removeCamera(camera){const index=this.cameras.indexOf(camera);if(index>=0){this.cameras.splice(index,1);sortPriority(this.cameras);}}destroy(){super.destroy();this.app.systems.off("update",this.onUpdate,this);}constructor(app){super(app);this.cameras=[];this.id="camera";this.ComponentType=CameraComponent;this.DataType=CameraComponentData;this.schema=_schema$1;this.on("beforeremove",this.onBeforeRemove,this);this.app.on("prerender",this.onAppPrerender,this);this.app.systems.on("update",this.onUpdate,this);}}Component._buildAccessors(CameraComponent.prototype,_schema$1);class LightComponentData{constructor(){this.enabled=true;this.light=void 0;this.type="directional";this.color=new Color(1,1,1);this.intensity=1;this.luminance=0;this.shape=LIGHTSHAPE_PUNCTUAL;this.affectSpecularity=true;this.castShadows=false;this.shadowDistance=40;this.shadowIntensity=1;this.shadowResolution=1024;this.shadowBias=.05;this.numCascades=1;this.bakeNumSamples=1;this.bakeArea=0;this.cascadeDistribution=.5;this.normalOffsetBias=0;this.range=10;this.innerConeAngle=40;this.outerConeAngle=45;this.falloffMode=LIGHTFALLOFF_LINEAR;this.shadowType=SHADOW_PCF3;this.vsmBlurSize=11;this.vsmBlurMode=BLUR_GAUSSIAN;this.vsmBias=.01*.25;this.cookieAsset=null;this.cookie=null;this.cookieIntensity=1;this.cookieFalloff=true;this.cookieChannel="rgb";this.cookieAngle=0;this.cookieScale=null;this.cookieOffset=null;this.shadowUpdateMode=SHADOWUPDATE_REALTIME;this.mask=1;this.affectDynamic=true;this.affectLightmapped=false;this.bake=false;this.bakeDir=true;this.isStatic=false;this.layers=[LAYERID_WORLD];this.penumbraSize=1;}}const properties=Object.keys(new LightComponentData);class LightComponent extends Component{get data(){const record=this.system.store[this.entity.getGuid()];return record?record.data:null}set enabled(arg){this._setValue("enabled",arg,function(newValue,oldValue){this.onSetEnabled(null,oldValue,newValue);});}get enabled(){return this.data.enabled}set light(arg){this._setValue("light",arg);}get light(){return this.data.light}set type(arg){this._setValue("type",arg,function(newValue,oldValue){this.system.changeType(this,oldValue,newValue);this.refreshProperties();});}get type(){return this.data.type}set color(arg){this._setValue("color",arg,function(newValue,oldValue){this.light.setColor(newValue);},true);}get color(){return this.data.color}set intensity(arg){this._setValue("intensity",arg,function(newValue,oldValue){this.light.intensity=newValue;});}get intensity(){return this.data.intensity}set luminance(arg){this._setValue("luminance",arg,function(newValue,oldValue){this.light.luminance=newValue;});}get luminance(){return this.data.luminance}set shape(arg){this._setValue("shape",arg,function(newValue,oldValue){this.light.shape=newValue;});}get shape(){return this.data.shape}set affectSpecularity(arg){this._setValue("affectSpecularity",arg,function(newValue,oldValue){this.light.affectSpecularity=newValue;});}get affectSpecularity(){return this.data.affectSpecularity}set castShadows(arg){this._setValue("castShadows",arg,function(newValue,oldValue){this.light.castShadows=newValue;});}get castShadows(){return this.data.castShadows}set shadowDistance(arg){this._setValue("shadowDistance",arg,function(newValue,oldValue){this.light.shadowDistance=newValue;});}get shadowDistance(){return this.data.shadowDistance}set shadowIntensity(arg){this._setValue("shadowIntensity",arg,function(newValue,oldValue){this.light.shadowIntensity=newValue;});}get shadowIntensity(){return this.data.shadowIntensity}set shadowResolution(arg){this._setValue("shadowResolution",arg,function(newValue,oldValue){this.light.shadowResolution=newValue;});}get shadowResolution(){return this.data.shadowResolution}set shadowBias(arg){this._setValue("shadowBias",arg,function(newValue,oldValue){this.light.shadowBias=-.01*math.clamp(newValue,0,1);});}get shadowBias(){return this.data.shadowBias}set numCascades(arg){this._setValue("numCascades",arg,function(newValue,oldValue){this.light.numCascades=math.clamp(Math.floor(newValue),1,4);});}get numCascades(){return this.data.numCascades}set bakeNumSamples(arg){this._setValue("bakeNumSamples",arg,function(newValue,oldValue){this.light.bakeNumSamples=math.clamp(Math.floor(newValue),1,255);});}get bakeNumSamples(){return this.data.bakeNumSamples}set bakeArea(arg){this._setValue("bakeArea",arg,function(newValue,oldValue){this.light.bakeArea=math.clamp(newValue,0,180);});}get bakeArea(){return this.data.bakeArea}set cascadeDistribution(arg){this._setValue("cascadeDistribution",arg,function(newValue,oldValue){this.light.cascadeDistribution=math.clamp(newValue,0,1);});}get cascadeDistribution(){return this.data.cascadeDistribution}set normalOffsetBias(arg){this._setValue("normalOffsetBias",arg,function(newValue,oldValue){this.light.normalOffsetBias=math.clamp(newValue,0,1);});}get normalOffsetBias(){return this.data.normalOffsetBias}set range(arg){this._setValue("range",arg,function(newValue,oldValue){this.light.attenuationEnd=newValue;});}get range(){return this.data.range}set innerConeAngle(arg){this._setValue("innerConeAngle",arg,function(newValue,oldValue){this.light.innerConeAngle=newValue;});}get innerConeAngle(){return this.data.innerConeAngle}set outerConeAngle(arg){this._setValue("outerConeAngle",arg,function(newValue,oldValue){this.light.outerConeAngle=newValue;});}get outerConeAngle(){return this.data.outerConeAngle}set falloffMode(arg){this._setValue("falloffMode",arg,function(newValue,oldValue){this.light.falloffMode=newValue;});}get falloffMode(){return this.data.falloffMode}set shadowType(arg){this._setValue("shadowType",arg,function(newValue,oldValue){this.light.shadowType=newValue;});}get shadowType(){return this.data.shadowType}set vsmBlurSize(arg){this._setValue("vsmBlurSize",arg,function(newValue,oldValue){this.light.vsmBlurSize=newValue;});}get vsmBlurSize(){return this.data.vsmBlurSize}set vsmBlurMode(arg){this._setValue("vsmBlurMode",arg,function(newValue,oldValue){this.light.vsmBlurMode=newValue;});}get vsmBlurMode(){return this.data.vsmBlurMode}set vsmBias(arg){this._setValue("vsmBias",arg,function(newValue,oldValue){this.light.vsmBias=math.clamp(newValue,0,1);});}get vsmBias(){return this.data.vsmBias}set cookieAsset(arg){this._setValue("cookieAsset",arg,function(newValue,oldValue){if(this._cookieAssetId&&(newValue instanceof Asset&&newValue.id===this._cookieAssetId||newValue===this._cookieAssetId)){return}this.onCookieAssetRemove();this._cookieAssetId=null;if(newValue instanceof Asset){this.data.cookieAsset=newValue.id;this._cookieAssetId=newValue.id;this.onCookieAssetAdd(newValue);}else if(typeof newValue==="number"){this._cookieAssetId=newValue;const asset=this.system.app.assets.get(newValue);if(asset){this.onCookieAssetAdd(asset);}else {this._cookieAssetAdd=true;this.system.app.assets.on(`add:${this._cookieAssetId}`,this.onCookieAssetAdd,this);}}});}get cookieAsset(){return this.data.cookieAsset}set cookie(arg){this._setValue("cookie",arg,function(newValue,oldValue){this.light.cookie=newValue;});}get cookie(){return this.data.cookie}set cookieIntensity(arg){this._setValue("cookieIntensity",arg,function(newValue,oldValue){this.light.cookieIntensity=math.clamp(newValue,0,1);});}get cookieIntensity(){return this.data.cookieIntensity}set cookieFalloff(arg){this._setValue("cookieFalloff",arg,function(newValue,oldValue){this.light.cookieFalloff=newValue;});}get cookieFalloff(){return this.data.cookieFalloff}set cookieChannel(arg){this._setValue("cookieChannel",arg,function(newValue,oldValue){this.light.cookieChannel=newValue;});}get cookieChannel(){return this.data.cookieChannel}set cookieAngle(arg){this._setValue("cookieAngle",arg,function(newValue,oldValue){if(newValue!==0||this.cookieScale!==null){if(!this._cookieMatrix)this._cookieMatrix=new Vec4;let scx=1;let scy=1;if(this.cookieScale){scx=this.cookieScale.x;scy=this.cookieScale.y;}const c=Math.cos(newValue*math.DEG_TO_RAD);const s=Math.sin(newValue*math.DEG_TO_RAD);this._cookieMatrix.set(c/scx,-s/scx,s/scy,c/scy);this.light.cookieTransform=this._cookieMatrix;}else {this.light.cookieTransform=null;}});}get cookieAngle(){return this.data.cookieAngle}set cookieScale(arg){this._setValue("cookieScale",arg,function(newValue,oldValue){if(newValue!==null||this.cookieAngle!==0){if(!this._cookieMatrix)this._cookieMatrix=new Vec4;const scx=newValue.x;const scy=newValue.y;const c=Math.cos(this.cookieAngle*math.DEG_TO_RAD);const s=Math.sin(this.cookieAngle*math.DEG_TO_RAD);this._cookieMatrix.set(c/scx,-s/scx,s/scy,c/scy);this.light.cookieTransform=this._cookieMatrix;}else {this.light.cookieTransform=null;}},true);}get cookieScale(){return this.data.cookieScale}set cookieOffset(arg){this._setValue("cookieOffset",arg,function(newValue,oldValue){this.light.cookieOffset=newValue;},true);}get cookieOffset(){return this.data.cookieOffset}set shadowUpdateMode(arg){this._setValue("shadowUpdateMode",arg,function(newValue,oldValue){this.light.shadowUpdateMode=newValue;},true);}get shadowUpdateMode(){return this.data.shadowUpdateMode}set mask(arg){this._setValue("mask",arg,function(newValue,oldValue){this.light.mask=newValue;});}get mask(){return this.data.mask}set affectDynamic(arg){this._setValue("affectDynamic",arg,function(newValue,oldValue){if(newValue){this.light.mask|=MASK_AFFECT_DYNAMIC;}else {this.light.mask&=~MASK_AFFECT_DYNAMIC;}this.light.layersDirty();});}get affectDynamic(){return this.data.affectDynamic}set affectLightmapped(arg){this._setValue("affectLightmapped",arg,function(newValue,oldValue){if(newValue){this.light.mask|=MASK_AFFECT_LIGHTMAPPED;if(this.bake)this.light.mask&=~MASK_BAKE;}else {this.light.mask&=~MASK_AFFECT_LIGHTMAPPED;if(this.bake)this.light.mask|=MASK_BAKE;}});}get affectLightmapped(){return this.data.affectLightmapped}set bake(arg){this._setValue("bake",arg,function(newValue,oldValue){if(newValue){this.light.mask|=MASK_BAKE;if(this.affectLightmapped)this.light.mask&=~MASK_AFFECT_LIGHTMAPPED;}else {this.light.mask&=~MASK_BAKE;if(this.affectLightmapped)this.light.mask|=MASK_AFFECT_LIGHTMAPPED;}this.light.layersDirty();});}get bake(){return this.data.bake}set bakeDir(arg){this._setValue("bakeDir",arg,function(newValue,oldValue){this.light.bakeDir=newValue;});}get bakeDir(){return this.data.bakeDir}set isStatic(arg){this._setValue("isStatic",arg,function(newValue,oldValue){this.light.isStatic=newValue;});}get isStatic(){return this.data.isStatic}set layers(arg){this._setValue("layers",arg,function(newValue,oldValue){for(let i=0;i<oldValue.length;i++){const layer=this.system.app.scene.layers.getLayerById(oldValue[i]);if(!layer)continue;layer.removeLight(this);this.light.removeLayer(layer);}for(let i=0;i<newValue.length;i++){const layer=this.system.app.scene.layers.getLayerById(newValue[i]);if(!layer)continue;if(this.enabled&&this.entity.enabled){layer.addLight(this);this.light.addLayer(layer);}}});}get layers(){return this.data.layers}set shadowUpdateOverrides(values){this.light.shadowUpdateOverrides=values;}get shadowUpdateOverrides(){return this.light.shadowUpdateOverrides}set penumbraSize(value){this.light.penumbraSize=value;}get penumbraSize(){return this.light.penumbraSize}_setValue(name,value,setFunc,skipEqualsCheck){const data=this.data;const oldValue=data[name];if(!skipEqualsCheck&&oldValue===value)return;data[name]=value;if(setFunc)setFunc.call(this,value,oldValue);}addLightToLayers(){for(let i=0;i<this.layers.length;i++){const layer=this.system.app.scene.layers.getLayerById(this.layers[i]);if(layer){layer.addLight(this);this.light.addLayer(layer);}}}removeLightFromLayers(){for(let i=0;i<this.layers.length;i++){const layer=this.system.app.scene.layers.getLayerById(this.layers[i]);if(layer){layer.removeLight(this);this.light.removeLayer(layer);}}}onLayersChanged(oldComp,newComp){if(this.enabled&&this.entity.enabled){this.addLightToLayers();}oldComp.off("add",this.onLayerAdded,this);oldComp.off("remove",this.onLayerRemoved,this);newComp.on("add",this.onLayerAdded,this);newComp.on("remove",this.onLayerRemoved,this);}onLayerAdded(layer){const index=this.layers.indexOf(layer.id);if(index>=0&&this.enabled&&this.entity.enabled){layer.addLight(this);this.light.addLayer(layer);}}onLayerRemoved(layer){const index=this.layers.indexOf(layer.id);if(index>=0){layer.removeLight(this);this.light.removeLayer(layer);}}refreshProperties(){for(let i=0;i<properties.length;i++){const name=properties[i];this[name]=this[name];}if(this.enabled&&this.entity.enabled){this.onEnable();}}onCookieAssetSet(){let forceLoad=false;if(this._cookieAsset.type==="cubemap"&&!this._cookieAsset.loadFaces){this._cookieAsset.loadFaces=true;forceLoad=true;}if(!this._cookieAsset.resource||forceLoad)this.system.app.assets.load(this._cookieAsset);if(this._cookieAsset.resource){this.onCookieAssetLoad();}}onCookieAssetAdd(asset){if(this._cookieAssetId!==asset.id)return;this._cookieAsset=asset;if(this.light.enabled){this.onCookieAssetSet();}this._cookieAsset.on("load",this.onCookieAssetLoad,this);this._cookieAsset.on("remove",this.onCookieAssetRemove,this);}onCookieAssetLoad(){if(!this._cookieAsset||!this._cookieAsset.resource){return}this.cookie=this._cookieAsset.resource;}onCookieAssetRemove(){if(!this._cookieAssetId){return}if(this._cookieAssetAdd){this.system.app.assets.off(`add:${this._cookieAssetId}`,this.onCookieAssetAdd,this);this._cookieAssetAdd=false;}if(this._cookieAsset){this._cookieAsset.off("load",this.onCookieAssetLoad,this);this._cookieAsset.off("remove",this.onCookieAssetRemove,this);this._cookieAsset=null;}this.cookie=null;}onEnable(){const scene=this.system.app.scene;const layers=scene.layers;this.light.enabled=true;this._evtLayersChanged=scene.on("set:layers",this.onLayersChanged,this);if(layers){this._evtLayerAdded=layers.on("add",this.onLayerAdded,this);this._evtLayerRemoved=layers.on("remove",this.onLayerRemoved,this);}if(this.enabled&&this.entity.enabled){this.addLightToLayers();}if(this._cookieAsset&&!this.cookie){this.onCookieAssetSet();}}onDisable(){var _this$_evtLayersChang;const scene=this.system.app.scene;const layers=scene.layers;this.light.enabled=false;(_this$_evtLayersChang=this._evtLayersChanged)==null||_this$_evtLayersChang.off();this._evtLayersChanged=null;if(layers){var _this$_evtLayerAdded,_this$_evtLayerRemove;(_this$_evtLayerAdded=this._evtLayerAdded)==null||_this$_evtLayerAdded.off();this._evtLayerAdded=null;(_this$_evtLayerRemove=this._evtLayerRemoved)==null||_this$_evtLayerRemove.off();this._evtLayerRemoved=null;}this.removeLightFromLayers();}onRemove(){this.onDisable();this.light.destroy();this.cookieAsset=null;}constructor(system,entity){super(system,entity);this._evtLayersChanged=null;this._evtLayerAdded=null;this._evtLayerRemoved=null;this._cookieAsset=null;this._cookieAssetId=null;this._cookieAssetAdd=false;this._cookieMatrix=null;}}class LightComponentSystem extends ComponentSystem{initializeComponentData(component,_data){const data=_extends({},_data);if(!data.type){data.type=component.data.type;}component.data.type=data.type;if(data.layers&&Array.isArray(data.layers)){data.layers=data.layers.slice(0);}if(data.color&&Array.isArray(data.color)){data.color=new Color(data.color[0],data.color[1],data.color[2]);}if(data.cookieOffset&&data.cookieOffset instanceof Array){data.cookieOffset=new Vec2(data.cookieOffset[0],data.cookieOffset[1]);}if(data.cookieScale&&data.cookieScale instanceof Array){data.cookieScale=new Vec2(data.cookieScale[0],data.cookieScale[1]);}if(data.enable){console.warn("WARNING: enable: Property is deprecated. Set enabled property instead.");data.enabled=data.enable;}if(!data.shape){data.shape=LIGHTSHAPE_PUNCTUAL;}const light=new Light(this.app.graphicsDevice,this.app.scene.clusteredLightingEnabled);light.type=lightTypes[data.type];light._node=component.entity;component.data.light=light;super.initializeComponentData(component,data,properties);}_onRemoveComponent(entity,component){component.onRemove();}cloneComponent(entity,clone){const light=entity.light;const data=[];let name;for(let i=0;i<properties.length;i++){name=properties[i];if(name==="light"){continue}if(light[name]&&light[name].clone){data[name]=light[name].clone();}else {data[name]=light[name];}}return this.addComponent(clone,data)}changeType(component,oldValue,newValue){if(oldValue!==newValue){component.light.type=lightTypes[newValue];}}constructor(app){super(app);this.id="light";this.ComponentType=LightComponent;this.DataType=LightComponentData;this.on("beforeremove",this._onRemoveComponent,this);}}const components=["x","y","z","w"];const vecLookup=[undefined,undefined,Vec2,Vec3,Vec4];function rawToValue(app,args,value,old){switch(args.type){case"boolean":return !!value;case"number":if(typeof value==="number"){return value}else if(typeof value==="string"){const v=parseInt(value,10);if(isNaN(v))return null;return v}else if(typeof value==="boolean"){return 0+value}return null;case"json":{const result={};if(Array.isArray(args.schema)){if(!value||typeof value!=="object"){value={};}for(let i=0;i<args.schema.length;i++){const field=args.schema[i];if(!field.name)continue;if(field.array){result[field.name]=[];const arr=Array.isArray(value[field.name])?value[field.name]:[];for(let j=0;j<arr.length;j++){result[field.name].push(rawToValue(app,field,arr[j]));}}else {const val=value.hasOwnProperty(field.name)?value[field.name]:field.default;result[field.name]=rawToValue(app,field,val);}}}return result}case"asset":if(value instanceof Asset){return value}else if(typeof value==="number"){return app.assets.get(value)||null}else if(typeof value==="string"){return app.assets.get(parseInt(value,10))||null}return null;case"entity":if(value instanceof GraphNode){return value}else if(typeof value==="string"){return app.getEntityFromIndex(value)}return null;case"rgb":case"rgba":if(value instanceof Color){if(old instanceof Color){old.copy(value);return old}return value.clone()}else if(value instanceof Array&&value.length>=3&&value.length<=4){for(let i=0;i<value.length;i++){if(typeof value[i]!=="number"){return null}}if(!old)old=new Color;old.r=value[0];old.g=value[1];old.b=value[2];old.a=value.length===3?1:value[3];return old}else if(typeof value==="string"&&/#(?:[0-9a-f]{2}){3,4}/i.test(value)){if(!old){old=new Color;}old.fromString(value);return old}return null;case"vec2":case"vec3":case"vec4":{const len=parseInt(args.type.slice(3),10);const vecType=vecLookup[len];if(value instanceof vecType){if(old instanceof vecType){old.copy(value);return old}return value.clone()}else if(value instanceof Array&&value.length===len){for(let i=0;i<value.length;i++){if(typeof value[i]!=="number"){return null}}if(!old)old=new vecType;for(let i=0;i<len;i++){old[components[i]]=value[i];}return old}return null}case"curve":if(value){let curve;if(value instanceof Curve||value instanceof CurveSet){curve=value.clone();}else {const CurveType=value.keys[0]instanceof Array?CurveSet:Curve;curve=new CurveType(value.keys);curve.type=value.type;}return curve}break}return value}function attributeToValue(app,schema,value,current){if(schema.array){return value.map((item,index)=>rawToValue(app,schema,item,current?current[index]:null))}return rawToValue(app,schema,value,current)}function assignAttributesToScript(app,attributeSchemaMap,data,script){if(!data)return;for(const attributeName in attributeSchemaMap){const attributeSchema=attributeSchemaMap[attributeName];const dataToAssign=data[attributeName];if(dataToAssign===undefined)continue;script[attributeName]=attributeToValue(app,attributeSchema,dataToAssign,script[attributeName]);}}class ScriptAttributes{add(name,args){if(this.index[name]){return}else if(ScriptAttributes.reservedNames.has(name)){return}this.index[name]=args;Object.defineProperty(this.scriptType.prototype,name,{get:function(){return this.__attributes[name]},set:function(raw){const evt="attr";const evtName=`attr:${name}`;const old=this.__attributes[name];let oldCopy=old;if(old&&args.type!=="json"&&args.type!=="entity"&&old.clone){if(this.hasEvent(evt)||this.hasEvent(evtName)){oldCopy=old.clone();}}if(args.array){this.__attributes[name]=[];if(raw){for(let i=0,len=raw.length;i<len;i++){this.__attributes[name].push(rawToValue(this.app,args,raw[i],old?old[i]:null));}}}else {this.__attributes[name]=rawToValue(this.app,args,raw,old);}this.fire(evt,name,this.__attributes[name],oldCopy);this.fire(evtName,this.__attributes[name],oldCopy);}});}remove(name){if(!this.index[name]){return false}delete this.index[name];delete this.scriptType.prototype[name];return true}has(name){return !!this.index[name]}get(name){return this.index[name]||null}constructor(scriptType){this.scriptType=scriptType;this.index={};}}ScriptAttributes.assignAttributesToScript=assignAttributesToScript;ScriptAttributes.attributeToValue=attributeToValue;ScriptAttributes.reservedNames=new Set(["app","entity","enabled","_enabled","_enabledOld","_destroyed","__attributes","__attributesRaw","__scriptType","__executionOrder","_callbacks","_callbackActive","has","get","on","off","fire","once","hasEvent"]);const SCRIPT_INITIALIZE="initialize";const SCRIPT_POST_INITIALIZE="postInitialize";const SCRIPT_UPDATE="update";const SCRIPT_POST_UPDATE="postUpdate";const SCRIPT_SWAP="swap";class Script extends EventHandler{set enabled(value){this._enabled=!!value;if(this.enabled===this._enabledOld)return;this._enabledOld=this.enabled;this.fire(this.enabled?"enable":"disable");this.fire("state",this.enabled);if(!this._initialized&&this.enabled){this._initialized=true;this.fire("preInitialize");if(this.initialize){this.entity.script._scriptMethod(this,SCRIPT_INITIALIZE);}}if(this._initialized&&!this._postInitialized&&this.enabled&&!this.entity.script._beingEnabled){this._postInitialized=true;if(this.postInitialize){this.entity.script._scriptMethod(this,SCRIPT_POST_INITIALIZE);}}}get enabled(){return this._enabled&&!this._destroyed&&this.entity.script.enabled&&this.entity.enabled}initScript(args){const script=this.constructor;this.app=args.app;this.entity=args.entity;this._enabled=typeof args.enabled==="boolean"?args.enabled:true;this._enabledOld=this.enabled;this.__destroyed=false;this.__scriptType=script;this.__executionOrder=-1;}static get scriptName(){return this.__name}constructor(args){super();this.app=void 0;this.entity=void 0;this._enabled=void 0;this._enabledOld=void 0;this._initialized=void 0;this._postInitialized=void 0;this.__destroyed=void 0;this.__scriptType=void 0;this.__executionOrder=void 0;this.initScript(args);}}Script.EVENT_ENABLE="enable";Script.EVENT_DISABLE="disable";Script.EVENT_STATE="state";Script.EVENT_DESTROY="destroy";Script.EVENT_ATTR="attr";Script.EVENT_ERROR="error";Script.__name=null;Script.__getScriptName=getScriptName;const funcNameRegex=/^\s*function(?:\s|\s*\/\*.*\*\/\s*)+([^(\s\/]*)\s*/;function getScriptName(constructorFn){if(typeof constructorFn!=="function")return undefined;if("name"in Function.prototype)return constructorFn.name;if(constructorFn===Function||constructorFn===Function.prototype.constructor)return "Function";const match=`${constructorFn}`.match(funcNameRegex);return match?match[1]:undefined}class ScriptType extends Script{static get attributes(){if(!this.hasOwnProperty("__attributes"))this.__attributes=new ScriptAttributes(this);return this.__attributes}initScript(args){Script.prototype.initScript.call(this,args);this.__attributes={};this.__attributesRaw=args.attributes||{};}initScriptType(args){this.initScript(args);}__initializeAttributes(force){if(!force&&!this.__attributesRaw){return}for(const key in this.__scriptType.attributes.index){if(this.__attributesRaw&&this.__attributesRaw.hasOwnProperty(key)){this[key]=this.__attributesRaw[key];}else if(!this.__attributes.hasOwnProperty(key)){if(this.__scriptType.attributes.index[key].hasOwnProperty("default")){this[key]=this.__scriptType.attributes.index[key].default;}else {this[key]=null;}}}this.__attributesRaw=null;}static extend(methods){for(const key in methods){if(!methods.hasOwnProperty(key)){continue}this.prototype[key]=methods[key];}}constructor(args){super(args);this.__attributes=void 0;this.__attributesRaw=void 0;this.initScriptType(args);}}const toLowerCamelCase$1=str=>str[0].toLowerCase()+str.substring(1);class ScriptComponent extends Component{set scripts(value){this._scriptsData=value;for(const key in value){if(!value.hasOwnProperty(key)){continue}const script=this._scriptsIndex[key];if(script){if(typeof value[key].enabled==="boolean"){script.once("preInitialize",()=>{this.initializeAttributes(script);});script.enabled=!!value[key].enabled;}if(typeof value[key].attributes==="object"){for(const attr in value[key].attributes){if(ScriptAttributes.reservedNames.has(attr)){continue}if(!script.__attributes.hasOwnProperty(attr)){const scriptType=this.system.app.scripts.get(key);if(scriptType){scriptType.attributes.add(attr,{});}}script[attr]=value[key].attributes[attr];}}}else {console.log(this.order);}}}get scripts(){return this._scripts}set enabled(value){const oldValue=this._enabled;this._enabled=value;this.fire("set","enabled",oldValue,value);}get enabled(){return this._enabled}onEnable(){this._beingEnabled=true;this._checkState();if(!this.entity._beingEnabled){this.onPostStateChange();}this._beingEnabled=false;}onDisable(){this._checkState();}onPostStateChange(){const wasLooping=this._beginLooping();for(let i=0,len=this.scripts.length;i<len;i++){const script=this.scripts[i];if(script._initialized&&!script._postInitialized&&script.enabled){script._postInitialized=true;if(script.postInitialize){this._scriptMethod(script,SCRIPT_POST_INITIALIZE);}}}this._endLooping(wasLooping);}_beginLooping(){const looping=this._isLoopingThroughScripts;this._isLoopingThroughScripts=true;return looping}_endLooping(wasLoopingBefore){this._isLoopingThroughScripts=wasLoopingBefore;if(!this._isLoopingThroughScripts){this._removeDestroyedScripts();}}_onSetEnabled(prop,old,value){this._beingEnabled=true;this._checkState();this._beingEnabled=false;}_checkState(){const state=this.enabled&&this.entity.enabled;if(state===this._oldState){return}this._oldState=state;this.fire(state?"enable":"disable");this.fire("state",state);if(state){this.system._addComponentToEnabled(this);}else {this.system._removeComponentFromEnabled(this);}const wasLooping=this._beginLooping();for(let i=0,len=this.scripts.length;i<len;i++){const script=this.scripts[i];script.once("preInitialize",()=>{this.initializeAttributes(script);});script.enabled=script._enabled;}this._endLooping(wasLooping);}_onBeforeRemove(){this.fire("remove");const wasLooping=this._beginLooping();for(let i=0;i<this.scripts.length;i++){const script=this.scripts[i];if(!script)continue;this.destroy(script.__scriptType.__name);}this._endLooping(wasLooping);}_removeDestroyedScripts(){const len=this._destroyedScripts.length;if(!len)return;for(let i=0;i<len;i++){const script=this._destroyedScripts[i];this._removeScriptInstance(script);}this._destroyedScripts.length=0;this._resetExecutionOrder(0,this._scripts.length);}_onInitializeAttributes(){for(let i=0,len=this.scripts.length;i<len;i++){const script=this.scripts[i];this.initializeAttributes(script);}}initializeAttributes(script){if(script instanceof ScriptType){script.__initializeAttributes();}else {var _this$system$app$scri;const name=script.__scriptType.__name;const data=this._attributeDataMap.get(name);if(!data){return}const schema=(_this$system$app$scri=this.system.app.scripts)==null?void 0:_this$system$app$scri.getSchema(name);assignAttributesToScript(this.system.app,schema.attributes,data,script);}}_scriptMethod(script,method,arg){script[method](arg);}_onInitialize(){const scripts=this._scripts;const wasLooping=this._beginLooping();for(let i=0,len=scripts.length;i<len;i++){const script=scripts[i];if(!script._initialized&&script.enabled){script._initialized=true;if(script.initialize){this._scriptMethod(script,SCRIPT_INITIALIZE);}}}this._endLooping(wasLooping);}_onPostInitialize(){this.onPostStateChange();}_onUpdate(dt){const list=this._updateList;if(!list.length)return;const wasLooping=this._beginLooping();for(list.loopIndex=0;list.loopIndex<list.length;list.loopIndex++){const script=list.items[list.loopIndex];if(script.enabled){this._scriptMethod(script,SCRIPT_UPDATE,dt);}}this._endLooping(wasLooping);}_onPostUpdate(dt){const list=this._postUpdateList;if(!list.length)return;const wasLooping=this._beginLooping();for(list.loopIndex=0;list.loopIndex<list.length;list.loopIndex++){const script=list.items[list.loopIndex];if(script.enabled){this._scriptMethod(script,SCRIPT_POST_UPDATE,dt);}}this._endLooping(wasLooping);}_insertScriptInstance(scriptInstance,index,scriptsLength){if(index===-1){this._scripts.push(scriptInstance);scriptInstance.__executionOrder=scriptsLength;if(scriptInstance.update){this._updateList.append(scriptInstance);}if(scriptInstance.postUpdate){this._postUpdateList.append(scriptInstance);}}else {this._scripts.splice(index,0,scriptInstance);scriptInstance.__executionOrder=index;this._resetExecutionOrder(index+1,scriptsLength+1);if(scriptInstance.update){this._updateList.insert(scriptInstance);}if(scriptInstance.postUpdate){this._postUpdateList.insert(scriptInstance);}}}_removeScriptInstance(scriptInstance){const idx=this._scripts.indexOf(scriptInstance);if(idx===-1)return idx;this._scripts.splice(idx,1);if(scriptInstance.update){this._updateList.remove(scriptInstance);}if(scriptInstance.postUpdate){this._postUpdateList.remove(scriptInstance);}return idx}_resetExecutionOrder(startIndex,scriptsLength){for(let i=startIndex;i<scriptsLength;i++){this._scripts[i].__executionOrder=i;}}_resolveEntityScriptAttribute(attribute,attributeName,oldValue,useGuid,newAttributes,duplicatedIdsMap){if(attribute.array){const len=oldValue.length;if(!len){return}const newGuidArray=oldValue.slice();for(let i=0;i<len;i++){const guid=newGuidArray[i]instanceof Entity?newGuidArray[i].getGuid():newGuidArray[i];if(duplicatedIdsMap[guid]){newGuidArray[i]=useGuid?duplicatedIdsMap[guid].getGuid():duplicatedIdsMap[guid];}}newAttributes[attributeName]=newGuidArray;}else {if(oldValue instanceof Entity){oldValue=oldValue.getGuid();}else if(typeof oldValue!=="string"){return}if(duplicatedIdsMap[oldValue]){newAttributes[attributeName]=duplicatedIdsMap[oldValue];}}}has(nameOrType){if(typeof nameOrType==="string"){return !!this._scriptsIndex[nameOrType]}if(!nameOrType)return false;const scriptType=nameOrType;const scriptName=scriptType.__name;const scriptData=this._scriptsIndex[scriptName];const scriptInstance=scriptData&&scriptData.instance;return scriptInstance instanceof scriptType}get(nameOrType){if(typeof nameOrType==="string"){const data=this._scriptsIndex[nameOrType];return data?data.instance:null}if(!nameOrType)return null;const scriptType=nameOrType;const scriptName=scriptType.__name;const scriptData=this._scriptsIndex[scriptName];const scriptInstance=scriptData&&scriptData.instance;return scriptInstance instanceof scriptType?scriptInstance:null}create(nameOrType,args={}){const self1=this;let scriptType=nameOrType;let scriptName=nameOrType;if(typeof scriptType==="string"){scriptType=this.system.app.scripts.get(scriptType);}else if(scriptType){var _scriptType,_scriptType$__name;scriptName=(_scriptType$__name=(_scriptType=scriptType).__name)!=null?_scriptType$__name:_scriptType.__name=toLowerCamelCase$1(getScriptName(scriptType));}if(scriptType){if(!this._scriptsIndex[scriptName]||!this._scriptsIndex[scriptName].instance){const scriptInstance=new scriptType({app:this.system.app,entity:this.entity,enabled:args.hasOwnProperty("enabled")?args.enabled:true,attributes:args.attributes});if(!(scriptInstance instanceof ScriptType)){this._attributeDataMap.set(scriptName,args.attributes);}const len=this._scripts.length;let ind=-1;if(typeof args.ind==="number"&&args.ind!==-1&&len>args.ind){ind=args.ind;}this._insertScriptInstance(scriptInstance,ind,len);this._scriptsIndex[scriptName]={instance:scriptInstance,onSwap:function(){self1.swap(scriptName);}};this[scriptName]=scriptInstance;if(!args.preloading){this.initializeAttributes(scriptInstance);}this.fire("create",scriptName,scriptInstance);this.fire(`create:${scriptName}`,scriptInstance);this.system.app.scripts.on(`swap:${scriptName}`,this._scriptsIndex[scriptName].onSwap);if(!args.preloading){if(scriptInstance.enabled&&!scriptInstance._initialized){scriptInstance._initialized=true;if(scriptInstance.initialize){this._scriptMethod(scriptInstance,SCRIPT_INITIALIZE);}}if(scriptInstance.enabled&&!scriptInstance._postInitialized){scriptInstance._postInitialized=true;if(scriptInstance.postInitialize){this._scriptMethod(scriptInstance,SCRIPT_POST_INITIALIZE);}}}return scriptInstance}}else {this._scriptsIndex[scriptName]={awaiting:true,ind:this._scripts.length};}return null}destroy(nameOrType){let scriptName=nameOrType;let scriptType=nameOrType;if(typeof scriptType==="string"){scriptType=this.system.app.scripts.get(scriptType);}else if(scriptType){scriptName=scriptType.__name;}const scriptData=this._scriptsIndex[scriptName];delete this._scriptsIndex[scriptName];if(!scriptData)return false;this._attributeDataMap.delete(scriptName);const scriptInstance=scriptData.instance;if(scriptInstance&&!scriptInstance._destroyed){scriptInstance.enabled=false;scriptInstance._destroyed=true;if(!this._isLoopingThroughScripts){const ind=this._removeScriptInstance(scriptInstance);if(ind>=0){this._resetExecutionOrder(ind,this._scripts.length);}}else {this._destroyedScripts.push(scriptInstance);}}this.system.app.scripts.off(`swap:${scriptName}`,scriptData.onSwap);delete this[scriptName];this.fire("destroy",scriptName,scriptInstance||null);this.fire(`destroy:${scriptName}`,scriptInstance||null);if(scriptInstance){scriptInstance.fire("destroy");}return true}swap(nameOrType){let scriptName=nameOrType;let scriptType=nameOrType;if(typeof scriptType==="string"){scriptType=this.system.app.scripts.get(scriptType);}else if(scriptType){scriptName=scriptType.__name;}const old=this._scriptsIndex[scriptName];if(!old||!old.instance)return false;const scriptInstanceOld=old.instance;const ind=this._scripts.indexOf(scriptInstanceOld);const scriptInstance=new scriptType({app:this.system.app,entity:this.entity,enabled:scriptInstanceOld.enabled,attributes:scriptInstanceOld.__attributes});if(!scriptInstance.swap){return false}this.initializeAttributes(scriptInstance);this._scripts[ind]=scriptInstance;this._scriptsIndex[scriptName].instance=scriptInstance;this[scriptName]=scriptInstance;scriptInstance.__executionOrder=ind;if(scriptInstanceOld.update){this._updateList.remove(scriptInstanceOld);}if(scriptInstanceOld.postUpdate){this._postUpdateList.remove(scriptInstanceOld);}if(scriptInstance.update){this._updateList.insert(scriptInstance);}if(scriptInstance.postUpdate){this._postUpdateList.insert(scriptInstance);}this._scriptMethod(scriptInstance,SCRIPT_SWAP,scriptInstanceOld);this.fire("swap",scriptName,scriptInstance);this.fire(`swap:${scriptName}`,scriptInstance);return true}resolveDuplicatedEntityReferenceProperties(oldScriptComponent,duplicatedIdsMap){const newScriptComponent=this.entity.script;for(const scriptName in oldScriptComponent._scriptsIndex){const scriptType=this.system.app.scripts.get(scriptName);if(!scriptType){continue}const script=oldScriptComponent._scriptsIndex[scriptName];if(!script||!script.instance){continue}const newAttributesRaw=newScriptComponent[scriptName].__attributesRaw;const newAttributes=newScriptComponent[scriptName].__attributes;if(!newAttributesRaw&&!newAttributes){continue}const useGuid=!!newAttributesRaw;const oldAttributes=script.instance.__attributes;for(const attributeName in oldAttributes){if(!oldAttributes[attributeName]){continue}const attribute=scriptType.attributes.get(attributeName);if(!attribute){continue}if(attribute.type==="entity"){this._resolveEntityScriptAttribute(attribute,attributeName,oldAttributes[attributeName],useGuid,newAttributesRaw||newAttributes,duplicatedIdsMap);}else if(attribute.type==="json"&&Array.isArray(attribute.schema)){const oldValue=oldAttributes[attributeName];const newJsonValue=newAttributesRaw?newAttributesRaw[attributeName]:newAttributes[attributeName];for(let i=0;i<attribute.schema.length;i++){const field=attribute.schema[i];if(field.type!=="entity"){continue}if(attribute.array){for(let j=0;j<oldValue.length;j++){this._resolveEntityScriptAttribute(field,field.name,oldValue[j][field.name],useGuid,newJsonValue[j],duplicatedIdsMap);}}else {this._resolveEntityScriptAttribute(field,field.name,oldValue[field.name],useGuid,newJsonValue,duplicatedIdsMap);}}}}}}move(nameOrType,ind){const len=this._scripts.length;if(ind>=len||ind<0){return false}let scriptType=nameOrType;let scriptName=nameOrType;if(typeof scriptName!=="string"){scriptName=nameOrType.__name;}else {scriptType=null;}const scriptData=this._scriptsIndex[scriptName];if(!scriptData||!scriptData.instance){return false}const scriptInstance=scriptData.instance;if(scriptType&&!(scriptInstance instanceof scriptType)){return false}const indOld=this._scripts.indexOf(scriptInstance);if(indOld===-1||indOld===ind){return false}this._scripts.splice(ind,0,this._scripts.splice(indOld,1)[0]);this._resetExecutionOrder(0,len);this._updateList.sort();this._postUpdateList.sort();this.fire("move",scriptName,scriptInstance,ind,indOld);this.fire(`move:${scriptName}`,scriptInstance,ind,indOld);return true}constructor(system,entity){super(system,entity);this._attributeDataMap=new Map;this._scripts=[];this._updateList=new SortedLoopArray({sortBy:"__executionOrder"});this._postUpdateList=new SortedLoopArray({sortBy:"__executionOrder"});this._scriptsIndex={};this._destroyedScripts=[];this._destroyed=false;this._scriptsData=null;this._oldState=true;this._enabled=true;this._beingEnabled=false;this._isLoopingThroughScripts=false;this._executionOrder=-1;this.on("set_enabled",this._onSetEnabled,this);}}ScriptComponent.EVENT_CREATE="create";ScriptComponent.EVENT_DESTROY="destroy";ScriptComponent.EVENT_ENABLE="enable";ScriptComponent.EVENT_DISABLE="disable";ScriptComponent.EVENT_REMOVE="remove";ScriptComponent.EVENT_STATE="state";ScriptComponent.EVENT_MOVE="move";ScriptComponent.EVENT_ERROR="error";class ScriptComponentData{constructor(){this.enabled=true;}}const METHOD_INITIALIZE_ATTRIBUTES="_onInitializeAttributes";const METHOD_INITIALIZE="_onInitialize";const METHOD_POST_INITIALIZE="_onPostInitialize";const METHOD_UPDATE="_onUpdate";const METHOD_POST_UPDATE="_onPostUpdate";let executionOrderCounter=0;class ScriptComponentSystem extends ComponentSystem{initializeComponentData(component,data){component._executionOrder=executionOrderCounter++;this._components.append(component);if(executionOrderCounter>Number.MAX_SAFE_INTEGER){this._resetExecutionOrder();}component.enabled=data.hasOwnProperty("enabled")?!!data.enabled:true;if(component.enabled&&component.entity.enabled){this._enabledComponents.append(component);}if(data.hasOwnProperty("order")&&data.hasOwnProperty("scripts")){component._scriptsData=data.scripts;for(let i=0;i<data.order.length;i++){component.create(data.order[i],{enabled:data.scripts[data.order[i]].enabled,attributes:data.scripts[data.order[i]].attributes,preloading:this.preloading});}}}cloneComponent(entity,clone){const order=[];const scripts={};for(let i=0;i<entity.script._scripts.length;i++){var _entity$script$_attri;const scriptInstance=entity.script._scripts[i];const scriptName=scriptInstance.__scriptType.__name;order.push(scriptName);const attributes=((_entity$script$_attri=entity.script._attributeDataMap)==null?void 0:_entity$script$_attri.get(scriptName))||{};for(const key in scriptInstance.__attributes){attributes[key]=scriptInstance.__attributes[key];}scripts[scriptName]={enabled:scriptInstance._enabled,attributes:attributes};}for(const key in entity.script._scriptsIndex){if(key.awaiting){order.splice(key.ind,0,key);}}const data={enabled:entity.script.enabled,order:order,scripts:scripts};return this.addComponent(clone,data)}_resetExecutionOrder(){executionOrderCounter=0;for(let i=0,len=this._components.length;i<len;i++){this._components.items[i]._executionOrder=executionOrderCounter++;}}_callComponentMethod(components,name,dt){for(components.loopIndex=0;components.loopIndex<components.length;components.loopIndex++){components.items[components.loopIndex][name](dt);}}_onInitialize(){this.preloading=false;this._callComponentMethod(this._components,METHOD_INITIALIZE_ATTRIBUTES);this._callComponentMethod(this._enabledComponents,METHOD_INITIALIZE);}_onPostInitialize(){this._callComponentMethod(this._enabledComponents,METHOD_POST_INITIALIZE);}_onUpdate(dt){this._callComponentMethod(this._enabledComponents,METHOD_UPDATE,dt);}_onPostUpdate(dt){this._callComponentMethod(this._enabledComponents,METHOD_POST_UPDATE,dt);}_addComponentToEnabled(component){this._enabledComponents.insert(component);}_removeComponentFromEnabled(component){this._enabledComponents.remove(component);}_onBeforeRemove(entity,component){const ind=this._components.items.indexOf(component);if(ind>=0){component._onBeforeRemove();}this._removeComponentFromEnabled(component);this._components.remove(component);}destroy(){super.destroy();this.app.systems.off("initialize",this._onInitialize,this);this.app.systems.off("postInitialize",this._onPostInitialize,this);this.app.systems.off("update",this._onUpdate,this);this.app.systems.off("postUpdate",this._onPostUpdate,this);}constructor(app){super(app);this.id="script";this.ComponentType=ScriptComponent;this.DataType=ScriptComponentData;this._components=new SortedLoopArray({sortBy:"_executionOrder"});this._enabledComponents=new SortedLoopArray({sortBy:"_executionOrder"});this.preloading=true;this.on("beforeremove",this._onBeforeRemove,this);this.app.systems.on("initialize",this._onInitialize,this);this.app.systems.on("postInitialize",this._onPostInitialize,this);this.app.systems.on("update",this._onUpdate,this);this.app.systems.on("postUpdate",this._onPostUpdate,this);}}class GSplatComponent extends Component{set customAabb(value){var _this$_instance;this._customAabb=value;(_this$_instance=this._instance)==null||(_this$_instance=_this$_instance.meshInstance)==null||_this$_instance.setCustomAabb(this._customAabb);}get customAabb(){return this._customAabb}set instance(value){var _this$_instance2;this.destroyInstance();this._instance=value;if((_this$_instance2=this._instance)!=null&&_this$_instance2.meshInstance){const mi=this._instance.meshInstance;if(!mi.node){mi.node=this.entity;}mi.setCustomAabb(this._customAabb);if(this._materialOptions){this._instance.createMaterial(this._materialOptions);}if(this.enabled&&this.entity.enabled){this.addToLayers();}}}get instance(){return this._instance}set materialOptions(value){this._materialOptions=Object.assign({},value);if(this._instance){this._instance.createMaterial(this._materialOptions);}}get materialOptions(){return this._materialOptions}get material(){var _this$_instance3;return (_this$_instance3=this._instance)==null?void 0:_this$_instance3.material}set layers(value){this.removeFromLayers();this._layers.length=0;for(let i=0;i<value.length;i++){this._layers[i]=value[i];}if(!this.enabled||!this.entity.enabled){return}this.addToLayers();}get layers(){return this._layers}set asset(value){const id=value instanceof Asset?value.id:value;if(this._assetReference.id===id)return;if(this._assetReference.asset&&this._assetReference.asset.resource){this._onGSplatAssetRemove();}this._assetReference.id=id;if(this._assetReference.asset){this._onGSplatAssetAdded();}}get asset(){return this._assetReference.id}assignAsset(asset){const id=asset instanceof Asset?asset.id:asset;this._assetReference.id=id;}destroyInstance(){if(this._instance){var _this$_instance4;this.removeFromLayers();(_this$_instance4=this._instance)==null||_this$_instance4.destroy();this._instance=null;}}addToLayers(){var _this$instance;const meshInstance=(_this$instance=this.instance)==null?void 0:_this$instance.meshInstance;if(meshInstance){const layers=this.system.app.scene.layers;for(let i=0;i<this._layers.length;i++){var _layers$getLayerById;(_layers$getLayerById=layers.getLayerById(this._layers[i]))==null||_layers$getLayerById.addMeshInstances([meshInstance]);}}}removeFromLayers(){var _this$instance2;const meshInstance=(_this$instance2=this.instance)==null?void 0:_this$instance2.meshInstance;if(meshInstance){const layers=this.system.app.scene.layers;for(let i=0;i<this._layers.length;i++){var _layers$getLayerById2;(_layers$getLayerById2=layers.getLayerById(this._layers[i]))==null||_layers$getLayerById2.removeMeshInstances([meshInstance]);}}}onRemoveChild(){this.removeFromLayers();}onInsertChild(){if(this._instance&&this.enabled&&this.entity.enabled){this.addToLayers();}}onRemove(){this.destroyInstance();this.asset=null;this._assetReference.id=null;this.entity.off("remove",this.onRemoveChild,this);this.entity.off("insert",this.onInsertChild,this);}onLayersChanged(oldComp,newComp){this.addToLayers();oldComp.off("add",this.onLayerAdded,this);oldComp.off("remove",this.onLayerRemoved,this);newComp.on("add",this.onLayerAdded,this);newComp.on("remove",this.onLayerRemoved,this);}onLayerAdded(layer){const index=this.layers.indexOf(layer.id);if(index<0)return;if(this._instance){layer.addMeshInstances(this._instance.meshInstance);}}onLayerRemoved(layer){const index=this.layers.indexOf(layer.id);if(index<0)return;if(this._instance){layer.removeMeshInstances(this._instance.meshInstance);}}onEnable(){const scene=this.system.app.scene;const layers=scene.layers;this._evtLayersChanged=scene.on("set:layers",this.onLayersChanged,this);if(layers){this._evtLayerAdded=layers.on("add",this.onLayerAdded,this);this._evtLayerRemoved=layers.on("remove",this.onLayerRemoved,this);}if(this._instance){this.addToLayers();}else if(this.asset){this._onGSplatAssetAdded();}}onDisable(){var _this$_evtLayersChang;const scene=this.system.app.scene;const layers=scene.layers;(_this$_evtLayersChang=this._evtLayersChanged)==null||_this$_evtLayersChang.off();this._evtLayersChanged=null;if(layers){var _this$_evtLayerAdded,_this$_evtLayerRemove;(_this$_evtLayerAdded=this._evtLayerAdded)==null||_this$_evtLayerAdded.off();this._evtLayerAdded=null;(_this$_evtLayerRemove=this._evtLayerRemoved)==null||_this$_evtLayerRemove.off();this._evtLayerRemoved=null;}this.removeFromLayers();}hide(){if(this._instance){this._instance.meshInstance.visible=false;}}show(){if(this._instance){this._instance.meshInstance.visible=true;}}_onGSplatAssetAdded(){if(!this._assetReference.asset){return}if(this._assetReference.asset.resource){this._onGSplatAssetLoad();}else if(this.enabled&&this.entity.enabled){this.system.app.assets.load(this._assetReference.asset);}}_onGSplatAssetLoad(){this.destroyInstance();const asset=this._assetReference.asset;if(asset){this.instance=asset.resource.createInstance();}}_onGSplatAssetUnload(){this.destroyInstance();}_onGSplatAssetRemove(){this._onGSplatAssetUnload();}constructor(system,entity){super(system,entity);this._layers=[LAYERID_WORLD];this._instance=null;this._customAabb=null;this._assetReference=void 0;this._materialOptions=null;this._evtLayersChanged=null;this._evtLayerAdded=null;this._evtLayerRemoved=null;this._assetReference=new AssetReference("asset",this,system.app.assets,{add:this._onGSplatAssetAdded,load:this._onGSplatAssetLoad,remove:this._onGSplatAssetRemove,unload:this._onGSplatAssetUnload},this);entity.on("remove",this.onRemoveChild,this);entity.on("removehierarchy",this.onRemoveChild,this);entity.on("insert",this.onInsertChild,this);entity.on("inserthierarchy",this.onInsertChild,this);}}class GSplatComponentData{constructor(){this.enabled=true;}}const _schema=["enabled"];const _properties=["instance","asset","layers"];class GSplatComponentSystem extends ComponentSystem{initializeComponentData(component,_data,properties){if(_data.layers&&_data.layers.length){_data.layers=_data.layers.slice(0);}for(let i=0;i<_properties.length;i++){if(_data.hasOwnProperty(_properties[i])){component[_properties[i]]=_data[_properties[i]];}}if(_data.aabbCenter&&_data.aabbHalfExtents){component.customAabb=new BoundingBox(new Vec3(_data.aabbCenter),new Vec3(_data.aabbHalfExtents));}super.initializeComponentData(component,_data,_schema);}cloneComponent(entity,clone){const gSplatComponent=entity.gsplat;const data={};for(let i=0;i<_properties.length;i++){data[_properties[i]]=gSplatComponent[_properties[i]];}data.enabled=gSplatComponent.enabled;delete data.instance;const component=this.addComponent(clone,data);component.instance=gSplatComponent.instance.clone();if(gSplatComponent.customAabb){component.customAabb=gSplatComponent.customAabb.clone();}return component}onRemove(entity,component){component.onRemove();}constructor(app){super(app);this.id="gsplat";this.ComponentType=GSplatComponent;this.DataType=GSplatComponentData;this.schema=_schema;this.on("beforeremove",this.onRemove,this);}}Component._buildAccessors(GSplatComponent.prototype,_schema);class Render extends EventHandler{set meshes(value){this.decRefMeshes();this._meshes=value;this.incRefMeshes();this.fire("set:meshes",value);}get meshes(){return this._meshes}destroy(){this.meshes=null;}decRefMeshes(){if(this._meshes){const count=this._meshes.length;for(let i=0;i<count;i++){const mesh=this._meshes[i];if(mesh){mesh.decRefCount();if(mesh.refCount<1){mesh.destroy();this._meshes[i]=null;}}}}}incRefMeshes(){if(this._meshes){const count=this._meshes.length;for(let i=0;i<count;i++){if(this._meshes[i]){this._meshes[i].incRefCount();}}}}constructor(){super();this._meshes=null;}}Render.EVENT_SETMESHES="set:meshes";function onContainerAssetLoaded(containerAsset){const renderAsset=this;if(!renderAsset.resource)return;const containerResource=containerAsset.resource;const render=containerResource.renders&&containerResource.renders[renderAsset.data.renderIndex];if(render){renderAsset.resource.meshes=render.resource.meshes;}}function onContainerAssetAdded(containerAsset){const renderAsset=this;renderAsset.registry.off(`load:${containerAsset.id}`,onContainerAssetLoaded,renderAsset);renderAsset.registry.on(`load:${containerAsset.id}`,onContainerAssetLoaded,renderAsset);renderAsset.registry.off(`remove:${containerAsset.id}`,onContainerAssetRemoved,renderAsset);renderAsset.registry.once(`remove:${containerAsset.id}`,onContainerAssetRemoved,renderAsset);if(!containerAsset.resource){renderAsset.registry.load(containerAsset);}else {onContainerAssetLoaded.call(renderAsset,containerAsset);}}function onContainerAssetRemoved(containerAsset){const renderAsset=this;renderAsset.registry.off(`load:${containerAsset.id}`,onContainerAssetLoaded,renderAsset);if(renderAsset.resource){renderAsset.resource.destroy();}}class RenderHandler extends ResourceHandler{open(url,data){return new Render}patch(asset,registry){if(!asset.data.containerAsset){return}const containerAsset=registry.get(asset.data.containerAsset);if(!containerAsset){registry.once(`add:${asset.data.containerAsset}`,onContainerAssetAdded,asset);return}onContainerAssetAdded.call(asset,containerAsset);}constructor(app){super(app,"render");this._registry=app.assets;}}class AnimCurve{get paths(){return this._paths}get input(){return this._input}get output(){return this._output}get interpolation(){return this._interpolation}constructor(paths,input,output,interpolation){this._paths=paths;this._input=input;this._output=output;this._interpolation=interpolation;}}class AnimData{get components(){return this._components}get data(){return this._data}constructor(components,data){this._components=components;this._data=data;}}function DracoWorker(jsUrl,wasmUrl){let draco;const POSITION_ATTRIBUTE=0;const NORMAL_ATTRIBUTE=1;const wrap=(typedArray,dataType)=>{switch(dataType){case draco.DT_INT8:return new Int8Array(typedArray.buffer,typedArray.byteOffset,typedArray.byteLength);case draco.DT_INT16:return new Int16Array(typedArray.buffer,typedArray.byteOffset,typedArray.byteLength/2);case draco.DT_INT32:return new Int32Array(typedArray.buffer,typedArray.byteOffset,typedArray.byteLength/4);case draco.DT_UINT8:return new Uint8Array(typedArray.buffer,typedArray.byteOffset,typedArray.byteLength);case draco.DT_UINT16:return new Uint16Array(typedArray.buffer,typedArray.byteOffset,typedArray.byteLength/2);case draco.DT_UINT32:return new Uint32Array(typedArray.buffer,typedArray.byteOffset,typedArray.byteLength/4);case draco.DT_FLOAT32:return new Float32Array(typedArray.buffer,typedArray.byteOffset,typedArray.byteLength/4)}return null};const componentSizeInBytes=dataType=>{switch(dataType){case draco.DT_INT8:return 1;case draco.DT_INT16:return 2;case draco.DT_INT32:return 4;case draco.DT_UINT8:return 1;case draco.DT_UINT16:return 2;case draco.DT_UINT32:return 4;case draco.DT_FLOAT32:return 4}return 1};const attributeSizeInBytes=attribute=>{return attribute.num_components()*componentSizeInBytes(attribute.data_type())};const attributeOrder={0:0,1:1,5:2,2:3,7:4,8:5,4:6,3:7};const generateNormals=(vertices,indices)=>{const subtract=(dst,a,b)=>{dst[0]=a[0]-b[0];dst[1]=a[1]-b[1];dst[2]=a[2]-b[2];};const cross=(dst,a,b)=>{dst[0]=a[1]*b[2]-b[1]*a[2];dst[1]=a[2]*b[0]-b[2]*a[0];dst[2]=a[0]*b[1]-b[0]*a[1];};const normalize=(dst,offset)=>{const a=dst[offset+0];const b=dst[offset+1];const c=dst[offset+2];const l=1/Math.sqrt(a*a+b*b+c*c);dst[offset+0]*=l;dst[offset+1]*=l;dst[offset+2]*=l;};const copy=(dst,src,srcOffset)=>{for(let i=0;i<3;++i){dst[i]=src[srcOffset+i];}};const numTriangles=indices.length/3;const numVertices=vertices.length/3;const result=new Float32Array(vertices.length);const a=[0,0,0],b=[0,0,0],c=[0,0,0],t1=[0,0,0],t2=[0,0,0],n=[0,0,0];for(let i=0;i<numTriangles;++i){const v0=indices[i*3+0]*3;const v1=indices[i*3+1]*3;const v2=indices[i*3+2]*3;copy(a,vertices,v0);copy(b,vertices,v1);copy(c,vertices,v2);subtract(t1,b,a);subtract(t2,c,a);cross(n,t1,t2);normalize(n,0);for(let j=0;j<3;++j){result[v0+j]+=n[j];result[v1+j]+=n[j];result[v2+j]+=n[j];}}for(let i=0;i<numVertices;++i){normalize(result,i*3);}return new Uint8Array(result.buffer)};const decodeMesh=inputBuffer=>{const result={};const buffer=new draco.DecoderBuffer;buffer.Init(inputBuffer,inputBuffer.length);const decoder=new draco.Decoder;if(decoder.GetEncodedGeometryType(buffer)!==draco.TRIANGULAR_MESH){result.error="Failed to decode draco mesh: not a mesh";return result}const mesh=new draco.Mesh;const status=decoder.DecodeBufferToMesh(buffer,mesh);if(!status||!status.ok()||mesh.ptr===0){result.error="Failed to decode draco asset";return result}const numIndices=mesh.num_faces()*3;const shortIndices=mesh.num_points()<=65535;const indicesSize=numIndices*(shortIndices?2:4);const indicesPtr=draco._malloc(indicesSize);if(shortIndices){decoder.GetTrianglesUInt16Array(mesh,indicesSize,indicesPtr);result.indices=new Uint16Array(draco.HEAPU16.buffer,indicesPtr,numIndices).slice().buffer;}else {decoder.GetTrianglesUInt32Array(mesh,indicesSize,indicesPtr);result.indices=new Uint32Array(draco.HEAPU32.buffer,indicesPtr,numIndices).slice().buffer;}draco._free(indicesPtr);const attributes=[];for(let i=0;i<mesh.num_attributes();++i){attributes.push(decoder.GetAttribute(mesh,i));}attributes.sort((a,b)=>{var _attributeOrder$a$att,_attributeOrder$b$att;return ((_attributeOrder$a$att=attributeOrder[a.attribute_type()])!=null?_attributeOrder$a$att:attributeOrder.length)-((_attributeOrder$b$att=attributeOrder[b.attribute_type()])!=null?_attributeOrder$b$att:attributeOrder.length)});result.attributes=attributes.map(a=>a.unique_id());let totalVertexSize=0;const offsets=attributes.map(a=>{const offset=totalVertexSize;totalVertexSize+=Math.ceil(attributeSizeInBytes(a)/4)*4;return offset});const hasNormals=attributes.some(a=>a.attribute_type()===NORMAL_ATTRIBUTE);const normalOffset=offsets[1];if(!hasNormals){for(let i=1;i<offsets.length;++i){offsets[i]+=12;}totalVertexSize+=12;}result.vertices=new ArrayBuffer(mesh.num_points()*totalVertexSize);const dst=new Uint8Array(result.vertices);for(let i=0;i<mesh.num_attributes();++i){const attribute=attributes[i];const sizeInBytes=attributeSizeInBytes(attribute);const ptrSize=mesh.num_points()*sizeInBytes;const ptr=draco._malloc(ptrSize);decoder.GetAttributeDataArrayForAllPoints(mesh,attribute,attribute.data_type(),ptrSize,ptr);const src=new Uint8Array(draco.HEAPU8.buffer,ptr,ptrSize);for(let j=0;j<mesh.num_points();++j){for(let c=0;c<sizeInBytes;++c){dst[j*totalVertexSize+offsets[i]+c]=src[j*sizeInBytes+c];}}if(!hasNormals&&attribute.attribute_type()===POSITION_ATTRIBUTE){const normals=generateNormals(wrap(src,attribute.data_type()),shortIndices?new Uint16Array(result.indices):new Uint32Array(result.indices));for(let j=0;j<mesh.num_points();++j){for(let c=0;c<12;++c){dst[j*totalVertexSize+normalOffset+c]=normals[j*12+c];}}}draco._free(ptr);}draco.destroy(mesh);draco.destroy(decoder);draco.destroy(buffer);return result};const decode=data=>{const result=decodeMesh(new Uint8Array(data.buffer));self.postMessage({jobId:data.jobId,error:result.error,indices:result.indices,vertices:result.vertices,attributes:result.attributes},[result.indices,result.vertices].filter(t=>t!=null));};const workQueue=[];self.onmessage=message=>{const data=message.data;switch(data.type){case"init":self.DracoDecoderModule({instantiateWasm:(imports,successCallback)=>{WebAssembly.instantiate(data.module,imports).then(result=>successCallback(result)).catch(reason=>console.error(`instantiate failed + ${reason}`));return {}}}).then(instance=>{draco=instance;workQueue.forEach(data=>decode(data));});break;case"decodeMesh":if(draco){decode(data);}else {workQueue.push(data);}break}};}const downloadMaxRetries=3;class JobQueue{init(workers){workers.forEach(worker=>{worker.addEventListener("message",message=>{const data=message.data;const callback=this.jobCallbacks.get(data.jobId);if(callback){callback(data.error,{indices:data.indices,vertices:data.vertices,attributes:data.attributes});}this.jobCallbacks.delete(data.jobId);if(this.jobQueue.length>0){const job=this.jobQueue.shift();this.run(worker,job);}else {const index2=this.workers[2].indexOf(worker);if(index2!==-1){this.workers[2].splice(index2,1);this.workers[1].push(worker);}else {const index1=this.workers[1].indexOf(worker);if(index1!==-1){this.workers[1].splice(index1,1);this.workers[0].push(worker);}}}});});this.workers[0]=workers;while(this.jobQueue.length&&(this.workers[0].length||this.workers[1].length)){const job=this.jobQueue.shift();if(this.workers[0].length>0){const worker=this.workers[0].shift();this.workers[1].push(worker);this.run(worker,job);}else {const worker=this.workers[1].shift();this.workers[2].push(worker);this.run(worker,job);}}}enqueueJob(buffer,callback){const job={jobId:this.jobId++,buffer:buffer};this.jobCallbacks.set(job.jobId,callback);if(this.workers[0].length>0){const worker=this.workers[0].shift();this.workers[1].push(worker);this.run(worker,job);}else if(this.workers[1].length>0){const worker=this.workers[1].shift();this.workers[2].push(worker);this.run(worker,job);}else {this.jobQueue.push(job);}}constructor(){this.workers=[[],[],[]];this.jobId=0;this.jobQueue=[];this.jobCallbacks=new Map;this.run=(worker,job)=>{worker.postMessage({type:"decodeMesh",jobId:job.jobId,buffer:job.buffer},[job.buffer]);};}}const downloadScript=url=>{return new Promise((resolve,reject)=>{const options={cache:true,responseType:"text",retry:downloadMaxRetries>0,maxRetries:downloadMaxRetries};http.get(url,options,(err,response)=>{if(err){reject(err);}else {resolve(response);}});})};const compileModule=url=>{const compileManual=()=>{return fetch(url).then(result=>result.arrayBuffer()).then(buffer=>WebAssembly.compile(buffer))};const compileStreaming=()=>{return WebAssembly.compileStreaming(fetch(url)).catch(err=>{return compileManual()})};return WebAssembly.compileStreaming?compileStreaming():compileManual()};const defaultNumWorkers$1=1;let jobQueue;let lazyConfig$1;const initializeWorkers=config=>{if(jobQueue){return true}if(!config){if(lazyConfig$1){config=lazyConfig$1;}else {const moduleConfig=WasmModule.getConfig("DracoDecoderModule");if(moduleConfig){config={jsUrl:moduleConfig.glueUrl,wasmUrl:moduleConfig.wasmUrl,numWorkers:moduleConfig.numWorkers};}else {config={jsUrl:"draco.wasm.js",wasmUrl:"draco.wasm.wasm",numWorkers:defaultNumWorkers$1};}}}if(!config.jsUrl||!config.wasmUrl){return false}jobQueue=new JobQueue;Promise.all([downloadScript(config.jsUrl),compileModule(config.wasmUrl)]).then(([dracoSource,dracoModule])=>{const code=["/* draco */",dracoSource,"/* worker */",`(
${DracoWorker.toString()}
)()

`].join("\n");const blob=new Blob([code],{type:"application/javascript"});const workerUrl=URL.createObjectURL(blob);const numWorkers=Math.max(1,Math.min(16,config.numWorkers||defaultNumWorkers$1));const workers=[];for(let i=0;i<numWorkers;++i){const worker=new Worker(workerUrl);worker.postMessage({type:"init",module:dracoModule});workers.push(worker);}jobQueue.init(workers);});return true};const dracoInitialize=config=>{if(config!=null&&config.lazyInit){lazyConfig$1=config;}else {initializeWorkers(config);}};const dracoDecode=(buffer,callback)=>{if(!initializeWorkers()){return false}jobQueue.enqueueJob(buffer,callback);return true};class GlbResources{destroy(){if(this.renders){this.renders.forEach(render=>{render.meshes=null;});}}constructor(){this.gltf=void 0;this.nodes=void 0;this.scenes=void 0;this.animations=void 0;this.textures=void 0;this.materials=void 0;this.variants=void 0;this.meshVariants=void 0;this.meshDefaultMaterials=void 0;this.renders=void 0;this.skins=void 0;this.lights=void 0;this.cameras=void 0;}}const isDataURI=uri=>{return /^data:[^\n\r,\u2028\u2029]*,.*$/i.test(uri)};const getDataURIMimeType=uri=>{return uri.substring(uri.indexOf(":")+1,uri.indexOf(";"))};const getNumComponents=accessorType=>{switch(accessorType){case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3;case"VEC4":return 4;case"MAT2":return 4;case"MAT3":return 9;case"MAT4":return 16;default:return 3}};const getComponentType$1=componentType=>{switch(componentType){case 5120:return TYPE_INT8;case 5121:return TYPE_UINT8;case 5122:return TYPE_INT16;case 5123:return TYPE_UINT16;case 5124:return TYPE_INT32;case 5125:return TYPE_UINT32;case 5126:return TYPE_FLOAT32;default:return 0}};const getComponentSizeInBytes=componentType=>{switch(componentType){case 5120:return 1;case 5121:return 1;case 5122:return 2;case 5123:return 2;case 5124:return 4;case 5125:return 4;case 5126:return 4;default:return 0}};const getComponentDataType=componentType=>{switch(componentType){case 5120:return Int8Array;case 5121:return Uint8Array;case 5122:return Int16Array;case 5123:return Uint16Array;case 5124:return Int32Array;case 5125:return Uint32Array;case 5126:return Float32Array;default:return null}};const gltfToEngineSemanticMap={"POSITION":SEMANTIC_POSITION,"NORMAL":SEMANTIC_NORMAL,"TANGENT":SEMANTIC_TANGENT,"COLOR_0":SEMANTIC_COLOR,"JOINTS_0":SEMANTIC_BLENDINDICES,"WEIGHTS_0":SEMANTIC_BLENDWEIGHT,"TEXCOORD_0":SEMANTIC_TEXCOORD0,"TEXCOORD_1":SEMANTIC_TEXCOORD1,"TEXCOORD_2":SEMANTIC_TEXCOORD2,"TEXCOORD_3":SEMANTIC_TEXCOORD3,"TEXCOORD_4":SEMANTIC_TEXCOORD4,"TEXCOORD_5":SEMANTIC_TEXCOORD5,"TEXCOORD_6":SEMANTIC_TEXCOORD6,"TEXCOORD_7":SEMANTIC_TEXCOORD7};const attributeOrder={[SEMANTIC_POSITION]:0,[SEMANTIC_NORMAL]:1,[SEMANTIC_TANGENT]:2,[SEMANTIC_COLOR]:3,[SEMANTIC_BLENDINDICES]:4,[SEMANTIC_BLENDWEIGHT]:5,[SEMANTIC_TEXCOORD0]:6,[SEMANTIC_TEXCOORD1]:7,[SEMANTIC_TEXCOORD2]:8,[SEMANTIC_TEXCOORD3]:9,[SEMANTIC_TEXCOORD4]:10,[SEMANTIC_TEXCOORD5]:11,[SEMANTIC_TEXCOORD6]:12,[SEMANTIC_TEXCOORD7]:13};const getDequantizeFunc=srcType=>{switch(srcType){case TYPE_INT8:return x=>Math.max(x/127,-1);case TYPE_UINT8:return x=>x/255;case TYPE_INT16:return x=>Math.max(x/32767,-1);case TYPE_UINT16:return x=>x/65535;default:return x=>x}};const dequantizeArray=(dstArray,srcArray,srcType)=>{const convFunc=getDequantizeFunc(srcType);const len=srcArray.length;for(let i=0;i<len;++i){dstArray[i]=convFunc(srcArray[i]);}return dstArray};const getAccessorData=(gltfAccessor,bufferViews,flatten=false)=>{const numComponents=getNumComponents(gltfAccessor.type);const dataType=getComponentDataType(gltfAccessor.componentType);if(!dataType){return null}let result;if(gltfAccessor.sparse){const sparse=gltfAccessor.sparse;const indicesAccessor={count:sparse.count,type:"SCALAR"};const indices=getAccessorData(Object.assign(indicesAccessor,sparse.indices),bufferViews,true);const valuesAccessor={count:sparse.count,type:gltfAccessor.type,componentType:gltfAccessor.componentType};const values=getAccessorData(Object.assign(valuesAccessor,sparse.values),bufferViews,true);if(gltfAccessor.hasOwnProperty("bufferView")){const baseAccessor={bufferView:gltfAccessor.bufferView,byteOffset:gltfAccessor.byteOffset,componentType:gltfAccessor.componentType,count:gltfAccessor.count,type:gltfAccessor.type};result=getAccessorData(baseAccessor,bufferViews,true).slice();}else {result=new dataType(gltfAccessor.count*numComponents);}for(let i=0;i<sparse.count;++i){const targetIndex=indices[i];for(let j=0;j<numComponents;++j){result[targetIndex*numComponents+j]=values[i*numComponents+j];}}}else {if(gltfAccessor.hasOwnProperty("bufferView")){const bufferView=bufferViews[gltfAccessor.bufferView];if(flatten&&bufferView.hasOwnProperty("byteStride")){const bytesPerElement=numComponents*dataType.BYTES_PER_ELEMENT;const storage=new ArrayBuffer(gltfAccessor.count*bytesPerElement);const tmpArray=new Uint8Array(storage);let dstOffset=0;for(let i=0;i<gltfAccessor.count;++i){let srcOffset=(gltfAccessor.byteOffset||0)+i*bufferView.byteStride;for(let b=0;b<bytesPerElement;++b){tmpArray[dstOffset++]=bufferView[srcOffset++];}}result=new dataType(storage);}else {result=new dataType(bufferView.buffer,bufferView.byteOffset+(gltfAccessor.byteOffset||0),gltfAccessor.count*numComponents);}}else {result=new dataType(gltfAccessor.count*numComponents);}}return result};const getAccessorDataFloat32=(gltfAccessor,bufferViews)=>{const data=getAccessorData(gltfAccessor,bufferViews,true);if(data instanceof Float32Array||!gltfAccessor.normalized){return data}const float32Data=new Float32Array(data.length);dequantizeArray(float32Data,data,getComponentType$1(gltfAccessor.componentType));return float32Data};const getAccessorBoundingBox=gltfAccessor=>{let min=gltfAccessor.min;let max=gltfAccessor.max;if(!min||!max){return null}if(gltfAccessor.normalized){const ctype=getComponentType$1(gltfAccessor.componentType);min=dequantizeArray([],min,ctype);max=dequantizeArray([],max,ctype);}return new BoundingBox(new Vec3((max[0]+min[0])*.5,(max[1]+min[1])*.5,(max[2]+min[2])*.5),new Vec3((max[0]-min[0])*.5,(max[1]-min[1])*.5,(max[2]-min[2])*.5))};const getPrimitiveType=primitive=>{if(!primitive.hasOwnProperty("mode")){return PRIMITIVE_TRIANGLES}switch(primitive.mode){case 0:return PRIMITIVE_POINTS;case 1:return PRIMITIVE_LINES;case 2:return PRIMITIVE_LINELOOP;case 3:return PRIMITIVE_LINESTRIP;case 4:return PRIMITIVE_TRIANGLES;case 5:return PRIMITIVE_TRISTRIP;case 6:return PRIMITIVE_TRIFAN;default:return PRIMITIVE_TRIANGLES}};const generateIndices=numVertices=>{const dummyIndices=new Uint16Array(numVertices);for(let i=0;i<numVertices;i++){dummyIndices[i]=i;}return dummyIndices};const generateNormals=(sourceDesc,indices)=>{const p=sourceDesc[SEMANTIC_POSITION];if(!p||p.components!==3){return}let positions;if(p.size!==p.stride){const srcStride=p.stride/typedArrayTypesByteSize[p.type];const src=new typedArrayTypes[p.type](p.buffer,p.offset,p.count*srcStride);positions=new typedArrayTypes[p.type](p.count*3);for(let i=0;i<p.count;++i){positions[i*3+0]=src[i*srcStride+0];positions[i*3+1]=src[i*srcStride+1];positions[i*3+2]=src[i*srcStride+2];}}else {positions=new typedArrayTypes[p.type](p.buffer,p.offset,p.count*3);}const numVertices=p.count;if(!indices){indices=generateIndices(numVertices);}const normalsTemp=calculateNormals(positions,indices);const normals=new Float32Array(normalsTemp.length);normals.set(normalsTemp);sourceDesc[SEMANTIC_NORMAL]={buffer:normals.buffer,size:12,offset:0,stride:12,count:numVertices,components:3,type:TYPE_FLOAT32};};const flipTexCoordVs=vertexBuffer=>{let i,j;const floatOffsets=[];const shortOffsets=[];const byteOffsets=[];for(i=0;i<vertexBuffer.format.elements.length;++i){const element=vertexBuffer.format.elements[i];if(element.name===SEMANTIC_TEXCOORD0||element.name===SEMANTIC_TEXCOORD1){switch(element.dataType){case TYPE_FLOAT32:floatOffsets.push({offset:element.offset/4+1,stride:element.stride/4});break;case TYPE_UINT16:shortOffsets.push({offset:element.offset/2+1,stride:element.stride/2});break;case TYPE_UINT8:byteOffsets.push({offset:element.offset+1,stride:element.stride});break}}}const flip=(offsets,type,one)=>{const typedArray=new type(vertexBuffer.storage);for(i=0;i<offsets.length;++i){let index=offsets[i].offset;const stride=offsets[i].stride;for(j=0;j<vertexBuffer.numVertices;++j){typedArray[index]=one-typedArray[index];index+=stride;}}};if(floatOffsets.length>0){flip(floatOffsets,Float32Array,1);}if(shortOffsets.length>0){flip(shortOffsets,Uint16Array,65535);}if(byteOffsets.length>0){flip(byteOffsets,Uint8Array,255);}};const cloneTexture=texture=>{const shallowCopyLevels=texture=>{const result=[];for(let mip=0;mip<texture._levels.length;++mip){let level=[];if(texture.cubemap){for(let face=0;face<6;++face){level.push(texture._levels[mip][face]);}}else {level=texture._levels[mip];}result.push(level);}return result};const result=new Texture(texture.device,texture);result._levels=shallowCopyLevels(texture);return result};const cloneTextureAsset=src=>{const result=new Asset(`${src.name}_clone`,src.type,src.file,src.data,src.options);result.loaded=true;result.resource=cloneTexture(src.resource);src.registry.add(result);return result};const createVertexBufferInternal=(device,sourceDesc,flipV)=>{const positionDesc=sourceDesc[SEMANTIC_POSITION];if(!positionDesc){return null}const numVertices=positionDesc.count;const vertexDesc=[];for(const semantic in sourceDesc){if(sourceDesc.hasOwnProperty(semantic)){const element={semantic:semantic,components:sourceDesc[semantic].components,type:sourceDesc[semantic].type,normalize:!!sourceDesc[semantic].normalize};if(!VertexFormat.isElementValid(device,element)){element.components++;}vertexDesc.push(element);}}vertexDesc.sort((lhs,rhs)=>{return attributeOrder[lhs.semantic]-attributeOrder[rhs.semantic]});let i,j,k;let source,target,sourceOffset;const vertexFormat=new VertexFormat(device,vertexDesc);let isCorrectlyInterleaved=true;for(i=0;i<vertexFormat.elements.length;++i){target=vertexFormat.elements[i];source=sourceDesc[target.name];sourceOffset=source.offset-positionDesc.offset;if(source.buffer!==positionDesc.buffer||source.stride!==target.stride||source.size!==target.size||sourceOffset!==target.offset){isCorrectlyInterleaved=false;break}}const vertexBuffer=new VertexBuffer(device,vertexFormat,numVertices);const vertexData=vertexBuffer.lock();const targetArray=new Uint32Array(vertexData);let sourceArray;if(isCorrectlyInterleaved){sourceArray=new Uint32Array(positionDesc.buffer,positionDesc.offset,numVertices*vertexBuffer.format.size/4);targetArray.set(sourceArray);}else {let targetStride,sourceStride;for(i=0;i<vertexBuffer.format.elements.length;++i){target=vertexBuffer.format.elements[i];targetStride=target.stride/4;source=sourceDesc[target.name];sourceStride=source.stride/4;sourceArray=new Uint32Array(source.buffer,source.offset,(source.count-1)*sourceStride+(source.size+3)/4);let src=0;let dst=target.offset/4;const kend=Math.floor((source.size+3)/4);for(j=0;j<numVertices;++j){for(k=0;k<kend;++k){targetArray[dst+k]=sourceArray[src+k];}src+=sourceStride;dst+=targetStride;}}}if(flipV){flipTexCoordVs(vertexBuffer);}vertexBuffer.unlock();return vertexBuffer};const createVertexBuffer=(device,attributes,indices,accessors,bufferViews,flipV,vertexBufferDict)=>{const useAttributes={};const attribIds=[];for(const attrib in attributes){if(attributes.hasOwnProperty(attrib)&&gltfToEngineSemanticMap.hasOwnProperty(attrib)){useAttributes[attrib]=attributes[attrib];attribIds.push(`${attrib}:${attributes[attrib]}`);}}attribIds.sort();const vbKey=attribIds.join();let vb=vertexBufferDict[vbKey];if(!vb){const sourceDesc={};for(const attrib in useAttributes){const accessor=accessors[attributes[attrib]];const accessorData=getAccessorData(accessor,bufferViews);const bufferView=bufferViews[accessor.bufferView];const semantic=gltfToEngineSemanticMap[attrib];const size=getNumComponents(accessor.type)*getComponentSizeInBytes(accessor.componentType);const stride=bufferView&&bufferView.hasOwnProperty("byteStride")?bufferView.byteStride:size;sourceDesc[semantic]={buffer:accessorData.buffer,size:size,offset:accessorData.byteOffset,stride:stride,count:accessor.count,components:getNumComponents(accessor.type),type:getComponentType$1(accessor.componentType),normalize:accessor.normalized};}if(!sourceDesc.hasOwnProperty(SEMANTIC_NORMAL)){generateNormals(sourceDesc,indices);}vb=createVertexBufferInternal(device,sourceDesc,flipV);vertexBufferDict[vbKey]=vb;}return vb};const createSkin=(device,gltfSkin,accessors,bufferViews,nodes,glbSkins)=>{let i,j,bindMatrix;const joints=gltfSkin.joints;const numJoints=joints.length;const ibp=[];if(gltfSkin.hasOwnProperty("inverseBindMatrices")){const inverseBindMatrices=gltfSkin.inverseBindMatrices;const ibmData=getAccessorData(accessors[inverseBindMatrices],bufferViews,true);const ibmValues=[];for(i=0;i<numJoints;i++){for(j=0;j<16;j++){ibmValues[j]=ibmData[i*16+j];}bindMatrix=new Mat4;bindMatrix.set(ibmValues);ibp.push(bindMatrix);}}else {for(i=0;i<numJoints;i++){bindMatrix=new Mat4;ibp.push(bindMatrix);}}const boneNames=[];for(i=0;i<numJoints;i++){boneNames[i]=nodes[joints[i]].name;}const key=boneNames.join("#");let skin=glbSkins.get(key);if(!skin){skin=new Skin(device,ibp,boneNames);glbSkins.set(key,skin);}return skin};const createDracoMesh=(device,primitive,accessors,bufferViews,meshVariants,meshDefaultMaterials,promises)=>{var _primitive$extensions;const result=new Mesh(device);result.aabb=getAccessorBoundingBox(accessors[primitive.attributes.POSITION]);const vertexDesc=[];for(const[name,index]of Object.entries(primitive.attributes)){var _accessor$normalized;const accessor=accessors[index];const semantic=gltfToEngineSemanticMap[name];const componentType=getComponentType$1(accessor.componentType);vertexDesc.push({semantic:semantic,components:getNumComponents(accessor.type),type:componentType,normalize:(_accessor$normalized=accessor.normalized)!=null?_accessor$normalized:semantic===SEMANTIC_COLOR&&(componentType===TYPE_UINT8||componentType===TYPE_UINT16)});}promises.push(new Promise((resolve,reject)=>{const dracoExt=primitive.extensions.KHR_draco_mesh_compression;dracoDecode(bufferViews[dracoExt.bufferView].slice().buffer,(err,decompressedData)=>{if(err){console.log(err);reject(err);}else {var _primitive$attributes;const order={};for(const[name,index]of Object.entries(dracoExt.attributes)){order[gltfToEngineSemanticMap[name]]=decompressedData.attributes.indexOf(index);}vertexDesc.sort((a,b)=>{return order[a.semantic]-order[b.semantic]});if(!((_primitive$attributes=primitive.attributes)!=null&&_primitive$attributes.NORMAL)){vertexDesc.splice(1,0,{semantic:"NORMAL",components:3,type:TYPE_FLOAT32});}const vertexFormat=new VertexFormat(device,vertexDesc);const numVertices=decompressedData.vertices.byteLength/vertexFormat.size;const indexFormat=numVertices<=65535?INDEXFORMAT_UINT16:INDEXFORMAT_UINT32;const numIndices=decompressedData.indices.byteLength/(numVertices<=65535?2:4);const vertexBuffer=new VertexBuffer(device,vertexFormat,numVertices,{data:decompressedData.vertices});const indexBuffer=new IndexBuffer(device,indexFormat,numIndices,BUFFER_STATIC,decompressedData.indices);result.vertexBuffer=vertexBuffer;result.indexBuffer[0]=indexBuffer;result.primitive[0].type=getPrimitiveType(primitive);result.primitive[0].base=0;result.primitive[0].count=indexBuffer?numIndices:numVertices;result.primitive[0].indexed=!!indexBuffer;resolve();}});}));if(primitive!=null&&(_primitive$extensions=primitive.extensions)!=null&&_primitive$extensions.KHR_materials_variants){const variants=primitive.extensions.KHR_materials_variants;const tempMapping={};variants.mappings.forEach(mapping=>{mapping.variants.forEach(variant=>{tempMapping[variant]=mapping.material;});});meshVariants[result.id]=tempMapping;}meshDefaultMaterials[result.id]=primitive.material;return result};const createMesh$1=(device,gltfMesh,accessors,bufferViews,flipV,vertexBufferDict,meshVariants,meshDefaultMaterials,assetOptions,promises)=>{const meshes=[];gltfMesh.primitives.forEach(primitive=>{var _primitive$extensions2;if((_primitive$extensions2=primitive.extensions)!=null&&_primitive$extensions2.KHR_draco_mesh_compression){meshes.push(createDracoMesh(device,primitive,accessors,bufferViews,meshVariants,meshDefaultMaterials,promises));}else {let indices=primitive.hasOwnProperty("indices")?getAccessorData(accessors[primitive.indices],bufferViews,true):null;const vertexBuffer=createVertexBuffer(device,primitive.attributes,indices,accessors,bufferViews,flipV,vertexBufferDict);const primitiveType=getPrimitiveType(primitive);const mesh=new Mesh(device);mesh.vertexBuffer=vertexBuffer;mesh.primitive[0].type=primitiveType;mesh.primitive[0].base=0;mesh.primitive[0].indexed=indices!==null;if(indices!==null){let indexFormat;if(indices instanceof Uint8Array){indexFormat=INDEXFORMAT_UINT8;}else if(indices instanceof Uint16Array){indexFormat=INDEXFORMAT_UINT16;}else {indexFormat=INDEXFORMAT_UINT32;}if(indexFormat===INDEXFORMAT_UINT32&&!device.extUintElement){indexFormat=INDEXFORMAT_UINT16;indices=new Uint16Array(indices);}if(indexFormat===INDEXFORMAT_UINT8&&device.isWebGPU){indexFormat=INDEXFORMAT_UINT16;indices=new Uint16Array(indices);}const indexBuffer=new IndexBuffer(device,indexFormat,indices.length,BUFFER_STATIC,indices);mesh.indexBuffer[0]=indexBuffer;mesh.primitive[0].count=indices.length;}else {mesh.primitive[0].count=vertexBuffer.numVertices;}if(primitive.hasOwnProperty("extensions")&&primitive.extensions.hasOwnProperty("KHR_materials_variants")){const variants=primitive.extensions.KHR_materials_variants;const tempMapping={};variants.mappings.forEach(mapping=>{mapping.variants.forEach(variant=>{tempMapping[variant]=mapping.material;});});meshVariants[mesh.id]=tempMapping;}meshDefaultMaterials[mesh.id]=primitive.material;let accessor=accessors[primitive.attributes.POSITION];mesh.aabb=getAccessorBoundingBox(accessor);if(primitive.hasOwnProperty("targets")){const targets=[];primitive.targets.forEach((target,index)=>{const options={};if(target.hasOwnProperty("POSITION")){accessor=accessors[target.POSITION];options.deltaPositions=getAccessorDataFloat32(accessor,bufferViews);options.deltaPositionsType=TYPE_FLOAT32;options.aabb=getAccessorBoundingBox(accessor);}if(target.hasOwnProperty("NORMAL")){accessor=accessors[target.NORMAL];options.deltaNormals=getAccessorDataFloat32(accessor,bufferViews);options.deltaNormalsType=TYPE_FLOAT32;}if(gltfMesh.hasOwnProperty("extras")&&gltfMesh.extras.hasOwnProperty("targetNames")){options.name=gltfMesh.extras.targetNames[index];}else {options.name=index.toString(10);}if(gltfMesh.hasOwnProperty("weights")){options.defaultWeight=gltfMesh.weights[index];}options.preserveData=assetOptions.morphPreserveData;targets.push(new MorphTarget(options));});mesh.morph=new Morph(targets,device,{preferHighPrecision:assetOptions.morphPreferHighPrecision});}meshes.push(mesh);}});return meshes};const extractTextureTransform=(source,material,maps)=>{var _source$extensions;let map;const texCoord=source.texCoord;if(texCoord){for(map=0;map<maps.length;++map){material[`${maps[map]}MapUv`]=texCoord;}}const zeros=[0,0];const ones=[1,1];const textureTransform=(_source$extensions=source.extensions)==null?void 0:_source$extensions.KHR_texture_transform;if(textureTransform){const offset=textureTransform.offset||zeros;const scale=textureTransform.scale||ones;const rotation=textureTransform.rotation?-textureTransform.rotation*math.RAD_TO_DEG:0;const tilingVec=new Vec2(scale[0],scale[1]);const offsetVec=new Vec2(offset[0],1-scale[1]-offset[1]);for(map=0;map<maps.length;++map){material[`${maps[map]}MapTiling`]=tilingVec;material[`${maps[map]}MapOffset`]=offsetVec;material[`${maps[map]}MapRotation`]=rotation;}}};const extensionPbrSpecGlossiness=(data,material,textures)=>{let color,texture;if(data.hasOwnProperty("diffuseFactor")){color=data.diffuseFactor;material.diffuse.set(Math.pow(color[0],1/2.2),Math.pow(color[1],1/2.2),Math.pow(color[2],1/2.2));material.opacity=color[3];}else {material.diffuse.set(1,1,1);material.opacity=1;}if(data.hasOwnProperty("diffuseTexture")){const diffuseTexture=data.diffuseTexture;texture=textures[diffuseTexture.index];material.diffuseMap=texture;material.diffuseMapChannel="rgb";material.opacityMap=texture;material.opacityMapChannel="a";extractTextureTransform(diffuseTexture,material,["diffuse","opacity"]);}material.useMetalness=false;if(data.hasOwnProperty("specularFactor")){color=data.specularFactor;material.specular.set(Math.pow(color[0],1/2.2),Math.pow(color[1],1/2.2),Math.pow(color[2],1/2.2));}else {material.specular.set(1,1,1);}if(data.hasOwnProperty("glossinessFactor")){material.gloss=data.glossinessFactor;}else {material.gloss=1;}if(data.hasOwnProperty("specularGlossinessTexture")){const specularGlossinessTexture=data.specularGlossinessTexture;material.specularEncoding="srgb";material.specularMap=material.glossMap=textures[specularGlossinessTexture.index];material.specularMapChannel="rgb";material.glossMapChannel="a";extractTextureTransform(specularGlossinessTexture,material,["gloss","metalness"]);}};const extensionClearCoat=(data,material,textures)=>{if(data.hasOwnProperty("clearcoatFactor")){material.clearCoat=data.clearcoatFactor*.25;}else {material.clearCoat=0;}if(data.hasOwnProperty("clearcoatTexture")){const clearcoatTexture=data.clearcoatTexture;material.clearCoatMap=textures[clearcoatTexture.index];material.clearCoatMapChannel="r";extractTextureTransform(clearcoatTexture,material,["clearCoat"]);}if(data.hasOwnProperty("clearcoatRoughnessFactor")){material.clearCoatGloss=data.clearcoatRoughnessFactor;}else {material.clearCoatGloss=0;}if(data.hasOwnProperty("clearcoatRoughnessTexture")){const clearcoatRoughnessTexture=data.clearcoatRoughnessTexture;material.clearCoatGlossMap=textures[clearcoatRoughnessTexture.index];material.clearCoatGlossMapChannel="g";extractTextureTransform(clearcoatRoughnessTexture,material,["clearCoatGloss"]);}if(data.hasOwnProperty("clearcoatNormalTexture")){const clearcoatNormalTexture=data.clearcoatNormalTexture;material.clearCoatNormalMap=textures[clearcoatNormalTexture.index];extractTextureTransform(clearcoatNormalTexture,material,["clearCoatNormal"]);if(clearcoatNormalTexture.hasOwnProperty("scale")){material.clearCoatBumpiness=clearcoatNormalTexture.scale;}}material.clearCoatGlossInvert=true;};const extensionUnlit=(data,material,textures)=>{material.useLighting=false;material.emissive.copy(material.diffuse);material.emissiveTint=material.diffuseTint;material.emissiveMap=material.diffuseMap;material.emissiveMapUv=material.diffuseMapUv;material.emissiveMapTiling.copy(material.diffuseMapTiling);material.emissiveMapOffset.copy(material.diffuseMapOffset);material.emissiveMapRotation=material.diffuseMapRotation;material.emissiveMapChannel=material.diffuseMapChannel;material.emissiveVertexColor=material.diffuseVertexColor;material.emissiveVertexColorChannel=material.diffuseVertexColorChannel;material.useLighting=false;material.useSkybox=false;material.diffuse.set(0,0,0);material.diffuseTint=false;material.diffuseMap=null;material.diffuseVertexColor=false;};const extensionSpecular=(data,material,textures)=>{material.useMetalnessSpecularColor=true;if(data.hasOwnProperty("specularColorTexture")){material.specularEncoding="srgb";material.specularMap=textures[data.specularColorTexture.index];material.specularMapChannel="rgb";extractTextureTransform(data.specularColorTexture,material,["specular"]);}if(data.hasOwnProperty("specularColorFactor")){const color=data.specularColorFactor;material.specular.set(Math.pow(color[0],1/2.2),Math.pow(color[1],1/2.2),Math.pow(color[2],1/2.2));}else {material.specular.set(1,1,1);}if(data.hasOwnProperty("specularFactor")){material.specularityFactor=data.specularFactor;}else {material.specularityFactor=1;}if(data.hasOwnProperty("specularTexture")){material.specularityFactorMapChannel="a";material.specularityFactorMap=textures[data.specularTexture.index];extractTextureTransform(data.specularTexture,material,["specularityFactor"]);}};const extensionIor=(data,material,textures)=>{if(data.hasOwnProperty("ior")){material.refractionIndex=1/data.ior;}};const extensionDispersion=(data,material,textures)=>{if(data.hasOwnProperty("dispersion")){material.dispersion=data.dispersion;}};const extensionTransmission=(data,material,textures)=>{material.blendType=BLEND_NORMAL;material.useDynamicRefraction=true;if(data.hasOwnProperty("transmissionFactor")){material.refraction=data.transmissionFactor;}if(data.hasOwnProperty("transmissionTexture")){material.refractionMapChannel="r";material.refractionMap=textures[data.transmissionTexture.index];extractTextureTransform(data.transmissionTexture,material,["refraction"]);}};const extensionSheen=(data,material,textures)=>{material.useSheen=true;if(data.hasOwnProperty("sheenColorFactor")){const color=data.sheenColorFactor;material.sheen.set(Math.pow(color[0],1/2.2),Math.pow(color[1],1/2.2),Math.pow(color[2],1/2.2));}else {material.sheen.set(1,1,1);}if(data.hasOwnProperty("sheenColorTexture")){material.sheenMap=textures[data.sheenColorTexture.index];material.sheenEncoding="srgb";extractTextureTransform(data.sheenColorTexture,material,["sheen"]);}if(data.hasOwnProperty("sheenRoughnessFactor")){material.sheenGloss=data.sheenRoughnessFactor;}else {material.sheenGloss=0;}if(data.hasOwnProperty("sheenRoughnessTexture")){material.sheenGlossMap=textures[data.sheenRoughnessTexture.index];material.sheenGlossMapChannel="a";extractTextureTransform(data.sheenRoughnessTexture,material,["sheenGloss"]);}material.sheenGlossInvert=true;};const extensionVolume=(data,material,textures)=>{material.blendType=BLEND_NORMAL;material.useDynamicRefraction=true;if(data.hasOwnProperty("thicknessFactor")){material.thickness=data.thicknessFactor;}if(data.hasOwnProperty("thicknessTexture")){material.thicknessMap=textures[data.thicknessTexture.index];material.thicknessMapChannel="g";extractTextureTransform(data.thicknessTexture,material,["thickness"]);}if(data.hasOwnProperty("attenuationDistance")){material.attenuationDistance=data.attenuationDistance;}if(data.hasOwnProperty("attenuationColor")){const color=data.attenuationColor;material.attenuation.set(Math.pow(color[0],1/2.2),Math.pow(color[1],1/2.2),Math.pow(color[2],1/2.2));}};const extensionEmissiveStrength=(data,material,textures)=>{if(data.hasOwnProperty("emissiveStrength")){material.emissiveIntensity=data.emissiveStrength;}};const extensionIridescence=(data,material,textures)=>{material.useIridescence=true;if(data.hasOwnProperty("iridescenceFactor")){material.iridescence=data.iridescenceFactor;}if(data.hasOwnProperty("iridescenceTexture")){material.iridescenceMapChannel="r";material.iridescenceMap=textures[data.iridescenceTexture.index];extractTextureTransform(data.iridescenceTexture,material,["iridescence"]);}if(data.hasOwnProperty("iridescenceIor")){material.iridescenceRefractionIndex=data.iridescenceIor;}if(data.hasOwnProperty("iridescenceThicknessMinimum")){material.iridescenceThicknessMin=data.iridescenceThicknessMinimum;}if(data.hasOwnProperty("iridescenceThicknessMaximum")){material.iridescenceThicknessMax=data.iridescenceThicknessMaximum;}if(data.hasOwnProperty("iridescenceThicknessTexture")){material.iridescenceThicknessMapChannel="g";material.iridescenceThicknessMap=textures[data.iridescenceThicknessTexture.index];extractTextureTransform(data.iridescenceThicknessTexture,material,["iridescenceThickness"]);}};const createMaterial=(gltfMaterial,textures,flipV)=>{const material=new StandardMaterial;material.occludeSpecular=SPECOCC_AO;material.diffuseTint=true;material.diffuseVertexColor=true;material.specularTint=true;material.specularVertexColor=true;if(gltfMaterial.hasOwnProperty("name")){material.name=gltfMaterial.name;}let color,texture;if(gltfMaterial.hasOwnProperty("pbrMetallicRoughness")){const pbrData=gltfMaterial.pbrMetallicRoughness;if(pbrData.hasOwnProperty("baseColorFactor")){color=pbrData.baseColorFactor;material.diffuse.set(Math.pow(color[0],1/2.2),Math.pow(color[1],1/2.2),Math.pow(color[2],1/2.2));material.opacity=color[3];}else {material.diffuse.set(1,1,1);material.opacity=1;}if(pbrData.hasOwnProperty("baseColorTexture")){const baseColorTexture=pbrData.baseColorTexture;texture=textures[baseColorTexture.index];material.diffuseMap=texture;material.diffuseMapChannel="rgb";material.opacityMap=texture;material.opacityMapChannel="a";extractTextureTransform(baseColorTexture,material,["diffuse","opacity"]);}material.useMetalness=true;material.specular.set(1,1,1);if(pbrData.hasOwnProperty("metallicFactor")){material.metalness=pbrData.metallicFactor;}else {material.metalness=1;}if(pbrData.hasOwnProperty("roughnessFactor")){material.gloss=pbrData.roughnessFactor;}else {material.gloss=1;}material.glossInvert=true;if(pbrData.hasOwnProperty("metallicRoughnessTexture")){const metallicRoughnessTexture=pbrData.metallicRoughnessTexture;material.metalnessMap=material.glossMap=textures[metallicRoughnessTexture.index];material.metalnessMapChannel="b";material.glossMapChannel="g";extractTextureTransform(metallicRoughnessTexture,material,["gloss","metalness"]);}}if(gltfMaterial.hasOwnProperty("normalTexture")){const normalTexture=gltfMaterial.normalTexture;material.normalMap=textures[normalTexture.index];extractTextureTransform(normalTexture,material,["normal"]);if(normalTexture.hasOwnProperty("scale")){material.bumpiness=normalTexture.scale;}}if(gltfMaterial.hasOwnProperty("occlusionTexture")){const occlusionTexture=gltfMaterial.occlusionTexture;material.aoMap=textures[occlusionTexture.index];material.aoMapChannel="r";extractTextureTransform(occlusionTexture,material,["ao"]);}if(gltfMaterial.hasOwnProperty("emissiveFactor")){color=gltfMaterial.emissiveFactor;material.emissive.set(Math.pow(color[0],1/2.2),Math.pow(color[1],1/2.2),Math.pow(color[2],1/2.2));material.emissiveTint=true;}else {material.emissive.set(0,0,0);material.emissiveTint=false;}if(gltfMaterial.hasOwnProperty("emissiveTexture")){const emissiveTexture=gltfMaterial.emissiveTexture;material.emissiveMap=textures[emissiveTexture.index];extractTextureTransform(emissiveTexture,material,["emissive"]);}if(gltfMaterial.hasOwnProperty("alphaMode")){switch(gltfMaterial.alphaMode){case"MASK":material.blendType=BLEND_NONE;if(gltfMaterial.hasOwnProperty("alphaCutoff")){material.alphaTest=gltfMaterial.alphaCutoff;}else {material.alphaTest=.5;}break;case"BLEND":material.blendType=BLEND_NORMAL;material.depthWrite=false;break;default:case"OPAQUE":material.blendType=BLEND_NONE;break}}else {material.blendType=BLEND_NONE;}if(gltfMaterial.hasOwnProperty("doubleSided")){material.twoSidedLighting=gltfMaterial.doubleSided;material.cull=gltfMaterial.doubleSided?CULLFACE_NONE:CULLFACE_BACK;}else {material.twoSidedLighting=false;material.cull=CULLFACE_BACK;}const extensions={"KHR_materials_clearcoat":extensionClearCoat,"KHR_materials_emissive_strength":extensionEmissiveStrength,"KHR_materials_ior":extensionIor,"KHR_materials_dispersion":extensionDispersion,"KHR_materials_iridescence":extensionIridescence,"KHR_materials_pbrSpecularGlossiness":extensionPbrSpecGlossiness,"KHR_materials_sheen":extensionSheen,"KHR_materials_specular":extensionSpecular,"KHR_materials_transmission":extensionTransmission,"KHR_materials_unlit":extensionUnlit,"KHR_materials_volume":extensionVolume};if(gltfMaterial.hasOwnProperty("extensions")){for(const key in gltfMaterial.extensions){const extensionFunc=extensions[key];if(extensionFunc!==undefined){extensionFunc(gltfMaterial.extensions[key],material,textures);}}}material.update();return material};const createAnimation=(gltfAnimation,animationIndex,gltfAccessors,bufferViews,nodes,meshes,gltfNodes)=>{const createAnimData=gltfAccessor=>{return new AnimData(getNumComponents(gltfAccessor.type),getAccessorDataFloat32(gltfAccessor,bufferViews))};const interpMap={"STEP":INTERPOLATION_STEP,"LINEAR":INTERPOLATION_LINEAR,"CUBICSPLINE":INTERPOLATION_CUBIC};const inputMap={};const outputMap={};const curveMap={};let outputCounter=1;let i;for(i=0;i<gltfAnimation.samplers.length;++i){const sampler=gltfAnimation.samplers[i];if(!inputMap.hasOwnProperty(sampler.input)){inputMap[sampler.input]=createAnimData(gltfAccessors[sampler.input]);}if(!outputMap.hasOwnProperty(sampler.output)){outputMap[sampler.output]=createAnimData(gltfAccessors[sampler.output]);}const interpolation=sampler.hasOwnProperty("interpolation")&&interpMap.hasOwnProperty(sampler.interpolation)?interpMap[sampler.interpolation]:INTERPOLATION_LINEAR;const curve={paths:[],input:sampler.input,output:sampler.output,interpolation:interpolation};curveMap[i]=curve;}const quatArrays=[];const transformSchema={"translation":"localPosition","rotation":"localRotation","scale":"localScale"};const constructNodePath=node=>{const path=[];while(node){path.unshift(node.name);node=node.parent;}return path};const createMorphTargetCurves=(curve,gltfNode,entityPath)=>{const out=outputMap[curve.output];if(!out){return}let targetNames;if(meshes&&meshes[gltfNode.mesh]){const mesh=meshes[gltfNode.mesh];if(mesh.hasOwnProperty("extras")&&mesh.extras.hasOwnProperty("targetNames")){targetNames=mesh.extras.targetNames;}}const outData=out.data;const morphTargetCount=outData.length/inputMap[curve.input].data.length;const keyframeCount=outData.length/morphTargetCount;const singleBufferSize=keyframeCount*4;const buffer=new ArrayBuffer(singleBufferSize*morphTargetCount);for(let j=0;j<morphTargetCount;j++){var _targetNames;const morphTargetOutput=new Float32Array(buffer,singleBufferSize*j,keyframeCount);for(let k=0;k<keyframeCount;k++){morphTargetOutput[k]=outData[k*morphTargetCount+j];}const output=new AnimData(1,morphTargetOutput);const weightName=(_targetNames=targetNames)!=null&&_targetNames[j]?`name.${targetNames[j]}`:j;outputMap[-outputCounter]=output;const morphCurve={paths:[{entityPath:entityPath,component:"graph",propertyPath:[`weight.${weightName}`]}],input:curve.input,output:-outputCounter,interpolation:curve.interpolation};outputCounter++;curveMap[`morphCurve-${i}-${j}`]=morphCurve;}};for(i=0;i<gltfAnimation.channels.length;++i){const channel=gltfAnimation.channels[i];const target=channel.target;const curve=curveMap[channel.sampler];const node=nodes[target.node];const gltfNode=gltfNodes[target.node];const entityPath=constructNodePath(node);if(target.path.startsWith("weights")){createMorphTargetCurves(curve,gltfNode,entityPath);curveMap[channel.sampler].morphCurve=true;}else {curve.paths.push({entityPath:entityPath,component:"graph",propertyPath:[transformSchema[target.path]]});}}const inputs=[];const outputs=[];const curves=[];for(const inputKey in inputMap){inputs.push(inputMap[inputKey]);inputMap[inputKey]=inputs.length-1;}for(const outputKey in outputMap){outputs.push(outputMap[outputKey]);outputMap[outputKey]=outputs.length-1;}for(const curveKey in curveMap){const curveData=curveMap[curveKey];if(curveData.morphCurve){continue}curves.push(new AnimCurve(curveData.paths,inputMap[curveData.input],outputMap[curveData.output],curveData.interpolation));if(curveData.paths.length>0&&curveData.paths[0].propertyPath[0]==="localRotation"&&curveData.interpolation!==INTERPOLATION_CUBIC){quatArrays.push(curves[curves.length-1].output);}}quatArrays.sort();let prevIndex=null;let data;for(i=0;i<quatArrays.length;++i){const index=quatArrays[i];if(i===0||index!==prevIndex){data=outputs[index];if(data.components===4){const d=data.data;const len=d.length-4;for(let j=0;j<len;j+=4){const dp=d[j+0]*d[j+4]+d[j+1]*d[j+5]+d[j+2]*d[j+6]+d[j+3]*d[j+7];if(dp<0){d[j+4]*=-1;d[j+5]*=-1;d[j+6]*=-1;d[j+7]*=-1;}}}prevIndex=index;}}let duration=0;for(i=0;i<inputs.length;i++){data=inputs[i]._data;duration=Math.max(duration,data.length===0?0:data[data.length-1]);}return new AnimTrack(gltfAnimation.hasOwnProperty("name")?gltfAnimation.name:`animation_${animationIndex}`,duration,inputs,outputs,curves)};const tempMat=new Mat4;const tempVec=new Vec3;const createNode=(gltfNode,nodeIndex)=>{const entity=new GraphNode;if(gltfNode.hasOwnProperty("name")&&gltfNode.name.length>0){entity.name=gltfNode.name;}else {entity.name=`node_${nodeIndex}`;}if(gltfNode.hasOwnProperty("matrix")){tempMat.data.set(gltfNode.matrix);tempMat.getTranslation(tempVec);entity.setLocalPosition(tempVec);tempMat.getEulerAngles(tempVec);entity.setLocalEulerAngles(tempVec);tempMat.getScale(tempVec);entity.setLocalScale(tempVec);}if(gltfNode.hasOwnProperty("rotation")){const r=gltfNode.rotation;entity.setLocalRotation(r[0],r[1],r[2],r[3]);}if(gltfNode.hasOwnProperty("translation")){const t=gltfNode.translation;entity.setLocalPosition(t[0],t[1],t[2]);}if(gltfNode.hasOwnProperty("scale")){const s=gltfNode.scale;entity.setLocalScale(s[0],s[1],s[2]);}return entity};const createCamera=(gltfCamera,node)=>{const projection=gltfCamera.type==="orthographic"?PROJECTION_ORTHOGRAPHIC:PROJECTION_PERSPECTIVE;const gltfProperties=projection===PROJECTION_ORTHOGRAPHIC?gltfCamera.orthographic:gltfCamera.perspective;const componentData={enabled:false,projection:projection,nearClip:gltfProperties.znear,aspectRatioMode:ASPECT_AUTO};if(gltfProperties.zfar){componentData.farClip=gltfProperties.zfar;}if(projection===PROJECTION_ORTHOGRAPHIC){componentData.orthoHeight=.5*gltfProperties.ymag;if(gltfProperties.ymag){componentData.aspectRatioMode=ASPECT_MANUAL;componentData.aspectRatio=gltfProperties.xmag/gltfProperties.ymag;}}else {componentData.fov=gltfProperties.yfov*math.RAD_TO_DEG;if(gltfProperties.aspectRatio){componentData.aspectRatioMode=ASPECT_MANUAL;componentData.aspectRatio=gltfProperties.aspectRatio;}}const cameraEntity=new Entity(gltfCamera.name);cameraEntity.addComponent("camera",componentData);return cameraEntity};const createLight=(gltfLight,node)=>{const lightProps={enabled:false,type:gltfLight.type==="point"?"omni":gltfLight.type,color:gltfLight.hasOwnProperty("color")?new Color(gltfLight.color):Color.WHITE,range:gltfLight.hasOwnProperty("range")?gltfLight.range:9999,falloffMode:LIGHTFALLOFF_INVERSESQUARED,intensity:gltfLight.hasOwnProperty("intensity")?math.clamp(gltfLight.intensity,0,2):1};if(gltfLight.hasOwnProperty("spot")){lightProps.innerConeAngle=gltfLight.spot.hasOwnProperty("innerConeAngle")?gltfLight.spot.innerConeAngle*math.RAD_TO_DEG:0;lightProps.outerConeAngle=gltfLight.spot.hasOwnProperty("outerConeAngle")?gltfLight.spot.outerConeAngle*math.RAD_TO_DEG:Math.PI/4;}if(gltfLight.hasOwnProperty("intensity")){lightProps.luminance=gltfLight.intensity*Light.getLightUnitConversion(lightTypes[lightProps.type],lightProps.outerConeAngle,lightProps.innerConeAngle);}const lightEntity=new Entity(node.name);lightEntity.rotateLocal(90,0,0);lightEntity.addComponent("light",lightProps);return lightEntity};const createSkins=(device,gltf,nodes,bufferViews)=>{if(!gltf.hasOwnProperty("skins")||gltf.skins.length===0){return []}const glbSkins=new Map;return gltf.skins.map(gltfSkin=>{return createSkin(device,gltfSkin,gltf.accessors,bufferViews,nodes,glbSkins)})};const createMeshes=(device,gltf,bufferViews,flipV,options)=>{var _gltf$meshes,_gltf$accessors,_gltf$bufferViews;const vertexBufferDict={};const meshVariants={};const meshDefaultMaterials={};const promises=[];const valid=!options.skipMeshes&&(gltf==null||(_gltf$meshes=gltf.meshes)==null?void 0:_gltf$meshes.length)&&(gltf==null||(_gltf$accessors=gltf.accessors)==null?void 0:_gltf$accessors.length)&&(gltf==null||(_gltf$bufferViews=gltf.bufferViews)==null?void 0:_gltf$bufferViews.length);const meshes=valid?gltf.meshes.map(gltfMesh=>{return createMesh$1(device,gltfMesh,gltf.accessors,bufferViews,flipV,vertexBufferDict,meshVariants,meshDefaultMaterials,options,promises)}):[];return {meshes,meshVariants,meshDefaultMaterials,promises}};const createMaterials=(gltf,textures,options,flipV)=>{var _options$material,_options$material$pro,_options$material2,_options$material3;if(!gltf.hasOwnProperty("materials")||gltf.materials.length===0){return []}const preprocess=options==null||(_options$material=options.material)==null?void 0:_options$material.preprocess;const process=(_options$material$pro=options==null||(_options$material2=options.material)==null?void 0:_options$material2.process)!=null?_options$material$pro:createMaterial;const postprocess=options==null||(_options$material3=options.material)==null?void 0:_options$material3.postprocess;return gltf.materials.map(gltfMaterial=>{if(preprocess){preprocess(gltfMaterial);}const material=process(gltfMaterial,textures,flipV);if(postprocess){postprocess(gltfMaterial,material);}return material})};const createVariants=gltf=>{if(!gltf.hasOwnProperty("extensions")||!gltf.extensions.hasOwnProperty("KHR_materials_variants")){return null}const data=gltf.extensions.KHR_materials_variants.variants;const variants={};for(let i=0;i<data.length;i++){variants[data[i].name]=i;}return variants};const createAnimations=(gltf,nodes,bufferViews,options)=>{var _options$animation,_options$animation2;if(!gltf.hasOwnProperty("animations")||gltf.animations.length===0){return []}const preprocess=options==null||(_options$animation=options.animation)==null?void 0:_options$animation.preprocess;const postprocess=options==null||(_options$animation2=options.animation)==null?void 0:_options$animation2.postprocess;return gltf.animations.map((gltfAnimation,index)=>{if(preprocess){preprocess(gltfAnimation);}const animation=createAnimation(gltfAnimation,index,gltf.accessors,bufferViews,nodes,gltf.meshes,gltf.nodes);if(postprocess){postprocess(gltfAnimation,animation);}return animation})};const createNodes=(gltf,options)=>{var _options$node,_options$node$process,_options$node2,_options$node3;if(!gltf.hasOwnProperty("nodes")||gltf.nodes.length===0){return []}const preprocess=options==null||(_options$node=options.node)==null?void 0:_options$node.preprocess;const process=(_options$node$process=options==null||(_options$node2=options.node)==null?void 0:_options$node2.process)!=null?_options$node$process:createNode;const postprocess=options==null||(_options$node3=options.node)==null?void 0:_options$node3.postprocess;const nodes=gltf.nodes.map((gltfNode,index)=>{if(preprocess){preprocess(gltfNode);}const node=process(gltfNode,index);if(postprocess){postprocess(gltfNode,node);}return node});for(let i=0;i<gltf.nodes.length;++i){const gltfNode=gltf.nodes[i];if(gltfNode.hasOwnProperty("children")){const parent=nodes[i];const uniqueNames={};for(let j=0;j<gltfNode.children.length;++j){const child=nodes[gltfNode.children[j]];if(!child.parent){if(uniqueNames.hasOwnProperty(child.name)){child.name+=uniqueNames[child.name]++;}else {uniqueNames[child.name]=1;}parent.addChild(child);}}}}return nodes};const createScenes=(gltf,nodes)=>{var _gltf$scenes$0$nodes;const scenes=[];const count=gltf.scenes.length;if(count===1&&((_gltf$scenes$0$nodes=gltf.scenes[0].nodes)==null?void 0:_gltf$scenes$0$nodes.length)===1){const nodeIndex=gltf.scenes[0].nodes[0];scenes.push(nodes[nodeIndex]);}else {for(let i=0;i<count;i++){const scene=gltf.scenes[i];if(scene.nodes){const sceneRoot=new GraphNode(scene.name);for(let n=0;n<scene.nodes.length;n++){const childNode=nodes[scene.nodes[n]];sceneRoot.addChild(childNode);}scenes.push(sceneRoot);}}}return scenes};const createCameras=(gltf,nodes,options)=>{let cameras=null;if(gltf.hasOwnProperty("nodes")&&gltf.hasOwnProperty("cameras")&&gltf.cameras.length>0){var _options$camera,_options$camera$proce,_options$camera2,_options$camera3;const preprocess=options==null||(_options$camera=options.camera)==null?void 0:_options$camera.preprocess;const process=(_options$camera$proce=options==null||(_options$camera2=options.camera)==null?void 0:_options$camera2.process)!=null?_options$camera$proce:createCamera;const postprocess=options==null||(_options$camera3=options.camera)==null?void 0:_options$camera3.postprocess;gltf.nodes.forEach((gltfNode,nodeIndex)=>{if(gltfNode.hasOwnProperty("camera")){const gltfCamera=gltf.cameras[gltfNode.camera];if(gltfCamera){if(preprocess){preprocess(gltfCamera);}const camera=process(gltfCamera,nodes[nodeIndex]);if(postprocess){postprocess(gltfCamera,camera);}if(camera){if(!cameras)cameras=new Map;cameras.set(gltfNode,camera);}}}});}return cameras};const createLights=(gltf,nodes,options)=>{let lights=null;if(gltf.hasOwnProperty("nodes")&&gltf.hasOwnProperty("extensions")&&gltf.extensions.hasOwnProperty("KHR_lights_punctual")&&gltf.extensions.KHR_lights_punctual.hasOwnProperty("lights")){const gltfLights=gltf.extensions.KHR_lights_punctual.lights;if(gltfLights.length){var _options$light,_options$light$proces,_options$light2,_options$light3;const preprocess=options==null||(_options$light=options.light)==null?void 0:_options$light.preprocess;const process=(_options$light$proces=options==null||(_options$light2=options.light)==null?void 0:_options$light2.process)!=null?_options$light$proces:createLight;const postprocess=options==null||(_options$light3=options.light)==null?void 0:_options$light3.postprocess;gltf.nodes.forEach((gltfNode,nodeIndex)=>{if(gltfNode.hasOwnProperty("extensions")&&gltfNode.extensions.hasOwnProperty("KHR_lights_punctual")&&gltfNode.extensions.KHR_lights_punctual.hasOwnProperty("light")){const lightIndex=gltfNode.extensions.KHR_lights_punctual.light;const gltfLight=gltfLights[lightIndex];if(gltfLight){if(preprocess){preprocess(gltfLight);}const light=process(gltfLight,nodes[nodeIndex]);if(postprocess){postprocess(gltfLight,light);}if(light){if(!lights)lights=new Map;lights.set(gltfNode,light);}}}});}}return lights};const linkSkins=(gltf,renders,skins)=>{gltf.nodes.forEach(gltfNode=>{if(gltfNode.hasOwnProperty("mesh")&&gltfNode.hasOwnProperty("skin")){const meshGroup=renders[gltfNode.mesh].meshes;meshGroup.forEach(mesh=>{mesh.skin=skins[gltfNode.skin];});}});};const createResources=async(device,gltf,bufferViews,textures,options)=>{var _options$global,_options$global2;const preprocess=options==null||(_options$global=options.global)==null?void 0:_options$global.preprocess;const postprocess=options==null||(_options$global2=options.global)==null?void 0:_options$global2.postprocess;if(preprocess){preprocess(gltf);}const flipV=gltf.asset&&gltf.asset.generator==="PlayCanvas";const nodes=createNodes(gltf,options);const scenes=createScenes(gltf,nodes);const lights=createLights(gltf,nodes,options);const cameras=createCameras(gltf,nodes,options);const variants=createVariants(gltf);const bufferViewData=await Promise.all(bufferViews);const{meshes,meshVariants,meshDefaultMaterials,promises}=createMeshes(device,gltf,bufferViewData,flipV,options);const animations=createAnimations(gltf,nodes,bufferViewData,options);const textureAssets=await Promise.all(textures);const textureInstances=textureAssets.map(t=>t.resource);const materials=createMaterials(gltf,textureInstances,options,flipV);const skins=createSkins(device,gltf,nodes,bufferViewData);const renders=[];for(let i=0;i<meshes.length;i++){renders[i]=new Render;renders[i].meshes=meshes[i];}linkSkins(gltf,renders,skins);const result=new GlbResources;result.gltf=gltf;result.nodes=nodes;result.scenes=scenes;result.animations=animations;result.textures=textureAssets;result.materials=materials;result.variants=variants;result.meshVariants=meshVariants;result.meshDefaultMaterials=meshDefaultMaterials;result.renders=renders;result.skins=skins;result.lights=lights;result.cameras=cameras;if(postprocess){postprocess(gltf,result);}await Promise.all(promises);return result};const applySampler=(texture,gltfSampler)=>{const getFilter=(filter,defaultValue)=>{switch(filter){case 9728:return FILTER_NEAREST;case 9729:return FILTER_LINEAR;case 9984:return FILTER_NEAREST_MIPMAP_NEAREST;case 9985:return FILTER_LINEAR_MIPMAP_NEAREST;case 9986:return FILTER_NEAREST_MIPMAP_LINEAR;case 9987:return FILTER_LINEAR_MIPMAP_LINEAR;default:return defaultValue}};const getWrap=(wrap,defaultValue)=>{switch(wrap){case 33071:return ADDRESS_CLAMP_TO_EDGE;case 33648:return ADDRESS_MIRRORED_REPEAT;case 10497:return ADDRESS_REPEAT;default:return defaultValue}};if(texture){var _gltfSampler;gltfSampler=(_gltfSampler=gltfSampler)!=null?_gltfSampler:{};texture.minFilter=getFilter(gltfSampler.minFilter,FILTER_LINEAR_MIPMAP_LINEAR);texture.magFilter=getFilter(gltfSampler.magFilter,FILTER_LINEAR);texture.addressU=getWrap(gltfSampler.wrapS,ADDRESS_REPEAT);texture.addressV=getWrap(gltfSampler.wrapT,ADDRESS_REPEAT);}};let gltfTextureUniqueId=0;const createImages=(gltf,bufferViews,urlBase,registry,options)=>{var _options$image,_options$image2,_options$image3;if(!gltf.images||gltf.images.length===0){return []}const preprocess=options==null||(_options$image=options.image)==null?void 0:_options$image.preprocess;const processAsync=options==null||(_options$image2=options.image)==null?void 0:_options$image2.processAsync;const postprocess=options==null||(_options$image3=options.image)==null?void 0:_options$image3.postprocess;const mimeTypeFileExtensions={"image/png":"png","image/jpeg":"jpg","image/basis":"basis","image/ktx":"ktx","image/ktx2":"ktx2","image/vnd-ms.dds":"dds"};const loadTexture=(gltfImage,url,bufferView,mimeType,options)=>{return new Promise((resolve,reject)=>{const continuation=bufferViewData=>{const name=`${gltfImage.name||"gltf-texture"}-${gltfTextureUniqueId++}`;const file={url:url||name};if(bufferViewData){file.contents=bufferViewData.slice(0).buffer;}if(mimeType){const extension=mimeTypeFileExtensions[mimeType];if(extension){file.filename=`${file.url}.${extension}`;}}const asset=new Asset(name,"texture",file,null,options);asset.on("load",asset=>resolve(asset));asset.on("error",err=>reject(err));registry.add(asset);registry.load(asset);};if(bufferView){bufferView.then(bufferViewData=>continuation(bufferViewData));}else {continuation(null);}})};return gltf.images.map((gltfImage,i)=>{if(preprocess){preprocess(gltfImage);}let promise;if(processAsync){promise=new Promise((resolve,reject)=>{processAsync(gltfImage,(err,textureAsset)=>{if(err){reject(err);}else {resolve(textureAsset);}});});}else {promise=new Promise(resolve=>{resolve(null);});}promise=promise.then(textureAsset=>{if(textureAsset){return textureAsset}else if(gltfImage.hasOwnProperty("uri")){if(isDataURI(gltfImage.uri)){return loadTexture(gltfImage,gltfImage.uri,null,getDataURIMimeType(gltfImage.uri),null)}return loadTexture(gltfImage,ABSOLUTE_URL.test(gltfImage.uri)?gltfImage.uri:path.join(urlBase,gltfImage.uri),null,null,{crossOrigin:"anonymous"})}else if(gltfImage.hasOwnProperty("bufferView")&&gltfImage.hasOwnProperty("mimeType")){return loadTexture(gltfImage,null,bufferViews[gltfImage.bufferView],gltfImage.mimeType,null)}return Promise.reject(new Error(`Invalid image found in gltf (neither uri or bufferView found). index=${i}`))});if(postprocess){promise=promise.then(textureAsset=>{postprocess(gltfImage,textureAsset);return textureAsset});}return promise})};const createTextures=(gltf,images,options)=>{var _gltf$images,_gltf$textures,_options$texture,_options$texture2,_options$texture3;if(!(gltf!=null&&(_gltf$images=gltf.images)!=null&&_gltf$images.length)||!(gltf!=null&&(_gltf$textures=gltf.textures)!=null&&_gltf$textures.length)){return []}const preprocess=options==null||(_options$texture=options.texture)==null?void 0:_options$texture.preprocess;const processAsync=options==null||(_options$texture2=options.texture)==null?void 0:_options$texture2.processAsync;const postprocess=options==null||(_options$texture3=options.texture)==null?void 0:_options$texture3.postprocess;const seenImages=new Set;return gltf.textures.map(gltfTexture=>{if(preprocess){preprocess(gltfTexture);}let promise;if(processAsync){promise=new Promise((resolve,reject)=>{processAsync(gltfTexture,gltf.images,(err,gltfImageIndex)=>{if(err){reject(err);}else {resolve(gltfImageIndex);}});});}else {promise=new Promise(resolve=>{resolve(null);});}promise=promise.then(gltfImageIndex=>{var _ref,_ref2,_gltfImageIndex,_gltfTexture$extensio,_gltfTexture$extensio2;gltfImageIndex=(_ref=(_ref2=(_gltfImageIndex=gltfImageIndex)!=null?_gltfImageIndex:gltfTexture==null||(_gltfTexture$extensio=gltfTexture.extensions)==null||(_gltfTexture$extensio=_gltfTexture$extensio.KHR_texture_basisu)==null?void 0:_gltfTexture$extensio.source)!=null?_ref2:gltfTexture==null||(_gltfTexture$extensio2=gltfTexture.extensions)==null||(_gltfTexture$extensio2=_gltfTexture$extensio2.EXT_texture_webp)==null?void 0:_gltfTexture$extensio2.source)!=null?_ref:gltfTexture.source;const cloneAsset=seenImages.has(gltfImageIndex);seenImages.add(gltfImageIndex);return images[gltfImageIndex].then(imageAsset=>{var _gltf$samplers;const asset=cloneAsset?cloneTextureAsset(imageAsset):imageAsset;applySampler(asset.resource,((_gltf$samplers=gltf.samplers)!=null?_gltf$samplers:[])[gltfTexture.sampler]);return asset})});if(postprocess){promise=promise.then(textureAsset=>{postprocess(gltfTexture,textureAsset);return textureAsset});}return promise})};const loadBuffers=(gltf,binaryChunk,urlBase,options)=>{var _options$buffer,_options$buffer2,_options$buffer3;if(!gltf.buffers||gltf.buffers.length===0){return []}const preprocess=options==null||(_options$buffer=options.buffer)==null?void 0:_options$buffer.preprocess;const processAsync=options==null||(_options$buffer2=options.buffer)==null?void 0:_options$buffer2.processAsync;const postprocess=options==null||(_options$buffer3=options.buffer)==null?void 0:_options$buffer3.postprocess;return gltf.buffers.map((gltfBuffer,i)=>{if(preprocess){preprocess(gltfBuffer);}let promise;if(processAsync){promise=new Promise((resolve,reject)=>{processAsync(gltfBuffer,(err,arrayBuffer)=>{if(err){reject(err);}else {resolve(arrayBuffer);}});});}else {promise=new Promise(resolve=>{resolve(null);});}promise=promise.then(arrayBuffer=>{if(arrayBuffer){return arrayBuffer}else if(gltfBuffer.hasOwnProperty("uri")){if(isDataURI(gltfBuffer.uri)){const byteString=atob(gltfBuffer.uri.split(",")[1]);const binaryArray=new Uint8Array(byteString.length);for(let j=0;j<byteString.length;j++){binaryArray[j]=byteString.charCodeAt(j);}return binaryArray}return new Promise((resolve,reject)=>{http.get(ABSOLUTE_URL.test(gltfBuffer.uri)?gltfBuffer.uri:path.join(urlBase,gltfBuffer.uri),{cache:true,responseType:"arraybuffer",retry:false},(err,result)=>{if(err){reject(err);}else {resolve(new Uint8Array(result));}});})}return binaryChunk});if(postprocess){promise=promise.then(buffer=>{postprocess(gltf.buffers[i],buffer);return buffer});}return promise})};const parseGltf=(gltfChunk,callback)=>{const decodeBinaryUtf8=array=>{if(typeof TextDecoder!=="undefined"){return new TextDecoder().decode(array)}let str="";for(let i=0;i<array.length;i++){str+=String.fromCharCode(array[i]);}return decodeURIComponent(escape(str))};const gltf=JSON.parse(decodeBinaryUtf8(gltfChunk));if(gltf.asset&&gltf.asset.version&&parseFloat(gltf.asset.version)<2){callback(`Invalid gltf version. Expected version 2.0 or above but found version '${gltf.asset.version}'.`);return}callback(null,gltf);};const parseGlb=(glbData,callback)=>{const data=glbData instanceof ArrayBuffer?new DataView(glbData):new DataView(glbData.buffer,glbData.byteOffset,glbData.byteLength);const magic=data.getUint32(0,true);const version=data.getUint32(4,true);const length=data.getUint32(8,true);if(magic!==1179937895){callback(`Invalid magic number found in glb header. Expected 0x46546C67, found 0x${magic.toString(16)}`);return}if(version!==2){callback(`Invalid version number found in glb header. Expected 2, found ${version}`);return}if(length<=0||length>data.byteLength){callback(`Invalid length found in glb header. Found ${length}`);return}const chunks=[];let offset=12;while(offset<length){const chunkLength=data.getUint32(offset,true);if(offset+chunkLength+8>data.byteLength){callback(`Invalid chunk length found in glb. Found ${chunkLength}`);}const chunkType=data.getUint32(offset+4,true);const chunkData=new Uint8Array(data.buffer,data.byteOffset+offset+8,chunkLength);chunks.push({length:chunkLength,type:chunkType,data:chunkData});offset+=chunkLength+8;}if(chunks.length!==1&&chunks.length!==2){callback("Invalid number of chunks found in glb file.");return}if(chunks[0].type!==1313821514){callback(`Invalid chunk type found in glb file. Expected 0x4E4F534A, found 0x${chunks[0].type.toString(16)}`);return}if(chunks.length>1&&chunks[1].type!==5130562){callback(`Invalid chunk type found in glb file. Expected 0x004E4942, found 0x${chunks[1].type.toString(16)}`);return}callback(null,{gltfChunk:chunks[0].data,binaryChunk:chunks.length===2?chunks[1].data:null});};const parseChunk=(filename,data,callback)=>{const hasGlbHeader=()=>{const u8=new Uint8Array(data);return u8[0]===103&&u8[1]===108&&u8[2]===84&&u8[3]===70};if(filename&&filename.toLowerCase().endsWith(".glb")||hasGlbHeader()){parseGlb(data,callback);}else {callback(null,{gltfChunk:data,binaryChunk:null});}};const createBufferViews=(gltf,buffers,options)=>{var _options$bufferView,_options$bufferView2,_options$bufferView3,_gltf$bufferViews2;const result=[];const preprocess=options==null||(_options$bufferView=options.bufferView)==null?void 0:_options$bufferView.preprocess;const processAsync=options==null||(_options$bufferView2=options.bufferView)==null?void 0:_options$bufferView2.processAsync;const postprocess=options==null||(_options$bufferView3=options.bufferView)==null?void 0:_options$bufferView3.postprocess;if(!((_gltf$bufferViews2=gltf.bufferViews)!=null&&_gltf$bufferViews2.length)){return result}for(let i=0;i<gltf.bufferViews.length;++i){const gltfBufferView=gltf.bufferViews[i];if(preprocess){preprocess(gltfBufferView);}let promise;if(processAsync){promise=new Promise((resolve,reject)=>{processAsync(gltfBufferView,buffers,(err,result)=>{if(err){reject(err);}else {resolve(result);}});});}else {promise=new Promise(resolve=>{resolve(null);});}promise=promise.then(buffer=>{if(buffer){return buffer}return buffers[gltfBufferView.buffer].then(buffer=>{return new Uint8Array(buffer.buffer,buffer.byteOffset+(gltfBufferView.byteOffset||0),gltfBufferView.byteLength)})});if(gltfBufferView.hasOwnProperty("byteStride")){promise=promise.then(typedArray=>{typedArray.byteStride=gltfBufferView.byteStride;return typedArray});}if(postprocess){promise=promise.then(typedArray=>{postprocess(gltfBufferView,typedArray);return typedArray});}result.push(promise);}return result};class GlbParser{static parse(filename,urlBase,data,device,registry,options,callback){parseChunk(filename,data,(err,chunks)=>{if(err){callback(err);return}parseGltf(chunks.gltfChunk,(err,gltf)=>{if(err){callback(err);return}const buffers=loadBuffers(gltf,chunks.binaryChunk,urlBase,options);const bufferViews=createBufferViews(gltf,buffers,options);const images=createImages(gltf,bufferViews,urlBase,registry,options);const textures=createTextures(gltf,images,options);createResources(device,gltf,bufferViews,textures,options).then(result=>callback(null,result)).catch(err=>callback(err));});});}static createDefaultMaterial(){return createMaterial({name:"defaultGlbMaterial"},[])}}class AnimationHandler extends ResourceHandler{load(url,callback,asset){if(typeof url==="string"){url={load:url,original:url};}const options={retry:this.maxRetries>0,maxRetries:this.maxRetries};if(url.load.startsWith("blob:")||url.load.startsWith("data:")){if(path.getExtension(url.original).toLowerCase()===".glb"){options.responseType=Http.ResponseType.ARRAY_BUFFER;}else {options.responseType=Http.ResponseType.JSON;}}http.get(url.load,options,(err,response)=>{if(err){callback(`Error loading animation resource: ${url.original} [${err}]`);}else {if(path.getExtension(url.original).toLowerCase()===".glb"){var _asset$options;GlbParser.parse("filename.glb","",response,this.device,this.assets,(_asset$options=asset==null?void 0:asset.options)!=null?_asset$options:{},(err,parseResult)=>{if(err){callback(err);}else {var _asset$data;const animations=parseResult.animations;if(asset!=null&&(_asset$data=asset.data)!=null&&_asset$data.events){for(let i=0;i<animations.length;i++){animations[i].events=new AnimEvents(Object.values(asset.data.events));}}parseResult.destroy();callback(null,animations);}});}else {callback(null,this[`_parseAnimationV${response.animation.version}`](response));}}});}open(url,data,asset){return data}_parseAnimationV3(data){const animData=data.animation;const anim=new Animation;anim.name=animData.name;anim.duration=animData.duration;for(let i=0;i<animData.nodes.length;i++){const node=new Node;const n=animData.nodes[i];node._name=n.name;for(let j=0;j<n.keys.length;j++){const k=n.keys[j];const t=k.time;const p=k.pos;const r=k.rot;const s=k.scale;const pos=new Vec3(p[0],p[1],p[2]);const rot=new Quat().setFromEulerAngles(r[0],r[1],r[2]);const scl=new Vec3(s[0],s[1],s[2]);const key=new Key(t,pos,rot,scl);node._keys.push(key);}anim.addNode(node);}return anim}_parseAnimationV4(data){const animData=data.animation;const anim=new Animation;anim.name=animData.name;anim.duration=animData.duration;for(let i=0;i<animData.nodes.length;i++){const node=new Node;const n=animData.nodes[i];node._name=n.name;const defPos=n.defaults.p;const defRot=n.defaults.r;const defScl=n.defaults.s;for(let j=0;j<n.keys.length;j++){const k=n.keys[j];const t=k.t;const p=defPos?defPos:k.p;const r=defRot?defRot:k.r;const s=defScl?defScl:k.s;const pos=new Vec3(p[0],p[1],p[2]);const rot=new Quat().setFromEulerAngles(r[0],r[1],r[2]);const scl=new Vec3(s[0],s[1],s[2]);const key=new Key(t,pos,rot,scl);node._keys.push(key);}anim.addNode(node);}return anim}constructor(app){super(app,"animation");this.device=app.graphicsDevice;this.assets=app.assets;}}class AnimClipHandler extends ResourceHandler{load(url,callback){if(typeof url==="string"){url={load:url,original:url};}const options={retry:this.maxRetries>0,maxRetries:this.maxRetries};if(url.load.startsWith("blob:")){options.responseType=Http.ResponseType.JSON;}http.get(url.load,options,(err,response)=>{if(err){callback(`Error loading animation clip resource: ${url.original} [${err}]`);}else {callback(null,response);}});}open(url,data){const name=data.name;const duration=data.duration;const inputs=data.inputs.map(input=>{return new AnimData(1,input)});const outputs=data.outputs.map(output=>{return new AnimData(output.components,output.data)});const curves=data.curves.map(curve=>{return new AnimCurve([curve.path],curve.inputIndex,curve.outputIndex,curve.interpolation)});return new AnimTrack(name,duration,inputs,outputs,curves)}constructor(app){super(app,"animclip");}}class AnimStateGraphHandler extends ResourceHandler{load(url,callback){if(typeof url==="string"){url={load:url,original:url};}const options={retry:this.maxRetries>0,maxRetries:this.maxRetries};if(url.load.startsWith("blob:")){options.responseType=Http.ResponseType.JSON;}http.get(url.load,options,(err,response)=>{if(err){callback(`Error loading animation state graph resource: ${url.original} [${err}]`);}else {callback(null,response);}});}open(url,data){return new AnimStateGraph(data)}constructor(app){super(app,"animstategraph");}}const ie=function(){if(typeof window==="undefined"){return false}const ua=window.navigator.userAgent;const msie=ua.indexOf("MSIE ");if(msie>0){return parseInt(ua.substring(msie+5,ua.indexOf(".",msie)),10)}const trident=ua.indexOf("Trident/");if(trident>0){const rv=ua.indexOf("rv:");return parseInt(ua.substring(rv+3,ua.indexOf(".",rv)),10)}return false}();const supportedExtensions=[".ogg",".mp3",".wav",".mp4a",".m4a",".mp4",".aac",".opus"];class AudioHandler extends ResourceHandler{_isSupported(url){const ext=path.getExtension(url);return supportedExtensions.indexOf(ext)>-1}load(url,callback){if(typeof url==="string"){url={load:url,original:url};}const success=function success(resource){callback(null,new Sound(resource));};const error=function error(err){let msg=`Error loading audio url: ${url.original}`;if(err){msg+=`: ${err.message||err}`;}console.warn(msg);callback(msg);};if(this._createSound){if(!this._isSupported(url.original)){error(`Audio format for ${url.original} not supported`);return}this._createSound(url.load,success,error);}else {error(null);}}_createSound(url,success,error){if(hasAudioContext()){const manager=this.manager;if(!manager.context){error("Audio manager has no audio context");return}const options={retry:this.maxRetries>0,maxRetries:this.maxRetries};if(url.startsWith("blob:")||url.startsWith("data:")){options.responseType=Http.ResponseType.ARRAY_BUFFER;}http.get(url,options,(err,response)=>{if(err){error(err);return}manager.context.decodeAudioData(response,success,error);});}else {let audio=null;try{audio=new Audio;}catch(e){error("No support for Audio element");return}if(ie){document.body.appendChild(audio);}const onReady=function onReady(){audio.removeEventListener("canplaythrough",onReady);if(ie){document.body.removeChild(audio);}success(audio);};audio.onerror=function(){audio.onerror=null;if(ie){document.body.removeChild(audio);}error();};audio.addEventListener("canplaythrough",onReady);audio.src=url;}}constructor(app){super(app,"audio");this.manager=app.soundManager;}}class BinaryHandler extends ResourceHandler{load(url,callback){if(typeof url==="string"){url={load:url,original:url};}http.get(url.load,{responseType:Http.ResponseType.ARRAY_BUFFER,retry:this.maxRetries>0,maxRetries:this.maxRetries},(err,response)=>{if(!err){callback(null,response);}else {callback(`Error loading binary resource: ${url.original} [${err}]`);}});}openBinary(data){return data.buffer}constructor(app){super(app,"binary");}}class GlbContainerResource{get model(){if(!this._model){const model=GlbContainerResource.createModel(this.data,this._defaultMaterial);const modelAsset=GlbContainerResource.createAsset(this._assetName,"model",model,0);this._assets.add(modelAsset);this._model=modelAsset;}return this._model}static createAsset(assetName,type,resource,index){const subAsset=new Asset(`${assetName}/${type}/${index}`,type,{url:""});subAsset.resource=resource;subAsset.loaded=true;return subAsset}instantiateModelEntity(options){const entity=new Entity;entity.addComponent("model",Object.assign({type:"asset",asset:this.model},options));return entity}instantiateRenderEntity(options){const defaultMaterial=this._defaultMaterial;const skinnedMeshInstances=[];const createMeshInstance=function createMeshInstance(root,entity,mesh,materials,meshDefaultMaterials,skins,gltfNode){const materialIndex=meshDefaultMaterials[mesh.id];const material=materialIndex===undefined?defaultMaterial:materials[materialIndex];const meshInstance=new MeshInstance(mesh,material);if(mesh.morph){meshInstance.morphInstance=new MorphInstance(mesh.morph);}if(gltfNode.hasOwnProperty("skin")){skinnedMeshInstances.push({meshInstance:meshInstance,rootBone:root,entity:entity});}return meshInstance};const cloneHierarchy=(root,node,glb)=>{const entity=new Entity;node._cloneInternal(entity);if(!root)root=entity;let attachedMi=null;let renderAsset=null;for(let i=0;i<glb.nodes.length;i++){const glbNode=glb.nodes[i];if(glbNode===node){const gltfNode=glb.gltf.nodes[i];if(gltfNode.hasOwnProperty("mesh")){const meshGroup=glb.renders[gltfNode.mesh].meshes;renderAsset=this.renders[gltfNode.mesh];for(let mi=0;mi<meshGroup.length;mi++){const mesh=meshGroup[mi];if(mesh){const cloneMi=createMeshInstance(root,entity,mesh,glb.materials,glb.meshDefaultMaterials,glb.skins,gltfNode);if(!attachedMi){attachedMi=[];}attachedMi.push(cloneMi);}}}if(glb.lights){const lightEntity=glb.lights.get(gltfNode);if(lightEntity){entity.addChild(lightEntity.clone());}}if(glb.cameras){const cameraEntity=glb.cameras.get(gltfNode);if(cameraEntity){cameraEntity.camera.system.cloneComponent(cameraEntity,entity);}}}}if(attachedMi){entity.addComponent("render",Object.assign({type:"asset",meshInstances:attachedMi},options));entity.render.assignAsset(renderAsset);}const children=node.children;for(let i=0;i<children.length;i++){const childClone=cloneHierarchy(root,children[i],glb);entity.addChild(childClone);}return entity};const sceneClones=[];for(const scene of this.data.scenes){sceneClones.push(cloneHierarchy(null,scene,this.data));}skinnedMeshInstances.forEach(data=>{data.meshInstance.skinInstance=SkinInstanceCache.createCachedSkinInstance(data.meshInstance.mesh.skin,data.rootBone,data.entity);data.meshInstance.node.render.rootBone=data.rootBone;});return GlbContainerResource.createSceneHierarchy(sceneClones,Entity)}getMaterialVariants(){return this.data.variants?Object.keys(this.data.variants):[]}applyMaterialVariant(entity,name){const variant=name?this.data.variants[name]:null;if(variant===undefined){return}const renders=entity.findComponents("render");for(let i=0;i<renders.length;i++){const renderComponent=renders[i];this._applyMaterialVariant(variant,renderComponent.meshInstances);}}applyMaterialVariantInstances(instances,name){const variant=name?this.data.variants[name]:null;if(variant===undefined){return}this._applyMaterialVariant(variant,instances);}_applyMaterialVariant(variant,instances){instances.forEach(instance=>{if(variant===null){instance.material=this._defaultMaterial;}else {const meshVariants=this.data.meshVariants[instance.mesh.id];if(meshVariants){instance.material=this.data.materials[meshVariants[variant]];}}});}static createSceneHierarchy(sceneNodes,nodeType){let root=null;if(sceneNodes.length===1){root=sceneNodes[0];}else {root=new nodeType("SceneGroup");for(const scene of sceneNodes){root.addChild(scene);}}return root}static createModel(glb,defaultMaterial){const createMeshInstance=function createMeshInstance(model,mesh,skins,skinInstances,materials,node,gltfNode){const materialIndex=glb.meshDefaultMaterials[mesh.id];const material=materialIndex===undefined?defaultMaterial:materials[materialIndex];const meshInstance=new MeshInstance(mesh,material,node);if(mesh.morph){const morphInstance=new MorphInstance(mesh.morph);meshInstance.morphInstance=morphInstance;model.morphInstances.push(morphInstance);}if(gltfNode.hasOwnProperty("skin")){const skinIndex=gltfNode.skin;const skin=skins[skinIndex];mesh.skin=skin;const skinInstance=skinInstances[skinIndex];meshInstance.skinInstance=skinInstance;model.skinInstances.push(skinInstance);}model.meshInstances.push(meshInstance);};const model=new Model;const skinInstances=[];for(const skin of glb.skins){const skinInstance=new SkinInstance(skin);skinInstance.bones=skin.bones;skinInstances.push(skinInstance);}model.graph=GlbContainerResource.createSceneHierarchy(glb.scenes,GraphNode);for(let i=0;i<glb.nodes.length;i++){const node=glb.nodes[i];if(node.root===model.graph){const gltfNode=glb.gltf.nodes[i];if(gltfNode.hasOwnProperty("mesh")){const meshGroup=glb.renders[gltfNode.mesh].meshes;for(let mi=0;mi<meshGroup.length;mi++){const mesh=meshGroup[mi];if(mesh){createMeshInstance(model,mesh,glb.skins,skinInstances,glb.materials,node,gltfNode);}}}}}return model}destroy(){const registry=this._assets;const destroyAsset=function destroyAsset(asset){registry.remove(asset);asset.unload();};const destroyAssets=function destroyAssets(assets){assets.forEach(asset=>{destroyAsset(asset);});};if(this.animations){destroyAssets(this.animations);this.animations=null;}if(this.textures){destroyAssets(this.textures);this.textures=null;}if(this.materials){destroyAssets(this.materials);this.materials=null;}if(this.renders){destroyAssets(this.renders);this.renders=null;}if(this._model){destroyAsset(this._model);this._model=null;}this.data=null;this.assets=null;}constructor(data,asset,assets,defaultMaterial){const createAsset=function createAsset(type,resource,index){const subAsset=GlbContainerResource.createAsset(asset.name,type,resource,index);assets.add(subAsset);return subAsset};const renders=[];for(let i=0;i<data.renders.length;++i){renders.push(createAsset("render",data.renders[i],i));}const materials=[];for(let i=0;i<data.materials.length;++i){materials.push(createAsset("material",data.materials[i],i));}const animations=[];for(let i=0;i<data.animations.length;++i){animations.push(createAsset("animation",data.animations[i],i));}this.data=data;this._model=null;this._assetName=asset.name;this._assets=assets;this._defaultMaterial=defaultMaterial;this.renders=renders;this.materials=materials;this.textures=data.textures;this.animations=animations;}}class GlbContainerParser{_getUrlWithoutParams(url){return url.indexOf("?")>=0?url.split("?")[0]:url}load(url,callback,asset){Asset.fetchArrayBuffer(url.load,(err,result)=>{if(err){callback(err);}else {GlbParser.parse(this._getUrlWithoutParams(url.original),path.extractPath(url.load),result,this._device,asset.registry,asset.options,(err,result)=>{if(err){callback(err);}else {callback(null,new GlbContainerResource(result,asset,this._assets,this._defaultMaterial));}});}},asset,this.maxRetries);}open(url,data,asset){return data}patch(asset,assets){}constructor(device,assets,maxRetries){this._device=device;this._assets=assets;this._defaultMaterial=GlbParser.createDefaultMaterial();this.maxRetries=maxRetries;}}class ContainerResource{instantiateModelEntity(options){return null}instantiateRenderEntity(options){return null}getMaterialVariants(){return null}applyMaterialVariant(entity,name){}applyMaterialVariantInstances(instances,name){}}class ContainerHandler extends ResourceHandler{set maxRetries(value){this.glbContainerParser.maxRetries=value;for(const parser in this.parsers){if(this.parsers.hasOwnProperty(parser)){this.parsers[parser].maxRetries=value;}}}get maxRetries(){return this.glbContainerParser.maxRetries}_getUrlWithoutParams(url){return url.indexOf("?")>=0?url.split("?")[0]:url}_getParser(url){const ext=url?path.getExtension(this._getUrlWithoutParams(url)).toLowerCase().replace(".",""):null;return this.parsers[ext]||this.glbContainerParser}load(url,callback,asset){if(typeof url==="string"){url={load:url,original:url};}this._getParser(url.original).load(url,callback,asset);}open(url,data,asset){return this._getParser(url).open(url,data,asset)}constructor(app){super(app,"container");this.glbContainerParser=new GlbContainerParser(app.graphicsDevice,app.assets,0);this.parsers={};}}class CssHandler extends ResourceHandler{load(url,callback){if(typeof url==="string"){url={load:url,original:url};}http.get(url.load,{retry:this.maxRetries>0,maxRetries:this.maxRetries},(err,response)=>{if(!err){callback(null,response);}else {callback(`Error loading css resource: ${url.original} [${err}]`);}});}openBinary(data){var _this$decoder;(_this$decoder=this.decoder)!=null?_this$decoder:this.decoder=new TextDecoder("utf-8");return this.decoder.decode(data)}constructor(app){super(app,"css");this.decoder=null;}}class CubemapHandler extends ResourceHandler{load(url,callback,asset){this.loadAssets(asset,callback);}open(url,data,asset){return asset?asset.resource:null}patch(asset,registry){this.loadAssets(asset,(err,result)=>{if(err){registry.fire("error",asset);registry.fire(`error:${asset.id}`,err,asset);asset.fire("error",asset);}});}getAssetIds(cubemapAsset){const result=[];result[0]=cubemapAsset.file;if((cubemapAsset.loadFaces||!cubemapAsset.file)&&cubemapAsset.data&&cubemapAsset.data.textures){for(let i=0;i<6;++i){result[i+1]=cubemapAsset.data.textures[i];}}else {result[1]=result[2]=result[3]=result[4]=result[5]=result[6]=null;}return result}compareAssetIds(assetIdA,assetIdB){if(assetIdA&&assetIdB){if(parseInt(assetIdA,10)===assetIdA||typeof assetIdA==="string"){return assetIdA===assetIdB}return assetIdA.url===assetIdB.url}return assetIdA!==null===(assetIdB!==null)}update(cubemapAsset,assetIds,assets){const assetData=cubemapAsset.data||{};const oldAssets=cubemapAsset._handlerState.assets;const oldResources=cubemapAsset._resources;let tex,mip,i;const resources=[null,null,null,null,null,null,null];const getType=function getType(){if(assetData.hasOwnProperty("type")){return assetData.type}if(assetData.hasOwnProperty("rgbm")){return assetData.rgbm?TEXTURETYPE_RGBM:TEXTURETYPE_DEFAULT}return null};if(!cubemapAsset.loaded||assets[0]!==oldAssets[0]){if(assets[0]){tex=assets[0].resource;if(tex.cubemap){for(i=0;i<6;++i){resources[i+1]=new Texture(this._device,{name:`${cubemapAsset.name}_prelitCubemap${tex.width>>i}`,cubemap:true,type:getType()||tex.type,width:tex.width>>i,height:tex.height>>i,format:tex.format,levels:[tex._levels[i]],fixCubemapSeams:true,addressU:ADDRESS_CLAMP_TO_EDGE,addressV:ADDRESS_CLAMP_TO_EDGE,mipmaps:i===0});}}else {tex.type=TEXTURETYPE_RGBP;tex.addressU=ADDRESS_CLAMP_TO_EDGE;tex.addressV=ADDRESS_CLAMP_TO_EDGE;tex.mipmaps=false;resources[1]=tex;}}}else {resources[1]=oldResources[1]||null;resources[2]=oldResources[2]||null;resources[3]=oldResources[3]||null;resources[4]=oldResources[4]||null;resources[5]=oldResources[5]||null;resources[6]=oldResources[6]||null;}const faceAssets=assets.slice(1);if(!cubemapAsset.loaded||!this.cmpArrays(faceAssets,oldAssets.slice(1))){if(faceAssets.indexOf(null)===-1){var _assetData$mipmaps;const faceTextures=faceAssets.map(asset=>{return asset.resource});const faceLevels=[];for(mip=0;mip<faceTextures[0]._levels.length;++mip){faceLevels.push(faceTextures.map(faceTexture=>{return faceTexture._levels[mip]}));}const format=faceTextures[0].format;const faces=new Texture(this._device,{name:`${cubemapAsset.name}_faces`,cubemap:true,type:getType()||faceTextures[0].type,width:faceTextures[0].width,height:faceTextures[0].height,format:format===PIXELFORMAT_RGB8?PIXELFORMAT_RGBA8:format,mipmaps:(_assetData$mipmaps=assetData.mipmaps)!=null?_assetData$mipmaps:true,levels:faceLevels,minFilter:assetData.hasOwnProperty("minFilter")?assetData.minFilter:faceTextures[0].minFilter,magFilter:assetData.hasOwnProperty("magFilter")?assetData.magFilter:faceTextures[0].magFilter,anisotropy:assetData.hasOwnProperty("anisotropy")?assetData.anisotropy:1,addressU:ADDRESS_CLAMP_TO_EDGE,addressV:ADDRESS_CLAMP_TO_EDGE,fixCubemapSeams:!!assets[0]});resources[0]=faces;}}else {resources[0]=oldResources[0]||null;}if(!this.cmpArrays(resources,oldResources)){cubemapAsset.resources=resources;cubemapAsset._handlerState.assetIds=assetIds;cubemapAsset._handlerState.assets=assets;for(i=0;i<oldResources.length;++i){if(oldResources[i]!==null&&resources.indexOf(oldResources[i])===-1){oldResources[i].destroy();}}}for(i=0;i<oldAssets.length;++i){if(oldAssets[i]!==null&&assets.indexOf(oldAssets[i])===-1){oldAssets[i].unload();}}}cmpArrays(arr1,arr2){if(arr1.length!==arr2.length){return false}for(let i=0;i<arr1.length;++i){if(arr1[i]!==arr2[i]){return false}}return true}resolveId(value){const valueInt=parseInt(value,10);return valueInt===value||valueInt.toString()===value?valueInt:value}loadAssets(cubemapAsset,callback){if(!cubemapAsset.hasOwnProperty("_handlerState")){cubemapAsset._handlerState={assetIds:[null,null,null,null,null,null,null],assets:[null,null,null,null,null,null,null]};}const self1=this;const assetIds=self1.getAssetIds(cubemapAsset);const assets=[null,null,null,null,null,null,null];const loadedAssetIds=cubemapAsset._handlerState.assetIds;const loadedAssets=cubemapAsset._handlerState.assets;const registry=self1._registry;let awaiting=7;const onLoad=function onLoad(index,asset){assets[index]=asset;awaiting--;if(awaiting===0){self1.update(cubemapAsset,assetIds,assets);callback(null,cubemapAsset.resources);}};const onError=function onError(index,err,asset){callback(err);};const processTexAsset=function processTexAsset(index,texAsset){if(texAsset.loaded){onLoad(index,texAsset);}else {registry.once(`load:${texAsset.id}`,onLoad.bind(self1,index));registry.once(`error:${texAsset.id}`,onError.bind(self1,index));if(!texAsset.loading){registry.load(texAsset);}}};let texAsset;for(let i=0;i<7;++i){const assetId=this.resolveId(assetIds[i]);if(!assetId){onLoad(i,null);}else if(self1.compareAssetIds(assetId,loadedAssetIds[i])){processTexAsset(i,loadedAssets[i]);}else if(parseInt(assetId,10)===assetId){texAsset=registry.get(assetId);if(texAsset){processTexAsset(i,texAsset);}else {setTimeout(((index,assetId_)=>{const texAsset=registry.get(assetId_);if(texAsset){processTexAsset(index,texAsset);}else {onError(index,`failed to find dependent cubemap asset=${assetId_}`);}}).bind(null,i,assetId));}}else {const file=typeof assetId==="string"?{url:assetId,filename:assetId}:assetId;texAsset=new Asset(`${cubemapAsset.name}_part_${i}`,"texture",file);registry.add(texAsset);processTexAsset(i,texAsset);}}}constructor(app){super(app,"cubemap");this._device=app.graphicsDevice;this._registry=app.assets;this._loader=app.loader;}}class FolderHandler extends ResourceHandler{load(url,callback){callback(null,null);}constructor(app){super(app,"folder");}}class Font{set data(value){this._data=value;if(!value){return}if(this._data.intensity!==undefined){this.intensity=this._data.intensity;}if(!this._data.info){this._data.info={};}if(!this._data.version||this._data.version<2){this._data.info.maps=[{width:this._data.info.width,height:this._data.info.height}];if(this._data.chars){for(const key in this._data.chars){this._data.chars[key].map=0;}}}}get data(){return this._data}constructor(textures,data){this.type=data?data.type||FONT_MSDF:FONT_MSDF;this.em=1;this.textures=textures;this.intensity=0;this._data=null;this.data=data;}}function upgradeDataSchema(data){if(data.version<3){if(data.version<2){data.info.maps=data.info.maps||[{width:data.info.width,height:data.info.height}];}data.chars=Object.keys(data.chars||{}).reduce((newChars,key)=>{const existing=data.chars[key];const newKey=existing.letter!==undefined?existing.letter:string.fromCodePoint(key);if(data.version<2){existing.map=existing.map||0;}newChars[newKey]=existing;return newChars},{});data.version=3;}return data}class FontHandler extends ResourceHandler{load(url,callback,asset){if(typeof url==="string"){url={load:url,original:url};}const self1=this;if(path.getExtension(url.original)===".json"){http.get(url.load,{retry:this.maxRetries>0,maxRetries:this.maxRetries},(err,response)=>{if(!err){const data=upgradeDataSchema(response);self1._loadTextures(url.load.replace(".json",".png"),data,(err,textures)=>{if(err){callback(err);}else {callback(null,{data:data,textures:textures});}});}else {callback(`Error loading font resource: ${url.original} [${err}]`);}});}else {if(asset&&asset.data){asset.data=upgradeDataSchema(asset.data);}this._loadTextures(url.load,asset&&asset.data,callback);}}_loadTextures(url,data,callback){const numTextures=data.info.maps.length;let numLoaded=0;let error=null;const textures=new Array(numTextures);const loader=this._loader;const loadTexture=function loadTexture(index){const onLoaded=function onLoaded(err,texture){if(error)return;if(err){error=err;callback(err);return}texture.upload();textures[index]=texture;numLoaded++;if(numLoaded===numTextures){callback(null,textures);}};if(index===0){loader.load(url,"texture",onLoaded);}else {loader.load(url.replace(".png",`${index}.png`),"texture",onLoaded);}};for(let i=0;i<numTextures;i++){loadTexture(i);}}open(url,data,asset){let font;if(data.textures){font=new Font(data.textures,data.data);}else {font=new Font(data,null);}return font}patch(asset,assets){const font=asset.resource;if(!font.data&&asset.data){font.data=asset.data;}else if(!asset.data&&font.data){asset.data=font.data;}if(asset.data){asset.data=upgradeDataSchema(asset.data);}}constructor(app){super(app,"font");this._loader=app.loader;this.maxRetries=0;}}const SH_C0=.28209479177387814;class SplatCompressedIterator{constructor(gsplatData,p,r,s,c,sh){const unpackUnorm=(value,bits)=>{const t=(1<<bits)-1;return (value&t)/t};const unpack111011=(result,value)=>{result.x=unpackUnorm(value>>>21,11);result.y=unpackUnorm(value>>>11,10);result.z=unpackUnorm(value,11);};const unpack8888=(result,value)=>{result.x=unpackUnorm(value>>>24,8);result.y=unpackUnorm(value>>>16,8);result.z=unpackUnorm(value>>>8,8);result.w=unpackUnorm(value,8);};const unpackRot=(result,value)=>{const norm=1/(Math.sqrt(2)*.5);const a=(unpackUnorm(value>>>20,10)-.5)*norm;const b=(unpackUnorm(value>>>10,10)-.5)*norm;const c=(unpackUnorm(value,10)-.5)*norm;const m=Math.sqrt(1-(a*a+b*b+c*c));switch(value>>>30){case 0:result.set(a,b,c,m);break;case 1:result.set(m,b,c,a);break;case 2:result.set(b,m,c,a);break;case 3:result.set(b,c,m,a);break}};const lerp=(a,b,t)=>{return a===b?a:a*(1-t)+b*t};const{chunkData,chunkSize,vertexData,shData,shBands}=gsplatData;const shCoeffs=[3,8,15][shBands-1];this.read=i=>{const ci=Math.floor(i/256)*chunkSize;if(p){unpack111011(p,vertexData[i*4+0]);p.x=lerp(chunkData[ci+0],chunkData[ci+3],p.x);p.y=lerp(chunkData[ci+1],chunkData[ci+4],p.y);p.z=lerp(chunkData[ci+2],chunkData[ci+5],p.z);}if(r){unpackRot(r,vertexData[i*4+1]);}if(s){unpack111011(s,vertexData[i*4+2]);s.x=lerp(chunkData[ci+6],chunkData[ci+9],s.x);s.y=lerp(chunkData[ci+7],chunkData[ci+10],s.y);s.z=lerp(chunkData[ci+8],chunkData[ci+11],s.z);}if(c){unpack8888(c,vertexData[i*4+3]);if(chunkSize>12){c.x=lerp(chunkData[ci+12],chunkData[ci+15],c.x);c.y=lerp(chunkData[ci+13],chunkData[ci+16],c.y);c.z=lerp(chunkData[ci+14],chunkData[ci+17],c.z);}}if(sh&&shBands>0){for(let j=0;j<3;++j){for(let k=0;k<15;++k){sh[j*15+k]=k<shCoeffs?shData[(i*3+j)*shCoeffs+k]*(8/255)-4:0;}}}};}}class GSplatCompressedData{createIter(p,r,s,c,sh){return new SplatCompressedIterator(this,p,r,s,c,sh)}calcAabb(result){const{chunkData,numChunks,chunkSize}=this;let s=Math.exp(Math.max(chunkData[9],chunkData[10],chunkData[11]));let mx=chunkData[0]-s;let my=chunkData[1]-s;let mz=chunkData[2]-s;let Mx=chunkData[3]+s;let My=chunkData[4]+s;let Mz=chunkData[5]+s;for(let i=1;i<numChunks;++i){const off=i*chunkSize;s=Math.exp(Math.max(chunkData[off+9],chunkData[off+10],chunkData[off+11]));mx=Math.min(mx,chunkData[off+0]-s);my=Math.min(my,chunkData[off+1]-s);mz=Math.min(mz,chunkData[off+2]-s);Mx=Math.max(Mx,chunkData[off+3]+s);My=Math.max(My,chunkData[off+4]+s);Mz=Math.max(Mz,chunkData[off+5]+s);}result.center.set((mx+Mx)*.5,(my+My)*.5,(mz+Mz)*.5);result.halfExtents.set((Mx-mx)*.5,(My-my)*.5,(Mz-mz)*.5);return true}getCenters(result){const{vertexData,chunkData,numChunks,chunkSize}=this;let mx,my,mz,Mx,My,Mz;for(let c=0;c<numChunks;++c){const off=c*chunkSize;mx=chunkData[off+0];my=chunkData[off+1];mz=chunkData[off+2];Mx=chunkData[off+3];My=chunkData[off+4];Mz=chunkData[off+5];const end=Math.min(this.numSplats,(c+1)*256);for(let i=c*256;i<end;++i){const p=vertexData[i*4];const px=(p>>>21)/2047;const py=(p>>>11&1023)/1023;const pz=(p&2047)/2047;result[i*3+0]=(1-px)*mx+px*Mx;result[i*3+1]=(1-py)*my+py*My;result[i*3+2]=(1-pz)*mz+pz*Mz;}}}calcFocalPoint(result){const{chunkData,numChunks,chunkSize}=this;result.x=0;result.y=0;result.z=0;for(let i=0;i<numChunks;++i){const off=i*chunkSize;result.x+=chunkData[off+0]+chunkData[off+3];result.y+=chunkData[off+1]+chunkData[off+4];result.z+=chunkData[off+2]+chunkData[off+5];}result.mulScalar(.5/numChunks);}get isCompressed(){return true}get numChunks(){return Math.ceil(this.numSplats/256)}get chunkSize(){return this.chunkData.length/this.numChunks}get shBands(){var _sizes,_this$shData;const sizes={3:1,8:2,15:3};return (_sizes=sizes[((_this$shData=this.shData)==null?void 0:_this$shData.length)/this.numSplats/3])!=null?_sizes:0}decompress(){const members=["x","y","z","f_dc_0","f_dc_1","f_dc_2","opacity","rot_0","rot_1","rot_2","rot_3","scale_0","scale_1","scale_2"];const{shBands}=this;if(shBands>0){const shMembers=[];for(let i=0;i<45;++i){shMembers.push(`f_rest_${i}`);}members.splice(members.indexOf("f_dc_0")+1,0,...shMembers);}const data={};members.forEach(name=>{data[name]=new Float32Array(this.numSplats);});const p=new Vec3;const r=new Quat;const s=new Vec3;const c=new Vec4;const sh=shBands>0?new Float32Array(45):null;const iter=this.createIter(p,r,s,c,sh);for(let i=0;i<this.numSplats;++i){iter.read(i);data.x[i]=p.x;data.y[i]=p.y;data.z[i]=p.z;data.rot_1[i]=r.x;data.rot_2[i]=r.y;data.rot_3[i]=r.z;data.rot_0[i]=r.w;data.scale_0[i]=s.x;data.scale_1[i]=s.y;data.scale_2[i]=s.z;data.f_dc_0[i]=(c.x-.5)/SH_C0;data.f_dc_1[i]=(c.y-.5)/SH_C0;data.f_dc_2[i]=(c.z-.5)/SH_C0;data.opacity[i]=c.w<=0?-40:c.w>=1?40:-Math.log(1/c.w-1);if(sh){for(let _c=0;_c<45;++_c){data[`f_rest_${_c}`][i]=sh[_c];}}}return new GSplatData([{name:"vertex",count:this.numSplats,properties:members.map(name=>{return {name:name,type:"float",byteSize:4,storage:data[name]}})}])}constructor(){this.numSplats=void 0;this.chunkData=void 0;this.vertexData=void 0;this.shData=void 0;}}const splatCoreVS=`
	uniform mat4 matrix_model;
	uniform mat4 matrix_view;
	uniform mat4 matrix_projection;
	uniform vec2 viewport;
	uniform vec4 tex_params;
	uniform highp usampler2D splatOrder;
	uniform highp usampler2D packedTexture;
	uniform highp sampler2D chunkTexture;
	attribute vec3 vertex_position;
	attribute uint vertex_id_attrib;
	#ifndef DITHER_NONE
		varying float id;
	#endif
	uint orderId;
	uint splatId;
	ivec2 packedUV;
	ivec2 chunkUV;
	vec4 chunkDataA;
	vec4 chunkDataB;
	vec4 chunkDataC;
	vec4 chunkDataD;
	vec4 chunkDataE;
	uvec4 packedData;
	bool calcSplatUV() {
		uint numSplats = uint(tex_params.x);
		uint packedWidth = uint(tex_params.y);
		uint chunkWidth = uint(tex_params.z);
		orderId = vertex_id_attrib + uint(vertex_position.z);
		if (orderId >= numSplats) {
			return false;
		}
		ivec2 orderUV = ivec2(
			int(orderId % packedWidth),
			int(orderId / packedWidth)
		);
		splatId = texelFetch(splatOrder, orderUV, 0).r;
		packedUV = ivec2(
			int(splatId % packedWidth),
			int(splatId / packedWidth)
		);
		uint chunkId = splatId / 256u;
		chunkUV = ivec2(
			int((chunkId % chunkWidth) * 5u),
			int(chunkId / chunkWidth)
		);
		return true;
	}
	void readData() {
		chunkDataA = texelFetch(chunkTexture, chunkUV, 0);
		chunkDataB = texelFetch(chunkTexture, ivec2(chunkUV.x + 1, chunkUV.y), 0);
		chunkDataC = texelFetch(chunkTexture, ivec2(chunkUV.x + 2, chunkUV.y), 0);
		chunkDataD = texelFetch(chunkTexture, ivec2(chunkUV.x + 3, chunkUV.y), 0);
		chunkDataE = texelFetch(chunkTexture, ivec2(chunkUV.x + 4, chunkUV.y), 0);
		packedData = texelFetch(packedTexture, packedUV, 0);
	}
	vec3 unpack111011(uint bits) {
		return vec3(
			float(bits >> 21u) / 2047.0,
			float((bits >> 11u) & 0x3ffu) / 1023.0,
			float(bits & 0x7ffu) / 2047.0
		);
	}
	vec4 unpack8888(uint bits) {
		return vec4(
			float(bits >> 24u) / 255.0,
			float((bits >> 16u) & 0xffu) / 255.0,
			float((bits >> 8u) & 0xffu) / 255.0,
			float(bits & 0xffu) / 255.0
		);
	}
	float norm = 1.0 / (sqrt(2.0) * 0.5);
	vec4 unpackRotation(uint bits) {
		float a = (float((bits >> 20u) & 0x3ffu) / 1023.0 - 0.5) * norm;
		float b = (float((bits >> 10u) & 0x3ffu) / 1023.0 - 0.5) * norm;
		float c = (float(bits & 0x3ffu) / 1023.0 - 0.5) * norm;
		float m = sqrt(1.0 - (a * a + b * b + c * c));
		uint mode = bits >> 30u;
		if (mode == 0u) return vec4(m, a, b, c);
		if (mode == 1u) return vec4(a, m, b, c);
		if (mode == 2u) return vec4(a, b, m, c);
		return vec4(a, b, c, m);
	}
	vec3 getCenter() {
		return mix(chunkDataA.xyz, vec3(chunkDataA.w, chunkDataB.xy), unpack111011(packedData.x));
	}
	vec4 getRotation() {
		return unpackRotation(packedData.y);
	}
	vec3 getScale() {
		return exp(mix(vec3(chunkDataB.zw, chunkDataC.x), chunkDataC.yzw, unpack111011(packedData.z)));
	}
	vec4 getColor() {
		vec4 r = unpack8888(packedData.w);
		return vec4(mix(chunkDataD.xyz, vec3(chunkDataD.w, chunkDataE.xy), r.rgb), r.w);
	}
	mat3 quatToMat3(vec4 R) {
		float x = R.x;
		float y = R.y;
		float z = R.z;
		float w = R.w;
		return mat3(
			1.0 - 2.0 * (z * z + w * w),
				  2.0 * (y * z + x * w),
				  2.0 * (y * w - x * z),
				  2.0 * (y * z - x * w),
			1.0 - 2.0 * (y * y + w * w),
				  2.0 * (z * w + x * y),
				  2.0 * (y * w + x * z),
				  2.0 * (z * w - x * y),
			1.0 - 2.0 * (y * y + z * z)
		);
	}
	void getCovariance(out vec3 covA, out vec3 covB) {
		mat3 rot = quatToMat3(getRotation());
		vec3 scale = getScale();
		mat3 M = transpose(mat3(
			scale.x * rot[0],
			scale.y * rot[1],
			scale.z * rot[2]
		));
		covA = vec3(dot(M[0], M[0]), dot(M[0], M[1]), dot(M[0], M[2]));
		covB = vec3(dot(M[1], M[1]), dot(M[1], M[2]), dot(M[2], M[2]));
	}
	vec4 calcV1V2(in vec3 splat_cam, in vec3 covA, in vec3 covB, mat3 W) {
		mat3 Vrk = mat3(
			covA.x, covA.y, covA.z, 
			covA.y, covB.x, covB.y,
			covA.z, covB.y, covB.z
		);
		float focal = viewport.x * matrix_projection[0][0];
		float J1 = focal / splat_cam.z;
		vec2 J2 = -J1 / splat_cam.z * splat_cam.xy;
		mat3 J = mat3(
			J1, 0.0, J2.x, 
			0.0, J1, J2.y, 
			0.0, 0.0, 0.0
		);
		mat3 T = W * J;
		mat3 cov = transpose(T) * Vrk * T;
		float diagonal1 = cov[0][0] + 0.3;
		float offDiagonal = cov[0][1];
		float diagonal2 = cov[1][1] + 0.3;
		float mid = 0.5 * (diagonal1 + diagonal2);
		float radius = length(vec2((diagonal1 - diagonal2) / 2.0, offDiagonal));
		float lambda1 = mid + radius;
		float lambda2 = max(mid - radius, 0.1);
		vec2 diagonalVector = normalize(vec2(offDiagonal, lambda1 - diagonal1));
		vec2 v1 = min(sqrt(2.0 * lambda1), 1024.0) * diagonalVector;
		vec2 v2 = min(sqrt(2.0 * lambda2), 1024.0) * vec2(diagonalVector.y, -diagonalVector.x);
		return vec4(v1, v2);
	}
#if defined(USE_SH)
	#define SH_C1 0.4886025119029199f
	#define SH_C2_0 1.0925484305920792f
	#define SH_C2_1 -1.0925484305920792f
	#define SH_C2_2 0.31539156525252005f
	#define SH_C2_3 -1.0925484305920792f
	#define SH_C2_4 0.5462742152960396f
	#define SH_C3_0 -0.5900435899266435f
	#define SH_C3_1 2.890611442640554f
	#define SH_C3_2 -0.4570457994644658f
	#define SH_C3_3 0.3731763325901154f
	#define SH_C3_4 -0.4570457994644658f
	#define SH_C3_5 1.445305721320277f
	#define SH_C3_6 -0.5900435899266435f
	uniform highp usampler2D shTexture0;
	uniform highp usampler2D shTexture1;
	uniform highp usampler2D shTexture2;
	vec4 sunpack8888(in uint bits) {
		return vec4((uvec4(bits) >> uvec4(0u, 8u, 16u, 24u)) & 0xffu) * (8.0 / 255.0) - 4.0;
	}
	void readSHData(out vec3 sh[15]) {
		uvec4 shData0 = texelFetch(shTexture0, packedUV, 0);
		uvec4 shData1 = texelFetch(shTexture1, packedUV, 0);
		uvec4 shData2 = texelFetch(shTexture2, packedUV, 0);
		vec4 r0 = sunpack8888(shData0.x);
		vec4 r1 = sunpack8888(shData0.y);
		vec4 r2 = sunpack8888(shData0.z);
		vec4 r3 = sunpack8888(shData0.w);
		vec4 g0 = sunpack8888(shData1.x);
		vec4 g1 = sunpack8888(shData1.y);
		vec4 g2 = sunpack8888(shData1.z);
		vec4 g3 = sunpack8888(shData1.w);
		vec4 b0 = sunpack8888(shData2.x);
		vec4 b1 = sunpack8888(shData2.y);
		vec4 b2 = sunpack8888(shData2.z);
		vec4 b3 = sunpack8888(shData2.w);
		sh[0] =  vec3(r0.x, g0.x, b0.x);
		sh[1] =  vec3(r0.y, g0.y, b0.y);
		sh[2] =  vec3(r0.z, g0.z, b0.z);
		sh[3] =  vec3(r0.w, g0.w, b0.w);
		sh[4] =  vec3(r1.x, g1.x, b1.x);
		sh[5] =  vec3(r1.y, g1.y, b1.y);
		sh[6] =  vec3(r1.z, g1.z, b1.z);
		sh[7] =  vec3(r1.w, g1.w, b1.w);
		sh[8] =  vec3(r2.x, g2.x, b2.x);
		sh[9] =  vec3(r2.y, g2.y, b2.y);
		sh[10] = vec3(r2.z, g2.z, b2.z);
		sh[11] = vec3(r2.w, g2.w, b2.w);
		sh[12] = vec3(r3.x, g3.x, b3.x);
		sh[13] = vec3(r3.y, g3.y, b3.y);
		sh[14] = vec3(r3.z, g3.z, b3.z);
	}
	vec3 evalSH(in vec3 dir) {
		vec3 sh[15];
		readSHData(sh);
		vec3 result = vec3(0.0);
		float x = dir.x;
		float y = dir.y;
		float z = dir.z;
		result += SH_C1 * (-sh[0] * y + sh[1] * z - sh[2] * x);
		float xx = x * x;
		float yy = y * y;
		float zz = z * z;
		float xy = x * y;
		float yz = y * z;
		float xz = x * z;
		result +=
			sh[3] * (SH_C2_0 * xy) *  +
			sh[4] * (SH_C2_1 * yz) +
			sh[5] * (SH_C2_2 * (2.0 * zz - xx - yy)) +
			sh[6] * (SH_C2_3 * xz) +
			sh[7] * (SH_C2_4 * (xx - yy));
		result +=
			sh[8]  * (SH_C3_0 * y * (3.0 * xx - yy)) +
			sh[9]  * (SH_C3_1 * xy * z) +
			sh[10] * (SH_C3_2 * y * (4.0 * zz - xx - yy)) +
			sh[11] * (SH_C3_3 * z * (2.0 * zz - 3.0 * xx - 3.0 * yy)) +
			sh[12] * (SH_C3_4 * x * (4.0 * zz - xx - yy)) +
			sh[13] * (SH_C3_5 * z * (xx - yy)) +
			sh[14] * (SH_C3_6 * x * (xx - 3.0 * yy));
		return result;
	}
#else
	vec3 evalSH(in vec3 dir) {
		return vec3(0.0);
	}
#endif
`;const splatCoreFS=`
	#ifndef DITHER_NONE
		varying float id;
	#endif
	#ifdef PICK_PASS
		uniform vec4 uColor;
	#endif
	vec4 evalSplat(vec2 texCoord, vec4 color) {
		mediump float A = dot(texCoord, texCoord);
		if (A > 1.0) {
			discard;
		}
		mediump float B = exp(-A * 4.0) * color.a;
		if (B < 1.0 / 255.0) {
			discard;
		}
		#ifdef PICK_PASS
			if (B < 0.3) {
				discard;
			}
			return uColor;
		#endif
		#ifndef DITHER_NONE
			opacityDither(B, id * 0.013);
		#endif
		#ifdef TONEMAP_ENABLED
			return vec4(gammaCorrectOutput(toneMap(decodeGamma(color.rgb))), B);
		#else
			return vec4(color.rgb, B);
		#endif
	}
`;class GSplatCompressedShaderGenerator{generateKey(options){var _options$defines$sort,_options$defines;const vsHash=hashCode(options.vertex);const fsHash=hashCode(options.fragment);const defines=(_options$defines$sort=(_options$defines=options.defines)==null?void 0:_options$defines.sort().join("-"))!=null?_options$defines$sort:"";return `splat-${options.pass}-${options.gamma}-${options.toneMapping}-${vsHash}-${fsHash}-${options.dither}-${defines}`}createShaderDefinition(device,options){var _options$defines2;const shaderPassInfo=ShaderPass.get(device).getByIndex(options.pass);const shaderPassDefines=shaderPassInfo.shaderDefines;const optionDefines=((_options$defines2=options.defines)!=null?_options$defines2:[]).map(d=>`#define ${d}`).join("\n");const defines=`${shaderPassDefines}
`+`${optionDefines}
`+`#define DITHER_${options.dither.toUpperCase()}
`+`#define TONEMAP_${options.toneMapping===TONEMAP_LINEAR?"DISABLED":"ENABLED"}
`;const vs=defines+splatCoreVS+options.vertex;const fs=defines+shaderChunks.decodePS+(options.dither===DITHER_NONE?"":shaderChunks.bayerPS+shaderChunks.opacityDitherPS)+ShaderGenerator.tonemapCode(options.toneMapping)+ShaderGenerator.gammaCode(options.gamma)+splatCoreFS+options.fragment;return ShaderUtils.createDefinition(device,{name:"SplatShader",attributes:{vertex_position:SEMANTIC_POSITION,vertex_id_attrib:SEMANTIC_ATTR13},vertexCode:vs,fragmentCode:fs})}}const gsplatCompressed=new GSplatCompressedShaderGenerator;const splatMainVS=`
	varying mediump vec2 texCoord;
	varying mediump vec4 color;
	uniform vec3 view_position;
	mediump vec4 discardVec = vec4(0.0, 0.0, 2.0, 1.0);
	void main(void)
	{
		if (!calcSplatUV()) {
			gl_Position = discardVec;
			return;
		}
		readData();
		vec3 center = getCenter();
		mat4 model_view = matrix_view * matrix_model;
		vec4 splat_cam = model_view * vec4(center, 1.0);
		vec4 splat_proj = matrix_projection * splat_cam;
		if (splat_proj.z < -splat_proj.w) {
			gl_Position = discardVec;
			return;
		}
		vec3 covA, covB;
		getCovariance(covA, covB);
		vec4 v1v2 = calcV1V2(splat_cam.xyz, covA, covB, transpose(mat3(model_view)));
		color = getColor();
		float scale = min(1.0, sqrt(-log(1.0 / 255.0 / color.a)) / 2.0);
		v1v2 *= scale;
		if (dot(v1v2.xy, v1v2.xy) < 4.0 && dot(v1v2.zw, v1v2.zw) < 4.0) {
			gl_Position = discardVec;
			return;
		}
		gl_Position = splat_proj + vec4((vertex_position.x * v1v2.xy + vertex_position.y * v1v2.zw) / viewport * splat_proj.w, 0, 0);
		texCoord = vertex_position.xy * scale / 2.0;
		#ifdef USE_SH
			vec4 worldCenter = matrix_model * vec4(center, 1.0);
			vec3 viewDir = normalize((worldCenter.xyz / worldCenter.w - view_position) * mat3(matrix_model));
			color.xyz = max(color.xyz + evalSH(viewDir), 0.0);
		#endif
		#ifndef DITHER_NONE
			id = float(splatId);
		#endif
	}
`;const splatMainFS=`
	varying mediump vec2 texCoord;
	varying mediump vec4 color;
	void main(void)
	{
		gl_FragColor = evalSplat(texCoord, color);
	}
`;const createGSplatCompressedMaterial=(options={})=>{var _options$dither;const ditherEnum=(_options$dither=options.dither)!=null?_options$dither:DITHER_NONE;const dither=ditherEnum!==DITHER_NONE;const material=new Material;material.name="compressedSplatMaterial";material.cull=CULLFACE_NONE;material.blendType=dither?BLEND_NONE:BLEND_NORMAL;material.depthWrite=dither;material.getShaderVariant=function(device,scene,defs,unused,pass,sortedLights,viewUniformFormat,viewBindGroupFormat){var _options$vertex,_options$fragment;const programOptions={pass:pass,gamma:pass===SHADER_FORWARDHDR?scene.gammaCorrection?GAMMA_SRGBHDR:GAMMA_NONE:scene.gammaCorrection,toneMapping:pass===SHADER_FORWARDHDR?TONEMAP_LINEAR:scene.toneMapping,vertex:(_options$vertex=options.vertex)!=null?_options$vertex:splatMainVS,fragment:(_options$fragment=options.fragment)!=null?_options$fragment:splatMainFS,dither:ditherEnum,defines:options.defines};const processingOptions=new ShaderProcessorOptions(viewUniformFormat,viewBindGroupFormat);const library=getProgramLibrary(device);library.register("splat-compressed",gsplatCompressed);return library.getProgram("splat-compressed",programOptions,processingOptions)};material.update();return material};const strideCopy=(target,targetStride,src,srcStride,numEntries)=>{for(let i=0;i<numEntries;++i){for(let j=0;j<srcStride;++j){target[i*targetStride+j]=src[i*srcStride+j];}}};class GSplatCompressed{destroy(){var _this$packedTexture,_this$chunkTexture,_this$shTexture,_this$shTexture2,_this$shTexture3;(_this$packedTexture=this.packedTexture)==null||_this$packedTexture.destroy();(_this$chunkTexture=this.chunkTexture)==null||_this$chunkTexture.destroy();(_this$shTexture=this.shTexture0)==null||_this$shTexture.destroy();(_this$shTexture2=this.shTexture1)==null||_this$shTexture2.destroy();(_this$shTexture3=this.shTexture2)==null||_this$shTexture3.destroy();}createMaterial(options){const hasSH=this.shTexture0!==null;const result=createGSplatCompressedMaterial(_extends({},hasSH?{defines:["USE_SH"]}:{},options));result.setParameter("packedTexture",this.packedTexture);result.setParameter("chunkTexture",this.chunkTexture);result.setParameter("tex_params",new Float32Array([this.numSplats,this.packedTexture.width,this.chunkTexture.width/5,0]));if(hasSH){result.setParameter("shTexture0",this.shTexture0);result.setParameter("shTexture1",this.shTexture1);result.setParameter("shTexture2",this.shTexture2);}return result}evalTextureSize(count){const width=Math.ceil(Math.sqrt(count));const height=Math.ceil(count/width);return new Vec2(width,height)}createTexture(name,format,size,data){return new Texture(this.device,_extends({name:name,width:size.x,height:size.y,format:format,cubemap:false,mipmaps:false,minFilter:FILTER_NEAREST,magFilter:FILTER_NEAREST,addressU:ADDRESS_CLAMP_TO_EDGE,addressV:ADDRESS_CLAMP_TO_EDGE},data?{levels:[data]}:{}))}constructor(device,gsplatData){this.device=void 0;this.numSplats=void 0;this.aabb=void 0;this.centers=void 0;this.packedTexture=void 0;this.chunkTexture=void 0;this.shTexture0=void 0;this.shTexture1=void 0;this.shTexture2=void 0;const{chunkData,chunkSize,numChunks,numSplats,vertexData,shBands}=gsplatData;this.device=device;this.numSplats=numSplats;this.aabb=new BoundingBox;gsplatData.calcAabb(this.aabb);this.centers=new Float32Array(numSplats*3);gsplatData.getCenters(this.centers);this.packedTexture=this.createTexture("packedData",PIXELFORMAT_RGBA32U,this.evalTextureSize(numSplats),vertexData);const chunkTextureSize=this.evalTextureSize(numChunks);chunkTextureSize.x*=5;this.chunkTexture=this.createTexture("chunkData",PIXELFORMAT_RGBA32F,chunkTextureSize);const chunkTextureData=this.chunkTexture.lock();strideCopy(chunkTextureData,20,chunkData,chunkSize,numChunks);if(chunkSize===12){for(let i=0;i<numChunks;++i){chunkTextureData[i*20+15]=1;chunkTextureData[i*20+16]=1;chunkTextureData[i*20+17]=1;}}this.chunkTexture.unlock();if(shBands>0){const{shData}=gsplatData;const size=this.evalTextureSize(numSplats);const texture0=this.createTexture("shTexture0",PIXELFORMAT_RGBA32U,size);const texture1=this.createTexture("shTexture1",PIXELFORMAT_RGBA32U,size);const texture2=this.createTexture("shTexture2",PIXELFORMAT_RGBA32U,size);const data0=texture0.lock();const data1=texture1.lock();const data2=texture2.lock();const target0=new Uint8Array(data0.buffer);const target1=new Uint8Array(data1.buffer);const target2=new Uint8Array(data2.buffer);const srcCoeffs=[3,8,15][shBands-1];for(let i=0;i<numSplats;++i){for(let j=0;j<15;++j){target0[i*16+j]=j<srcCoeffs?shData[(i*3+0)*srcCoeffs+j]:127;target1[i*16+j]=j<srcCoeffs?shData[(i*3+1)*srcCoeffs+j]:127;target2[i*16+j]=j<srcCoeffs?shData[(i*3+2)*srcCoeffs+j]:127;}}texture0.unlock();texture1.unlock();texture2.unlock();this.shTexture0=texture0;this.shTexture1=texture1;this.shTexture2=texture2;}else {this.shTexture0=null;this.shTexture1=null;this.shTexture2=null;}}}class GSplatResource{destroy(){var _this$splat;this.device=null;this.splatData=null;(_this$splat=this.splat)==null||_this$splat.destroy();this.splat=null;}createSplat(){if(!this.splat){this.splat=this.splatData.isCompressed?new GSplatCompressed(this.device,this.splatData):new GSplat(this.device,this.splatData);}return this.splat}instantiate(options={}){const splatInstance=this.createInstance(options);const entity=new Entity;const component=entity.addComponent("gsplat",{instance:splatInstance});entity.setLocalEulerAngles(0,0,180);component.customAabb=splatInstance.splat.aabb.clone();return entity}createInstance(options={}){const splat=this.createSplat();return new GSplatInstance(splat,options)}constructor(device,splatData){this.device=void 0;this.splatData=void 0;this.splat=null;this.device=device;this.splatData=splatData;}}const magicBytes=new Uint8Array([112,108,121,10]);const endHeaderBytes=new Uint8Array([10,101,110,100,95,104,101,97,100,101,114,10]);const dataTypeMap=new Map([["char",Int8Array],["uchar",Uint8Array],["short",Int16Array],["ushort",Uint16Array],["int",Int32Array],["uint",Uint32Array],["float",Float32Array],["double",Float64Array]]);class StreamBuf{async read(){const{value,done}=await this.reader.read();if(done){throw new Error("Stream finished before end of header")}this.push(value);}push(data){if(!this.data){this.data=data;this.view=new DataView(this.data.buffer);this.tail=data.length;}else {const remaining=this.tail-this.head;const newSize=remaining+data.length;if(this.data.length>=newSize){if(this.head>0){this.data.copyWithin(0,this.head,this.tail);this.data.set(data,remaining);this.head=0;this.tail=newSize;}else {this.data.set(data,this.tail);this.tail+=data.length;}}else {const tmp=new Uint8Array(newSize);if(this.head>0||this.tail<this.data.length){tmp.set(this.data.subarray(this.head,this.tail),0);}else {tmp.set(this.data,0);}tmp.set(data,remaining);this.data=tmp;this.view=new DataView(this.data.buffer);this.head=0;this.tail=newSize;}}}compact(){if(this.head>0){this.data.copyWithin(0,this.head,this.tail);this.tail-=this.head;this.head=0;}}get remaining(){return this.tail-this.head}getInt8(){const result=this.view.getInt8(this.head);this.head++;return result}getUint8(){const result=this.view.getUint8(this.head);this.head++;return result}getInt16(){const result=this.view.getInt16(this.head,true);this.head+=2;return result}getUint16(){const result=this.view.getUint16(this.head,true);this.head+=2;return result}getInt32(){const result=this.view.getInt32(this.head,true);this.head+=4;return result}getUint32(){const result=this.view.getUint32(this.head,true);this.head+=4;return result}getFloat32(){const result=this.view.getFloat32(this.head,true);this.head+=4;return result}getFloat64(){const result=this.view.getFloat64(this.head,true);this.head+=8;return result}constructor(reader){this.reader=void 0;this.data=void 0;this.view=void 0;this.head=0;this.tail=0;this.reader=reader;}}const parseHeader=lines=>{const elements=[];let format;for(let i=1;i<lines.length;++i){const words=lines[i].split(" ");switch(words[0]){case"format":format=words[1];break;case"element":elements.push({name:words[1],count:parseInt(words[2],10),properties:[]});break;case"property":{if(!dataTypeMap.has(words[1])){throw new Error(`Unrecognized property data type '${words[1]}' in ply header`)}const element=elements[elements.length-1];element.properties.push({type:words[1],name:words[2],storage:null,byteSize:dataTypeMap.get(words[1]).BYTES_PER_ELEMENT});break}default:throw new Error(`Unrecognized header value '${words[0]}' in ply header`)}}return {elements,format}};const isCompressedPly=elements=>{const chunkProperties=["min_x","min_y","min_z","max_x","max_y","max_z","min_scale_x","min_scale_y","min_scale_z","max_scale_x","max_scale_y","max_scale_z","min_r","min_g","min_b","max_r","max_g","max_b"];const vertexProperties=["packed_position","packed_rotation","packed_scale","packed_color"];const shProperties=new Array(45).fill("").map((_,i)=>`f_rest_${i}`);const hasBaseElements=()=>{return elements[0].name==="chunk"&&elements[0].properties.every((p,i)=>p.name===chunkProperties[i]&&p.type==="float")&&elements[1].name==="vertex"&&elements[1].properties.every((p,i)=>p.name===vertexProperties[i]&&p.type==="uint")};const hasSHElements=()=>{return elements[2].name==="sh"&&[9,24,45].indexOf(elements[2].properties.length)!==-1&&elements[2].properties.every((p,i)=>p.name===shProperties[i]&&p.type==="uchar")};return elements.length===2&&hasBaseElements()||elements.length===3&&hasBaseElements()&&hasSHElements()};const isFloatPly=elements=>{return elements.length===1&&elements[0].name==="vertex"&&elements[0].properties.every(p=>p.type==="float")};const readCompressedPly=async(streamBuf,elements,littleEndian)=>{const result=new GSplatCompressedData;const numChunks=elements[0].count;const numChunkProperties=elements[0].properties.length;const numVertices=elements[1].count;const evalStorageSize=count=>{const width=Math.ceil(Math.sqrt(count));const height=Math.ceil(count/width);return width*height};result.numSplats=numVertices;result.chunkData=new Float32Array(numChunks*numChunkProperties);result.vertexData=new Uint32Array(evalStorageSize(numVertices)*4);const read=async(buffer,length)=>{const target=new Uint8Array(buffer);let cursor=0;while(cursor<length){while(streamBuf.remaining===0){await streamBuf.read();}const toCopy=Math.min(length-cursor,streamBuf.remaining);const src=streamBuf.data;for(let i=0;i<toCopy;++i){target[cursor++]=src[streamBuf.head++];}}};await read(result.chunkData.buffer,numChunks*numChunkProperties*4);await read(result.vertexData.buffer,numVertices*4*4);if(elements.length===3){result.shData=new Uint8Array(elements[2].count*elements[2].properties.length);await read(result.shData.buffer,result.shData.byteLength);}return result};const readFloatPly=async(streamBuf,elements,littleEndian)=>{const element=elements[0];const properties=element.properties;const numProperties=properties.length;const storage=properties.map(p=>p.storage);const inputSize=properties.reduce((a,p)=>a+p.byteSize,0);let vertexIdx=0;let floatData;const checkFloatData=()=>{var _floatData;const buffer=streamBuf.data.buffer;if(((_floatData=floatData)==null?void 0:_floatData.buffer)!==buffer){floatData=new Float32Array(buffer,0,buffer.byteLength/4);}};checkFloatData();while(vertexIdx<element.count){while(streamBuf.remaining<inputSize){await streamBuf.read();checkFloatData();}const toRead=Math.min(element.count-vertexIdx,Math.floor(streamBuf.remaining/inputSize));for(let j=0;j<numProperties;++j){const s=storage[j];for(let n=0;n<toRead;++n){s[n+vertexIdx]=floatData[n*numProperties+j];}}vertexIdx+=toRead;streamBuf.head+=toRead*inputSize;}return new GSplatData(elements)};const readGeneralPly=async(streamBuf,elements,littleEndian)=>{for(let i=0;i<elements.length;++i){const element=elements[i];const inputSize=element.properties.reduce((a,p)=>a+p.byteSize,0);const propertyParsingFunctions=element.properties.map(p=>{if(p.storage){switch(p.type){case"char":return (streamBuf,c)=>{p.storage[c]=streamBuf.getInt8();};case"uchar":return (streamBuf,c)=>{p.storage[c]=streamBuf.getUint8();};case"short":return (streamBuf,c)=>{p.storage[c]=streamBuf.getInt16();};case"ushort":return (streamBuf,c)=>{p.storage[c]=streamBuf.getUint16();};case"int":return (streamBuf,c)=>{p.storage[c]=streamBuf.getInt32();};case"uint":return (streamBuf,c)=>{p.storage[c]=streamBuf.getUint32();};case"float":return (streamBuf,c)=>{p.storage[c]=streamBuf.getFloat32();};case"double":return (streamBuf,c)=>{p.storage[c]=streamBuf.getFloat64();};default:throw new Error(`Unsupported property data type '${p.type}' in ply header`)}}else {return streamBuf=>{streamBuf.head+=p.byteSize;}}});let c=0;while(c<element.count){while(streamBuf.remaining<inputSize){await streamBuf.read();}const toRead=Math.min(element.count-c,Math.floor(streamBuf.remaining/inputSize));for(let n=0;n<toRead;++n){for(let j=0;j<element.properties.length;++j){propertyParsingFunctions[j](streamBuf,c);}c++;}}}return new GSplatData(elements)};const readPly=async(reader,propertyFilter=null)=>{const find=(buf,search)=>{const endIndex=buf.length-search.length;let i,j;for(i=0;i<=endIndex;++i){for(j=0;j<search.length;++j){if(buf[i+j]!==search[j]){break}}if(j===search.length){return i}}return -1};const startsWith=(a,b)=>{if(a.length<b.length){return false}for(let i=0;i<b.length;++i){if(a[i]!==b[i]){return false}}return true};const streamBuf=new StreamBuf(reader);let headerLength;while(true){await streamBuf.read();if(streamBuf.tail>=magicBytes.length&&!startsWith(streamBuf.data,magicBytes)){throw new Error("Invalid ply header")}headerLength=find(streamBuf.data,endHeaderBytes);if(headerLength!==-1){break}}const lines=new TextDecoder("ascii").decode(streamBuf.data.subarray(0,headerLength)).split("\n").filter(line=>!line.startsWith("comment "));const{elements,format}=parseHeader(lines);if(format!=="binary_little_endian"&&format!=="binary_big_endian"){throw new Error("Unsupported ply format")}streamBuf.head=headerLength+endHeaderBytes.length;streamBuf.compact();if(isCompressedPly(elements)){return await readCompressedPly(streamBuf,elements)}elements.forEach(e=>{e.properties.forEach(p=>{const storageType=dataTypeMap.get(p.type);if(storageType){const storage=!propertyFilter||propertyFilter(p.name)?new storageType(e.count):null;p.storage=storage;}});});if(isFloatPly(elements)){return await readFloatPly(streamBuf,elements)}return await readGeneralPly(streamBuf,elements)};const defaultElementFilter=val=>true;class PlyParser{async load(url,callback,asset){const response=await fetch(url.load);if(!response||!response.body){callback("Error loading resource",null);}else {var _asset$data$elementFi;readPly(response.body.getReader(),(_asset$data$elementFi=asset.data.elementFilter)!=null?_asset$data$elementFi:defaultElementFilter).then(gsplatData=>{if(!gsplatData.isCompressed){var _asset$data$reorder;if((_asset$data$reorder=asset.data.reorder)!=null?_asset$data$reorder:true){gsplatData.reorderData();}}const resource=new GSplatResource(this.device,gsplatData.isCompressed&&asset.data.decompress?gsplatData.decompress():gsplatData);callback(null,resource);}).catch(err=>{callback(err,null);});}}open(url,data){return data}constructor(device,assets,maxRetries){this.device=void 0;this.assets=void 0;this.maxRetries=void 0;this.device=device;this.assets=assets;this.maxRetries=maxRetries;}}class GSplatHandler extends ResourceHandler{load(url,callback,asset){if(typeof url==="string"){url={load:url,original:url};}this.parser.load(url,callback,asset);}open(url,data,asset){return this.parser.open(url,data,asset)}constructor(app){super(app,"gsplat");this.parser=new PlyParser(app.graphicsDevice,app.assets,3);}}class CompressUtils{static setCompressedPRS(entity,data,compressed){const a=compressed.singleVecs;let b,i;const v=data.___1;if(!v){b=compressed.tripleVecs;i=data.___2;}let n=v?v[0]:b[i];entity.setLocalPosition(a[n],a[n+1],a[n+2]);n=v?v[1]:b[i+1];entity.setLocalEulerAngles(a[n],a[n+1],a[n+2]);n=v?v[2]:b[i+2];entity.setLocalScale(a[n],a[n+1],a[n+2]);}static oneCharToKey(s,data){const i=s.charCodeAt(0)-data.fieldFirstCode;return data.fieldArray[i]}static multCharToKey(s,data){let ind=0;for(let i=0;i<s.length;i++){ind=ind*data.fieldCodeBase+s.charCodeAt(i)-data.fieldFirstCode;}return data.fieldArray[ind]}}class Decompress{run(){const type=Object.prototype.toString.call(this._node);if(type==="[object Object]"){this._handleMap();}else if(type==="[object Array]"){this._handleArray();}else {this._result=this._node;}return this._result}_handleMap(){this._result={};const a=Object.keys(this._node);a.forEach(this._handleKey,this);}_handleKey(origKey){let newKey=origKey;const len=origKey.length;if(len===1){newKey=CompressUtils.oneCharToKey(origKey,this._data);}else if(len===2){newKey=CompressUtils.multCharToKey(origKey,this._data);}this._result[newKey]=new Decompress(this._node[origKey],this._data).run();}_handleArray(){this._result=[];this._node.forEach(this._handleArElt,this);}_handleArElt(elt){const v=new Decompress(elt,this._data).run();this._result.push(v);}constructor(node,data){this._node=node;this._data=data;}}class SceneParser{parse(data){const entities={};let parent=null;const compressed=data.compressedFormat;if(compressed&&!data.entDecompressed){data.entDecompressed=true;data.entities=new Decompress(data.entities,compressed).run();}for(const id in data.entities){const curData=data.entities[id];const curEnt=this._createEntity(curData,compressed);entities[id]=curEnt;if(curData.parent===null){parent=curEnt;}}for(const id in data.entities){const curEnt=entities[id];const children=data.entities[id].children;const len=children.length;for(let i=0;i<len;i++){const childEnt=entities[children[i]];if(childEnt){curEnt.addChild(childEnt);}}}this._openComponentData(parent,data.entities);return parent}_createEntity(data,compressed){var _data$enabled;const entity=new Entity(data.name,this._app);entity.setGuid(data.resource_id);this._setPosRotScale(entity,data,compressed);entity._enabled=(_data$enabled=data.enabled)!=null?_data$enabled:true;if(this._isTemplate){entity._template=true;}else {entity._enabledInHierarchy=entity._enabled;}entity.template=data.template;if(data.tags){for(let i=0;i<data.tags.length;i++){entity.tags.add(data.tags[i]);}}if(data.labels){data.labels.forEach(label=>{entity.addLabel(label);});}return entity}_setPosRotScale(entity,data,compressed){if(compressed){CompressUtils.setCompressedPRS(entity,data,compressed);}else {const p=data.position;const r=data.rotation;const s=data.scale;entity.setLocalPosition(p[0],p[1],p[2]);entity.setLocalEulerAngles(r[0],r[1],r[2]);entity.setLocalScale(s[0],s[1],s[2]);}}_openComponentData(entity,entities){const systemsList=this._app.systems.list;let len=systemsList.length;const entityData=entities[entity.getGuid()];for(let i=0;i<len;i++){const system=systemsList[i];const componentData=entityData.components[system.id];if(componentData){system.addComponent(entity,componentData);}}len=entityData.children.length;const children=entity._children;for(let i=0;i<len;i++){if(children[i]){children[i]=this._openComponentData(children[i],entities);}}return entity}constructor(app,isTemplate){this._app=app;this._isTemplate=isTemplate;}}class SceneUtils{static load(url,maxRetries,callback){if(typeof url==="string"){url={load:url,original:url};}http.get(url.load,{retry:maxRetries>0,maxRetries:maxRetries},(err,response)=>{if(!err){callback(err,response);}else {let errMsg=`Error while loading scene JSON ${url.original}`;if(err.message){errMsg+=`: ${err.message}`;if(err.stack){errMsg+=`
${err.stack}`;}}else {errMsg+=`: ${err}`;}callback(errMsg);}});}}class HierarchyHandler extends ResourceHandler{load(url,callback){SceneUtils.load(url,this.maxRetries,callback);}open(url,data){this._app.systems.script.preloading=true;const parser=new SceneParser(this._app,false);const parent=parser.parse(data);this._app.systems.script.preloading=false;return parent}constructor(app){super(app,"hierarchy");}}class HtmlHandler extends ResourceHandler{load(url,callback){if(typeof url==="string"){url={load:url,original:url};}http.get(url.load,{retry:this.maxRetries>0,maxRetries:this.maxRetries},(err,response)=>{if(!err){callback(null,response);}else {callback(`Error loading html resource: ${url.original} [${err}]`);}});}openBinary(data){var _this$decoder;(_this$decoder=this.decoder)!=null?_this$decoder:this.decoder=new TextDecoder("utf-8");return this.decoder.decode(data)}constructor(app){super(app,"html");this.decoder=null;}}class JsonHandler extends ResourceHandler{load(url,callback){if(typeof url==="string"){url={load:url,original:url};}const options={retry:this.maxRetries>0,maxRetries:this.maxRetries};if(url.load.startsWith("blob:")){options.responseType=Http.ResponseType.JSON;}http.get(url.load,options,(err,response)=>{if(!err){callback(null,response);}else {callback(`Error loading JSON resource: ${url.original} [${err}]`);}});}openBinary(data){var _this$decoder;(_this$decoder=this.decoder)!=null?_this$decoder:this.decoder=new TextDecoder("utf-8");return JSON.parse(this.decoder.decode(data))}constructor(app){super(app,"json");this.decoder=null;}}class StandardMaterialValidator{setInvalid(key,data){this.valid=false;if(this.removeInvalid){delete data[key];}}validate(data){const TYPES=standardMaterialParameterTypes;const REMOVED=standardMaterialRemovedParameters;const pathMapping=data.mappingFormat==="path";for(const key in data){const type=TYPES[key];if(!type){if(REMOVED[key]){delete data[key];}else {this.valid=false;}continue}if(type.startsWith("enum")){const enumType=type.split(":")[1];if(this.enumValidators[enumType]){if(!this.enumValidators[enumType](data[key])){this.setInvalid(key,data);}}}else if(type==="number"){if(typeof data[key]!=="number"){this.setInvalid(key,data);}}else if(type==="boolean"){if(typeof data[key]!=="boolean"){this.setInvalid(key,data);}}else if(type==="string"){if(typeof data[key]!=="string"){this.setInvalid(key,data);}}else if(type==="vec2"){if(!(data[key]instanceof Array&&data[key].length===2)){this.setInvalid(key,data);}}else if(type==="rgb"){if(!(data[key]instanceof Array&&data[key].length===3)){this.setInvalid(key,data);}}else if(type==="texture"){if(!pathMapping){if(!(typeof data[key]==="number"||data[key]===null)){if(!(data[key]instanceof Texture)){this.setInvalid(key,data);}}}else {if(!(typeof data[key]==="string"||data[key]===null)){if(!(data[key]instanceof Texture)){this.setInvalid(key,data);}}}}else if(type==="boundingbox"){if(!(data[key].center&&data[key].center instanceof Array&&data[key].center.length===3)){this.setInvalid(key,data);}if(!(data[key].halfExtents&&data[key].halfExtents instanceof Array&&data[key].halfExtents.length===3)){this.setInvalid(key,data);}}else if(type==="cubemap"){if(!(typeof data[key]==="number"||data[key]===null||data[key]===undefined)){if(!(data[key]instanceof Texture&&data[key].cubemap)){this.setInvalid(key,data);}}}else if(type==="chunks"){const chunkNames=Object.keys(data[key]);for(let i=0;i<chunkNames.length;i++){if(typeof data[key][chunkNames[i]]!=="string"){this.setInvalid(chunkNames[i],data[key]);}}}else {console.error(`Unknown material type: ${type}`);}}data.validated=true;return this.valid}_createEnumValidator(values){return function(value){return values.indexOf(value)>=0}}constructor(){this.removeInvalid=true;this.valid=true;this.enumValidators={occludeSpecular:this._createEnumValidator([SPECOCC_NONE,SPECOCC_AO,SPECOCC_GLOSSDEPENDENT]),cull:this._createEnumValidator([CULLFACE_NONE,CULLFACE_BACK,CULLFACE_FRONT,CULLFACE_FRONTANDBACK]),blendType:this._createEnumValidator([BLEND_SUBTRACTIVE,BLEND_ADDITIVE,BLEND_NORMAL,BLEND_NONE,BLEND_PREMULTIPLIED,BLEND_MULTIPLICATIVE,BLEND_ADDITIVEALPHA,BLEND_MULTIPLICATIVE2X,BLEND_SCREEN,BLEND_MIN,BLEND_MAX]),depthFunc:this._createEnumValidator([FUNC_NEVER,FUNC_LESS,FUNC_EQUAL,FUNC_LESSEQUAL,FUNC_GREATER,FUNC_NOTEQUAL,FUNC_GREATEREQUAL,FUNC_ALWAYS]),shadingModel:this._createEnumValidator([SPECULAR_PHONG,SPECULAR_BLINN])};}}class JsonStandardMaterialParser{parse(input){const migrated=this.migrate(input);const validated=this._validate(migrated);const material=new StandardMaterial;this.initialize(material,validated);return material}initialize(material,data){if(!data.validated){data=this._validate(data);}if(data.chunks){material.chunks=_extends({},data.chunks);}for(const key in data){const type=standardMaterialParameterTypes[key];const value=data[key];if(type==="vec2"){material[key]=new Vec2(value[0],value[1]);}else if(type==="rgb"){material[key]=new Color(value[0],value[1],value[2]);}else if(type==="texture"){if(value instanceof Texture){material[key]=value;}else if(!(material[key]instanceof Texture&&typeof value==="number"&&value>0)){material[key]=null;}}else if(type==="cubemap"){if(value instanceof Texture){material[key]=value;}else if(!(material[key]instanceof Texture&&typeof value==="number"&&value>0)){material[key]=null;}if(key==="cubeMap"&&!value){material.prefilteredCubemaps=null;}}else if(type==="boundingbox"){const center=new Vec3(value.center[0],value.center[1],value.center[2]);const halfExtents=new Vec3(value.halfExtents[0],value.halfExtents[1],value.halfExtents[2]);material[key]=new BoundingBox(center,halfExtents);}else {material[key]=data[key];}}material.update();}migrate(data){if(data.shader){data.shadingModel=data.shader==="blinn"?SPECULAR_BLINN:SPECULAR_PHONG;delete data.shader;}else if(data.shadingModel===undefined){data.shadingModel=SPECULAR_BLINN;}if(data.mapping_format){data.mappingFormat=data.mapping_format;delete data.mapping_format;}let i;const RENAMED_PROPERTIES=[["bumpMapFactor","bumpiness"],["aoUvSet","aoMapUv"],["aoMapVertexColor","aoVertexColor"],["diffuseMapVertexColor","diffuseVertexColor"],["emissiveMapVertexColor","emissiveVertexColor"],["specularMapVertexColor","specularVertexColor"],["metalnessMapVertexColor","metalnessVertexColor"],["opacityMapVertexColor","opacityVertexColor"],["glossMapVertexColor","glossVertexColor"],["lightMapVertexColor","lightVertexColor"],["diffuseMapTint","diffuseTint"],["specularMapTint","specularTint"],["emissiveMapTint","emissiveTint"],["metalnessMapTint","metalnessTint"],["clearCoatGlossiness","clearCoatGloss"]];for(i=0;i<RENAMED_PROPERTIES.length;i++){const _old=RENAMED_PROPERTIES[i][0];const _new=RENAMED_PROPERTIES[i][1];if(data[_old]!==undefined){if(data[_new]===undefined){data[_new]=data[_old];}delete data[_old];}}const DEPRECATED_PROPERTIES=["fresnelFactor","shadowSampleType"];for(i=0;i<DEPRECATED_PROPERTIES.length;i++){const name=DEPRECATED_PROPERTIES[i];if(data.hasOwnProperty(name)){delete data[name];}}__adjustStandardMaterialData(data);return data}_validate(data){if(!data.validated){if(!this._validator){this._validator=new StandardMaterialValidator;}this._validator.validate(data);}return data}constructor(){this._validator=null;}}const PLACEHOLDER_MAP={aoMap:"white",diffuseMap:"gray",specularMap:"gray",specularityFactorMap:"white",metalnessMap:"black",glossMap:"gray",sheenMap:"black",sheenGlossinessMap:"gray",clearCoatMap:"black",clearCoatGlossMap:"gray",clearCoatNormalMap:"normal",refractionMap:"white",emissiveMap:"gray",normalMap:"normal",heightMap:"gray",opacityMap:"gray",sphereMap:"gray",lightMap:"white"};class MaterialHandler extends ResourceHandler{load(url,callback){if(typeof url==="string"){url={load:url,original:url};}http.get(url.load,{retry:this.maxRetries>0,maxRetries:this.maxRetries},(err,response)=>{if(!err){if(callback){response._engine=true;callback(null,response);}}else {if(callback){callback(`Error loading material: ${url.original} [${err}]`);}}});}open(url,data){const material=this._parser.parse(data);if(data._engine){material._data=data;delete data._engine;}return material}_createPlaceholders(){this._placeholderTextures={};const textures={white:[255,255,255,255],gray:[128,128,128,255],black:[0,0,0,255],normal:[128,128,255,255]};for(const key in textures){if(!textures.hasOwnProperty(key)){continue}this._placeholderTextures[key]=new Texture(this._device,{width:2,height:2,format:PIXELFORMAT_RGBA8,name:"material_placeholder"});const pixels=this._placeholderTextures[key].lock();for(let i=0;i<4;i++){for(let c=0;c<4;c++){pixels[i*4+c]=textures[key][c];}}this._placeholderTextures[key].unlock();}}patch(asset,assets){if(asset.resource._data){asset._data=asset.resource._data;delete asset.resource._data;}asset.data.name=asset.name;asset.resource.name=asset.name;this._bindAndAssignAssets(asset,assets);asset.off("unload",this._onAssetUnload,this);asset.on("unload",this._onAssetUnload,this);}_onAssetUnload(asset){delete asset.data.parameters;delete asset.data.chunks;delete asset.data.name;}_assignTexture(parameterName,materialAsset,texture){materialAsset.resource[parameterName]=texture;}_getPlaceholderTexture(parameterName){if(!this._placeholderTextures){this._createPlaceholders();}const placeholder=PLACEHOLDER_MAP[parameterName];const texture=this._placeholderTextures[placeholder];return texture}_assignPlaceholderTexture(parameterName,materialAsset){materialAsset.resource[parameterName]=this._getPlaceholderTexture(parameterName);}_onTextureLoad(parameterName,materialAsset,textureAsset){this._assignTexture(parameterName,materialAsset,textureAsset.resource);materialAsset.resource.update();}_onTextureAdd(parameterName,materialAsset,textureAsset){this._assets.load(textureAsset);}_onTextureRemoveOrUnload(parameterName,materialAsset,textureAsset){const material=materialAsset.resource;if(material){if(materialAsset.resource[parameterName]===textureAsset.resource){this._assignPlaceholderTexture(parameterName,materialAsset);material.update();}}}_assignCubemap(parameterName,materialAsset,textures){materialAsset.resource[parameterName]=textures[0];if(parameterName==="cubeMap"){const prefiltered=textures.slice(1);if(prefiltered.every(t=>t)){materialAsset.resource.prefilteredCubemaps=prefiltered;}else if(prefiltered[0]){materialAsset.resource.envAtlas=prefiltered[0];}}}_onCubemapLoad(parameterName,materialAsset,cubemapAsset){this._assignCubemap(parameterName,materialAsset,cubemapAsset.resources);this._parser.initialize(materialAsset.resource,materialAsset.data);}_onCubemapAdd(parameterName,materialAsset,cubemapAsset){if(materialAsset.data.shadingModel===SPECULAR_PHONG){materialAsset.loadFaces=true;}this._assets.load(cubemapAsset);}_onCubemapRemoveOrUnload(parameterName,materialAsset,cubemapAsset){const material=materialAsset.resource;if(materialAsset.data.prefilteredCubeMap128===cubemapAsset.resources[1]){this._assignCubemap(parameterName,materialAsset,[null,null,null,null,null,null,null]);material.update();}}_bindAndAssignAssets(materialAsset,assets){const data=this._parser.migrate(materialAsset.data);const material=materialAsset.resource;const pathMapping=data.mappingFormat==="path";const TEXTURES=standardMaterialTextureParameters;let i,name,assetReference;for(i=0;i<TEXTURES.length;i++){name=TEXTURES[i];assetReference=material._assetReferences[name];const dataAssetId=data[name];const materialTexture=material[name];const isPlaceHolderTexture=materialTexture===this._getPlaceholderTexture(name);const dataValidated=data.validated;if(dataAssetId&&(!materialTexture||!dataValidated||isPlaceHolderTexture)){if(!assetReference){assetReference=new AssetReference(name,materialAsset,assets,{load:this._onTextureLoad,add:this._onTextureAdd,remove:this._onTextureRemoveOrUnload,unload:this._onTextureRemoveOrUnload},this);material._assetReferences[name]=assetReference;}if(pathMapping){assetReference.url=materialAsset.getAbsoluteUrl(dataAssetId);}else {assetReference.id=dataAssetId;}if(assetReference.asset){if(assetReference.asset.resource){this._assignTexture(name,materialAsset,assetReference.asset.resource);}else {this._assignPlaceholderTexture(name,materialAsset);}assets.load(assetReference.asset);}}else {if(assetReference){if(pathMapping){assetReference.url=null;}else {assetReference.id=null;}}}}const CUBEMAPS=standardMaterialCubemapParameters;for(i=0;i<CUBEMAPS.length;i++){name=CUBEMAPS[i];assetReference=material._assetReferences[name];if(data[name]&&!materialAsset.data.prefilteredCubeMap128){if(!assetReference){assetReference=new AssetReference(name,materialAsset,assets,{load:this._onCubemapLoad,add:this._onCubemapAdd,remove:this._onCubemapRemoveOrUnload,unload:this._onCubemapRemoveOrUnload},this);material._assetReferences[name]=assetReference;}if(pathMapping){assetReference.url=data[name];}else {assetReference.id=data[name];}if(assetReference.asset){if(assetReference.asset.loaded){this._assignCubemap(name,materialAsset,assetReference.asset.resources);}assets.load(assetReference.asset);}}}this._parser.initialize(material,data);}constructor(app){super(app,"material");this._assets=app.assets;this._device=app.graphicsDevice;this._placeholderTextures=null;this._parser=new JsonStandardMaterialParser;}}class GlbModelParser{parse(data,callback,asset){var _asset$options;GlbParser.parse("filename.glb","",data,this._device,this._assets,(_asset$options=asset==null?void 0:asset.options)!=null?_asset$options:{},(err,result)=>{if(err){callback(err);}else {const model=GlbContainerResource.createModel(result,this._defaultMaterial);result.destroy();callback(null,model);}});}constructor(modelHandler){this._device=modelHandler.device;this._defaultMaterial=modelHandler.defaultMaterial;this._assets=modelHandler.assets;}}const JSON_PRIMITIVE_TYPE={"points":PRIMITIVE_POINTS,"lines":PRIMITIVE_LINES,"lineloop":PRIMITIVE_LINELOOP,"linestrip":PRIMITIVE_LINESTRIP,"triangles":PRIMITIVE_TRIANGLES,"trianglestrip":PRIMITIVE_TRISTRIP,"trianglefan":PRIMITIVE_TRIFAN};const JSON_VERTEX_ELEMENT_TYPE={"int8":TYPE_INT8,"uint8":TYPE_UINT8,"int16":TYPE_INT16,"uint16":TYPE_UINT16,"int32":TYPE_INT32,"uint32":TYPE_UINT32,"float32":TYPE_FLOAT32};class JsonModelParser{parse(data,callback){const modelData=data.model;if(!modelData){callback(null,null);return}if(modelData.version<=1){callback("JsonModelParser#parse: Trying to parse unsupported model format.");return}const nodes=this._parseNodes(data);const skins=this._parseSkins(data,nodes);const vertexBuffers=this._parseVertexBuffers(data);const indices=this._parseIndexBuffers(data,vertexBuffers);const morphs=this._parseMorphs(data,nodes,vertexBuffers);const meshes=this._parseMeshes(data,skins.skins,morphs.morphs,vertexBuffers,indices.buffer,indices.data);const meshInstances=this._parseMeshInstances(data,nodes,meshes,skins.skins,skins.instances,morphs.morphs,morphs.instances);const model=new Model;model.graph=nodes[0];model.meshInstances=meshInstances;model.skinInstances=skins.instances;model.morphInstances=morphs.instances;model.getGraph().syncHierarchy();callback(null,model);}_parseNodes(data){const modelData=data.model;const nodes=[];let i;for(i=0;i<modelData.nodes.length;i++){const nodeData=modelData.nodes[i];const node=new GraphNode(nodeData.name);node.setLocalPosition(nodeData.position[0],nodeData.position[1],nodeData.position[2]);node.setLocalEulerAngles(nodeData.rotation[0],nodeData.rotation[1],nodeData.rotation[2]);node.setLocalScale(nodeData.scale[0],nodeData.scale[1],nodeData.scale[2]);node.scaleCompensation=!!nodeData.scaleCompensation;nodes.push(node);}for(i=1;i<modelData.parents.length;i++){nodes[modelData.parents[i]].addChild(nodes[i]);}return nodes}_parseSkins(data,nodes){const modelData=data.model;const skins=[];const skinInstances=[];let i,j;for(i=0;i<modelData.skins.length;i++){const skinData=modelData.skins[i];const inverseBindMatrices=[];for(j=0;j<skinData.inverseBindMatrices.length;j++){const ibm=skinData.inverseBindMatrices[j];inverseBindMatrices[j]=new Mat4().set(ibm);}const skin=new Skin(this._device,inverseBindMatrices,skinData.boneNames);skins.push(skin);const skinInstance=new SkinInstance(skin);const bones=[];for(j=0;j<skin.boneNames.length;j++){const boneName=skin.boneNames[j];const bone=nodes[0].findByName(boneName);bones.push(bone);}skinInstance.bones=bones;skinInstances.push(skinInstance);}return {skins:skins,instances:skinInstances}}_getMorphVertexCount(modelData,morphIndex,vertexBuffers){for(let i=0;i<modelData.meshes.length;i++){const meshData=modelData.meshes[i];if(meshData.morph===morphIndex){const vertexBuffer=vertexBuffers[meshData.vertices];return vertexBuffer.numVertices}}return undefined}_parseMorphs(data,nodes,vertexBuffers){const modelData=data.model;const morphs=[];const morphInstances=[];let i,j,vertexCount;let targets,morphTarget,morphTargetArray;if(modelData.morphs){const sparseToFull=function sparseToFull(data,indices,totalCount){const full=new Float32Array(totalCount*3);for(let s=0;s<indices.length;s++){const dstIndex=indices[s]*3;full[dstIndex]=data[s*3];full[dstIndex+1]=data[s*3+1];full[dstIndex+2]=data[s*3+2];}return full};for(i=0;i<modelData.morphs.length;i++){targets=modelData.morphs[i].targets;morphTargetArray=[];vertexCount=this._getMorphVertexCount(modelData,i,vertexBuffers);for(j=0;j<targets.length;j++){const targetAabb=targets[j].aabb;const min=targetAabb.min;const max=targetAabb.max;const aabb=new BoundingBox(new Vec3((max[0]+min[0])*.5,(max[1]+min[1])*.5,(max[2]+min[2])*.5),new Vec3((max[0]-min[0])*.5,(max[1]-min[1])*.5,(max[2]-min[2])*.5));const indices=targets[j].indices;let deltaPositions=targets[j].deltaPositions;let deltaNormals=targets[j].deltaNormals;if(indices){deltaPositions=sparseToFull(deltaPositions,indices,vertexCount);deltaNormals=sparseToFull(deltaNormals,indices,vertexCount);}morphTarget=new MorphTarget({deltaPositions:deltaPositions,deltaNormals:deltaNormals,name:targets[j].name,aabb:aabb});morphTargetArray.push(morphTarget);}const morph=new Morph(morphTargetArray,this._device);morphs.push(morph);const morphInstance=new MorphInstance(morph);morphInstances.push(morphInstance);}}return {morphs:morphs,instances:morphInstances}}_parseVertexBuffers(data){const modelData=data.model;const vertexBuffers=[];const attributeMap={position:SEMANTIC_POSITION,normal:SEMANTIC_NORMAL,tangent:SEMANTIC_TANGENT,blendWeight:SEMANTIC_BLENDWEIGHT,blendIndices:SEMANTIC_BLENDINDICES,color:SEMANTIC_COLOR,texCoord0:SEMANTIC_TEXCOORD0,texCoord1:SEMANTIC_TEXCOORD1,texCoord2:SEMANTIC_TEXCOORD2,texCoord3:SEMANTIC_TEXCOORD3,texCoord4:SEMANTIC_TEXCOORD4,texCoord5:SEMANTIC_TEXCOORD5,texCoord6:SEMANTIC_TEXCOORD6,texCoord7:SEMANTIC_TEXCOORD7};for(let i=0;i<modelData.vertices.length;i++){const vertexData=modelData.vertices[i];const formatDesc=[];for(const attributeName in vertexData){const attribute=vertexData[attributeName];formatDesc.push({semantic:attributeMap[attributeName],components:attribute.components,type:JSON_VERTEX_ELEMENT_TYPE[attribute.type],normalize:attributeMap[attributeName]===SEMANTIC_COLOR});}const vertexFormat=new VertexFormat(this._device,formatDesc);const numVertices=vertexData.position.data.length/vertexData.position.components;const vertexBuffer=new VertexBuffer(this._device,vertexFormat,numVertices);const iterator=new VertexIterator(vertexBuffer);for(let j=0;j<numVertices;j++){for(const attributeName in vertexData){const attribute=vertexData[attributeName];switch(attribute.components){case 1:iterator.element[attributeMap[attributeName]].set(attribute.data[j]);break;case 2:iterator.element[attributeMap[attributeName]].set(attribute.data[j*2],1-attribute.data[j*2+1]);break;case 3:iterator.element[attributeMap[attributeName]].set(attribute.data[j*3],attribute.data[j*3+1],attribute.data[j*3+2]);break;case 4:iterator.element[attributeMap[attributeName]].set(attribute.data[j*4],attribute.data[j*4+1],attribute.data[j*4+2],attribute.data[j*4+3]);break}}iterator.next();}iterator.end();vertexBuffers.push(vertexBuffer);}return vertexBuffers}_parseIndexBuffers(data,vertexBuffers){const modelData=data.model;let indexBuffer=null;let indexData=null;let i;let numIndices=0;for(i=0;i<modelData.meshes.length;i++){const meshData=modelData.meshes[i];if(meshData.indices!==undefined){numIndices+=meshData.indices.length;}}let maxVerts=0;for(i=0;i<vertexBuffers.length;i++){maxVerts=Math.max(maxVerts,vertexBuffers[i].numVertices);}if(numIndices>0){if(maxVerts>65535&&this._device.extUintElement){indexBuffer=new IndexBuffer(this._device,INDEXFORMAT_UINT32,numIndices);indexData=new Uint32Array(indexBuffer.lock());}else {indexBuffer=new IndexBuffer(this._device,INDEXFORMAT_UINT16,numIndices);indexData=new Uint16Array(indexBuffer.lock());}}return {buffer:indexBuffer,data:indexData}}_parseMeshes(data,skins,morphs,vertexBuffers,indexBuffer,indexData){const modelData=data.model;const meshes=[];let indexBase=0;for(let i=0;i<modelData.meshes.length;i++){const meshData=modelData.meshes[i];const meshAabb=meshData.aabb;const min=meshAabb.min;const max=meshAabb.max;const aabb=new BoundingBox(new Vec3((max[0]+min[0])*.5,(max[1]+min[1])*.5,(max[2]+min[2])*.5),new Vec3((max[0]-min[0])*.5,(max[1]-min[1])*.5,(max[2]-min[2])*.5));const indexed=meshData.indices!==undefined;const mesh=new Mesh(this._device);mesh.vertexBuffer=vertexBuffers[meshData.vertices];mesh.indexBuffer[0]=indexed?indexBuffer:null;mesh.primitive[0].type=JSON_PRIMITIVE_TYPE[meshData.type];mesh.primitive[0].base=indexed?meshData.base+indexBase:meshData.base;mesh.primitive[0].count=meshData.count;mesh.primitive[0].indexed=indexed;mesh.skin=meshData.skin!==undefined?skins[meshData.skin]:null;mesh.morph=meshData.morph!==undefined?morphs[meshData.morph]:null;mesh.aabb=aabb;if(indexed){indexData.set(meshData.indices,indexBase);indexBase+=meshData.indices.length;}meshes.push(mesh);}if(indexBuffer!==null){indexBuffer.unlock();}return meshes}_parseMeshInstances(data,nodes,meshes,skins,skinInstances,morphs,morphInstances){const modelData=data.model;const meshInstances=[];let i;for(i=0;i<modelData.meshInstances.length;i++){const meshInstanceData=modelData.meshInstances[i];const node=nodes[meshInstanceData.node];const mesh=meshes[meshInstanceData.mesh];const meshInstance=new MeshInstance(mesh,this._defaultMaterial,node);if(mesh.skin){const skinIndex=skins.indexOf(mesh.skin);meshInstance.skinInstance=skinInstances[skinIndex];}if(mesh.morph){const morphIndex=morphs.indexOf(mesh.morph);meshInstance.morphInstance=morphInstances[morphIndex];}meshInstances.push(meshInstance);}return meshInstances}constructor(modelHandler){this._device=modelHandler.device;this._defaultMaterial=modelHandler.defaultMaterial;}}class ModelHandler extends ResourceHandler{load(url,callback,asset){if(typeof url==="string"){url={load:url,original:url};}const options={retry:this.maxRetries>0,maxRetries:this.maxRetries};if(url.load.startsWith("blob:")||url.load.startsWith("data:")){if(path.getExtension(url.original).toLowerCase()===".glb"){options.responseType=Http.ResponseType.ARRAY_BUFFER;}else {options.responseType=Http.ResponseType.JSON;}}http.get(url.load,options,(err,response)=>{if(!callback){return}if(!err){for(let i=0;i<this._parsers.length;i++){const p=this._parsers[i];if(p.decider(url.original,response)){p.parser.parse(response,(err,parseResult)=>{if(err){callback(err);}else {callback(null,parseResult);}},asset);return}}callback("No parsers found");}else {callback(`Error loading model: ${url.original} [${err}]`);}});}open(url,data){return data}patch(asset,assets){if(!asset.resource){return}const data=asset.data;const self1=this;asset.resource.meshInstances.forEach((meshInstance,i)=>{if(data.mapping){const handleMaterial=function handleMaterial(asset){if(asset.resource){meshInstance.material=asset.resource;}else {asset.once("load",handleMaterial);assets.load(asset);}asset.once("remove",asset=>{if(meshInstance.material===asset.resource){meshInstance.material=self1.defaultMaterial;}});};if(!data.mapping[i]){meshInstance.material=self1.defaultMaterial;return}const id=data.mapping[i].material;const url=data.mapping[i].path;let material;if(id!==undefined){if(!id){meshInstance.material=self1.defaultMaterial;}else {material=assets.get(id);if(material){handleMaterial(material);}else {assets.once(`add:${id}`,handleMaterial);}}}else if(url){const path=asset.getAbsoluteUrl(data.mapping[i].path);material=assets.getByUrl(path);if(material){handleMaterial(material);}else {assets.once(`add:url:${path}`,handleMaterial);}}}});}addParser(parser,decider){this._parsers.push({parser:parser,decider:decider});}constructor(app){super(app,"model");this._parsers=[];this.device=app.graphicsDevice;this.assets=app.assets;this.defaultMaterial=getDefaultMaterial(this.device);this.addParser(new JsonModelParser(this),(url,data)=>{return path.getExtension(url)===".json"});this.addParser(new GlbModelParser(this),(url,data)=>{return path.getExtension(url)===".glb"});}}class SceneHandler extends ResourceHandler{load(url,callback){SceneUtils.load(url,this.maxRetries,callback);}open(url,data){this._app.systems.script.preloading=true;const parser=new SceneParser(this._app,false);const parent=parser.parse(data);const scene=this._app.scene;scene.root=parent;this._app.applySceneSettings(data.settings);this._app.systems.script.preloading=false;return scene}constructor(app){super(app,"scene");}}const reservedScriptNames=new Set(["system","entity","create","destroy","swap","move","data","scripts","_scripts","_scriptsIndex","_scriptsData","enabled","_oldState","onEnable","onDisable","onPostStateChange","_onSetEnabled","_checkState","_onBeforeRemove","_onInitializeAttributes","_onInitialize","_onPostInitialize","_onUpdate","_onPostUpdate","_callbacks","_callbackActive","has","get","on","off","fire","once","hasEvent"]);function getReservedScriptNames(){return reservedScriptNames}function createScript(name,app){if(reservedScriptNames.has(name)){throw new Error(`Script name '${name}' is reserved, please rename the script`)}const scriptType=function scriptType(args){EventHandler.prototype.initEventHandler.call(this);ScriptType.prototype.initScriptType.call(this,args);};scriptType.prototype=Object.create(ScriptType.prototype);scriptType.prototype.constructor=scriptType;scriptType.extend=ScriptType.extend;scriptType.attributes=new ScriptAttributes(scriptType);registerScript(scriptType,name,app);return scriptType}const reservedAttributes={};ScriptAttributes.reservedNames.forEach((value,value2,set)=>{reservedAttributes[value]=1;});createScript.reservedAttributes=reservedAttributes;function registerScript(script,name,app){if(typeof script!=="function"){throw new Error(`script class: '${script}' must be a constructor function (i.e. class).`)}if(!(script.prototype instanceof Script)){throw new Error(`script class: '${ScriptType.__getScriptName(script)}' does not extend pc.Script.`)}name=name||script.__name||ScriptType.__getScriptName(script);if(reservedScriptNames.has(name)){throw new Error(`script name: '${name}' is reserved, please change script name`)}script.__name=name;const registry=app?app.scripts:AppBase.getApplication().scripts;registry.add(script);ScriptTypes.push(script);}const toLowerCamelCase=str=>str[0].toLowerCase()+str.substring(1);class ScriptHandler extends ResourceHandler{clearCache(){for(const key in this._cache){const element=this._cache[key];const parent=element.parentNode;if(parent){parent.removeChild(element);}}this._cache={};}load(url,callback){if(typeof url==="string"){url={load:url,original:url};}const self1=this;script.app=this._app;const onScriptLoad=(url.load,(err,url,extra)=>{if(!err){if(script.legacy){let Type=null;if(ScriptTypes._types.length){Type=ScriptTypes._types.pop();}if(Type){this._scripts[url]=Type;}else {Type=null;}callback(null,Type,extra);}else {const obj={};for(let i=0;i<ScriptTypes._types.length;i++){obj[ScriptTypes._types[i].name]=ScriptTypes._types[i];}ScriptTypes._types.length=0;callback(null,obj,extra);delete self1._loader._cache[ResourceLoader.makeKey(url,"script")];}}else {callback(err);}});const[basePath]=url.load.split("?");const isEsmScript=basePath.endsWith(".mjs");if(isEsmScript){this._loadModule(basePath,onScriptLoad);}else {this._loadScript(url.load,onScriptLoad);}}open(url,data){return data}patch(asset,assets){}_loadScript(url,callback){const head=document.head;const element=document.createElement("script");this._cache[url]=element;element.async=false;element.addEventListener("error",e=>{callback(`Script: ${e.target.src} failed to load`);},false);let done=false;element.onload=element.onreadystatechange=function(){if(!done&&(!this.readyState||this.readyState==="loaded"||this.readyState==="complete")){done=true;callback(null,url,element);}};element.src=url;head.appendChild(element);}_loadModule(url,callback){const baseUrl=platform.browser?window.location.origin+window.location.pathname:import.meta.url;const importUrl=new URL(url,baseUrl);__esmScriptDynamicImportRuntime__(/* @vite-ignore */importUrl.toString()).then(module=>{const filename=importUrl.pathname.split("/").pop();const scriptSchema=this._app.assets.find(filename,"script").data.scripts;for(const key in module){const scriptClass=module[key];const extendsScriptType=scriptClass.prototype instanceof Script;if(extendsScriptType){const scriptName=toLowerCamelCase(scriptClass.name);registerScript(scriptClass,scriptName);this._app.scripts.addSchema(scriptName,scriptSchema[scriptName]);}}callback(null,url,null);}).catch(err=>{callback(err);});}constructor(app){super(app,"script");this._scripts={};this._cache={};}}class ShaderHandler extends ResourceHandler{load(url,callback){if(typeof url==="string"){url={load:url,original:url};}http.get(url.load,{retry:this.maxRetries>0,maxRetries:this.maxRetries},(err,response)=>{if(!err){callback(null,response);}else {callback(`Error loading shader resource: ${url.original} [${err}]`);}});}openBinary(data){var _this$decoder;(_this$decoder=this.decoder)!=null?_this$decoder:this.decoder=new TextDecoder("utf-8");return this.decoder.decode(data)}constructor(app){super(app,"shader");this.decoder=null;}}function onTextureAtlasLoaded(atlasAsset){const spriteAsset=this;if(spriteAsset.resource){spriteAsset.resource.atlas=atlasAsset.resource;}}function onTextureAtlasAdded(atlasAsset){const spriteAsset=this;spriteAsset.registry.load(atlasAsset);}class SpriteHandler extends ResourceHandler{load(url,callback){if(typeof url==="string"){url={load:url,original:url};}if(path.getExtension(url.original)===".json"){http.get(url.load,{retry:this.maxRetries>0,maxRetries:this.maxRetries},(err,response)=>{if(!err){callback(null,response);}else {callback(err);}});}}open(url,data){const sprite=new Sprite(this._device);if(url){sprite.__data=data;}return sprite}patch(asset,assets){const sprite=asset.resource;if(sprite.__data){asset.data.pixelsPerUnit=sprite.__data.pixelsPerUnit;asset.data.renderMode=sprite.__data.renderMode;asset.data.frameKeys=sprite.__data.frameKeys;if(sprite.__data.textureAtlasAsset){const atlas=assets.getByUrl(sprite.__data.textureAtlasAsset);if(atlas){asset.data.textureAtlasAsset=atlas.id;}else {console.warn(`Could not find textureatlas with url: ${sprite.__data.textureAtlasAsset}`);}}}sprite.startUpdate();sprite.renderMode=asset.data.renderMode;sprite.pixelsPerUnit=asset.data.pixelsPerUnit;sprite.frameKeys=asset.data.frameKeys;this._updateAtlas(asset);sprite.endUpdate();asset.off("change",this._onAssetChange,this);asset.on("change",this._onAssetChange,this);}_updateAtlas(asset){const sprite=asset.resource;if(!asset.data.textureAtlasAsset){sprite.atlas=null;return}this._assets.off(`load:${asset.data.textureAtlasAsset}`,onTextureAtlasLoaded,asset);this._assets.on(`load:${asset.data.textureAtlasAsset}`,onTextureAtlasLoaded,asset);const atlasAsset=this._assets.get(asset.data.textureAtlasAsset);if(atlasAsset&&atlasAsset.resource){sprite.atlas=atlasAsset.resource;}else {if(!atlasAsset){this._assets.off(`add:${asset.data.textureAtlasAsset}`,onTextureAtlasAdded,asset);this._assets.on(`add:${asset.data.textureAtlasAsset}`,onTextureAtlasAdded,asset);}else {this._assets.load(atlasAsset);}}}_onAssetChange(asset,attribute,value,oldValue){if(attribute==="data"){if(value&&value.textureAtlasAsset&&oldValue&&value.textureAtlasAsset!==oldValue.textureAtlasAsset){this._assets.off(`load:${oldValue.textureAtlasAsset}`,onTextureAtlasLoaded,asset);this._assets.off(`add:${oldValue.textureAtlasAsset}`,onTextureAtlasAdded,asset);}}}constructor(app){super(app,"sprite");this._assets=app.assets;this._device=app.graphicsDevice;}}class Template{instantiate(){if(!this._templateRoot){this._parseTemplate();}return this._templateRoot.clone()}_parseTemplate(){const parser=new SceneParser(this._app,true);this._templateRoot=parser.parse(this._data);}constructor(app,data){this._app=void 0;this._data=void 0;this._templateRoot=null;this._app=app;this._data=data;}}class TemplateHandler extends ResourceHandler{load(url,callback){if(typeof url==="string"){url={load:url,original:url};}const options={retry:this.maxRetries>0,maxRetries:this.maxRetries};http.get(url.load,options,(err,response)=>{if(err){callback(`Error requesting template: ${url.original}`);}else {callback(err,response);}});}open(url,data){return new Template(this._app,data)}openBinary(data){var _this$decoder;(_this$decoder=this.decoder)!=null?_this$decoder:this.decoder=new TextDecoder("utf-8");return new Template(this._app,JSON.parse(this.decoder.decode(data)))}constructor(app){super(app,"template");this.decoder=null;}}class TextHandler extends ResourceHandler{load(url,callback){if(typeof url==="string"){url={load:url,original:url};}http.get(url.load,{retry:this.maxRetries>0,maxRetries:this.maxRetries},(err,response)=>{if(!err){callback(null,response);}else {callback(`Error loading text resource: ${url.original} [${err}]`);}});}openBinary(data){var _this$decoder;(_this$decoder=this.decoder)!=null?_this$decoder:this.decoder=new TextDecoder("utf-8");return this.decoder.decode(data)}constructor(app){super(app,"text");this.decoder=null;}}const JSON_ADDRESS_MODE$1={"repeat":ADDRESS_REPEAT,"clamp":ADDRESS_CLAMP_TO_EDGE,"mirror":ADDRESS_MIRRORED_REPEAT};const JSON_FILTER_MODE$1={"nearest":FILTER_NEAREST,"linear":FILTER_LINEAR,"nearest_mip_nearest":FILTER_NEAREST_MIPMAP_NEAREST,"linear_mip_nearest":FILTER_LINEAR_MIPMAP_NEAREST,"nearest_mip_linear":FILTER_NEAREST_MIPMAP_LINEAR,"linear_mip_linear":FILTER_LINEAR_MIPMAP_LINEAR};const regexFrame=/^data\.frames\.(\d+)$/;class TextureAtlasHandler extends ResourceHandler{load(url,callback){if(typeof url==="string"){url={load:url,original:url};}const self1=this;const handler=this._loader.getHandler("texture");if(path.getExtension(url.original)===".json"){http.get(url.load,{retry:this.maxRetries>0,maxRetries:this.maxRetries},(err,response)=>{if(!err){const textureUrl=url.original.replace(".json",".png");self1._loader.load(textureUrl,"texture",(err,texture)=>{if(err){callback(err);}else {callback(null,{data:response,texture:texture});}});}else {callback(err);}});}else {handler.load(url,callback);}}open(url,data){const resource=new TextureAtlas;if(data.texture&&data.data){resource.texture=data.texture;resource.__data=data.data;}else {const handler=this._loader.getHandler("texture");const texture=handler.open(url,data);if(!texture)return null;resource.texture=texture;}return resource}patch(asset,assets){if(!asset.resource){return}if(asset.resource.__data){if(asset.resource.__data.minfilter!==undefined)asset.data.minfilter=asset.resource.__data.minfilter;if(asset.resource.__data.magfilter!==undefined)asset.data.magfilter=asset.resource.__data.magfilter;if(asset.resource.__data.addressu!==undefined)asset.data.addressu=asset.resource.__data.addressu;if(asset.resource.__data.addressv!==undefined)asset.data.addressv=asset.resource.__data.addressv;if(asset.resource.__data.mipmaps!==undefined)asset.data.mipmaps=asset.resource.__data.mipmaps;if(asset.resource.__data.anisotropy!==undefined)asset.data.anisotropy=asset.resource.__data.anisotropy;if(asset.resource.__data.rgbm!==undefined)asset.data.rgbm=!!asset.resource.__data.rgbm;asset.data.frames=asset.resource.__data.frames;delete asset.resource.__data;}const texture=asset.resource.texture;if(texture){texture.name=asset.name;if(asset.data.hasOwnProperty("minfilter")&&texture.minFilter!==JSON_FILTER_MODE$1[asset.data.minfilter]){texture.minFilter=JSON_FILTER_MODE$1[asset.data.minfilter];}if(asset.data.hasOwnProperty("magfilter")&&texture.magFilter!==JSON_FILTER_MODE$1[asset.data.magfilter]){texture.magFilter=JSON_FILTER_MODE$1[asset.data.magfilter];}if(asset.data.hasOwnProperty("addressu")&&texture.addressU!==JSON_ADDRESS_MODE$1[asset.data.addressu]){texture.addressU=JSON_ADDRESS_MODE$1[asset.data.addressu];}if(asset.data.hasOwnProperty("addressv")&&texture.addressV!==JSON_ADDRESS_MODE$1[asset.data.addressv]){texture.addressV=JSON_ADDRESS_MODE$1[asset.data.addressv];}if(asset.data.hasOwnProperty("mipmaps")&&texture.mipmaps!==asset.data.mipmaps){texture.mipmaps=asset.data.mipmaps;}if(asset.data.hasOwnProperty("anisotropy")&&texture.anisotropy!==asset.data.anisotropy){texture.anisotropy=asset.data.anisotropy;}if(asset.data.hasOwnProperty("rgbm")){const type=asset.data.rgbm?TEXTURETYPE_RGBM:TEXTURETYPE_DEFAULT;if(texture.type!==type){texture.type=type;}}}asset.resource.texture=texture;const frames={};for(const key in asset.data.frames){const frame=asset.data.frames[key];frames[key]={rect:new Vec4(frame.rect),pivot:new Vec2(frame.pivot),border:new Vec4(frame.border)};}asset.resource.frames=frames;asset.off("change",this._onAssetChange,this);asset.on("change",this._onAssetChange,this);}_onAssetChange(asset,attribute,value){let frame;if(attribute==="data"||attribute==="data.frames"){const frames={};for(const key in value.frames){frame=value.frames[key];frames[key]={rect:new Vec4(frame.rect),pivot:new Vec2(frame.pivot),border:new Vec4(frame.border)};}asset.resource.frames=frames;}else {const match=attribute.match(regexFrame);if(match){const frameKey=match[1];if(value){if(!asset.resource.frames[frameKey]){asset.resource.frames[frameKey]={rect:new Vec4(value.rect),pivot:new Vec2(value.pivot),border:new Vec4(value.border)};}else {frame=asset.resource.frames[frameKey];frame.rect.set(value.rect[0],value.rect[1],value.rect[2],value.rect[3]);frame.pivot.set(value.pivot[0],value.pivot[1]);frame.border.set(value.border[0],value.border[1],value.border[2],value.border[3]);}asset.resource.fire("set:frame",frameKey,asset.resource.frames[frameKey]);}else {if(asset.resource.frames[frameKey]){delete asset.resource.frames[frameKey];asset.resource.fire("remove:frame",frameKey);}}}}}constructor(app){super(app,"textureatlas");this._loader=app.loader;}}function BasisWorker(){const BASIS_FORMAT={cTFETC1:0,cTFETC2:1,cTFBC1:2,cTFBC3:3,cTFPVRTC1_4_RGB:8,cTFPVRTC1_4_RGBA:9,cTFASTC_4x4:10,cTFATC_RGB:11,cTFATC_RGBA_INTERPOLATED_ALPHA:12,cTFRGBA32:13,cTFRGB565:14,cTFRGBA4444:16};const opaqueMapping={astc:BASIS_FORMAT.cTFASTC_4x4,dxt:BASIS_FORMAT.cTFBC1,etc1:BASIS_FORMAT.cTFETC1,etc2:BASIS_FORMAT.cTFETC1,pvr:BASIS_FORMAT.cTFPVRTC1_4_RGB,atc:BASIS_FORMAT.cTFATC_RGB,none:BASIS_FORMAT.cTFRGB565};const alphaMapping={astc:BASIS_FORMAT.cTFASTC_4x4,dxt:BASIS_FORMAT.cTFBC3,etc1:BASIS_FORMAT.cTFRGBA4444,etc2:BASIS_FORMAT.cTFETC2,pvr:BASIS_FORMAT.cTFPVRTC1_4_RGBA,atc:BASIS_FORMAT.cTFATC_RGBA_INTERPOLATED_ALPHA,none:BASIS_FORMAT.cTFRGBA4444};const PIXEL_FORMAT={ETC1:21,ETC2_RGB:22,ETC2_RGBA:23,DXT1:8,DXT5:10,PVRTC_4BPP_RGB_1:26,PVRTC_4BPP_RGBA_1:27,ASTC_4x4:28,ATC_RGB:29,ATC_RGBA:30,R8_G8_B8_A8:7,R5_G6_B5:3,R4_G4_B4_A4:5};const basisToEngineMapping=(basisFormat,deviceDetails)=>{switch(basisFormat){case BASIS_FORMAT.cTFETC1:return deviceDetails.formats.etc1?PIXEL_FORMAT.ETC1:PIXEL_FORMAT.ETC2_RGB;case BASIS_FORMAT.cTFETC2:return PIXEL_FORMAT.ETC2_RGBA;case BASIS_FORMAT.cTFBC1:return PIXEL_FORMAT.DXT1;case BASIS_FORMAT.cTFBC3:return PIXEL_FORMAT.DXT5;case BASIS_FORMAT.cTFPVRTC1_4_RGB:return PIXEL_FORMAT.PVRTC_4BPP_RGB_1;case BASIS_FORMAT.cTFPVRTC1_4_RGBA:return PIXEL_FORMAT.PVRTC_4BPP_RGBA_1;case BASIS_FORMAT.cTFASTC_4x4:return PIXEL_FORMAT.ASTC_4x4;case BASIS_FORMAT.cTFATC_RGB:return PIXEL_FORMAT.ATC_RGB;case BASIS_FORMAT.cTFATC_RGBA_INTERPOLATED_ALPHA:return PIXEL_FORMAT.ATC_RGBA;case BASIS_FORMAT.cTFRGBA32:return PIXEL_FORMAT.R8_G8_B8_A8;case BASIS_FORMAT.cTFRGB565:return PIXEL_FORMAT.R5_G6_B5;case BASIS_FORMAT.cTFRGBA4444:return PIXEL_FORMAT.R4_G4_B4_A4}};const unswizzleGGGR=data=>{const genB=function genB(R,G){const r=R*(2/255)-1;const g=G*(2/255)-1;const b=Math.sqrt(1-Math.min(1,r*r+g*g));return Math.max(0,Math.min(255,Math.floor((b+1)*.5*255)))};for(let offset=0;offset<data.length;offset+=4){const R=data[offset+3];const G=data[offset+1];data[offset+0]=R;data[offset+2]=genB(R,G);data[offset+3]=255;}return data};const pack565=data=>{const result=new Uint16Array(data.length/4);for(let offset=0;offset<data.length;offset+=4){const R=data[offset+0];const G=data[offset+1];const B=data[offset+2];result[offset/4]=(R&248)<<8|(G&252)<<3|B>>3;}return result};const isPOT=(width,height)=>{return (width&width-1)===0&&(height&height-1)===0};const performanceNow=()=>{return typeof performance!=="undefined"?performance.now():0};let basis;let rgbPriority;let rgbaPriority;const chooseTargetFormat=(deviceDetails,hasAlpha,isUASTC)=>{if(isUASTC){if(deviceDetails.formats.astc){return "astc"}}else {if(hasAlpha){if(deviceDetails.formats.etc2){return "etc2"}}else {if(deviceDetails.formats.etc1||deviceDetails.formats.etc2){return "etc1"}}}const testInOrder=priority=>{for(let i=0;i<priority.length;++i){const format=priority[i];if(deviceDetails.formats[format]){return format}}return "none"};return testInOrder(hasAlpha?rgbaPriority:rgbPriority)};const dimensionsValid=(width,height,format,webgl2)=>{switch(format){case BASIS_FORMAT.cTFETC1:case BASIS_FORMAT.cTFETC2:return true;case BASIS_FORMAT.cTFBC1:case BASIS_FORMAT.cTFBC3:return (width&3)===0&&(height&3)===0;case BASIS_FORMAT.cTFPVRTC1_4_RGB:case BASIS_FORMAT.cTFPVRTC1_4_RGBA:return isPOT(width,height)&&(width===height||webgl2);case BASIS_FORMAT.cTFASTC_4x4:return true;case BASIS_FORMAT.cTFATC_RGB:case BASIS_FORMAT.cTFATC_RGBA_INTERPOLATED_ALPHA:return true}return false};const transcodeKTX2=(url,data,options)=>{if(!basis.KTX2File){throw new Error("Basis transcoder module does not include support for KTX2.")}const funcStart=performanceNow();const basisFile=new basis.KTX2File(new Uint8Array(data));const width=basisFile.getWidth();const height=basisFile.getHeight();const levels=basisFile.getLevels();const hasAlpha=!!basisFile.getHasAlpha();const isUASTC=basisFile.isUASTC&&basisFile.isUASTC();if(!width||!height||!levels){basisFile.close();basisFile.delete();throw new Error(`Invalid image dimensions url=${url} width=${width} height=${height} levels=${levels}`)}const format=chooseTargetFormat(options.deviceDetails,hasAlpha,isUASTC);const unswizzle=!!options.isGGGR&&format==="pvr";let basisFormat;if(unswizzle){basisFormat=BASIS_FORMAT.cTFRGBA32;}else {basisFormat=hasAlpha?alphaMapping[format]:opaqueMapping[format];if(!dimensionsValid(width,height,basisFormat,options.deviceDetails.webgl2)){basisFormat=hasAlpha?BASIS_FORMAT.cTFRGBA32:BASIS_FORMAT.cTFRGB565;}}if(!basisFile.startTranscoding()){basisFile.close();basisFile.delete();throw new Error(`Failed to start transcoding url=${url}`)}let i;const levelData=[];for(let mip=0;mip<levels;++mip){const dstSize=basisFile.getImageTranscodedSizeInBytes(mip,0,0,basisFormat);const dst=new Uint8Array(dstSize);if(!basisFile.transcodeImage(dst,mip,0,0,basisFormat,0,-1,-1)){basisFile.close();basisFile.delete();throw new Error(`Failed to transcode image url=${url}`)}const is16BitFormat=basisFormat===BASIS_FORMAT.cTFRGB565||basisFormat===BASIS_FORMAT.cTFRGBA4444;levelData.push(is16BitFormat?new Uint16Array(dst.buffer):dst);}basisFile.close();basisFile.delete();if(unswizzle){basisFormat=BASIS_FORMAT.cTFRGB565;for(i=0;i<levelData.length;++i){levelData[i]=pack565(unswizzleGGGR(levelData[i]));}}return {format:basisToEngineMapping(basisFormat,options.deviceDetails),width:width,height:height,levels:levelData,cubemap:false,transcodeTime:performanceNow()-funcStart,url:url,unswizzledGGGR:unswizzle}};const transcodeBasis=(url,data,options)=>{const funcStart=performanceNow();const basisFile=new basis.BasisFile(new Uint8Array(data));const width=basisFile.getImageWidth(0,0);const height=basisFile.getImageHeight(0,0);const images=basisFile.getNumImages();const levels=basisFile.getNumLevels(0);const hasAlpha=!!basisFile.getHasAlpha();const isUASTC=basisFile.isUASTC&&basisFile.isUASTC();if(!width||!height||!images||!levels){basisFile.close();basisFile.delete();throw new Error(`Invalid image dimensions url=${url} width=${width} height=${height} images=${images} levels=${levels}`)}const format=chooseTargetFormat(options.deviceDetails,hasAlpha,isUASTC);const unswizzle=!!options.isGGGR&&format==="pvr";let basisFormat;if(unswizzle){basisFormat=BASIS_FORMAT.cTFRGBA32;}else {basisFormat=hasAlpha?alphaMapping[format]:opaqueMapping[format];if(!dimensionsValid(width,height,basisFormat,options.deviceDetails.webgl2)){basisFormat=hasAlpha?BASIS_FORMAT.cTFRGBA32:BASIS_FORMAT.cTFRGB565;}}if(!basisFile.startTranscoding()){basisFile.close();basisFile.delete();throw new Error(`Failed to start transcoding url=${url}`)}let i;const levelData=[];for(let mip=0;mip<levels;++mip){const dstSize=basisFile.getImageTranscodedSizeInBytes(0,mip,basisFormat);const dst=new Uint8Array(dstSize);if(!basisFile.transcodeImage(dst,0,mip,basisFormat,0,0)){if(mip===levels-1&&dstSize===levelData[mip-1].buffer.byteLength){dst.set(new Uint8Array(levelData[mip-1].buffer));console.warn(`Failed to transcode last mipmap level, using previous level instead url=${url}`);}else {basisFile.close();basisFile.delete();throw new Error(`Failed to transcode image url=${url}`)}}const is16BitFormat=basisFormat===BASIS_FORMAT.cTFRGB565||basisFormat===BASIS_FORMAT.cTFRGBA4444;levelData.push(is16BitFormat?new Uint16Array(dst.buffer):dst);}basisFile.close();basisFile.delete();if(unswizzle){basisFormat=BASIS_FORMAT.cTFRGB565;for(i=0;i<levelData.length;++i){levelData[i]=pack565(unswizzleGGGR(levelData[i]));}}return {format:basisToEngineMapping(basisFormat,options.deviceDetails),width:width,height:height,levels:levelData,cubemap:false,transcodeTime:performanceNow()-funcStart,url:url,unswizzledGGGR:unswizzle}};const transcode=(url,data,options)=>{return options.isKTX2?transcodeKTX2(url,data,options):transcodeBasis(url,data,options)};const workerTranscode=(url,data,options)=>{try{const result=transcode(url,data,options);result.levels=result.levels.map(v=>v.buffer);self.postMessage({url:url,data:result},result.levels);}catch(err){self.postMessage({url:url,err:err},null);}};const workerInit=(config,callback)=>{const instantiateWasmFunc=(imports,successCallback)=>{WebAssembly.instantiate(config.module,imports).then(result=>{successCallback(result);}).catch(reason=>{console.error(`instantiate failed + ${reason}`);});return {}};self.BASIS(config.module?{instantiateWasm:instantiateWasmFunc}:null).then(instance=>{instance.initializeBasis();basis=instance;rgbPriority=config.rgbPriority;rgbaPriority=config.rgbaPriority;callback(null);});};const queue=[];self.onmessage=message=>{const data=message.data;switch(data.type){case"init":workerInit(data.config,()=>{for(let i=0;i<queue.length;++i){workerTranscode(queue[i].url,queue[i].data,queue[i].options);}queue.length=0;});break;case"transcode":if(basis){workerTranscode(data.url,data.data,data.options);}else {queue.push(data);}break}};}const getCompressionFormats=device=>{return {astc:!!device.extCompressedTextureASTC,atc:!!device.extCompressedTextureATC,dxt:!!device.extCompressedTextureS3TC,etc1:!!device.extCompressedTextureETC1,etc2:!!device.extCompressedTextureETC,pvr:!!device.extCompressedTexturePVRTC}};const prepareWorkerModules=(config,callback)=>{const getWorkerBlob=basisCode=>{const code=["/* basis */",basisCode,"",`(${BasisWorker.toString()})()

`].join("\n");return new Blob([code],{type:"application/javascript"})};const wasmSupported=()=>{try{if(typeof WebAssembly==="object"&&typeof WebAssembly.instantiate==="function"){const module=new WebAssembly.Module(Uint8Array.of(0,97,115,109,1,0,0,0));if(module instanceof WebAssembly.Module){return new WebAssembly.Instance(module) instanceof WebAssembly.Instance}}}catch(e){}return false};const sendResponse=(basisCode,module)=>{callback(null,{workerUrl:URL.createObjectURL(getWorkerBlob(basisCode)),module:module,rgbPriority:config.rgbPriority,rgbaPriority:config.rgbaPriority});};const options={cache:true,responseType:"text",retry:config.maxRetries>0,maxRetries:config.maxRetries};if(config.glueUrl&&config.wasmUrl&&wasmSupported()){let basisCode=null;let module=null;http.get(config.glueUrl,options,(err,response)=>{if(err){callback(err);}else {if(module){sendResponse(response,module);}else {basisCode=response;}}});const fetchPromise=fetch(config.wasmUrl);const compileManual=()=>{fetchPromise.then(result=>result.arrayBuffer()).then(buffer=>WebAssembly.compile(buffer)).then(module_=>{if(basisCode){sendResponse(basisCode,module_);}else {module=module_;}}).catch(err=>{callback(err,null);});};if(WebAssembly.compileStreaming){WebAssembly.compileStreaming(fetchPromise).then(module_=>{if(basisCode){sendResponse(basisCode,module_);}else {module=module_;}}).catch(err=>{compileManual();});}else {compileManual();}}else {http.get(config.fallbackUrl,options,(err,response)=>{if(err){callback(err,null);}else {sendResponse(response,null);}});}};class BasisQueue{enqueueJob(url,data,callback,options){if(this.callbacks.hasOwnProperty(url)){this.callbacks[url].push(callback);}else {this.callbacks[url]=[callback];const job={url:url,data:data,options:options};if(this.clients.length>0){this.clients.shift().run(job);}else {this.queue.push(job);}}}enqueueClient(client){if(this.queue.length>0){client.run(this.queue.shift());}else {this.clients.push(client);}}handleResponse(url,err,data){const callback=this.callbacks[url];if(err){for(let i=0;i<callback.length;++i){callback[i](err);}}else {if(data.format===PIXELFORMAT_RGB565||data.format===PIXELFORMAT_RGBA4){data.levels=data.levels.map(v=>{return new Uint16Array(v)});}else {data.levels=data.levels.map(v=>{return new Uint8Array(v)});}for(let i=0;i<callback.length;++i){callback[i](null,data);}}delete this.callbacks[url];}constructor(){this.callbacks={};this.queue=[];this.clients=[];}}class BasisClient{run(job){const transfer=[];if(job.data instanceof ArrayBuffer){transfer.push(job.data);}this.worker.postMessage({type:"transcode",url:job.url,format:job.format,data:job.data,options:job.options},transfer);if(this.eager){this.queue.enqueueClient(this);}}constructor(queue,config,eager){this.queue=queue;this.worker=new Worker(config.workerUrl);this.worker.addEventListener("message",message=>{const data=message.data;this.queue.handleResponse(data.url,data.err,data.data);if(!this.eager){this.queue.enqueueClient(this);}});this.worker.postMessage({type:"init",config:config});this.eager=eager;}}const defaultNumWorkers=1;const defaultRgbPriority=["etc1","etc2","astc","dxt","pvr","atc"];const defaultRgbaPriority=["astc","dxt","etc2","pvr","atc"];const defaultMaxRetries=5;const queue=new BasisQueue;let lazyConfig=null;let initializing=false;function basisInitialize(config){if(initializing){return}if(!config){config=lazyConfig||{};}else if(config.lazyInit){lazyConfig=config;return}if(!config.glueUrl||!config.wasmUrl||!config.fallbackUrl){const moduleConfig=WasmModule.getConfig("BASIS");if(moduleConfig){config={glueUrl:moduleConfig.glueUrl,wasmUrl:moduleConfig.wasmUrl,fallbackUrl:moduleConfig.fallbackUrl,numWorkers:moduleConfig.numWorkers};}}if(config.glueUrl||config.wasmUrl||config.fallbackUrl){initializing=true;const numWorkers=Math.max(1,Math.min(16,config.numWorkers||defaultNumWorkers));const eagerWorkers=config.numWorkers===1||(config.hasOwnProperty("eagerWorkers")?config.eagerWorkers:true);config.rgbPriority=config.rgbPriority||defaultRgbPriority;config.rgbaPriority=config.rgbaPriority||defaultRgbaPriority;config.maxRetries=config.hasOwnProperty("maxRetries")?config.maxRetries:defaultMaxRetries;prepareWorkerModules(config,(err,clientConfig)=>{if(err){console.error(`failed to initialize basis worker: ${err}`);}else {for(let i=0;i<numWorkers;++i){queue.enqueueClient(new BasisClient(queue,clientConfig,eagerWorkers));}}});}}let deviceDetails=null;function basisTranscode(device,url,data,callback,options){basisInitialize();if(!deviceDetails){deviceDetails={webgl2:device.isWebGL2,formats:getCompressionFormats(device)};}queue.enqueueJob(url,data,callback,{deviceDetails:deviceDetails,isGGGR:!!(options!=null&&options.isGGGR),isKTX2:!!(options!=null&&options.isKTX2)});return initializing}class TextureParser{load(url,callback,asset){throw new Error("not implemented")}open(url,data,device){throw new Error("not implemented")}}class BasisParser extends TextureParser{load(url,callback,asset){const device=this.device;const transcode=data=>{var _asset$file;const basisModuleFound=basisTranscode(device,url.load,data,callback,{isGGGR:((asset==null||(_asset$file=asset.file)==null||(_asset$file=_asset$file.variants)==null||(_asset$file=_asset$file.basis)==null?void 0:_asset$file.opt)&8)!==0});if(!basisModuleFound){callback(`Basis module not found. Asset '${asset.name}' basis texture variant will not be loaded.`);}};Asset.fetchArrayBuffer(url.load,(err,result)=>{if(err){callback(err);}else {transcode(result);}},asset,this.maxRetries);}open(url,data,device,textureOptions={}){const texture=new Texture(device,_extends({name:url,addressU:data.cubemap?ADDRESS_CLAMP_TO_EDGE:ADDRESS_REPEAT,addressV:data.cubemap?ADDRESS_CLAMP_TO_EDGE:ADDRESS_REPEAT,width:data.width,height:data.height,format:data.format,cubemap:data.cubemap,levels:data.levels},textureOptions));texture.upload();return texture}constructor(registry,device){super();this.device=device;this.maxRetries=0;}}class ImgParser extends TextureParser{load(url,callback,asset){var _asset$file;const hasContents=!!(asset!=null&&(_asset$file=asset.file)!=null&&_asset$file.contents);if(hasContents){if(this.device.supportsImageBitmap){this._loadImageBitmapFromBlob(new Blob([asset.file.contents]),callback);return}url={load:URL.createObjectURL(new Blob([asset.file.contents])),original:url.original};}const handler=(err,result)=>{if(hasContents){URL.revokeObjectURL(url.load);}callback(err,result);};let crossOrigin;if(asset&&asset.options&&asset.options.hasOwnProperty("crossOrigin")){crossOrigin=asset.options.crossOrigin;}else if(ABSOLUTE_URL.test(url.load)){crossOrigin=this.crossOrigin;}if(this.device.supportsImageBitmap){this._loadImageBitmap(url.load,url.original,crossOrigin,handler);}else {this._loadImage(url.load,url.original,crossOrigin,handler);}}open(url,data,device,textureOptions={}){const texture=new Texture(device,_extends({name:url,width:data.width,height:data.height,format:PIXELFORMAT_RGBA8},textureOptions));texture.setSource(data);return texture}_loadImage(url,originalUrl,crossOrigin,callback){const image=new Image;if(crossOrigin){image.crossOrigin=crossOrigin;}let retries=0;const maxRetries=this.maxRetries;let retryTimeout;image.onload=function(){callback(null,image);};image.onerror=function(){if(retryTimeout)return;if(maxRetries>0&&++retries<=maxRetries){const retryDelay=Math.pow(2,retries)*100;console.log(`Error loading Texture from: '${originalUrl}' - Retrying in ${retryDelay}ms...`);const idx=url.indexOf("?");const separator=idx>=0?"&":"?";retryTimeout=setTimeout(()=>{image.src=`${url+separator}retry=${Date.now()}`;retryTimeout=null;},retryDelay);}else {callback(`Error loading Texture from: '${originalUrl}'`);}};image.src=url;}_loadImageBitmap(url,originalUrl,crossOrigin,callback){const options={cache:true,responseType:"blob",retry:this.maxRetries>0,maxRetries:this.maxRetries};http.get(url,options,(err,blob)=>{if(err){callback(err);}else {this._loadImageBitmapFromBlob(blob,callback);}});}_loadImageBitmapFromBlob(blob,callback){createImageBitmap(blob,{premultiplyAlpha:"none",colorSpaceConversion:"none"}).then(imageBitmap=>callback(null,imageBitmap)).catch(e=>callback(e));}constructor(registry,device){super();this.crossOrigin=registry.prefix?"anonymous":null;this.maxRetries=0;this.device=device;}}const IDENTIFIER=[1481919403,3140563232,169478669];const KNOWN_FORMATS={33776:PIXELFORMAT_DXT1,33778:PIXELFORMAT_DXT3,33779:PIXELFORMAT_DXT5,36196:PIXELFORMAT_ETC1,37492:PIXELFORMAT_ETC2_RGB,37496:PIXELFORMAT_ETC2_RGBA,35840:PIXELFORMAT_PVRTC_4BPP_RGB_1,35841:PIXELFORMAT_PVRTC_2BPP_RGB_1,35842:PIXELFORMAT_PVRTC_4BPP_RGBA_1,35843:PIXELFORMAT_PVRTC_2BPP_RGBA_1,32849:PIXELFORMAT_RGB8,32856:PIXELFORMAT_RGBA8,35905:PIXELFORMAT_SRGB,35907:PIXELFORMAT_SRGBA,35898:PIXELFORMAT_111110F,34843:PIXELFORMAT_RGB16F,34842:PIXELFORMAT_RGBA16F};function createContainer(pixelFormat,buffer,byteOffset,byteSize){return pixelFormat===PIXELFORMAT_111110F?new Uint32Array(buffer,byteOffset,byteSize/4):new Uint8Array(buffer,byteOffset,byteSize)}class KtxParser extends TextureParser{load(url,callback,asset){Asset.fetchArrayBuffer(url.load,callback,asset,this.maxRetries);}open(url,data,device,textureOptions={}){const textureData=this.parse(data);if(!textureData){return null}const texture=new Texture(device,_extends({name:url,addressU:textureData.cubemap?ADDRESS_CLAMP_TO_EDGE:ADDRESS_REPEAT,addressV:textureData.cubemap?ADDRESS_CLAMP_TO_EDGE:ADDRESS_REPEAT,width:textureData.width,height:textureData.height,format:textureData.format,cubemap:textureData.cubemap,levels:textureData.levels},textureOptions));texture.upload();return texture}parse(data){const dataU32=new Uint32Array(data);if(IDENTIFIER[0]!==dataU32[0]||IDENTIFIER[1]!==dataU32[1]||IDENTIFIER[2]!==dataU32[2]){return null}const header={endianness:dataU32[3],glType:dataU32[4],glTypeSize:dataU32[5],glFormat:dataU32[6],glInternalFormat:dataU32[7],glBaseInternalFormat:dataU32[8],pixelWidth:dataU32[9],pixelHeight:dataU32[10],pixelDepth:dataU32[11],numberOfArrayElements:dataU32[12],numberOfFaces:dataU32[13],numberOfMipmapLevels:dataU32[14],bytesOfKeyValueData:dataU32[15]};if(header.pixelDepth>1){return null}if(header.numberOfArrayElements!==0){return null}const format=KNOWN_FORMATS[header.glInternalFormat];if(format===undefined){return null}let offset=16+header.bytesOfKeyValueData/4;const isCubemap=header.numberOfFaces>1;const levels=[];for(let mipmapLevel=0;mipmapLevel<(header.numberOfMipmapLevels||1);mipmapLevel++){const imageSizeInBytes=dataU32[offset++];if(isCubemap){levels.push([]);}const target=isCubemap?levels[mipmapLevel]:levels;for(let face=0;face<(isCubemap?6:1);++face){target.push(createContainer(format,data,offset*4,imageSizeInBytes));offset+=imageSizeInBytes+3>>2;}}return {format:format,width:header.pixelWidth,height:header.pixelHeight,levels:levels,cubemap:isCubemap}}constructor(registry){super();this.maxRetries=0;}}const KHRConstants={KHR_DF_MODEL_ETC1S:163,KHR_DF_MODEL_UASTC:166};class Ktx2Parser extends TextureParser{load(url,callback,asset){Asset.fetchArrayBuffer(url.load,(err,result)=>{if(err){callback(err,result);}else {this.parse(result,url,callback,asset);}},asset,this.maxRetries);}open(url,data,device,textureOptions={}){const texture=new Texture(device,_extends({name:url,addressU:data.cubemap?ADDRESS_CLAMP_TO_EDGE:ADDRESS_REPEAT,addressV:data.cubemap?ADDRESS_CLAMP_TO_EDGE:ADDRESS_REPEAT,width:data.width,height:data.height,format:data.format,cubemap:data.cubemap,levels:data.levels},textureOptions));texture.upload();return texture}parse(arraybuffer,url,callback,asset){const rs=new ReadStream(arraybuffer);const magic=[rs.readU32be(),rs.readU32be(),rs.readU32be()];if(magic[0]!==2873840728||magic[1]!==540160187||magic[2]!==218765834){return null}const header={vkFormat:rs.readU32(),typeSize:rs.readU32(),pixelWidth:rs.readU32(),pixelHeight:rs.readU32(),pixelDepth:rs.readU32(),layerCount:rs.readU32(),faceCount:rs.readU32(),levelCount:rs.readU32(),supercompressionScheme:rs.readU32()};const index={dfdByteOffset:rs.readU32(),dfdByteLength:rs.readU32(),kvdByteOffset:rs.readU32(),kvdByteLength:rs.readU32(),sgdByteOffset:rs.readU64(),sgdByteLength:rs.readU64()};const levels=[];for(let i=0;i<Math.max(1,header.levelCount);++i){levels.push({byteOffset:rs.readU64(),byteLength:rs.readU64(),uncompressedByteLength:rs.readU64()});}const dfdTotalSize=rs.readU32();if(dfdTotalSize!==index.kvdByteOffset-index.dfdByteOffset){return null}rs.skip(8);const colorModel=rs.readU8();rs.skip(index.dfdByteLength-9);rs.skip(index.kvdByteLength);if(header.supercompressionScheme===1||colorModel===KHRConstants.KHR_DF_MODEL_UASTC){var _asset$file;const basisModuleFound=basisTranscode(this.device,url.load,arraybuffer,callback,{isGGGR:((asset==null||(_asset$file=asset.file)==null||(_asset$file=_asset$file.variants)==null||(_asset$file=_asset$file.basis)==null?void 0:_asset$file.opt)&8)!==0,isKTX2:true});if(!basisModuleFound){callback(`Basis module not found. Asset "${asset.name}" basis texture variant will not be loaded.`);}}else {callback("unsupported KTX2 pixel format");}}constructor(registry,device){super();this.maxRetries=0;this.device=device;}}class DdsParser extends TextureParser{load(url,callback,asset){Asset.fetchArrayBuffer(url.load,callback,asset,this.maxRetries);}open(url,data,device,textureOptions={}){const header=new Uint32Array(data,0,128/4);const width=header[4];const height=header[3];const mips=Math.max(header[7],1);const isFourCc=header[20]===4;const fcc=header[21];const bpp=header[22];const isCubemap=header[28]===65024;const FCC_DXT1=827611204;const FCC_DXT5=894720068;const FCC_FP16=113;const FCC_FP32=116;const FCC_ETC1=826496069;const FCC_PVRTC_2BPP_RGB_1=825438800;const FCC_PVRTC_2BPP_RGBA_1=825504336;const FCC_PVRTC_4BPP_RGB_1=825439312;const FCC_PVRTC_4BPP_RGBA_1=825504848;let compressed=false;let etc1=false;let pvrtc2=false;let pvrtc4=false;let format=null;let componentSize=1;let texture;if(isFourCc){if(fcc===FCC_DXT1){format=PIXELFORMAT_DXT1;compressed=true;}else if(fcc===FCC_DXT5){format=PIXELFORMAT_DXT5;compressed=true;}else if(fcc===FCC_FP16){format=PIXELFORMAT_RGBA16F;componentSize=2;}else if(fcc===FCC_FP32){format=PIXELFORMAT_RGBA32F;componentSize=4;}else if(fcc===FCC_ETC1){format=PIXELFORMAT_ETC1;compressed=true;etc1=true;}else if(fcc===FCC_PVRTC_2BPP_RGB_1||fcc===FCC_PVRTC_2BPP_RGBA_1){format=fcc===FCC_PVRTC_2BPP_RGB_1?PIXELFORMAT_PVRTC_2BPP_RGB_1:PIXELFORMAT_PVRTC_2BPP_RGBA_1;compressed=true;pvrtc2=true;}else if(fcc===FCC_PVRTC_4BPP_RGB_1||fcc===FCC_PVRTC_4BPP_RGBA_1){format=fcc===FCC_PVRTC_4BPP_RGB_1?PIXELFORMAT_PVRTC_4BPP_RGB_1:PIXELFORMAT_PVRTC_4BPP_RGBA_1;compressed=true;pvrtc4=true;}}else {if(bpp===32){format=PIXELFORMAT_RGBA8;}}if(!format){texture=new Texture(device,{width:4,height:4,format:PIXELFORMAT_RGB8,name:"dds-legacy-empty"});return texture}texture=new Texture(device,_extends({name:url,addressU:isCubemap?ADDRESS_CLAMP_TO_EDGE:ADDRESS_REPEAT,addressV:isCubemap?ADDRESS_CLAMP_TO_EDGE:ADDRESS_REPEAT,width:width,height:height,format:format,cubemap:isCubemap,mipmaps:mips>1},textureOptions));let offset=128;const faces=isCubemap?6:1;let mipSize;const DXT_BLOCK_WIDTH=4;const DXT_BLOCK_HEIGHT=4;const blockSize=fcc===FCC_DXT1?8:16;let numBlocksAcross,numBlocksDown,numBlocks;for(let face=0;face<faces;face++){let mipWidth=width;let mipHeight=height;for(let i=0;i<mips;i++){if(compressed){if(etc1){mipSize=Math.floor((mipWidth+3)/4)*Math.floor((mipHeight+3)/4)*8;}else if(pvrtc2){mipSize=Math.max(mipWidth,16)*Math.max(mipHeight,8)/4;}else if(pvrtc4){mipSize=Math.max(mipWidth,8)*Math.max(mipHeight,8)/2;}else {numBlocksAcross=Math.floor((mipWidth+DXT_BLOCK_WIDTH-1)/DXT_BLOCK_WIDTH);numBlocksDown=Math.floor((mipHeight+DXT_BLOCK_HEIGHT-1)/DXT_BLOCK_HEIGHT);numBlocks=numBlocksAcross*numBlocksDown;mipSize=numBlocks*blockSize;}}else {mipSize=mipWidth*mipHeight*4;}const mipBuff=format===PIXELFORMAT_RGBA32F?new Float32Array(data,offset,mipSize):format===PIXELFORMAT_RGBA16F?new Uint16Array(data,offset,mipSize):new Uint8Array(data,offset,mipSize);if(!isCubemap){texture._levels[i]=mipBuff;}else {if(!texture._levels[i])texture._levels[i]=[];texture._levels[i][face]=mipBuff;}offset+=mipSize*componentSize;mipWidth=Math.max(mipWidth*.5,1);mipHeight=Math.max(mipHeight*.5,1);}}texture.upload();return texture}constructor(registry){super();this.maxRetries=0;}}class HdrParser extends TextureParser{load(url,callback,asset){Asset.fetchArrayBuffer(url.load,callback,asset,this.maxRetries);}open(url,data,device,textureOptions={}){const textureData=this.parse(data);if(!textureData){return null}const texture=new Texture(device,_extends({name:url,addressU:ADDRESS_REPEAT,addressV:ADDRESS_CLAMP_TO_EDGE,minFilter:FILTER_NEAREST,magFilter:FILTER_NEAREST,width:textureData.width,height:textureData.height,levels:textureData.levels,format:PIXELFORMAT_RGBA8,type:TEXTURETYPE_RGBE,mipmaps:false},textureOptions));texture.upload();return texture}parse(data){const readStream=new ReadStream(data);const magic=readStream.readLine();if(!magic.startsWith("#?RADIANCE")){return null}const variables={};while(true){const line=readStream.readLine();if(line.length===0){break}else {const parts=line.split("=");if(parts.length===2){variables[parts[0]]=parts[1];}}}if(!variables.hasOwnProperty("FORMAT")){return null}const resolution=readStream.readLine().split(" ");if(resolution.length!==4){return null}const height=parseInt(resolution[1],10);const width=parseInt(resolution[3],10);const pixels=this._readPixels(readStream,width,height,resolution[0]==="-Y");if(!pixels){return null}return {width:width,height:height,levels:[pixels]}}_readPixels(readStream,width,height,flipY){if(width<8||width>32767){return this._readPixelsFlat(readStream,width,height)}const rgbe=[0,0,0,0];readStream.readArray(rgbe);if(rgbe[0]!==2||rgbe[1]!==2||(rgbe[2]&128)!==0){readStream.skip(-4);return this._readPixelsFlat(readStream,width,height)}const buffer=new ArrayBuffer(width*height*4);const view=new Uint8Array(buffer);let scanstart=flipY?0:width*4*(height-1);let x,y,i,channel,count,value;for(y=0;y<height;++y){if(y){readStream.readArray(rgbe);}if((rgbe[2]<<8)+rgbe[3]!==width){return null}for(channel=0;channel<4;++channel){x=0;while(x<width){count=readStream.readU8();if(count>128){count-=128;if(x+count>width){return null}value=readStream.readU8();for(i=0;i<count;++i){view[scanstart+channel+4*x++]=value;}}else {if(count===0||x+count>width){return null}for(i=0;i<count;++i){view[scanstart+channel+4*x++]=readStream.readU8();}}}}scanstart+=width*4*(flipY?1:-1);}return view}_readPixelsFlat(readStream,width,height){return readStream.remainingBytes===width*height*4?new Uint8Array(readStream.arraybuffer,readStream.offset):null}constructor(registry){super();this.maxRetries=0;}}const JSON_ADDRESS_MODE={"repeat":ADDRESS_REPEAT,"clamp":ADDRESS_CLAMP_TO_EDGE,"mirror":ADDRESS_MIRRORED_REPEAT};const JSON_FILTER_MODE={"nearest":FILTER_NEAREST,"linear":FILTER_LINEAR,"nearest_mip_nearest":FILTER_NEAREST_MIPMAP_NEAREST,"linear_mip_nearest":FILTER_LINEAR_MIPMAP_NEAREST,"nearest_mip_linear":FILTER_NEAREST_MIPMAP_LINEAR,"linear_mip_linear":FILTER_LINEAR_MIPMAP_LINEAR};const JSON_TEXTURE_TYPE={"default":TEXTURETYPE_DEFAULT,"rgbm":TEXTURETYPE_RGBM,"rgbe":TEXTURETYPE_RGBE,"rgbp":TEXTURETYPE_RGBP,"swizzleGGGR":TEXTURETYPE_SWIZZLEGGGR};const _completePartialMipmapChain=function _completePartialMipmapChain(texture){const requiredMipLevels=TextureUtils.calcMipLevelsCount(texture._width,texture._height);const isHtmlElement=function isHtmlElement(object){return object instanceof HTMLCanvasElement||object instanceof HTMLImageElement||object instanceof HTMLVideoElement};if(!(texture._format===PIXELFORMAT_RGBA8||texture._format===PIXELFORMAT_RGBA32F)||texture._volume||texture._compressed||texture._levels.length===1||texture._levels.length===requiredMipLevels||isHtmlElement(texture._cubemap?texture._levels[0][0]:texture._levels[0])){return}const downsample=function downsample(width,height,data){const sampledWidth=Math.max(1,width>>1);const sampledHeight=Math.max(1,height>>1);const sampledData=new data.constructor(sampledWidth*sampledHeight*4);const xs=Math.floor(width/sampledWidth);const ys=Math.floor(height/sampledHeight);const xsys=xs*ys;for(let y=0;y<sampledHeight;++y){for(let x=0;x<sampledWidth;++x){for(let e=0;e<4;++e){let sum=0;for(let sy=0;sy<ys;++sy){for(let sx=0;sx<xs;++sx){sum+=data[(x*xs+sx+(y*ys+sy)*width)*4+e];}}sampledData[(x+y*sampledWidth)*4+e]=sum/xsys;}}}return sampledData};for(let level=texture._levels.length;level<requiredMipLevels;++level){const width=Math.max(1,texture._width>>level-1);const height=Math.max(1,texture._height>>level-1);if(texture._cubemap){const mips=[];for(let face=0;face<6;++face){mips.push(downsample(width,height,texture._levels[level-1][face]));}texture._levels.push(mips);}else {texture._levels.push(downsample(width,height,texture._levels[level-1]));}}texture._levelsUpdated=texture._cubemap?[[true,true,true,true,true,true]]:[true];};class TextureHandler extends ResourceHandler{set crossOrigin(value){this.imgParser.crossOrigin=value;}get crossOrigin(){return this.imgParser.crossOrigin}set maxRetries(value){this.imgParser.maxRetries=value;for(const parser in this.parsers){if(this.parsers.hasOwnProperty(parser)){this.parsers[parser].maxRetries=value;}}}get maxRetries(){return this.imgParser.maxRetries}_getUrlWithoutParams(url){return url.indexOf("?")>=0?url.split("?")[0]:url}_getParser(url){const ext=path.getExtension(this._getUrlWithoutParams(url)).toLowerCase().replace(".","");return this.parsers[ext]||this.imgParser}_getTextureOptions(asset){const options={};if(asset){var _asset$name;if(((_asset$name=asset.name)==null?void 0:_asset$name.length)>0){options.name=asset.name;}const assetData=asset.data;if(assetData.hasOwnProperty("minfilter")){options.minFilter=JSON_FILTER_MODE[assetData.minfilter];}if(assetData.hasOwnProperty("magfilter")){options.magFilter=JSON_FILTER_MODE[assetData.magfilter];}if(assetData.hasOwnProperty("addressu")){options.addressU=JSON_ADDRESS_MODE[assetData.addressu];}if(assetData.hasOwnProperty("addressv")){options.addressV=JSON_ADDRESS_MODE[assetData.addressv];}if(assetData.hasOwnProperty("mipmaps")){options.mipmaps=assetData.mipmaps;}if(assetData.hasOwnProperty("anisotropy")){options.anisotropy=assetData.anisotropy;}if(assetData.hasOwnProperty("flipY")){options.flipY=!!assetData.flipY;}if(assetData.hasOwnProperty("type")){options.type=JSON_TEXTURE_TYPE[assetData.type];}else if(assetData.hasOwnProperty("rgbm")&&assetData.rgbm){options.type=TEXTURETYPE_RGBM;}else if(asset.file&&(asset.file.opt&8)!==0){options.type=TEXTURETYPE_SWIZZLEGGGR;}}return options}load(url,callback,asset){if(typeof url==="string"){url={load:url,original:url};}this._getParser(url.original).load(url,callback,asset);}open(url,data,asset){if(!url){return undefined}const textureOptions=this._getTextureOptions(asset);let texture=this._getParser(url).open(url,data,this._device,textureOptions);if(texture===null){texture=new Texture(this._device,{width:4,height:4,format:PIXELFORMAT_RGB8});}else {_completePartialMipmapChain(texture);if(data.unswizzledGGGR){asset.file.variants.basis.opt&=~8;}}return texture}patch(asset,assets){const texture=asset.resource;if(!texture){return}const options=this._getTextureOptions(asset);for(const key of Object.keys(options)){texture[key]=options[key];}}constructor(app){super(app,"texture");const assets=app.assets;const device=app.graphicsDevice;this._device=device;this._assets=assets;this.imgParser=new ImgParser(assets,device);this.parsers={dds:new DdsParser(assets),ktx:new KtxParser(assets),ktx2:new Ktx2Parser(assets,device),basis:new BasisParser(assets,device),hdr:new HdrParser(assets)};}}const XRTYPE_INLINE="inline";const XRTYPE_VR="immersive-vr";const XRTYPE_AR="immersive-ar";const XRSPACE_VIEWER="viewer";const XRSPACE_LOCAL="local";const XRSPACE_LOCALFLOOR="local-floor";const XRSPACE_BOUNDEDFLOOR="bounded-floor";const XRSPACE_UNBOUNDED="unbounded";const XRTARGETRAY_GAZE="gaze";const XRTARGETRAY_SCREEN="screen";const XRTARGETRAY_POINTER="tracked-pointer";const XREYE_NONE="none";const XREYE_LEFT="left";const XREYE_RIGHT="right";const XRHAND_NONE="none";const XRHAND_LEFT="left";const XRHAND_RIGHT="right";const XRTRACKABLE_POINT="point";const XRTRACKABLE_PLANE="plane";const XRTRACKABLE_MESH="mesh";const XRDEPTHSENSINGUSAGE_CPU="cpu-optimized";const XRDEPTHSENSINGUSAGE_GPU="gpu-optimized";const XRDEPTHSENSINGFORMAT_L8A8="luminance-alpha";const XRDEPTHSENSINGFORMAT_F32="float32";class XrDepthSensing extends EventHandler{_onSessionStart(){if(this._views.availableDepth){var _this$_views$list$;this._evtDepthResize=(_this$_views$list$=this._views.list[0])==null?void 0:_this$_views$list$.on("depth:resize",this._onDepthResize,this);}}_onSessionEnd(){if(this._evtDepthResize){this._evtDepthResize.off();this._evtDepthResize=null;}if(this._available){this._available=false;this.fire("unavailable");}}_onDepthResize(width,height){this.fire("resize",width,height);}getDepth(u,v){var _this$_views$list$0$g,_this$_views$list$2;return (_this$_views$list$0$g=(_this$_views$list$2=this._views.list[0])==null?void 0:_this$_views$list$2.getDepth(u,v))!=null?_this$_views$list$0$g:null}update(){if(this._manager.session&&this.supported&&this._views.availableDepth&&this._views.list.length&&!this._available){this._available=true;this.fire("available");}}get supported(){return this._views.supportedDepth}get available(){return this._views.availableDepth}get usage(){return this._views.depthUsage}get dataFormat(){return this._views.depthFormat}get width(){var _this$_views$list$0$t,_this$_views$list$3;return (_this$_views$list$0$t=(_this$_views$list$3=this._views.list[0])==null||(_this$_views$list$3=_this$_views$list$3.textureDepth)==null?void 0:_this$_views$list$3.width)!=null?_this$_views$list$0$t:0}get height(){var _this$_views$list$0$t2,_this$_views$list$4;return (_this$_views$list$0$t2=(_this$_views$list$4=this._views.list[0])==null||(_this$_views$list$4=_this$_views$list$4.textureDepth)==null?void 0:_this$_views$list$4.height)!=null?_this$_views$list$0$t2:0}get texture(){var _this$_views$list$5;return (_this$_views$list$5=this._views.list[0])==null?void 0:_this$_views$list$5.textureDepth}get uvMatrix(){var _this$_views$list$0$d,_this$_views$list$6;return (_this$_views$list$0$d=(_this$_views$list$6=this._views.list[0])==null?void 0:_this$_views$list$6.depthUvMatrix)!=null?_this$_views$list$0$d:this._uvMatrix}get rawValueToMeters(){var _this$_views$list$0$d2,_this$_views$list$7;return (_this$_views$list$0$d2=(_this$_views$list$7=this._views.list[0])==null?void 0:_this$_views$list$7.depthValueToMeters)!=null?_this$_views$list$0$d2:0}constructor(manager){super();this._manager=void 0;this._views=void 0;this._available=false;this._evtDepthResize=null;this._uvMatrix=Mat4.IDENTITY.clone();this._manager=manager;this._views=manager.views;if(this._views.supportedDepth){this._manager.on("start",this._onSessionStart,this);this._manager.on("end",this._onSessionEnd,this);}}}XrDepthSensing.EVENT_AVAILABLE="available";XrDepthSensing.EVENT_UNAVAILABLE="unavailable";XrDepthSensing.EVENT_RESIZE="resize";class XrDomOverlay{get supported(){return this._supported}get available(){return this._supported&&this._manager.active&&this._manager._session.domOverlayState!==null}get state(){if(!this._supported||!this._manager.active||!this._manager._session.domOverlayState){return null}return this._manager._session.domOverlayState.type}set root(value){if(!this._supported||this._manager.active){return}this._root=value;}get root(){return this._root}constructor(manager){this._manager=void 0;this._supported=platform.browser&&!!window.XRDOMOverlayState;this._root=null;this._manager=manager;}}const poolVec3=[];const poolQuat=[];class XrHitTestSource extends EventHandler{remove(){if(!this._xrHitTestSource){return}const sources=this.manager.hitTest.sources;const ind=sources.indexOf(this);if(ind!==-1)sources.splice(ind,1);this.onStop();}onStop(){this._xrHitTestSource.cancel();this._xrHitTestSource=null;this.fire("remove");this.manager.hitTest.fire("remove",this);}update(frame){if(this._transient){const transientResults=frame.getHitTestResultsForTransientInput(this._xrHitTestSource);for(let i=0;i<transientResults.length;i++){const transientResult=transientResults[i];if(!transientResult.results.length){continue}let inputSource;if(transientResult.inputSource){inputSource=this.manager.input._getByInputSource(transientResult.inputSource);}this.updateHitResults(transientResult.results,inputSource);}}else {const results=frame.getHitTestResults(this._xrHitTestSource);if(!results.length){return}this.updateHitResults(results);}}updateHitResults(results,inputSource){var _poolVec3$pop,_poolVec3$pop2,_poolQuat$pop;if(this._inputSource&&this._inputSource!==inputSource){return}const origin=(_poolVec3$pop=poolVec3.pop())!=null?_poolVec3$pop:new Vec3;if(inputSource){origin.copy(inputSource.getOrigin());}else {origin.copy(this.manager.camera.getPosition());}let candidateDistance=Infinity;let candidateHitTestResult=null;const position=(_poolVec3$pop2=poolVec3.pop())!=null?_poolVec3$pop2:new Vec3;const rotation=(_poolQuat$pop=poolQuat.pop())!=null?_poolQuat$pop:new Quat;for(let i=0;i<results.length;i++){const pose=results[i].getPose(this.manager._referenceSpace);const distance=origin.distance(pose.transform.position);if(distance>=candidateDistance){continue}candidateDistance=distance;candidateHitTestResult=results[i];position.copy(pose.transform.position);rotation.copy(pose.transform.orientation);}this.fire("result",position,rotation,inputSource||this._inputSource,candidateHitTestResult);this.manager.hitTest.fire("result",this,position,rotation,inputSource||this._inputSource,candidateHitTestResult);poolVec3.push(origin);poolVec3.push(position);poolQuat.push(rotation);}constructor(manager,xrHitTestSource,transient,inputSource=null){super();this.manager=void 0;this._xrHitTestSource=void 0;this._transient=void 0;this._inputSource=void 0;this.manager=manager;this._xrHitTestSource=xrHitTestSource;this._transient=transient;this._inputSource=inputSource;}}XrHitTestSource.EVENT_REMOVE="remove";XrHitTestSource.EVENT_RESULT="result";class XrHitTest extends EventHandler{_onSessionStart(){if(this.manager.session.enabledFeatures){const available=this.manager.session.enabledFeatures.indexOf("hit-test")!==-1;if(!available)return;this._available=available;this.fire("available");}else if(!this._checkingAvailability){this._checkingAvailability=true;this.manager.session.requestReferenceSpace(XRSPACE_VIEWER).then(referenceSpace=>{this.manager.session.requestHitTestSource({space:referenceSpace}).then(hitTestSource=>{hitTestSource.cancel();if(this.manager.active){this._available=true;this.fire("available");}}).catch(()=>{});}).catch(()=>{});}}_onSessionEnd(){if(!this._available)return;this._available=false;for(let i=0;i<this.sources.length;i++){this.sources[i].onStop();}this.sources=[];this.fire("unavailable");}start(options={}){if(!this._supported){options.callback==null||options.callback(new Error("XR HitTest is not supported"),null);return}if(!this._available){options.callback==null||options.callback(new Error("XR HitTest is not available"),null);return}if(!options.profile&&!options.spaceType){options.spaceType=XRSPACE_VIEWER;}let xrRay;const offsetRay=options.offsetRay;if(offsetRay){const origin=new DOMPoint(offsetRay.origin.x,offsetRay.origin.y,offsetRay.origin.z,1);const direction=new DOMPoint(offsetRay.direction.x,offsetRay.direction.y,offsetRay.direction.z,0);xrRay=new XRRay(origin,direction);}const callback=options.callback;if(options.spaceType){this.manager.session.requestReferenceSpace(options.spaceType).then(referenceSpace=>{if(!this.manager.session){const err=new Error("XR Session is not started (2)");if(callback)callback(err);this.fire("error",err);return}this.manager.session.requestHitTestSource({space:referenceSpace,entityTypes:options.entityTypes||undefined,offsetRay:xrRay}).then(xrHitTestSource=>{this._onHitTestSource(xrHitTestSource,false,options.inputSource,callback);}).catch(ex=>{if(callback)callback(ex);this.fire("error",ex);});}).catch(ex=>{if(callback)callback(ex);this.fire("error",ex);});}else {this.manager.session.requestHitTestSourceForTransientInput({profile:options.profile,entityTypes:options.entityTypes||undefined,offsetRay:xrRay}).then(xrHitTestSource=>{this._onHitTestSource(xrHitTestSource,true,options.inputSource,callback);}).catch(ex=>{if(callback)callback(ex);this.fire("error",ex);});}}_onHitTestSource(xrHitTestSource,transient,inputSource,callback){if(!this.manager.session){xrHitTestSource.cancel();const err=new Error("XR Session is not started (3)");if(callback)callback(err);this.fire("error",err);return}const hitTestSource=new XrHitTestSource(this.manager,xrHitTestSource,transient,inputSource!=null?inputSource:null);this.sources.push(hitTestSource);if(callback)callback(null,hitTestSource);this.fire("add",hitTestSource);}update(frame){if(!this._available){return}for(let i=0;i<this.sources.length;i++){this.sources[i].update(frame);}}get supported(){return this._supported}get available(){return this._available}constructor(manager){super();this.manager=void 0;this._supported=platform.browser&&!!(window.XRSession&&window.XRSession.prototype.requestHitTestSource);this._available=false;this._checkingAvailability=false;this.sources=[];this.manager=manager;if(this._supported){this.manager.on("start",this._onSessionStart,this);this.manager.on("end",this._onSessionEnd,this);}}}XrHitTest.EVENT_AVAILABLE="available";XrHitTest.EVENT_UNAVAILABLE="unavailable";XrHitTest.EVENT_ADD="add";XrHitTest.EVENT_REMOVE="remove";XrHitTest.EVENT_RESULT="result";XrHitTest.EVENT_ERROR="error";class XrTrackedImage extends EventHandler{get image(){return this._image}set width(value){this._width=value;}get width(){return this._width}get trackable(){return this._trackable}get tracking(){return this._tracking}get emulated(){return this._emulated}prepare(){if(this._bitmap){return {image:this._bitmap,widthInMeters:this._width}}return createImageBitmap(this._image).then(bitmap=>{this._bitmap=bitmap;return {image:this._bitmap,widthInMeters:this._width}})}destroy(){this._image=null;this._pose=null;if(this._bitmap){this._bitmap.close();this._bitmap=null;}}getPosition(){if(this._pose)this._position.copy(this._pose.transform.position);return this._position}getRotation(){if(this._pose)this._rotation.copy(this._pose.transform.orientation);return this._rotation}constructor(image,width){super();this._image=void 0;this._width=void 0;this._bitmap=null;this._measuredWidth=0;this._trackable=false;this._tracking=false;this._emulated=false;this._pose=null;this._position=new Vec3;this._rotation=new Quat;this._image=image;this._width=width;}}XrTrackedImage.EVENT_TRACKED="tracked";XrTrackedImage.EVENT_UNTRACKED="untracked";class XrImageTracking extends EventHandler{add(image,width){if(!this._supported||this._manager.active)return null;const trackedImage=new XrTrackedImage(image,width);this._images.push(trackedImage);return trackedImage}remove(trackedImage){if(this._manager.active)return;const ind=this._images.indexOf(trackedImage);if(ind!==-1){trackedImage.destroy();this._images.splice(ind,1);}}_onSessionStart(){this._manager.session.getTrackedImageScores().then(images=>{this._available=true;for(let i=0;i<images.length;i++){this._images[i]._trackable=images[i]==="trackable";}}).catch(err=>{this._available=false;this.fire("error",err);});}_onSessionEnd(){this._available=false;for(let i=0;i<this._images.length;i++){const image=this._images[i];image._pose=null;image._measuredWidth=0;if(image._tracking){image._tracking=false;image.fire("untracked");}}}prepareImages(callback){if(this._images.length){Promise.all(this._images.map(trackedImage=>{return trackedImage.prepare()})).then(bitmaps=>{callback(null,bitmaps);}).catch(err=>{callback(err,null);});}else {callback(null,null);}}update(frame){if(!this._available)return;const results=frame.getImageTrackingResults();const index={};for(let i=0;i<results.length;i++){index[results[i].index]=results[i];const trackedImage=this._images[results[i].index];trackedImage._emulated=results[i].trackingState==="emulated";trackedImage._measuredWidth=results[i].measuredWidthInMeters;trackedImage._pose=frame.getPose(results[i].imageSpace,this._manager._referenceSpace);}for(let i=0;i<this._images.length;i++){if(this._images[i]._tracking&&!index[i]){this._images[i]._tracking=false;this._images[i].fire("untracked");}else if(!this._images[i]._tracking&&index[i]){this._images[i]._tracking=true;this._images[i].fire("tracked");}}}get supported(){return this._supported}get available(){return this._available}get images(){return this._images}constructor(manager){super();this._manager=void 0;this._supported=platform.browser&&!!window.XRImageTrackingResult;this._available=false;this._images=[];this._manager=manager;if(this._supported){this._manager.on("start",this._onSessionStart,this);this._manager.on("end",this._onSessionEnd,this);}}}XrImageTracking.EVENT_ERROR="error";class XrFinger{get index(){return this._index}get hand(){return this._hand}get joints(){return this._joints}get tip(){return this._tip}constructor(index,hand){this._index=void 0;this._hand=void 0;this._joints=[];this._tip=null;this._index=index;this._hand=hand;this._hand._fingers.push(this);}}const tipJointIds=platform.browser&&window.XRHand?["thumb-tip","index-finger-tip","middle-finger-tip","ring-finger-tip","pinky-finger-tip"]:[];const tipJointIdsIndex={};for(let i=0;i<tipJointIds.length;i++){tipJointIdsIndex[tipJointIds[i]]=true;}class XrJoint{update(pose){this._dirtyLocal=true;this._radius=pose.radius;this._localPosition.copy(pose.transform.position);this._localRotation.copy(pose.transform.orientation);}_updateTransforms(){if(this._dirtyLocal){this._dirtyLocal=false;this._localTransform.setTRS(this._localPosition,this._localRotation,Vec3.ONE);}const manager=this._hand._manager;const parent=manager.camera.parent;if(parent){this._worldTransform.mul2(parent.getWorldTransform(),this._localTransform);}else {this._worldTransform.copy(this._localTransform);}}getPosition(){this._updateTransforms();this._worldTransform.getTranslation(this._position);return this._position}getRotation(){this._updateTransforms();this._rotation.setFromMat4(this._worldTransform);return this._rotation}get index(){return this._index}get hand(){return this._hand}get finger(){return this._finger}get wrist(){return this._wrist}get tip(){return this._tip}get radius(){return this._radius||.005}constructor(index,id,hand,finger=null){this._index=void 0;this._id=void 0;this._hand=void 0;this._finger=void 0;this._wrist=void 0;this._tip=void 0;this._radius=null;this._localTransform=new Mat4;this._worldTransform=new Mat4;this._localPosition=new Vec3;this._localRotation=new Quat;this._position=new Vec3;this._rotation=new Quat;this._dirtyLocal=true;this._index=index;this._id=id;this._hand=hand;this._finger=finger;this._wrist=id==="wrist";this._tip=this._finger&&!!tipJointIdsIndex[id];}}let fingerJointIds=[];const vecA$1=new Vec3;const vecB$1=new Vec3;const vecC=new Vec3;if(platform.browser&&window.XRHand){fingerJointIds=[["thumb-metacarpal","thumb-phalanx-proximal","thumb-phalanx-distal","thumb-tip"],["index-finger-metacarpal","index-finger-phalanx-proximal","index-finger-phalanx-intermediate","index-finger-phalanx-distal","index-finger-tip"],["middle-finger-metacarpal","middle-finger-phalanx-proximal","middle-finger-phalanx-intermediate","middle-finger-phalanx-distal","middle-finger-tip"],["ring-finger-metacarpal","ring-finger-phalanx-proximal","ring-finger-phalanx-intermediate","ring-finger-phalanx-distal","ring-finger-tip"],["pinky-finger-metacarpal","pinky-finger-phalanx-proximal","pinky-finger-phalanx-intermediate","pinky-finger-phalanx-distal","pinky-finger-tip"]];}class XrHand extends EventHandler{update(frame){const xrInputSource=this._inputSource._xrInputSource;for(let j=0;j<this._joints.length;j++){const joint=this._joints[j];const jointSpace=xrInputSource.hand.get(joint._id);if(jointSpace){let pose;if(frame.session.visibilityState!=="hidden"){pose=frame.getJointPose(jointSpace,this._manager._referenceSpace);}if(pose){joint.update(pose);if(joint.wrist&&!this._tracking){this._tracking=true;this.fire("tracking");}}else if(joint.wrist){if(this._tracking){this._tracking=false;this.fire("trackinglost");}break}}}const j1=this._jointsById["thumb-metacarpal"];const j4=this._jointsById["thumb-tip"];const j6=this._jointsById["index-finger-phalanx-proximal"];const j9=this._jointsById["index-finger-tip"];const j16=this._jointsById["ring-finger-phalanx-proximal"];const j21=this._jointsById["pinky-finger-phalanx-proximal"];if(j1&&j4&&j6&&j9&&j16&&j21){this._inputSource._dirtyRay=true;this._inputSource._rayLocal.origin.lerp(j4._localPosition,j9._localPosition,.5);let jointL=j1;let jointR=j21;if(this._inputSource.handedness===XRHAND_LEFT){const t=jointL;jointL=jointR;jointR=t;}vecA$1.sub2(jointL._localPosition,this._wrist._localPosition);vecB$1.sub2(jointR._localPosition,this._wrist._localPosition);vecC.cross(vecA$1,vecB$1).normalize();vecA$1.lerp(j6._localPosition,j16._localPosition,.5);vecA$1.sub(this._wrist._localPosition).normalize();this._inputSource._rayLocal.direction.lerp(vecC,vecA$1,.5).normalize();}const squeezing=this._fingerIsClosed(1)&&this._fingerIsClosed(2)&&this._fingerIsClosed(3)&&this._fingerIsClosed(4);if(squeezing){if(!this._inputSource._squeezing){this._inputSource._squeezing=true;this._inputSource.fire("squeezestart");this._manager.input.fire("squeezestart",this._inputSource);}}else {if(this._inputSource._squeezing){this._inputSource._squeezing=false;this._inputSource.fire("squeeze");this._manager.input.fire("squeeze",this._inputSource);this._inputSource.fire("squeezeend");this._manager.input.fire("squeezeend",this._inputSource);}}}_fingerIsClosed(index){const finger=this._fingers[index];vecA$1.sub2(finger.joints[0]._localPosition,finger.joints[1]._localPosition).normalize();vecB$1.sub2(finger.joints[2]._localPosition,finger.joints[3]._localPosition).normalize();return vecA$1.dot(vecB$1)<-.8}getJointById(id){return this._jointsById[id]||null}get fingers(){return this._fingers}get joints(){return this._joints}get tips(){return this._tips}get wrist(){return this._wrist}get tracking(){return this._tracking}constructor(inputSource){super();this._manager=void 0;this._inputSource=void 0;this._tracking=false;this._fingers=[];this._joints=[];this._jointsById={};this._tips=[];this._wrist=null;const xrHand=inputSource._xrInputSource.hand;this._manager=inputSource._manager;this._inputSource=inputSource;if(xrHand.get("wrist")){const joint=new XrJoint(0,"wrist",this,null);this._wrist=joint;this._joints.push(joint);this._jointsById.wrist=joint;}for(let f=0;f<fingerJointIds.length;f++){const finger=new XrFinger(f,this);for(let j=0;j<fingerJointIds[f].length;j++){const jointId=fingerJointIds[f][j];if(!xrHand.get(jointId))continue;const joint=new XrJoint(j,jointId,this,finger);this._joints.push(joint);this._jointsById[jointId]=joint;if(joint.tip){this._tips.push(joint);finger._tip=joint;}finger._joints.push(joint);}}}}XrHand.EVENT_TRACKING="tracking";XrHand.EVENT_TRACKINGLOST="trackinglost";const vec3A$1=new Vec3;const quat=new Quat;let ids$1=0;class XrInputSource extends EventHandler{get id(){return this._id}get inputSource(){return this._xrInputSource}get targetRayMode(){return this._xrInputSource.targetRayMode}get handedness(){return this._xrInputSource.handedness}get profiles(){return this._xrInputSource.profiles}get grip(){return this._grip}get hand(){return this._hand}get gamepad(){return this._xrInputSource.gamepad||null}get selecting(){return this._selecting}get squeezing(){return this._squeezing}set elementInput(value){if(this._elementInput===value){return}this._elementInput=value;if(!this._elementInput){this._elementEntity=null;}}get elementInput(){return this._elementInput}get elementEntity(){return this._elementEntity}get hitTestSources(){return this._hitTestSources}update(frame){if(this._hand){this._hand.update(frame);}else {const gripSpace=this._xrInputSource.gripSpace;if(gripSpace){const gripPose=frame.getPose(gripSpace,this._manager._referenceSpace);if(gripPose){if(!this._grip){this._grip=true;this._localTransform=new Mat4;this._worldTransform=new Mat4;this._localPositionLast=new Vec3;this._localPosition=new Vec3;this._localRotation=new Quat;this._linearVelocity=new Vec3;}const timestamp=now();const dt=(timestamp-this._velocitiesTimestamp)/1e3;this._velocitiesTimestamp=timestamp;this._dirtyLocal=true;this._localPositionLast.copy(this._localPosition);this._localPosition.copy(gripPose.transform.position);this._localRotation.copy(gripPose.transform.orientation);this._velocitiesAvailable=true;if(this._manager.input.velocitiesSupported&&gripPose.linearVelocity){this._linearVelocity.copy(gripPose.linearVelocity);}else if(dt>0){vec3A$1.sub2(this._localPosition,this._localPositionLast).divScalar(dt);this._linearVelocity.lerp(this._linearVelocity,vec3A$1,.15);}}else {this._velocitiesAvailable=false;}}const targetRayPose=frame.getPose(this._xrInputSource.targetRaySpace,this._manager._referenceSpace);if(targetRayPose){this._dirtyRay=true;this._rayLocal.origin.copy(targetRayPose.transform.position);this._rayLocal.direction.set(0,0,-1);quat.copy(targetRayPose.transform.orientation);quat.transformVector(this._rayLocal.direction,this._rayLocal.direction);}}}_updateTransforms(){if(this._dirtyLocal){this._dirtyLocal=false;this._localTransform.setTRS(this._localPosition,this._localRotation,Vec3.ONE);}const parent=this._manager.camera.parent;if(parent){this._worldTransform.mul2(parent.getWorldTransform(),this._localTransform);}else {this._worldTransform.copy(this._localTransform);}}_updateRayTransforms(){const dirty=this._dirtyRay;this._dirtyRay=false;const parent=this._manager.camera.parent;if(parent){const parentTransform=this._manager.camera.parent.getWorldTransform();parentTransform.getTranslation(this._position);this._rotation.setFromMat4(parentTransform);this._rotation.transformVector(this._rayLocal.origin,this._ray.origin);this._ray.origin.add(this._position);this._rotation.transformVector(this._rayLocal.direction,this._ray.direction);}else if(dirty){this._ray.origin.copy(this._rayLocal.origin);this._ray.direction.copy(this._rayLocal.direction);}}getPosition(){if(!this._position)return null;this._updateTransforms();this._worldTransform.getTranslation(this._position);return this._position}getLocalPosition(){return this._localPosition}getRotation(){if(!this._rotation)return null;this._updateTransforms();this._rotation.setFromMat4(this._worldTransform);return this._rotation}getLocalRotation(){return this._localRotation}getLinearVelocity(){if(!this._velocitiesAvailable){return null}return this._linearVelocity}getOrigin(){this._updateRayTransforms();return this._ray.origin}getDirection(){this._updateRayTransforms();return this._ray.direction}hitTestStart(options={}){options.inputSource=this;options.profile=this._xrInputSource.profiles[0];const callback=options.callback;options.callback=(err,hitTestSource)=>{if(hitTestSource)this.onHitTestSourceAdd(hitTestSource);if(callback)callback(err,hitTestSource);};this._manager.hitTest.start(options);}onHitTestSourceAdd(hitTestSource){this._hitTestSources.push(hitTestSource);this.fire("hittest:add",hitTestSource);hitTestSource.on("result",(position,rotation,inputSource,hitTestResult)=>{if(inputSource!==this)return;this.fire("hittest:result",hitTestSource,position,rotation,hitTestResult);});hitTestSource.once("remove",()=>{this.onHitTestSourceRemove(hitTestSource);this.fire("hittest:remove",hitTestSource);});}onHitTestSourceRemove(hitTestSource){const ind=this._hitTestSources.indexOf(hitTestSource);if(ind!==-1)this._hitTestSources.splice(ind,1);}constructor(manager,xrInputSource){super();this._id=void 0;this._manager=void 0;this._xrInputSource=void 0;this._ray=new Ray;this._rayLocal=new Ray;this._grip=false;this._hand=null;this._velocitiesAvailable=false;this._velocitiesTimestamp=now();this._localTransform=null;this._worldTransform=null;this._position=new Vec3;this._rotation=new Quat;this._localPosition=null;this._localPositionLast=null;this._localRotation=null;this._linearVelocity=null;this._dirtyLocal=true;this._dirtyRay=false;this._selecting=false;this._squeezing=false;this._elementInput=true;this._elementEntity=null;this._hitTestSources=[];this._id=++ids$1;this._manager=manager;this._xrInputSource=xrInputSource;if(xrInputSource.hand){this._hand=new XrHand(this);}}}XrInputSource.EVENT_REMOVE="remove";XrInputSource.EVENT_SELECT="select";XrInputSource.EVENT_SELECTSTART="selectstart";XrInputSource.EVENT_SELECTEND="selectend";XrInputSource.EVENT_SQUEEZE="squeeze";XrInputSource.EVENT_SQUEEZESTART="squeezestart";XrInputSource.EVENT_SQUEEZEEND="squeezeend";XrInputSource.EVENT_HITTESTADD="hittest:add";XrInputSource.EVENT_HITTESTREMOVE="hittest:remove";XrInputSource.EVENT_HITTESTRESULT="hittest:result";class XrInput extends EventHandler{_onSessionStart(){const session=this.manager.session;session.addEventListener("inputsourceschange",this._onInputSourcesChangeEvt);session.addEventListener("select",evt=>{const inputSource=this._getByInputSource(evt.inputSource);inputSource.update(evt.frame);inputSource.fire("select",evt);this.fire("select",inputSource,evt);});session.addEventListener("selectstart",evt=>{const inputSource=this._getByInputSource(evt.inputSource);inputSource.update(evt.frame);inputSource._selecting=true;inputSource.fire("selectstart",evt);this.fire("selectstart",inputSource,evt);});session.addEventListener("selectend",evt=>{const inputSource=this._getByInputSource(evt.inputSource);inputSource.update(evt.frame);inputSource._selecting=false;inputSource.fire("selectend",evt);this.fire("selectend",inputSource,evt);});session.addEventListener("squeeze",evt=>{const inputSource=this._getByInputSource(evt.inputSource);inputSource.update(evt.frame);inputSource.fire("squeeze",evt);this.fire("squeeze",inputSource,evt);});session.addEventListener("squeezestart",evt=>{const inputSource=this._getByInputSource(evt.inputSource);inputSource.update(evt.frame);inputSource._squeezing=true;inputSource.fire("squeezestart",evt);this.fire("squeezestart",inputSource,evt);});session.addEventListener("squeezeend",evt=>{const inputSource=this._getByInputSource(evt.inputSource);inputSource.update(evt.frame);inputSource._squeezing=false;inputSource.fire("squeezeend",evt);this.fire("squeezeend",inputSource,evt);});const inputSources=session.inputSources;for(let i=0;i<inputSources.length;i++){this._addInputSource(inputSources[i]);}}_onSessionEnd(){let i=this._inputSources.length;while(i--){const inputSource=this._inputSources[i];this._inputSources.splice(i,1);inputSource.fire("remove");this.fire("remove",inputSource);}const session=this.manager.session;session.removeEventListener("inputsourceschange",this._onInputSourcesChangeEvt);}_onInputSourcesChange(evt){for(let i=0;i<evt.removed.length;i++){this._removeInputSource(evt.removed[i]);}for(let i=0;i<evt.added.length;i++){this._addInputSource(evt.added[i]);}}_getByInputSource(xrInputSource){for(let i=0;i<this._inputSources.length;i++){if(this._inputSources[i].inputSource===xrInputSource){return this._inputSources[i]}}return null}_addInputSource(xrInputSource){if(this._getByInputSource(xrInputSource)){return}const inputSource=new XrInputSource(this.manager,xrInputSource);this._inputSources.push(inputSource);this.fire("add",inputSource);}_removeInputSource(xrInputSource){for(let i=0;i<this._inputSources.length;i++){if(this._inputSources[i].inputSource!==xrInputSource){continue}const inputSource=this._inputSources[i];this._inputSources.splice(i,1);let h=inputSource.hitTestSources.length;while(h--){inputSource.hitTestSources[h].remove();}inputSource.fire("remove");this.fire("remove",inputSource);return}}update(frame){for(let i=0;i<this._inputSources.length;i++){this._inputSources[i].update(frame);}}get inputSources(){return this._inputSources}constructor(manager){var _window$XRPose;super();this.manager=void 0;this._inputSources=[];this._onInputSourcesChangeEvt=void 0;this.velocitiesSupported=false;this.manager=manager;this.velocitiesSupported=!!(platform.browser&&(_window$XRPose=window.XRPose)!=null&&(_window$XRPose=_window$XRPose.prototype)!=null&&_window$XRPose.hasOwnProperty("linearVelocity"));this._onInputSourcesChangeEvt=evt=>{this._onInputSourcesChange(evt);};this.manager.on("start",this._onSessionStart,this);this.manager.on("end",this._onSessionEnd,this);}}XrInput.EVENT_ADD="add";XrInput.EVENT_REMOVE="remove";XrInput.EVENT_SELECT="select";XrInput.EVENT_SELECTSTART="selectstart";XrInput.EVENT_SELECTEND="selectend";XrInput.EVENT_SQUEEZE="squeeze";XrInput.EVENT_SQUEEZESTART="squeezestart";XrInput.EVENT_SQUEEZEEND="squeezeend";const vec3A=new Vec3;const vec3B=new Vec3;const mat4A=new Mat4;const mat4B=new Mat4;class XrLightEstimation extends EventHandler{_onSessionStart(){const supported=!!this._manager.session.requestLightProbe;if(!supported)return;this._supported=true;}_onSessionEnd(){this._supported=false;this._available=false;this._lightProbeRequested=false;this._lightProbe=null;}start(){let err;if(!this._manager.session){err=new Error("XR session is not running");}if(!err&&this._manager.type!==XRTYPE_AR){err=new Error("XR session type is not AR");}if(!err&&!this._supported){err=new Error("light-estimation is not supported");}if(!err&&this._lightProbe||this._lightProbeRequested){err=new Error("light estimation is already requested");}if(err){this.fire("error",err);return}this._lightProbeRequested=true;this._manager.session.requestLightProbe().then(lightProbe=>{const wasRequested=this._lightProbeRequested;this._lightProbeRequested=false;if(this._manager.active){if(wasRequested){this._lightProbe=lightProbe;}}else {this.fire("error",new Error("XR session is not active"));}}).catch(ex=>{this._lightProbeRequested=false;this.fire("error",ex);});}end(){this._lightProbeRequested=false;this._lightProbe=null;this._available=false;}update(frame){if(!this._lightProbe)return;const lightEstimate=frame.getLightEstimate(this._lightProbe);if(!lightEstimate)return;if(!this._available){this._available=true;this.fire("available");}const pli=lightEstimate.primaryLightIntensity;this._intensity=Math.max(1,Math.max(pli.x,Math.max(pli.y,pli.z)));vec3A.copy(pli).mulScalar(1/this._intensity);this._color.set(vec3A.x,vec3A.y,vec3A.z);vec3A.set(0,0,0);vec3B.copy(lightEstimate.primaryLightDirection);mat4A.setLookAt(vec3B,vec3A,Vec3.UP);mat4B.setFromAxisAngle(Vec3.RIGHT,90);mat4A.mul(mat4B);this._rotation.setFromMat4(mat4A);this._sphericalHarmonics.set(lightEstimate.sphericalHarmonicsCoefficients);}get supported(){return this._supported}get available(){return this._available}get intensity(){return this._available?this._intensity:null}get color(){return this._available?this._color:null}get rotation(){return this._available?this._rotation:null}get sphericalHarmonics(){return this._available?this._sphericalHarmonics:null}constructor(manager){super();this._manager=void 0;this._supported=false;this._available=false;this._lightProbeRequested=false;this._lightProbe=null;this._intensity=0;this._rotation=new Quat;this._color=new Color;this._sphericalHarmonics=new Float32Array(27);this._manager=manager;this._manager.on("start",this._onSessionStart,this);this._manager.on("end",this._onSessionEnd,this);}}XrLightEstimation.EVENT_AVAILABLE="available";XrLightEstimation.EVENT_ERROR="error";let ids=0;class XrPlane extends EventHandler{destroy(){if(!this._xrPlane)return;this._xrPlane=null;this.fire("remove");}update(frame){const manager=this._planeDetection._manager;const pose=frame.getPose(this._xrPlane.planeSpace,manager._referenceSpace);if(pose){this._position.copy(pose.transform.position);this._rotation.copy(pose.transform.orientation);}if(this._lastChangedTime!==this._xrPlane.lastChangedTime){this._lastChangedTime=this._xrPlane.lastChangedTime;this.fire("change");}}getPosition(){return this._position}getRotation(){return this._rotation}get id(){return this._id}get orientation(){return this._orientation}get points(){return this._xrPlane.polygon}get label(){return this._xrPlane.semanticLabel||""}constructor(planeDetection,xrPlane){super();this._id=void 0;this._planeDetection=void 0;this._xrPlane=void 0;this._lastChangedTime=void 0;this._orientation=void 0;this._position=new Vec3;this._rotation=new Quat;this._id=++ids;this._planeDetection=planeDetection;this._xrPlane=xrPlane;this._lastChangedTime=xrPlane.lastChangedTime;this._orientation=xrPlane.orientation;}}XrPlane.EVENT_REMOVE="remove";XrPlane.EVENT_CHANGE="change";class XrPlaneDetection extends EventHandler{_onSessionStart(){if(this._manager.session.enabledFeatures){const available=this._manager.session.enabledFeatures.indexOf("plane-detection")!==-1;if(available){this._available=true;this.fire("available");}}}_onSessionEnd(){for(let i=0;i<this._planes.length;i++){this._planes[i].destroy();this.fire("remove",this._planes[i]);}this._planesIndex.clear();this._planes.length=0;if(this._available){this._available=false;this.fire("unavailable");}}update(frame){if(!this._available){if(!this._manager.session.enabledFeatures&&frame.detectedPlanes.size){this._available=true;this.fire("available");}else {return}}const detectedPlanes=frame.detectedPlanes;for(const[xrPlane,plane]of this._planesIndex){if(detectedPlanes.has(xrPlane)){continue}this._planesIndex.delete(xrPlane);this._planes.splice(this._planes.indexOf(plane),1);plane.destroy();this.fire("remove",plane);}for(const xrPlane of detectedPlanes){let plane=this._planesIndex.get(xrPlane);if(!plane){plane=new XrPlane(this,xrPlane);this._planesIndex.set(xrPlane,plane);this._planes.push(plane);plane.update(frame);this.fire("add",plane);}else {plane.update(frame);}}}get supported(){return this._supported}get available(){return this._available}get planes(){return this._planes}constructor(manager){super();this._manager=void 0;this._supported=platform.browser&&!!window.XRPlane;this._available=false;this._planesIndex=new Map;this._planes=[];this._manager=manager;if(this._supported){this._manager.on("start",this._onSessionStart,this);this._manager.on("end",this._onSessionEnd,this);}}}XrPlaneDetection.EVENT_AVAILABLE="available";XrPlaneDetection.EVENT_UNAVAILABLE="unavailable";XrPlaneDetection.EVENT_ADD="add";XrPlaneDetection.EVENT_REMOVE="remove";class XrAnchor extends EventHandler{destroy(){if(!this._xrAnchor)return;const xrAnchor=this._xrAnchor;this._xrAnchor.delete();this._xrAnchor=null;this.fire("destroy",xrAnchor,this);}update(frame){if(!this._xrAnchor){return}const pose=frame.getPose(this._xrAnchor.anchorSpace,this._anchors.manager._referenceSpace);if(pose){if(this._position.equals(pose.transform.position)&&this._rotation.equals(pose.transform.orientation)){return}this._position.copy(pose.transform.position);this._rotation.copy(pose.transform.orientation);this.fire("change");}}getPosition(){return this._position}getRotation(){return this._rotation}persist(callback){if(!this._anchors.persistence){callback==null||callback(new Error("Persistent Anchors are not supported"),null);return}if(this._uuid){callback==null||callback(null,this._uuid);return}if(this._uuidRequests){if(callback)this._uuidRequests.push(callback);return}this._uuidRequests=[];this._xrAnchor.requestPersistentHandle().then(uuid=>{this._uuid=uuid;this._anchors._indexByUuid.set(this._uuid,this);callback==null||callback(null,uuid);for(const uuidRequest of this._uuidRequests){uuidRequest(null,uuid);}this._uuidRequests=null;this.fire("persist",uuid);}).catch(ex=>{callback==null||callback(ex,null);for(const uuidRequest of this._uuidRequests){uuidRequest(ex,null);}this._uuidRequests=null;});}forget(callback){if(!this._uuid){callback==null||callback(new Error("Anchor is not persistent"));return}this._anchors.forget(this._uuid,ex=>{this._uuid=null;callback==null||callback(ex);this.fire("forget");});}get uuid(){return this._uuid}get persistent(){return !!this._uuid}constructor(anchors,xrAnchor,uuid=null){super();this._position=new Vec3;this._rotation=new Quat;this._uuid=null;this._uuidRequests=null;this._anchors=anchors;this._xrAnchor=xrAnchor;this._uuid=uuid;}}XrAnchor.EVENT_DESTROY="destroy";XrAnchor.EVENT_CHANGE="change";XrAnchor.EVENT_PERSIST="persist";XrAnchor.EVENT_FORGET="forget";class XrAnchors extends EventHandler{_onSessionStart(){const available=this.manager.session.enabledFeatures.indexOf("anchors")!==-1;if(!available)return;this._available=available;this.fire("available");}_onSessionEnd(){if(!this._available)return;this._available=false;for(let _i=0;_i<this._creationQueue.length;_i++){if(!this._creationQueue[_i].callback){continue}this._creationQueue[_i].callback(new Error("session ended"),null);}this._creationQueue.length=0;this._index.clear();this._indexByUuid.clear();let i=this._list.length;while(i--){this._list[i].destroy();}this._list.length=0;this.fire("unavailable");}_createAnchor(xrAnchor,uuid=null){const anchor=new XrAnchor(this,xrAnchor,uuid);this._index.set(xrAnchor,anchor);if(uuid)this._indexByUuid.set(uuid,anchor);this._list.push(anchor);anchor.once("destroy",this._onAnchorDestroy,this);return anchor}_onAnchorDestroy(xrAnchor,anchor){this._index.delete(xrAnchor);if(anchor.uuid)this._indexByUuid.delete(anchor.uuid);const ind=this._list.indexOf(anchor);if(ind!==-1)this._list.splice(ind,1);this.fire("destroy",anchor);}create(position,rotation,callback){if(!this._available){callback==null||callback(new Error("Anchors API is not available"),null);return}if(window.XRHitTestResult&&position instanceof XRHitTestResult){const hitResult=position;callback=rotation;if(!this._supported){callback==null||callback(new Error("Anchors API is not supported"),null);return}if(!hitResult.createAnchor){callback==null||callback(new Error("Creating Anchor from Hit Test is not supported"),null);return}hitResult.createAnchor().then(xrAnchor=>{const anchor=this._createAnchor(xrAnchor);callback==null||callback(null,anchor);this.fire("add",anchor);}).catch(ex=>{callback==null||callback(ex,null);this.fire("error",ex);});}else {this._creationQueue.push({transform:new XRRigidTransform(position,rotation),callback:callback});}}restore(uuid,callback){if(!this._available){callback==null||callback(new Error("Anchors API is not available"),null);return}if(!this._persistence){callback==null||callback(new Error("Anchor Persistence is not supported"),null);return}if(!this.manager.active){callback==null||callback(new Error("WebXR session is not active"),null);return}this.manager.session.restorePersistentAnchor(uuid).then(xrAnchor=>{const anchor=this._createAnchor(xrAnchor,uuid);callback==null||callback(null,anchor);this.fire("add",anchor);}).catch(ex=>{callback==null||callback(ex,null);this.fire("error",ex);});}forget(uuid,callback){if(!this._available){callback==null||callback(new Error("Anchors API is not available"));return}if(!this._persistence){callback==null||callback(new Error("Anchor Persistence is not supported"));return}if(!this.manager.active){callback==null||callback(new Error("WebXR session is not active"));return}this.manager.session.deletePersistentAnchor(uuid).then(()=>{callback==null||callback(null);}).catch(ex=>{callback==null||callback(ex);this.fire("error",ex);});}update(frame){if(!this._available){if(!this.manager.session.enabledFeatures&&!this._checkingAvailability){this._checkingAvailability=true;frame.createAnchor(new XRRigidTransform,this.manager._referenceSpace).then(xrAnchor=>{xrAnchor.delete();if(this.manager.active){this._available=true;this.fire("available");}}).catch(()=>{});}return}if(this._creationQueue.length){for(let i=0;i<this._creationQueue.length;i++){const request=this._creationQueue[i];frame.createAnchor(request.transform,this.manager._referenceSpace).then(xrAnchor=>{if(request.callback){this._callbacksAnchors.set(xrAnchor,request.callback);}}).catch(ex=>{if(request.callback){request.callback(ex,null);}this.fire("error",ex);});}this._creationQueue.length=0;}for(const[xrAnchor,anchor]of this._index){if(frame.trackedAnchors.has(xrAnchor)){continue}this._index.delete(xrAnchor);anchor.destroy();}for(let i=0;i<this._list.length;i++){this._list[i].update(frame);}for(const xrAnchor of frame.trackedAnchors){if(this._index.has(xrAnchor)){continue}try{const tmp=xrAnchor.anchorSpace;}catch(ex){continue}const anchor=this._createAnchor(xrAnchor);anchor.update(frame);const callback=this._callbacksAnchors.get(xrAnchor);if(callback){this._callbacksAnchors.delete(xrAnchor);callback(null,anchor);}this.fire("add",anchor);}}get supported(){return this._supported}get available(){return this._available}get persistence(){return this._persistence}get uuids(){if(!this._available){return null}if(!this._persistence){return null}if(!this.manager.active){return null}return this.manager.session.persistentAnchors}get list(){return this._list}constructor(manager){var _window;super();this.manager=void 0;this._supported=platform.browser&&!!window.XRAnchor;this._available=false;this._checkingAvailability=false;this._persistence=platform.browser&&!!((_window=window)!=null&&(_window=_window.XRSession)!=null&&_window.prototype.restorePersistentAnchor);this._creationQueue=[];this._index=new Map;this._indexByUuid=new Map;this._list=[];this._callbacksAnchors=new Map;this.manager=manager;if(this._supported){this.manager.on("start",this._onSessionStart,this);this.manager.on("end",this._onSessionEnd,this);}}}XrAnchors.EVENT_AVAILABLE="available";XrAnchors.EVENT_UNAVAILABLE="unavailable";XrAnchors.EVENT_ERROR="error";XrAnchors.EVENT_ADD="add";XrAnchors.EVENT_DESTROY="destroy";class XrMesh extends EventHandler{get xrMesh(){return this._xrMesh}get label(){return this._xrMesh.semanticLabel||""}get vertices(){return this._xrMesh.vertices}get indices(){return this._xrMesh.indices}destroy(){if(!this._xrMesh)return;this._xrMesh=null;this.fire("remove");}update(frame){const manager=this._meshDetection._manager;const pose=frame.getPose(this._xrMesh.meshSpace,manager._referenceSpace);if(pose){this._position.copy(pose.transform.position);this._rotation.copy(pose.transform.orientation);}if(this._lastChanged!==this._xrMesh.lastChangedTime){this._lastChanged=this._xrMesh.lastChangedTime;this.fire("change");}}getPosition(){return this._position}getRotation(){return this._rotation}constructor(meshDetection,xrMesh){super();this._meshDetection=void 0;this._xrMesh=void 0;this._lastChanged=0;this._position=new Vec3;this._rotation=new Quat;this._meshDetection=meshDetection;this._xrMesh=xrMesh;this._lastChanged=this._xrMesh.lastChangedTime;}}XrMesh.EVENT_REMOVE="remove";XrMesh.EVENT_CHANGE="change";class XrMeshDetection extends EventHandler{update(frame){if(!this._available){if(!this._manager.session.enabledFeatures&&frame.detectedMeshes.size){this._available=true;this.fire("available");}else {return}}for(const xrMesh of frame.detectedMeshes){let mesh=this._index.get(xrMesh);if(!mesh){mesh=new XrMesh(this,xrMesh);this._index.set(xrMesh,mesh);this._list.push(mesh);mesh.update(frame);this.fire("add",mesh);}else {mesh.update(frame);}}for(const mesh of this._index.values()){if(frame.detectedMeshes.has(mesh.xrMesh)){continue}this._removeMesh(mesh);}}_removeMesh(mesh){this._index.delete(mesh.xrMesh);this._list.splice(this._list.indexOf(mesh),1);mesh.destroy();this.fire("remove",mesh);}_onSessionStart(){if(this._manager.session.enabledFeatures){const available=this._manager.session.enabledFeatures.indexOf("mesh-detection")!==-1;if(!available)return;this._available=available;this.fire("available");}}_onSessionEnd(){if(!this._available)return;this._available=false;for(const mesh of this._index.values()){this._removeMesh(mesh);}this.fire("unavailable");}get supported(){return this._supported}get available(){return this._available}get meshes(){return this._list}constructor(manager){super();this._manager=void 0;this._supported=platform.browser&&!!window.XRMesh;this._available=false;this._index=new Map;this._list=[];this._manager=manager;if(this._supported){this._manager.on("start",this._onSessionStart,this);this._manager.on("end",this._onSessionEnd,this);}}}XrMeshDetection.EVENT_AVAILABLE="available";XrMeshDetection.EVENT_UNAVAILABLE="unavailable";XrMeshDetection.EVENT_ADD="add";XrMeshDetection.EVENT_REMOVE="remove";class XrView extends EventHandler{get textureColor(){return this._textureColor}get textureDepth(){return this._textureDepth}get depthUvMatrix(){return this._depthMatrix}get depthValueToMeters(){var _this$_depthInfo;return ((_this$_depthInfo=this._depthInfo)==null?void 0:_this$_depthInfo.rawValueToMeters)||0}get eye(){return this._xrView.eye}get viewport(){return this._viewport}get projMat(){return this._projMat}get projViewOffMat(){return this._projViewOffMat}get viewOffMat(){return this._viewOffMat}get viewInvOffMat(){return this._viewInvOffMat}get viewMat3(){return this._viewMat3}get positionData(){return this._positionData}update(frame,xrView){this._xrView=xrView;if(this._manager.views.availableColor){this._xrCamera=this._xrView.camera;}const layer=frame.session.renderState.baseLayer;const viewport=layer.getViewport(this._xrView);this._viewport.x=viewport.x;this._viewport.y=viewport.y;this._viewport.z=viewport.width;this._viewport.w=viewport.height;this._projMat.set(this._xrView.projectionMatrix);this._viewMat.set(this._xrView.transform.inverse.matrix);this._viewInvMat.set(this._xrView.transform.matrix);this._updateTextureColor();this._updateDepth(frame);}_updateTextureColor(){if(!this._manager.views.availableColor||!this._xrCamera||!this._textureColor){return}const binding=this._manager.webglBinding;if(!binding){return}const texture=binding.getCameraImage(this._xrCamera);if(!texture){return}const device=this._manager.app.graphicsDevice;const gl=device.gl;if(!this._frameBufferSource){this._frameBufferSource=gl.createFramebuffer();this._frameBuffer=gl.createFramebuffer();}else {var _device$extDrawBuffer,_device$extDrawBuffer2;const attachmentBaseConstant=device.isWebGL2?gl.COLOR_ATTACHMENT0:(_device$extDrawBuffer=(_device$extDrawBuffer2=device.extDrawBuffers)==null?void 0:_device$extDrawBuffer2.COLOR_ATTACHMENT0_WEBGL)!=null?_device$extDrawBuffer:gl.COLOR_ATTACHMENT0;const width=this._xrCamera.width;const height=this._xrCamera.height;device.setFramebuffer(this._frameBufferSource);gl.framebufferTexture2D(gl.FRAMEBUFFER,attachmentBaseConstant,gl.TEXTURE_2D,texture,0);device.setFramebuffer(this._frameBuffer);gl.framebufferTexture2D(gl.FRAMEBUFFER,attachmentBaseConstant,gl.TEXTURE_2D,this._textureColor.impl._glTexture,0);gl.bindFramebuffer(gl.READ_FRAMEBUFFER,this._frameBufferSource);gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER,this._frameBuffer);gl.blitFramebuffer(0,height,width,0,0,0,width,height,gl.COLOR_BUFFER_BIT,gl.NEAREST);}}_updateDepth(frame){var _this$_depthInfo2,_this$_depthInfo3;if(!this._manager.views.availableDepth||!this._textureDepth){return}const gpu=this._manager.views.depthGpuOptimized;const infoSource=gpu?this._manager.webglBinding:frame;if(!infoSource){this._depthInfo=null;return}const depthInfo=infoSource.getDepthInformation(this._xrView);if(!depthInfo){this._depthInfo=null;return}let matrixDirty=!this._depthInfo!==!depthInfo;this._depthInfo=depthInfo;const width=((_this$_depthInfo2=this._depthInfo)==null?void 0:_this$_depthInfo2.width)||4;const height=((_this$_depthInfo3=this._depthInfo)==null?void 0:_this$_depthInfo3.height)||4;let resized=false;if(this._textureDepth.width!==width||this._textureDepth.height!==height){this._textureDepth._width=width;this._textureDepth._height=height;matrixDirty=true;resized=true;}if(matrixDirty){if(this._depthInfo){this._depthMatrix.data.set(this._depthInfo.normDepthBufferFromNormView.matrix);}else {this._depthMatrix.setIdentity();}}if(this._depthInfo){if(gpu){if(this._depthInfo.texture){this._textureDepth.impl._glTexture=this._depthInfo.texture;}}else {this._textureDepth._levels[0]=new Uint8Array(this._depthInfo.data);this._textureDepth.upload();}}else {this._textureDepth._levels[0]=this._emptyDepthBuffer;this._textureDepth.upload();}if(resized)this.fire("depth:resize",width,height);}updateTransforms(transform){if(transform){this._viewInvOffMat.mul2(transform,this._viewInvMat);this.viewOffMat.copy(this._viewInvOffMat).invert();}else {this._viewInvOffMat.copy(this._viewInvMat);this.viewOffMat.copy(this._viewMat);}this._viewMat3.setFromMat4(this._viewOffMat);this._projViewOffMat.mul2(this._projMat,this._viewOffMat);this._positionData[0]=this._viewInvOffMat.data[12];this._positionData[1]=this._viewInvOffMat.data[13];this._positionData[2]=this._viewInvOffMat.data[14];}_onDeviceLost(){this._frameBufferSource=null;this._frameBuffer=null;this._depthInfo=null;}getDepth(u,v){var _this$_depthInfo$getD,_this$_depthInfo4;if(this._manager.views.depthGpuOptimized){return null}return (_this$_depthInfo$getD=(_this$_depthInfo4=this._depthInfo)==null?void 0:_this$_depthInfo4.getDepthInMeters(u,v))!=null?_this$_depthInfo$getD:null}destroy(){this._depthInfo=null;if(this._textureColor){this._textureColor.destroy();this._textureColor=null;}if(this._textureDepth){this._textureDepth.destroy();this._textureDepth=null;}if(this._frameBufferSource){const gl=this._manager.app.graphicsDevice.gl;gl.deleteFramebuffer(this._frameBufferSource);this._frameBufferSource=null;gl.deleteFramebuffer(this._frameBuffer);this._frameBuffer=null;}}constructor(manager,xrView,viewsCount){super();this._manager=void 0;this._xrView=void 0;this._positionData=new Float32Array(3);this._viewport=new Vec4;this._projMat=new Mat4;this._projViewOffMat=new Mat4;this._viewMat=new Mat4;this._viewOffMat=new Mat4;this._viewMat3=new Mat3;this._viewInvMat=new Mat4;this._viewInvOffMat=new Mat4;this._xrCamera=null;this._textureColor=null;this._textureDepth=null;this._depthInfo=null;this._emptyDepthBuffer=new Uint8Array(32);this._depthMatrix=new Mat4;this._manager=manager;this._xrView=xrView;const device=this._manager.app.graphicsDevice;if(this._manager.views.supportedColor){this._xrCamera=this._xrView.camera;if(this._manager.views.availableColor&&this._xrCamera){this._textureColor=new Texture(device,{format:PIXELFORMAT_RGB8,mipmaps:false,addressU:ADDRESS_CLAMP_TO_EDGE,addressV:ADDRESS_CLAMP_TO_EDGE,minFilter:FILTER_LINEAR,magFilter:FILTER_LINEAR,width:this._xrCamera.width,height:this._xrCamera.height,name:`XrView-${this._xrView.eye}-Color`});}}if(this._manager.views.supportedDepth&&this._manager.views.availableDepth){this._textureDepth=new Texture(device,{format:this._manager.views.depthPixelFormat,arrayLength:viewsCount===1?0:viewsCount,mipmaps:false,addressU:ADDRESS_CLAMP_TO_EDGE,addressV:ADDRESS_CLAMP_TO_EDGE,minFilter:FILTER_LINEAR,magFilter:FILTER_LINEAR,width:4,height:4,name:`XrView-${this._xrView.eye}-Depth`});for(let i=0;i<this._textureDepth._levels.length;i++){this._textureDepth._levels[i]=this._emptyDepthBuffer;}}if(this._textureColor||this._textureDepth){device.on("devicelost",this._onDeviceLost,this);}}}XrView.EVENT_DEPTHRESIZE="depth:resize";class XrViews extends EventHandler{get list(){return this._list}get supportedColor(){return this._supportedColor}get supportedDepth(){return this._supportedDepth}get availableColor(){return this._availableColor}get availableDepth(){return this._availableDepth}get depthUsage(){return this._depthUsage}get depthGpuOptimized(){return this._depthUsage===XRDEPTHSENSINGUSAGE_GPU}get depthFormat(){return this._depthFormat}get depthPixelFormat(){var _this$_depthFormats$t;return (_this$_depthFormats$t=this._depthFormats[this._depthFormat])!=null?_this$_depthFormats$t:null}update(frame,xrViews){for(let i=0;i<xrViews.length;i++){this._indexTmp.set(xrViews[i].eye,xrViews[i]);}for(const[eye,xrView]of this._indexTmp){let view=this._index.get(eye);if(!view){view=new XrView(this._manager,xrView,xrViews.length);this._index.set(eye,view);this._list.push(view);view.update(frame,xrView);this.fire("add",view);}else {view.update(frame,xrView);}}for(const[eye,view]of this._index){if(this._indexTmp.has(eye)){continue}view.destroy();this._index.delete(eye);const ind=this._list.indexOf(view);if(ind!==-1)this._list.splice(ind,1);this.fire("remove",view);}this._indexTmp.clear();}get(eye){return this._index.get(eye)||null}_onSessionStart(){if(this._manager.type!==XRTYPE_AR){return}if(!this._manager.session.enabledFeatures){return}this._availableColor=this._manager.session.enabledFeatures.indexOf("camera-access")!==-1;this._availableDepth=this._manager.session.enabledFeatures.indexOf("depth-sensing")!==-1;if(this._availableDepth){const session=this._manager.session;this._depthUsage=session.depthUsage;this._depthFormat=session.depthDataFormat;}}_onSessionEnd(){for(const view of this._index.values()){view.destroy();}this._index.clear();this._availableColor=false;this._availableDepth=false;this._depthUsage="";this._depthFormat="";this._list.length=0;}constructor(manager){super();this._manager=void 0;this._index=new Map;this._indexTmp=new Map;this._list=[];this._supportedColor=platform.browser&&!!window.XRCamera&&!!window.XRWebGLBinding;this._supportedDepth=platform.browser&&!!window.XRDepthInformation;this._availableColor=false;this._availableDepth=false;this._depthUsage="";this._depthFormat="";this._depthFormats={[XRDEPTHSENSINGFORMAT_L8A8]:PIXELFORMAT_LA8,[XRDEPTHSENSINGFORMAT_F32]:PIXELFORMAT_R32F};this._manager=manager;this._manager.on("start",this._onSessionStart,this);this._manager.on("end",this._onSessionEnd,this);}}XrViews.EVENT_ADD="add";XrViews.EVENT_REMOVE="remove";class XrManager extends EventHandler{destroy(){}start(camera,type,spaceType,options){var _options$framebufferS,_this$app$graphicsDev,_this$app$graphicsDev2;let callback=options;if(typeof options==="object"){callback=options.callback;}if(!this._available[type]){if(callback)callback(new Error("XR is not available"));return}if(this._session){if(callback)callback(new Error("XR session is already started"));return}this._camera=camera;this._camera.camera.xr=this;this._type=type;this._spaceType=spaceType;this._framebufferScaleFactor=(_options$framebufferS=options==null?void 0:options.framebufferScaleFactor)!=null?_options$framebufferS:1;this._setClipPlanes(camera.nearClip,camera.farClip);const opts={requiredFeatures:[spaceType],optionalFeatures:[]};const webgl=((_this$app$graphicsDev=this.app.graphicsDevice)==null?void 0:_this$app$graphicsDev.isWebGL1)||((_this$app$graphicsDev2=this.app.graphicsDevice)==null?void 0:_this$app$graphicsDev2.isWebGL2);if(type===XRTYPE_AR){opts.optionalFeatures.push("light-estimation");opts.optionalFeatures.push("hit-test");if(options){if(options.imageTracking&&this.imageTracking.supported){opts.optionalFeatures.push("image-tracking");}if(options.planeDetection){opts.optionalFeatures.push("plane-detection");}if(options.meshDetection){opts.optionalFeatures.push("mesh-detection");}}if(this.domOverlay.supported&&this.domOverlay.root){opts.optionalFeatures.push("dom-overlay");opts.domOverlay={root:this.domOverlay.root};}if(options&&options.anchors&&this.anchors.supported){opts.optionalFeatures.push("anchors");}if(options&&options.depthSensing&&this.depthSensing.supported){opts.optionalFeatures.push("depth-sensing");const usagePreference=[];const dataFormatPreference=[];if(!navigator.userAgent.includes("OculusBrowser")){usagePreference.push(XRDEPTHSENSINGUSAGE_CPU);dataFormatPreference.push(XRDEPTHSENSINGFORMAT_L8A8);if(options.depthSensing.usagePreference){const ind=usagePreference.indexOf(options.depthSensing.usagePreference);if(ind!==-1)usagePreference.splice(ind,1);usagePreference.unshift(options.depthSensing.usagePreference);}if(options.depthSensing.dataFormatPreference){const ind=dataFormatPreference.indexOf(options.depthSensing.dataFormatPreference);if(ind!==-1)dataFormatPreference.splice(ind,1);dataFormatPreference.unshift(options.depthSensing.dataFormatPreference);}}opts.depthSensing={usagePreference:usagePreference,dataFormatPreference:dataFormatPreference};}if(webgl&&options&&options.cameraColor&&this.views.supportedColor){opts.optionalFeatures.push("camera-access");}}opts.optionalFeatures.push("hand-tracking");if(options&&options.optionalFeatures){opts.optionalFeatures=opts.optionalFeatures.concat(options.optionalFeatures);}if(this.imageTracking.supported&&this.imageTracking.images.length){this.imageTracking.prepareImages((err,trackedImages)=>{if(err){if(callback)callback(err);this.fire("error",err);return}if(trackedImages!==null){opts.trackedImages=trackedImages;}this._onStartOptionsReady(type,spaceType,opts,callback);});}else {this._onStartOptionsReady(type,spaceType,opts,callback);}}_onStartOptionsReady(type,spaceType,options,callback){navigator.xr.requestSession(type,options).then(session=>{this._onSessionStart(session,spaceType,callback);}).catch(ex=>{this._camera.camera.xr=null;this._camera=null;this._type=null;this._spaceType=null;if(callback)callback(ex);this.fire("error",ex);});}end(callback){if(!this._session){if(callback)callback(new Error("XR Session is not initialized"));return}this.webglBinding=null;if(callback)this.once("end",callback);this._session.end();}isAvailable(type){return this._available[type]}_deviceAvailabilityCheck(){for(const key in this._available){this._sessionSupportCheck(key);}}initiateRoomCapture(callback){if(!this._session){callback(new Error("Session is not active"));return}if(!this._session.initiateRoomCapture){callback(new Error("Session does not support manual room capture"));return}this._session.initiateRoomCapture().then(()=>{if(callback)callback(null);}).catch(err=>{if(callback)callback(err);});}updateTargetFrameRate(frameRate,callback){var _this$_session;if(!((_this$_session=this._session)!=null&&_this$_session.updateTargetFrameRate)){callback==null||callback(new Error("unable to update frameRate"));return}this._session.updateTargetFrameRate(frameRate).then(()=>{callback==null||callback();}).catch(err=>{callback==null||callback(err);});}_sessionSupportCheck(type){navigator.xr.isSessionSupported(type).then(available=>{if(this._available[type]===available){return}this._available[type]=available;this.fire("available",type,available);this.fire(`available:${type}`,available);}).catch(ex=>{this.fire("error",ex);});}_onSessionStart(session,spaceType,callback){let failed=false;this._session=session;const onVisibilityChange=()=>{this.fire("visibility:change",session.visibilityState);};const onClipPlanesChange=()=>{this._setClipPlanes(this._camera.nearClip,this._camera.farClip);};const onEnd=()=>{if(this._camera){this._camera.off("set_nearClip",onClipPlanesChange);this._camera.off("set_farClip",onClipPlanesChange);this._camera.camera.xr=null;this._camera=null;}session.removeEventListener("end",onEnd);session.removeEventListener("visibilitychange",onVisibilityChange);if(!failed)this.fire("end");this._session=null;this._referenceSpace=null;this._width=0;this._height=0;this._type=null;this._spaceType=null;if(this.app.systems){this.app.tick();}};session.addEventListener("end",onEnd);session.addEventListener("visibilitychange",onVisibilityChange);this._camera.on("set_nearClip",onClipPlanesChange);this._camera.on("set_farClip",onClipPlanesChange);this._createBaseLayer();if(this.session.supportedFrameRates){this._supportedFrameRates=Array.from(this.session.supportedFrameRates);}else {this._supportedFrameRates=null;}this._session.addEventListener("frameratechange",()=>{var _this$_session2;this.fire("frameratechange",(_this$_session2=this._session)==null?void 0:_this$_session2.frameRate);});session.requestReferenceSpace(spaceType).then(referenceSpace=>{this._referenceSpace=referenceSpace;this.app.tick();if(callback)callback(null);this.fire("start");}).catch(ex=>{failed=true;session.end();if(callback)callback(ex);this.fire("error",ex);});}_setClipPlanes(near,far){if(this._depthNear===near&&this._depthFar===far){return}this._depthNear=near;this._depthFar=far;if(!this._session){return}this._session.updateRenderState({depthNear:this._depthNear,depthFar:this._depthFar});}_createBaseLayer(){const device=this.app.graphicsDevice;const framebufferScaleFactor=device.maxPixelRatio/window.devicePixelRatio*this._framebufferScaleFactor;this._baseLayer=new XRWebGLLayer(this._session,device.gl,{alpha:true,depth:true,stencil:true,framebufferScaleFactor:framebufferScaleFactor,antialias:false});const deviceType=device.deviceType;if((deviceType===DEVICETYPE_WEBGL1||deviceType===DEVICETYPE_WEBGL2)&&window.XRWebGLBinding){try{this.webglBinding=new XRWebGLBinding(this._session,device.gl);}catch(ex){this.fire("error",ex);}}this._session.updateRenderState({baseLayer:this._baseLayer,depthNear:this._depthNear,depthFar:this._depthFar});}_onDeviceLost(){if(!this._session){return}if(this.webglBinding){this.webglBinding=null;}this._baseLayer=null;this._session.updateRenderState({baseLayer:this._baseLayer,depthNear:this._depthNear,depthFar:this._depthFar});}_onDeviceRestored(){if(!this._session){return}setTimeout(()=>{this.app.graphicsDevice.gl.makeXRCompatible().then(()=>{this._createBaseLayer();}).catch(ex=>{this.fire("error",ex);});},0);}update(frame){if(!this._session)return false;const width=frame.session.renderState.baseLayer.framebufferWidth;const height=frame.session.renderState.baseLayer.framebufferHeight;if(this._width!==width||this._height!==height){this._width=width;this._height=height;this.app.graphicsDevice.setResolution(width,height);}const pose=frame.getViewerPose(this._referenceSpace);if(!pose)return false;const lengthOld=this.views.list.length;this.views.update(frame,pose.views);const posePosition=pose.transform.position;const poseOrientation=pose.transform.orientation;this._localPosition.set(posePosition.x,posePosition.y,posePosition.z);this._localRotation.set(poseOrientation.x,poseOrientation.y,poseOrientation.z,poseOrientation.w);if(lengthOld===0&&this.views.list.length>0){const viewProjMat=new Mat4;const view=this.views.list[0];viewProjMat.copy(view.projMat);const data=viewProjMat.data;const fov=2*Math.atan(1/data[5])*180/Math.PI;const aspectRatio=data[5]/data[0];const farClip=data[14]/(data[10]+1);const nearClip=data[14]/(data[10]-1);const horizontalFov=false;const camera=this._camera.camera;camera.setXrProperties({aspectRatio,farClip,fov,horizontalFov,nearClip});}this._camera.camera._node.setLocalPosition(this._localPosition);this._camera.camera._node.setLocalRotation(this._localRotation);this.input.update(frame);if(this._type===XRTYPE_AR){if(this.hitTest.supported){this.hitTest.update(frame);}if(this.lightEstimation.supported){this.lightEstimation.update(frame);}if(this.imageTracking.supported){this.imageTracking.update(frame);}if(this.anchors.supported){this.anchors.update(frame);}if(this.planeDetection.supported){this.planeDetection.update(frame);}if(this.depthSensing.supported){this.depthSensing.update();}if(this.meshDetection.supported){this.meshDetection.update(frame);}}this.fire("update",frame);return true}get supported(){return this._supported}get active(){return !!this._session}get type(){return this._type}get spaceType(){return this._spaceType}get session(){return this._session}get frameRate(){var _this$_session$frameR,_this$_session3;return (_this$_session$frameR=(_this$_session3=this._session)==null?void 0:_this$_session3.frameRate)!=null?_this$_session$frameR:null}get supportedFrameRates(){return this._supportedFrameRates}get framebufferScaleFactor(){return this._framebufferScaleFactor}set fixedFoveation(value){var _this$_baseLayer$fixe,_this$_baseLayer;if(((_this$_baseLayer$fixe=(_this$_baseLayer=this._baseLayer)==null?void 0:_this$_baseLayer.fixedFoveation)!=null?_this$_baseLayer$fixe:null)!==null){if(this.app.graphicsDevice.samples>1);this._baseLayer.fixedFoveation=value;}}get fixedFoveation(){var _this$_baseLayer$fixe2,_this$_baseLayer2;return (_this$_baseLayer$fixe2=(_this$_baseLayer2=this._baseLayer)==null?void 0:_this$_baseLayer2.fixedFoveation)!=null?_this$_baseLayer$fixe2:null}get camera(){return this._camera?this._camera.entity:null}get visibilityState(){if(!this._session){return null}return this._session.visibilityState}constructor(app){super();this.app=void 0;this._supported=platform.browser&&!!navigator.xr;this._available={};this._type=null;this._spaceType=null;this._session=null;this._baseLayer=null;this.webglBinding=null;this._referenceSpace=null;this.depthSensing=void 0;this.domOverlay=void 0;this.hitTest=void 0;this.imageTracking=void 0;this.planeDetection=void 0;this.meshDetection=void 0;this.input=void 0;this.lightEstimation=void 0;this.views=void 0;this.anchors=void 0;this._camera=null;this._localPosition=new Vec3;this._localRotation=new Quat;this._depthNear=.1;this._depthFar=1e3;this._supportedFrameRates=null;this._width=0;this._height=0;this._framebufferScaleFactor=1;this.app=app;this._available[XRTYPE_INLINE]=false;this._available[XRTYPE_VR]=false;this._available[XRTYPE_AR]=false;this.views=new XrViews(this);this.depthSensing=new XrDepthSensing(this);this.domOverlay=new XrDomOverlay(this);this.hitTest=new XrHitTest(this);this.imageTracking=new XrImageTracking(this);this.planeDetection=new XrPlaneDetection(this);this.meshDetection=new XrMeshDetection(this);this.input=new XrInput(this);this.lightEstimation=new XrLightEstimation(this);this.anchors=new XrAnchors(this);this.views=new XrViews(this);if(this._supported){navigator.xr.addEventListener("devicechange",()=>{this._deviceAvailabilityCheck();});this._deviceAvailabilityCheck();this.app.graphicsDevice.on("devicelost",this._onDeviceLost,this);this.app.graphicsDevice.on("devicerestored",this._onDeviceRestored,this);}}}XrManager.EVENT_AVAILABLE="available";XrManager.EVENT_START="start";XrManager.EVENT_END="end";XrManager.EVENT_UPDATE="update";XrManager.EVENT_ERROR="error";class Application extends AppBase{createDevice(canvas,options){if(!options.graphicsDeviceOptions){options.graphicsDeviceOptions={};}if(platform.browser&&!!navigator.xr){options.graphicsDeviceOptions.xrCompatible=true;}options.graphicsDeviceOptions.alpha=options.graphicsDeviceOptions.alpha||false;return new WebglGraphicsDevice(canvas,options.graphicsDeviceOptions)}addComponentSystems(appOptions){appOptions.componentSystems=[RigidBodyComponentSystem,CollisionComponentSystem,JointComponentSystem,AnimationComponentSystem,AnimComponentSystem,ModelComponentSystem,RenderComponentSystem,CameraComponentSystem,LightComponentSystem,script.legacy?ScriptLegacyComponentSystem:ScriptComponentSystem,AudioSourceComponentSystem,SoundComponentSystem,AudioListenerComponentSystem,ParticleSystemComponentSystem,ScreenComponentSystem,ElementComponentSystem,ButtonComponentSystem,ScrollViewComponentSystem,ScrollbarComponentSystem,SpriteComponentSystem,LayoutGroupComponentSystem,LayoutChildComponentSystem,ZoneComponentSystem,GSplatComponentSystem];}addResourceHandles(appOptions){appOptions.resourceHandlers=[RenderHandler,AnimationHandler,AnimClipHandler,AnimStateGraphHandler,ModelHandler,MaterialHandler,TextureHandler,TextHandler,JsonHandler,AudioHandler,ScriptHandler,SceneHandler,CubemapHandler,HtmlHandler,CssHandler,ShaderHandler,HierarchyHandler,FolderHandler,FontHandler,BinaryHandler,TextureAtlasHandler,SpriteHandler,TemplateHandler,ContainerHandler,GSplatHandler];}constructor(canvas,options={}){var _options$graphicsDevi;super(canvas);const appOptions=new AppOptions;appOptions.graphicsDevice=(_options$graphicsDevi=options.graphicsDevice)!=null?_options$graphicsDevi:this.createDevice(canvas,options);this.addComponentSystems(appOptions);this.addResourceHandles(appOptions);appOptions.elementInput=options.elementInput;appOptions.keyboard=options.keyboard;appOptions.mouse=options.mouse;appOptions.touch=options.touch;appOptions.gamepads=options.gamepads;appOptions.scriptPrefix=options.scriptPrefix;appOptions.assetPrefix=options.assetPrefix;appOptions.scriptsOrder=options.scriptsOrder;appOptions.soundManager=new SoundManager;appOptions.lightmapper=Lightmapper;appOptions.batchManager=BatchManager;appOptions.xr=XrManager;this.init(appOptions);}}class AssetListLoader extends EventHandler{destroy(){const self1=this;this._registry.off("load",this._onLoad);this._registry.off("error",this._onError);this._waitingAssets.forEach(function(id){self1._registry.off(`add:${id}`,this._onAddAsset);});this.off("progress");this.off("load");}_assetHasDependencies(asset){var _asset$file;return asset.type==="model"&&((_asset$file=asset.file)==null?void 0:_asset$file.url)&&asset.file.url&&asset.file.url.match(/.json$/g)}load(done,scope){if(this._loading){return}this._loading=true;this._callback=done;this._scope=scope;this._registry.on("load",this._onLoad,this);this._registry.on("error",this._onError,this);let loadingAssets=false;this._assets.forEach(asset=>{if(!asset.loaded){loadingAssets=true;if(this._assetHasDependencies(asset)){this._registry.loadFromUrl(asset.file.url,asset.type,(err,loadedAsset)=>{if(err){this._onError(err,asset);return}this._onLoad(asset);});}this._loadingAssets.add(asset);this._registry.add(asset);}});this._loadingAssets.forEach(asset=>{if(!this._assetHasDependencies(asset)){this._registry.load(asset);}});if(!loadingAssets&&this._waitingAssets.size===0){this._loadingComplete();}}ready(done,scope=this){if(this._loaded){done.call(scope,Array.from(this._assets));}else {this.once("load",assets=>{done.call(scope,assets);});}}_loadingComplete(){if(this._loaded)return;this._loaded=true;this._registry.off("load",this._onLoad,this);this._registry.off("error",this._onError,this);if(this._failed.length){if(this._callback){this._callback.call(this._scope,"Failed to load some assets",this._failed);}this.fire("error",this._failed);}else {if(this._callback){this._callback.call(this._scope);}this.fire("load",Array.from(this._assets));}}_onLoad(asset){if(this._loadingAssets.has(asset)){this.fire("progress",asset);this._loadingAssets.delete(asset);}if(this._loadingAssets.size===0){setTimeout(()=>{this._loadingComplete(this._failed);},0);}}_onError(err,asset){if(this._loadingAssets.has(asset)){this._failed.push(asset);this._loadingAssets.delete(asset);}if(this._loadingAssets.size===0){setTimeout(()=>{this._loadingComplete(this._failed);},0);}}_onAddAsset(asset){this._waitingAssets.delete(asset);this._assets.add(asset);if(!asset.loaded){this._loadingAssets.add(asset);this._registry.load(asset);}}_waitForAsset(assetId){this._waitingAssets.add(assetId);this._registry.once(`add:${assetId}`,this._onAddAsset,this);}constructor(assetList,assetRegistry){super();this._assets=new Set;this._loadingAssets=new Set;this._waitingAssets=new Set;this._registry=assetRegistry;this._loading=false;this._loaded=false;this._failed=[];assetList.forEach(a=>{if(a instanceof Asset){if(!a.registry){a.registry=assetRegistry;}this._assets.add(a);}else {const asset=assetRegistry.get(a);if(asset){this._assets.add(asset);}else {this._waitForAsset(a);}}});}}const MAX_TEXTURE_SIZE=4096;const DEFAULT_TEXTURE_SIZE=512;class Atlas{destroy(){this.texture.destroy();}clear(clearColor){const{width,height}=this.canvas;this.ctx.clearRect(0,0,width,height);this.ctx.fillStyle=clearColor;this.ctx.fillRect(0,0,width,height);}constructor(device,width,height,name){this.canvas=document.createElement("canvas");this.canvas.width=width;this.canvas.height=height;this.texture=new Texture(device,{name:name,format:PIXELFORMAT_RGBA8,width:width,height:height,mipmaps:true,minFilter:FILTER_LINEAR_MIPMAP_LINEAR,magFilter:FILTER_LINEAR,addressU:ADDRESS_CLAMP_TO_EDGE,addressV:ADDRESS_CLAMP_TO_EDGE,levels:[this.canvas]});this.ctx=this.canvas.getContext("2d",{alpha:true});}}class CanvasFont extends EventHandler{createTextures(text){const _chars=this._normalizeCharsSet(text);if(_chars.length!==this.chars.length){this._renderAtlas(_chars);return}for(let i=0;i<_chars.length;i++){if(_chars[i]!==this.chars[i]){this._renderAtlas(_chars);return}}}updateTextures(text){const _chars=this._normalizeCharsSet(text);const newCharsSet=[];for(let i=0;i<_chars.length;i++){const char=_chars[i];if(!this.data.chars[char]){newCharsSet.push(char);}}if(newCharsSet.length>0){this._renderAtlas(this.chars.concat(newCharsSet));}}destroy(){this.atlases.forEach(atlas=>atlas.destroy());this.chars=null;this.color=null;this.data=null;this.fontName=null;this.fontSize=null;this.glyphSize=null;this.intensity=null;this.atlases=null;this.type=null;this.fontWeight=null;}_colorToRgbString(color,alpha){let str;const r=Math.round(255*color.r);const g=Math.round(255*color.g);const b=Math.round(255*color.b);if(alpha){str=`rgba(${r}, ${g}, ${b}, ${color.a})`;}else {str=`rgb(${r}, ${g}, ${b})`;}return str}renderCharacter(context,char,x,y,color){context.fillStyle=color;context.fillText(char,x,y);}_getAtlas(index){if(index>=this.atlases.length){this.atlases[index]=new Atlas(this.app.graphicsDevice,this.width,this.height,`font-atlas-${this.fontName}-${index}`);}return this.atlases[index]}_renderAtlas(charsArray){this.chars=charsArray;const w=this.width;const h=this.height;const color=this._colorToRgbString(this.color,false);const a=this.color.a;this.color.a=1/255;const transparent=this._colorToRgbString(this.color,true);this.color.a=a;const TEXT_ALIGN="center";const TEXT_BASELINE="alphabetic";let atlasIndex=0;let atlas=this._getAtlas(atlasIndex++);atlas.clear(transparent);this.data=this._createJson(this.chars,this.fontName,w,h);const symbols=string.getSymbols(this.chars.join(""));let maxHeight=0;let maxDescent=0;const metrics={};for(let i=0;i<symbols.length;i++){const ch=symbols[i];metrics[ch]=this._getTextMetrics(ch);maxHeight=Math.max(maxHeight,metrics[ch].height);maxDescent=Math.max(maxDescent,metrics[ch].descent);}this.glyphSize=Math.max(this.glyphSize,maxHeight);const sx=this.glyphSize+this.padding*2;const sy=this.glyphSize+this.padding*2;const _xOffset=this.glyphSize/2+this.padding;const _yOffset=sy-maxDescent-this.padding;let _x=0;let _y=0;for(let i=0;i<symbols.length;i++){const ch=symbols[i];const code=string.getCodePoint(symbols[i]);let fs=this.fontSize;atlas.ctx.font=`${this.fontWeight} ${fs.toString()}px ${this.fontName}`;atlas.ctx.textAlign=TEXT_ALIGN;atlas.ctx.textBaseline=TEXT_BASELINE;let width=atlas.ctx.measureText(ch).width;if(width>fs){fs=this.fontSize*this.fontSize/width;atlas.ctx.font=`${this.fontWeight} ${fs.toString()}px ${this.fontName}`;width=this.fontSize;}this.renderCharacter(atlas.ctx,ch,_x+_xOffset,_y+_yOffset,color);const xoffset=this.padding+(this.glyphSize-width)/2;const yoffset=-this.padding+metrics[ch].descent-maxDescent;const xadvance=width;this._addChar(this.data,ch,code,_x,_y,sx,sy,xoffset,yoffset,xadvance,atlasIndex-1,w,h);_x+=sx;if(_x+sx>w){_x=0;_y+=sy;if(_y+sy>h){atlas=this._getAtlas(atlasIndex++);atlas.clear(transparent);_y=0;}}}this.atlases.splice(atlasIndex).forEach(atlas=>atlas.destroy());this.atlases.forEach(atlas=>atlas.texture.upload());this.fire("render");}_createJson(chars,fontName,width,height){const base={"version":3,"intensity":this.intensity,"info":{"face":fontName,"width":width,"height":height,"maps":[{"width":width,"height":height}]},"chars":{}};return base}_addChar(json,char,charCode,x,y,w,h,xoffset,yoffset,xadvance,mapNum,mapW,mapH){if(json.info.maps.length<mapNum+1){json.info.maps.push({"width":mapW,"height":mapH});}const scale=this.fontSize/32;json.chars[char]={"id":charCode,"letter":char,"x":x,"y":y,"width":w,"height":h,"xadvance":xadvance/scale,"xoffset":xoffset/scale,"yoffset":(yoffset+this.padding)/scale,"scale":scale,"range":1,"map":mapNum,"bounds":[0,0,w/scale,h/scale]};}_normalizeCharsSet(text){const unicodeConverterFunc=this.app.systems.element.getUnicodeConverter();if(unicodeConverterFunc){text=unicodeConverterFunc(text);}const set={};const symbols=string.getSymbols(text);for(let i=0;i<symbols.length;i++){const ch=symbols[i];if(set[ch])continue;set[ch]=ch;}const chars=Object.keys(set);return chars.sort()}_getTextMetrics(text){const textSpan=document.createElement("span");textSpan.id="content-span";textSpan.innerHTML=text;const block=document.createElement("div");block.id="content-block";block.style.display="inline-block";block.style.width="1px";block.style.height="0px";const div=document.createElement("div");div.appendChild(textSpan);div.appendChild(block);div.style.font=`${this.fontSize}px ${this.fontName}`;const body=document.body;body.appendChild(div);let ascent=-1;let descent=-1;let height=-1;try{block.style["vertical-align"]="baseline";ascent=block.offsetTop-textSpan.offsetTop;block.style["vertical-align"]="bottom";height=block.offsetTop-textSpan.offsetTop;descent=height-ascent;}finally{document.body.removeChild(div);}return {ascent:ascent,descent:descent,height:height}}get textures(){return this.atlases.map(atlas=>atlas.texture)}constructor(app,options={}){super();this.type="bitmap";this.app=app;this.intensity=0;this.fontWeight=options.fontWeight||"normal";this.fontSize=parseInt(options.fontSize,10);this.glyphSize=this.fontSize;this.fontName=options.fontName||"Arial";this.color=options.color||new Color(1,1,1);this.padding=options.padding||0;this.width=Math.min(MAX_TEXTURE_SIZE,options.width||DEFAULT_TEXTURE_SIZE);this.height=Math.min(MAX_TEXTURE_SIZE,options.height||DEFAULT_TEXTURE_SIZE);this.atlases=[];this.chars="";this.data={};}}const tempMeshInstances$1=[];const lights=[[],[],[]];class RenderPassPicker extends RenderPass{update(camera,scene,layers,mapping){this.camera=camera;this.scene=scene;this.layers=layers;this.mapping=mapping;}execute(){const device=this.device;const{renderer,camera,scene,layers,mapping,renderTarget}=this;const srcLayers=scene.layers.layerList;const subLayerEnabled=scene.layers.subLayerEnabled;const isTransparent=scene.layers.subLayerList;const pickColorId=device.scope.resolve("uColor");const pickColor=this.pickColor;for(let i=0;i<srcLayers.length;i++){const srcLayer=srcLayers[i];if(layers&&layers.indexOf(srcLayer)<0){continue}if(srcLayer.enabled&&subLayerEnabled[i]){if(srcLayer.camerasSet.has(camera.camera)){const transparent=isTransparent[i];if(srcLayer._clearDepthBuffer){renderer.clear(camera.camera,false,true,false);}const meshInstances=srcLayer.meshInstances;for(let j=0;j<meshInstances.length;j++){const meshInstance=meshInstances[j];if(meshInstance.pick&&meshInstance.transparent===transparent){tempMeshInstances$1.push(meshInstance);mapping.set(meshInstance.id,meshInstance);}}if(tempMeshInstances$1.length>0){renderer.setCameraUniforms(camera.camera,renderTarget);renderer.renderForward(camera.camera,tempMeshInstances$1,lights,SHADER_PICK,meshInstance=>{const miId=meshInstance.id;pickColor[0]=(miId>>16&255)/255;pickColor[1]=(miId>>8&255)/255;pickColor[2]=(miId&255)/255;pickColor[3]=(miId>>24&255)/255;pickColorId.setValue(pickColor);device.setBlendState(BlendState.NOBLEND);});tempMeshInstances$1.length=0;}}}}}constructor(device,renderer){super(device);this.pickColor=new Float32Array(4);this.renderer=renderer;}}const tempSet=new Set;class Picker{getSelection(x,y,width=1,height=1){const device=this.device;y=this.renderTarget.height-(y+height);x=Math.floor(x);y=Math.floor(y);width=Math.floor(Math.max(width,1));height=Math.floor(Math.max(height,1));device.setRenderTarget(this.renderTarget);device.updateBegin();const pixels=new Uint8Array(4*width*height);device.readPixels(x,y,width,height,pixels);device.updateEnd();const mapping=this.mapping;for(let i=0;i<width*height;i++){const r=pixels[4*i+0];const g=pixels[4*i+1];const b=pixels[4*i+2];const a=pixels[4*i+3];const index=a<<24|r<<16|g<<8|b;if(index!==-1){tempSet.add(mapping.get(index));}}const selection=[];tempSet.forEach(meshInstance=>selection.push(meshInstance));tempSet.clear();return selection}allocateRenderTarget(){const colorBuffer=new Texture(this.device,{format:PIXELFORMAT_RGBA8,width:this.width,height:this.height,mipmaps:false,minFilter:FILTER_NEAREST,magFilter:FILTER_NEAREST,addressU:ADDRESS_CLAMP_TO_EDGE,addressV:ADDRESS_CLAMP_TO_EDGE,name:"pick"});this.renderTarget=new RenderTarget({colorBuffer:colorBuffer,depth:true});}releaseRenderTarget(){if(this.renderTarget){this.renderTarget.destroyTextureBuffers();this.renderTarget.destroy();this.renderTarget=null;}}prepare(camera,scene,layers){if(camera instanceof Camera){camera=camera.node.camera;}if(layers instanceof Layer){layers=[layers];}if(!this.renderTarget||this.width!==this.renderTarget.width||this.height!==this.renderTarget.height){this.releaseRenderTarget();this.allocateRenderTarget();}this.mapping.clear();const renderPass=this.renderPass;renderPass.init(this.renderTarget);renderPass.colorOps.clearValue=Color.WHITE;renderPass.colorOps.clear=true;renderPass.depthStencilOps.clearDepth=true;renderPass.update(camera,scene,layers,this.mapping);renderPass.render();}resize(width,height){this.width=Math.floor(width);this.height=Math.floor(height);}constructor(app,width,height){this.renderTarget=null;this.mapping=new Map;if(app instanceof GraphicsDevice){app=getApplication();}this.renderer=app.renderer;this.device=app.graphicsDevice;this.renderPass=new RenderPassPicker(this.device,app.renderer);this.width=0;this.height=0;this.resize(width,height);}}class SceneSettingsHandler extends ResourceHandler{load(url,callback){SceneUtils.load(url,this.maxRetries,callback);}open(url,data){return data.settings}constructor(app){super(app,"scenesettings");}}let targetX,targetY;const vecA=new Vec3;const vecB=new Vec3;const rayA=new Ray;const rayB=new Ray;const rayC=new Ray;rayA.end=new Vec3;rayB.end=new Vec3;rayC.end=new Vec3;const _pq=new Vec3;const _pa=new Vec3;const _pb=new Vec3;const _pc=new Vec3;const _pd=new Vec3;const _m=new Vec3;const _au=new Vec3;const _bv=new Vec3;const _cw=new Vec3;const _ir=new Vec3;const _sct=new Vec3;const _accumulatedScale=new Vec3;const _paddingTop=new Vec3;const _paddingBottom=new Vec3;const _paddingLeft=new Vec3;const _paddingRight=new Vec3;const _cornerBottomLeft=new Vec3;const _cornerBottomRight=new Vec3;const _cornerTopRight=new Vec3;const _cornerTopLeft=new Vec3;const ZERO_VEC4=new Vec4;function scalarTriple(p1,p2,p3){return _sct.cross(p1,p2).dot(p3)}function intersectLineQuad(p,q,corners){_pq.sub2(q,p);_pa.sub2(corners[0],p);_pb.sub2(corners[1],p);_pc.sub2(corners[2],p);_m.cross(_pc,_pq);let v=_pa.dot(_m);let u;let w;if(v>=0){u=-_pb.dot(_m);if(u<0){return -1}w=scalarTriple(_pq,_pb,_pa);if(w<0){return -1}const denom=1/(u+v+w);_au.copy(corners[0]).mulScalar(u*denom);_bv.copy(corners[1]).mulScalar(v*denom);_cw.copy(corners[2]).mulScalar(w*denom);_ir.copy(_au).add(_bv).add(_cw);}else {_pd.sub2(corners[3],p);u=_pd.dot(_m);if(u<0){return -1}w=scalarTriple(_pq,_pa,_pd);if(w<0){return -1}v=-v;const denom=1/(u+v+w);_au.copy(corners[0]).mulScalar(u*denom);_bv.copy(corners[3]).mulScalar(v*denom);_cw.copy(corners[2]).mulScalar(w*denom);_ir.copy(_au).add(_bv).add(_cw);}if(_pq.sub2(corners[0],corners[2]).lengthSq()<1e-4*1e-4)return -1;if(_pq.sub2(corners[1],corners[3]).lengthSq()<1e-4*1e-4)return -1;return _ir.sub(p).lengthSq()}class ElementInputEvent{stopPropagation(){this._stopPropagation=true;if(this.event){this.event.stopImmediatePropagation();this.event.stopPropagation();}}constructor(event,element,camera){this.event=event;this.element=element;this.camera=camera;this._stopPropagation=false;}}class ElementMouseEvent extends ElementInputEvent{constructor(event,element,camera,x,y,lastX,lastY){super(event,element,camera);this.x=x;this.y=y;this.ctrlKey=event.ctrlKey||false;this.altKey=event.altKey||false;this.shiftKey=event.shiftKey||false;this.metaKey=event.metaKey||false;this.button=event.button;if(Mouse.isPointerLocked()){this.dx=event.movementX||event.webkitMovementX||event.mozMovementX||0;this.dy=event.movementY||event.webkitMovementY||event.mozMovementY||0;}else {this.dx=x-lastX;this.dy=y-lastY;}this.wheelDelta=0;if(event.type==="wheel"){if(event.deltaY>0){this.wheelDelta=1;}else if(event.deltaY<0){this.wheelDelta=-1;}}}}class ElementTouchEvent extends ElementInputEvent{constructor(event,element,camera,x,y,touch){super(event,element,camera);this.touches=event.touches;this.changedTouches=event.changedTouches;this.x=x;this.y=y;this.touch=touch;}}class ElementSelectEvent extends ElementInputEvent{constructor(event,element,camera,inputSource){super(event,element,camera);this.inputSource=inputSource;}}class ElementInput{set enabled(value){this._enabled=value;}get enabled(){return this._enabled}set app(value){this._app=value;}get app(){return this._app||getApplication()}attach(domElement){if(this._attached){this._attached=false;this.detach();}this._target=domElement;this._attached=true;const opts=platform.passiveEvents?{passive:true}:false;if(this._useMouse){window.addEventListener("mouseup",this._upHandler,opts);window.addEventListener("mousedown",this._downHandler,opts);window.addEventListener("mousemove",this._moveHandler,opts);window.addEventListener("wheel",this._wheelHandler,opts);}if(this._useTouch&&platform.touch){this._target.addEventListener("touchstart",this._touchstartHandler,opts);this._target.addEventListener("touchend",this._touchendHandler,false);this._target.addEventListener("touchmove",this._touchmoveHandler,false);this._target.addEventListener("touchcancel",this._touchcancelHandler,false);}this.attachSelectEvents();}attachSelectEvents(){if(!this._selectEventsAttached&&this._useXr&&this.app&&this.app.xr&&this.app.xr.supported){if(!this._clickedEntities){this._clickedEntities={};}this._selectEventsAttached=true;this.app.xr.on("start",this._onXrStart,this);}}detach(){if(!this._attached)return;this._attached=false;const opts=platform.passiveEvents?{passive:true}:false;if(this._useMouse){window.removeEventListener("mouseup",this._upHandler,opts);window.removeEventListener("mousedown",this._downHandler,opts);window.removeEventListener("mousemove",this._moveHandler,opts);window.removeEventListener("wheel",this._wheelHandler,opts);}if(this._useTouch){this._target.removeEventListener("touchstart",this._touchstartHandler,opts);this._target.removeEventListener("touchend",this._touchendHandler,false);this._target.removeEventListener("touchmove",this._touchmoveHandler,false);this._target.removeEventListener("touchcancel",this._touchcancelHandler,false);}if(this._selectEventsAttached){this._selectEventsAttached=false;this.app.xr.off("start",this._onXrStart,this);this.app.xr.off("end",this._onXrEnd,this);this.app.xr.off("update",this._onXrUpdate,this);this.app.xr.input.off("selectstart",this._onSelectStart,this);this.app.xr.input.off("selectend",this._onSelectEnd,this);this.app.xr.input.off("remove",this._onXrInputRemove,this);}this._target=null;}addElement(element){if(this._elements.indexOf(element)===-1){this._elements.push(element);}}removeElement(element){const idx=this._elements.indexOf(element);if(idx!==-1){this._elements.splice(idx,1);}}_handleUp(event){if(!this._enabled)return;if(Mouse.isPointerLocked()){return}this._calcMouseCoords(event);this._onElementMouseEvent("mouseup",event);}_handleDown(event){if(!this._enabled)return;if(Mouse.isPointerLocked()){return}this._calcMouseCoords(event);this._onElementMouseEvent("mousedown",event);}_handleMove(event){if(!this._enabled)return;this._calcMouseCoords(event);this._onElementMouseEvent("mousemove",event);this._lastX=targetX;this._lastY=targetY;}_handleWheel(event){if(!this._enabled)return;this._calcMouseCoords(event);this._onElementMouseEvent("mousewheel",event);}_determineTouchedElements(event){const touchedElements={};const cameras=this.app.systems.camera.cameras;for(let i=cameras.length-1;i>=0;i--){const camera=cameras[i];let done=0;const len=event.changedTouches.length;for(let j=0;j<len;j++){if(touchedElements[event.changedTouches[j].identifier]){done++;continue}const coords=getTouchTargetCoords(event.changedTouches[j]);const element=this._getTargetElementByCoords(camera,coords.x,coords.y);if(element){done++;touchedElements[event.changedTouches[j].identifier]={element:element,camera:camera,x:coords.x,y:coords.y};}}if(done===len){break}}return touchedElements}_handleTouchStart(event){if(!this._enabled)return;const newTouchedElements=this._determineTouchedElements(event);for(let i=0,len=event.changedTouches.length;i<len;i++){const touch=event.changedTouches[i];const newTouchInfo=newTouchedElements[touch.identifier];const oldTouchInfo=this._touchedElements[touch.identifier];if(newTouchInfo&&(!oldTouchInfo||newTouchInfo.element!==oldTouchInfo.element)){this._fireEvent(event.type,new ElementTouchEvent(event,newTouchInfo.element,newTouchInfo.camera,newTouchInfo.x,newTouchInfo.y,touch));this._touchesForWhichTouchLeaveHasFired[touch.identifier]=false;}}for(const touchId in newTouchedElements){this._touchedElements[touchId]=newTouchedElements[touchId];}}_handleTouchEnd(event){if(!this._enabled)return;const cameras=this.app.systems.camera.cameras;for(const key in this._clickedEntities){delete this._clickedEntities[key];}for(let i=0,len=event.changedTouches.length;i<len;i++){const touch=event.changedTouches[i];const touchInfo=this._touchedElements[touch.identifier];if(!touchInfo){continue}const element=touchInfo.element;const camera=touchInfo.camera;const x=touchInfo.x;const y=touchInfo.y;delete this._touchedElements[touch.identifier];delete this._touchesForWhichTouchLeaveHasFired[touch.identifier];const coords=getTouchTargetCoords(touch);for(let c=cameras.length-1;c>=0;c--){const hovered=this._getTargetElementByCoords(cameras[c],coords.x,coords.y);if(hovered===element){if(!this._clickedEntities[element.entity.getGuid()]){this._fireEvent("click",new ElementTouchEvent(event,element,camera,x,y,touch));this._clickedEntities[element.entity.getGuid()]=Date.now();}}}this._fireEvent(event.type,new ElementTouchEvent(event,element,camera,x,y,touch));}}_handleTouchMove(event){event.preventDefault();if(!this._enabled)return;const newTouchedElements=this._determineTouchedElements(event);for(let i=0,len=event.changedTouches.length;i<len;i++){const touch=event.changedTouches[i];const newTouchInfo=newTouchedElements[touch.identifier];const oldTouchInfo=this._touchedElements[touch.identifier];if(oldTouchInfo){const coords=getTouchTargetCoords(touch);if((!newTouchInfo||newTouchInfo.element!==oldTouchInfo.element)&&!this._touchesForWhichTouchLeaveHasFired[touch.identifier]){this._fireEvent("touchleave",new ElementTouchEvent(event,oldTouchInfo.element,oldTouchInfo.camera,coords.x,coords.y,touch));this._touchesForWhichTouchLeaveHasFired[touch.identifier]=true;}this._fireEvent("touchmove",new ElementTouchEvent(event,oldTouchInfo.element,oldTouchInfo.camera,coords.x,coords.y,touch));}}}_onElementMouseEvent(eventType,event){let element=null;const lastHovered=this._hoveredElement;this._hoveredElement=null;const cameras=this.app.systems.camera.cameras;let camera;for(let i=cameras.length-1;i>=0;i--){camera=cameras[i];element=this._getTargetElementByCoords(camera,targetX,targetY);if(element){break}}this._hoveredElement=element;if((eventType==="mousemove"||eventType==="mouseup")&&this._pressedElement){this._fireEvent(eventType,new ElementMouseEvent(event,this._pressedElement,camera,targetX,targetY,this._lastX,this._lastY));}else if(element){this._fireEvent(eventType,new ElementMouseEvent(event,element,camera,targetX,targetY,this._lastX,this._lastY));if(eventType==="mousedown"){this._pressedElement=element;}}if(lastHovered!==this._hoveredElement){if(lastHovered){this._fireEvent("mouseleave",new ElementMouseEvent(event,lastHovered,camera,targetX,targetY,this._lastX,this._lastY));}if(this._hoveredElement){this._fireEvent("mouseenter",new ElementMouseEvent(event,this._hoveredElement,camera,targetX,targetY,this._lastX,this._lastY));}}if(eventType==="mouseup"&&this._pressedElement){if(this._pressedElement===this._hoveredElement){const guid=this._hoveredElement.entity.getGuid();let fireClick=!this._clickedEntities;if(this._clickedEntities){const lastTouchUp=this._clickedEntities[guid]||0;const dt=Date.now()-lastTouchUp;fireClick=dt>300;delete this._clickedEntities[guid];}if(fireClick){this._fireEvent("click",new ElementMouseEvent(event,this._hoveredElement,camera,targetX,targetY,this._lastX,this._lastY));}}this._pressedElement=null;}}_onXrStart(){this.app.xr.on("end",this._onXrEnd,this);this.app.xr.on("update",this._onXrUpdate,this);this.app.xr.input.on("selectstart",this._onSelectStart,this);this.app.xr.input.on("selectend",this._onSelectEnd,this);this.app.xr.input.on("remove",this._onXrInputRemove,this);}_onXrEnd(){this.app.xr.off("update",this._onXrUpdate,this);this.app.xr.input.off("selectstart",this._onSelectStart,this);this.app.xr.input.off("selectend",this._onSelectEnd,this);this.app.xr.input.off("remove",this._onXrInputRemove,this);}_onXrUpdate(){if(!this._enabled)return;const inputSources=this.app.xr.input.inputSources;for(let i=0;i<inputSources.length;i++){this._onElementSelectEvent("selectmove",inputSources[i],null);}}_onXrInputRemove(inputSource){const hovered=this._selectedElements[inputSource.id];if(hovered){inputSource._elementEntity=null;this._fireEvent("selectleave",new ElementSelectEvent(null,hovered,null,inputSource));}delete this._selectedElements[inputSource.id];delete this._selectedPressedElements[inputSource.id];}_onSelectStart(inputSource,event){if(!this._enabled)return;this._onElementSelectEvent("selectstart",inputSource,event);}_onSelectEnd(inputSource,event){if(!this._enabled)return;this._onElementSelectEvent("selectend",inputSource,event);}_onElementSelectEvent(eventType,inputSource,event){let element;const hoveredBefore=this._selectedElements[inputSource.id];let hoveredNow;const cameras=this.app.systems.camera.cameras;let camera;if(inputSource.elementInput){rayC.set(inputSource.getOrigin(),inputSource.getDirection());for(let i=cameras.length-1;i>=0;i--){camera=cameras[i];element=this._getTargetElementByRay(rayC,camera);if(element){break}}}inputSource._elementEntity=element||null;if(element){this._selectedElements[inputSource.id]=element;hoveredNow=element;}else {delete this._selectedElements[inputSource.id];}if(hoveredBefore!==hoveredNow){if(hoveredBefore)this._fireEvent("selectleave",new ElementSelectEvent(event,hoveredBefore,camera,inputSource));if(hoveredNow)this._fireEvent("selectenter",new ElementSelectEvent(event,hoveredNow,camera,inputSource));}const pressed=this._selectedPressedElements[inputSource.id];if(eventType==="selectmove"&&pressed){this._fireEvent("selectmove",new ElementSelectEvent(event,pressed,camera,inputSource));}if(eventType==="selectstart"){this._selectedPressedElements[inputSource.id]=hoveredNow;if(hoveredNow)this._fireEvent("selectstart",new ElementSelectEvent(event,hoveredNow,camera,inputSource));}if(!inputSource.elementInput&&pressed){delete this._selectedPressedElements[inputSource.id];if(hoveredBefore){this._fireEvent("selectend",new ElementSelectEvent(event,pressed,camera,inputSource));}}if(eventType==="selectend"&&inputSource.elementInput){delete this._selectedPressedElements[inputSource.id];if(pressed){this._fireEvent("selectend",new ElementSelectEvent(event,pressed,camera,inputSource));}if(pressed&&pressed===hoveredBefore){this._fireEvent("click",new ElementSelectEvent(event,pressed,camera,inputSource));}}}_fireEvent(name,evt){let element=evt.element;while(true){element.fire(name,evt);if(evt._stopPropagation){break}if(!element.entity.parent){break}element=element.entity.parent.element;if(!element){break}}}_calcMouseCoords(event){const rect=this._target.getBoundingClientRect();const left=Math.floor(rect.left);const top=Math.floor(rect.top);targetX=event.clientX-left;targetY=event.clientY-top;}_sortElements(a,b){const layerOrder=this.app.scene.layers.sortTransparentLayers(a.layers,b.layers);if(layerOrder!==0)return layerOrder;if(a.screen&&!b.screen){return -1}if(!a.screen&&b.screen){return 1}if(!a.screen&&!b.screen){return 0}if(a.screen.screen.screenSpace&&!b.screen.screen.screenSpace){return -1}if(b.screen.screen.screenSpace&&!a.screen.screen.screenSpace){return 1}return b.drawOrder-a.drawOrder}_getTargetElementByCoords(camera,x,y){const rayScreen=this._calculateRayScreen(x,y,camera,rayA)?rayA:null;const ray3d=this._calculateRay3d(x,y,camera,rayB)?rayB:null;return this._getTargetElement(camera,rayScreen,ray3d)}_getTargetElementByRay(ray,camera){rayA.origin.copy(ray.origin);rayA.direction.copy(ray.direction);rayA.end.copy(rayA.direction).mulScalar(camera.farClip*2).add(rayA.origin);const ray3d=rayA;const screenPos=camera.worldToScreen(ray3d.origin,vecA);const rayScreen=this._calculateRayScreen(screenPos.x,screenPos.y,camera,rayB)?rayB:null;return this._getTargetElement(camera,rayScreen,ray3d)}_getTargetElement(camera,rayScreen,ray3d){let result=null;let closestDistance3d=Infinity;this._elements.sort(this._sortHandler);for(let i=0,len=this._elements.length;i<len;i++){const element=this._elements[i];if(!element.layers.some(v=>camera.layersSet.has(v))){continue}if(element.screen&&element.screen.screen.screenSpace){if(!rayScreen){continue}const currentDistance=this._checkElement(rayScreen,element,true);if(currentDistance>=0){result=element;break}}else {if(!ray3d){continue}const currentDistance=this._checkElement(ray3d,element,false);if(currentDistance>=0){if(currentDistance<closestDistance3d){result=element;closestDistance3d=currentDistance;}if(element.screen){result=element;break}}}}return result}_calculateRayScreen(x,y,camera,ray){const sw=this.app.graphicsDevice.width;const sh=this.app.graphicsDevice.height;const cameraWidth=camera.rect.z*sw;const cameraHeight=camera.rect.w*sh;const cameraLeft=camera.rect.x*sw;const cameraRight=cameraLeft+cameraWidth;const cameraBottom=(1-camera.rect.y)*sh;const cameraTop=cameraBottom-cameraHeight;let _x=x*sw/this._target.clientWidth;let _y=y*sh/this._target.clientHeight;if(_x>=cameraLeft&&_x<=cameraRight&&_y<=cameraBottom&&_y>=cameraTop){_x=sw*(_x-cameraLeft)/cameraWidth;_y=sh*(_y-cameraTop)/cameraHeight;_y=sh-_y;ray.origin.set(_x,_y,1);ray.direction.set(0,0,-1);ray.end.copy(ray.direction).mulScalar(2).add(ray.origin);return true}return false}_calculateRay3d(x,y,camera,ray){const sw=this._target.clientWidth;const sh=this._target.clientHeight;const cameraWidth=camera.rect.z*sw;const cameraHeight=camera.rect.w*sh;const cameraLeft=camera.rect.x*sw;const cameraRight=cameraLeft+cameraWidth;const cameraBottom=(1-camera.rect.y)*sh;const cameraTop=cameraBottom-cameraHeight;let _x=x;let _y=y;if(x>=cameraLeft&&x<=cameraRight&&y<=cameraBottom&&_y>=cameraTop){_x=sw*(_x-cameraLeft)/cameraWidth;_y=sh*(_y-cameraTop)/cameraHeight;camera.screenToWorld(_x,_y,camera.nearClip,vecA);camera.screenToWorld(_x,_y,camera.farClip,vecB);ray.origin.copy(vecA);ray.direction.set(0,0,-1);ray.end.copy(vecB);return true}return false}_checkElement(ray,element,screen){if(element.maskedBy){if(this._checkElement(ray,element.maskedBy.element,screen)<0){return -1}}let scale;if(screen){scale=ElementInput.calculateScaleToScreen(element);}else {scale=ElementInput.calculateScaleToWorld(element);}const corners=ElementInput.buildHitCorners(element,screen?element.screenCorners:element.worldCorners,scale);return intersectLineQuad(ray.origin,ray.end,corners)}static buildHitCorners(element,screenOrWorldCorners,scale){let hitCorners=screenOrWorldCorners;const button=element.entity&&element.entity.button;if(button){const hitPadding=element.entity.button.hitPadding||ZERO_VEC4;_paddingTop.copy(element.entity.up);_paddingBottom.copy(_paddingTop).mulScalar(-1);_paddingRight.copy(element.entity.right);_paddingLeft.copy(_paddingRight).mulScalar(-1);_paddingTop.mulScalar(hitPadding.w*scale.y);_paddingBottom.mulScalar(hitPadding.y*scale.y);_paddingRight.mulScalar(hitPadding.z*scale.x);_paddingLeft.mulScalar(hitPadding.x*scale.x);_cornerBottomLeft.copy(hitCorners[0]).add(_paddingBottom).add(_paddingLeft);_cornerBottomRight.copy(hitCorners[1]).add(_paddingBottom).add(_paddingRight);_cornerTopRight.copy(hitCorners[2]).add(_paddingTop).add(_paddingRight);_cornerTopLeft.copy(hitCorners[3]).add(_paddingTop).add(_paddingLeft);hitCorners=[_cornerBottomLeft,_cornerBottomRight,_cornerTopRight,_cornerTopLeft];}if(scale.x<0){const left=hitCorners[2].x;const right=hitCorners[0].x;hitCorners[0].x=left;hitCorners[1].x=right;hitCorners[2].x=right;hitCorners[3].x=left;}if(scale.y<0){const bottom=hitCorners[2].y;const top=hitCorners[0].y;hitCorners[0].y=bottom;hitCorners[1].y=bottom;hitCorners[2].y=top;hitCorners[3].y=top;}if(scale.z<0){const x=hitCorners[2].x;const y=hitCorners[2].y;const z=hitCorners[2].z;hitCorners[2].x=hitCorners[0].x;hitCorners[2].y=hitCorners[0].y;hitCorners[2].z=hitCorners[0].z;hitCorners[0].x=x;hitCorners[0].y=y;hitCorners[0].z=z;}return hitCorners}static calculateScaleToScreen(element){let current=element.entity;const screenScale=element.screen.screen.scale;_accumulatedScale.set(screenScale,screenScale,screenScale);while(current&&!current.screen){_accumulatedScale.mul(current.getLocalScale());current=current.parent;}return _accumulatedScale}static calculateScaleToWorld(element){let current=element.entity;_accumulatedScale.set(1,1,1);while(current){_accumulatedScale.mul(current.getLocalScale());current=current.parent;}return _accumulatedScale}constructor(domElement,options){this._app=null;this._attached=false;this._target=null;this._enabled=true;this._lastX=0;this._lastY=0;this._upHandler=this._handleUp.bind(this);this._downHandler=this._handleDown.bind(this);this._moveHandler=this._handleMove.bind(this);this._wheelHandler=this._handleWheel.bind(this);this._touchstartHandler=this._handleTouchStart.bind(this);this._touchendHandler=this._handleTouchEnd.bind(this);this._touchcancelHandler=this._touchendHandler;this._touchmoveHandler=this._handleTouchMove.bind(this);this._sortHandler=this._sortElements.bind(this);this._elements=[];this._hoveredElement=null;this._pressedElement=null;this._touchedElements={};this._touchesForWhichTouchLeaveHasFired={};this._selectedElements={};this._selectedPressedElements={};this._useMouse=!options||options.useMouse!==false;this._useTouch=!options||options.useTouch!==false;this._useXr=!options||options.useXr!==false;this._selectEventsAttached=false;if(platform.touch){this._clickedEntities={};}this.attach(domElement);}}const LINEBATCH_WORLD=0;const LINEBATCH_OVERLAY=1;const LINEBATCH_GIZMO=2;const log={write:function(text){console.log(text);},open:function(){log.write(`Powered by PlayCanvas ${version} ${revision}`);},info:function(text){console.info(`INFO:    ${text}`);},debug:function(text){console.debug(`DEBUG:   ${text}`);},error:function(text){console.error(`ERROR:   ${text}`);},warning:function(text){console.warn(`WARNING: ${text}`);},alert:function(text){log.write(`ALERT:   ${text}`);alert(text);},assert:function(condition,text){if(condition===false){log.write(`ASSERT:  ${text}`);}}};string.endsWith=function(s,subs){return s.endsWith(subs)};string.startsWith=function(s,subs){return s.startsWith(subs)};class Timer{start(){this._isRunning=true;this._a=now();}stop(){this._isRunning=false;this._b=now();}getMilliseconds(){return this._b-this._a}constructor(){this._isRunning=false;this._a=0;this._b=0;}}const time={now:now,Timer:Timer};Object.defineProperty(Color.prototype,"data",{get:function(){if(!this._data){this._data=new Float32Array(4);}this._data[0]=this.r;this._data[1]=this.g;this._data[2]=this.b;this._data[3]=this.a;return this._data}});Object.defineProperty(Color.prototype,"data3",{get:function(){if(!this._data3){this._data3=new Float32Array(3);}this._data3[0]=this.r;this._data3[1]=this.g;this._data3[2]=this.b;return this._data3}});function inherits(Self,Super){const Temp=function Temp(){};const Func=function Func(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8){Super.call(this,arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);Self.call(this,arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);};Func._super=Super.prototype;Temp.prototype=Super.prototype;Func.prototype=new Temp;return Func}function makeArray(arr){return Array.prototype.slice.call(arr)}function createStyle(cssString){const result=document.createElement("style");result.type="text/css";if(result.styleSheet){result.styleSheet.cssText=cssString;}else {result.appendChild(document.createTextNode(cssString));}return result}math.INV_LOG2=Math.LOG2E;math.intToBytes=math.intToBytes32;math.bytesToInt=math.bytesToInt32;Object.defineProperty(Vec2.prototype,"data",{get:function(){if(!this._data){this._data=new Float32Array(2);}this._data[0]=this.x;this._data[1]=this.y;return this._data}});Vec2.prototype.scale=Vec2.prototype.mulScalar;Object.defineProperty(Vec3.prototype,"data",{get:function(){if(!this._data){this._data=new Float32Array(3);}this._data[0]=this.x;this._data[1]=this.y;this._data[2]=this.z;return this._data}});Vec3.prototype.scale=Vec3.prototype.mulScalar;Object.defineProperty(Vec4.prototype,"data",{get:function(){if(!this._data){this._data=new Float32Array(4);}this._data[0]=this.x;this._data[1]=this.y;this._data[2]=this.z;this._data[3]=this.w;return this._data}});Vec4.prototype.scale=Vec4.prototype.mulScalar;const shape={Aabb:BoundingBox,Sphere:BoundingSphere,Plane:Plane};BoundingSphere.prototype.intersectRay=BoundingSphere.prototype.intersectsRay;Frustum.prototype.update=function(projectionMatrix,viewMatrix){const viewProj=new Mat4;viewProj.mul2(projectionMatrix,viewMatrix);this.setFromMat4(viewProj);};const ELEMENTTYPE_INT8=TYPE_INT8;const ELEMENTTYPE_UINT8=TYPE_UINT8;const ELEMENTTYPE_INT16=TYPE_INT16;const ELEMENTTYPE_UINT16=TYPE_UINT16;const ELEMENTTYPE_INT32=TYPE_INT32;const ELEMENTTYPE_UINT32=TYPE_UINT32;const ELEMENTTYPE_FLOAT32=TYPE_FLOAT32;const PIXELFORMAT_L8_A8=PIXELFORMAT_LA8;const PIXELFORMAT_R5_G6_B5=PIXELFORMAT_RGB565;const PIXELFORMAT_R5_G5_B5_A1=PIXELFORMAT_RGBA5551;const PIXELFORMAT_R4_G4_B4_A4=PIXELFORMAT_RGBA4;const PIXELFORMAT_R8_G8_B8=PIXELFORMAT_RGB8;const PIXELFORMAT_R8_G8_B8_A8=PIXELFORMAT_RGBA8;const BLENDMODE_CONSTANT_COLOR=BLENDMODE_CONSTANT;const BLENDMODE_ONE_MINUS_CONSTANT_COLOR=BLENDMODE_ONE_MINUS_CONSTANT;const BLENDMODE_CONSTANT_ALPHA=BLENDMODE_CONSTANT;const BLENDMODE_ONE_MINUS_CONSTANT_ALPHA=BLENDMODE_ONE_MINUS_CONSTANT;function UnsupportedBrowserError(message){this.name="UnsupportedBrowserError";this.message=message||"";}UnsupportedBrowserError.prototype=Error.prototype;function ContextCreationError(message){this.name="ContextCreationError";this.message=message||"";}ContextCreationError.prototype=Error.prototype;const programlib={begin:ShaderGenerator.begin,dummyFragmentCode:ShaderUtils.dummyFragmentCode,end:ShaderGenerator.end,fogCode:ShaderGenerator.fogCode,gammaCode:ShaderGenerator.gammaCode,precisionCode:ShaderUtils.precisionCode,skinCode:ShaderGenerator.skinCode,tonemapCode:ShaderGenerator.tonemapCode,versionCode:ShaderUtils.versionCode};const gfx={ADDRESS_CLAMP_TO_EDGE:ADDRESS_CLAMP_TO_EDGE,ADDRESS_MIRRORED_REPEAT:ADDRESS_MIRRORED_REPEAT,ADDRESS_REPEAT:ADDRESS_REPEAT,BLENDMODE_ZERO:BLENDMODE_ZERO,BLENDMODE_ONE:BLENDMODE_ONE,BLENDMODE_SRC_COLOR:BLENDMODE_SRC_COLOR,BLENDMODE_ONE_MINUS_SRC_COLOR:BLENDMODE_ONE_MINUS_SRC_COLOR,BLENDMODE_DST_COLOR:BLENDMODE_DST_COLOR,BLENDMODE_ONE_MINUS_DST_COLOR:BLENDMODE_ONE_MINUS_DST_COLOR,BLENDMODE_SRC_ALPHA:BLENDMODE_SRC_ALPHA,BLENDMODE_SRC_ALPHA_SATURATE:BLENDMODE_SRC_ALPHA_SATURATE,BLENDMODE_ONE_MINUS_SRC_ALPHA:BLENDMODE_ONE_MINUS_SRC_ALPHA,BLENDMODE_DST_ALPHA:BLENDMODE_DST_ALPHA,BLENDMODE_ONE_MINUS_DST_ALPHA:BLENDMODE_ONE_MINUS_DST_ALPHA,BUFFER_STATIC:BUFFER_STATIC,BUFFER_DYNAMIC:BUFFER_DYNAMIC,BUFFER_STREAM:BUFFER_STREAM,CULLFACE_NONE:CULLFACE_NONE,CULLFACE_BACK:CULLFACE_BACK,CULLFACE_FRONT:CULLFACE_FRONT,CULLFACE_FRONTANDBACK:CULLFACE_FRONTANDBACK,ELEMENTTYPE_INT8:TYPE_INT8,ELEMENTTYPE_UINT8:TYPE_UINT8,ELEMENTTYPE_INT16:TYPE_INT16,ELEMENTTYPE_UINT16:TYPE_UINT16,ELEMENTTYPE_INT32:TYPE_INT32,ELEMENTTYPE_UINT32:TYPE_UINT32,ELEMENTTYPE_FLOAT32:TYPE_FLOAT32,FILTER_NEAREST:FILTER_NEAREST,FILTER_LINEAR:FILTER_LINEAR,FILTER_NEAREST_MIPMAP_NEAREST:FILTER_NEAREST_MIPMAP_NEAREST,FILTER_NEAREST_MIPMAP_LINEAR:FILTER_NEAREST_MIPMAP_LINEAR,FILTER_LINEAR_MIPMAP_NEAREST:FILTER_LINEAR_MIPMAP_NEAREST,FILTER_LINEAR_MIPMAP_LINEAR:FILTER_LINEAR_MIPMAP_LINEAR,INDEXFORMAT_UINT8:INDEXFORMAT_UINT8,INDEXFORMAT_UINT16:INDEXFORMAT_UINT16,INDEXFORMAT_UINT32:INDEXFORMAT_UINT32,PIXELFORMAT_RGB565:PIXELFORMAT_RGB565,PIXELFORMAT_RGB8:PIXELFORMAT_RGB8,PIXELFORMAT_RGBA8:PIXELFORMAT_RGBA8,PRIMITIVE_POINTS:PRIMITIVE_POINTS,PRIMITIVE_LINES:PRIMITIVE_LINES,PRIMITIVE_LINELOOP:PRIMITIVE_LINELOOP,PRIMITIVE_LINESTRIP:PRIMITIVE_LINESTRIP,PRIMITIVE_TRIANGLES:PRIMITIVE_TRIANGLES,PRIMITIVE_TRISTRIP:PRIMITIVE_TRISTRIP,PRIMITIVE_TRIFAN:PRIMITIVE_TRIFAN,SEMANTIC_POSITION:SEMANTIC_POSITION,SEMANTIC_NORMAL:SEMANTIC_NORMAL,SEMANTIC_COLOR:SEMANTIC_COLOR,SEMANTIC_TEXCOORD:SEMANTIC_TEXCOORD,SEMANTIC_TEXCOORD0:SEMANTIC_TEXCOORD0,SEMANTIC_TEXCOORD1:SEMANTIC_TEXCOORD1,SEMANTIC_ATTR0:SEMANTIC_ATTR0,SEMANTIC_ATTR1:SEMANTIC_ATTR1,SEMANTIC_ATTR2:SEMANTIC_ATTR2,SEMANTIC_ATTR3:SEMANTIC_ATTR3,TEXTURELOCK_READ:TEXTURELOCK_READ,TEXTURELOCK_WRITE:TEXTURELOCK_WRITE,drawQuadWithShader:drawQuadWithShader,programlib:programlib,shaderChunks:shaderChunks,ContextCreationError:ContextCreationError,Device:GraphicsDevice,IndexBuffer:IndexBuffer,ProgramLibrary:ProgramLibrary,RenderTarget:RenderTarget,ScopeId:ScopeId,Shader:Shader,ShaderInput:WebglShaderInput,Texture:Texture,UnsupportedBrowserError:UnsupportedBrowserError,VertexBuffer:VertexBuffer,VertexFormat:VertexFormat,VertexIterator:VertexIterator};const _viewport=new Vec4;function createSphere(device,opts){return Mesh.fromGeometry(device,new SphereGeometry(opts))}function createPlane(device,opts){return Mesh.fromGeometry(device,new PlaneGeometry(opts))}function createBox(device,opts){return Mesh.fromGeometry(device,new BoxGeometry(opts))}function createTorus(device,opts){return Mesh.fromGeometry(device,new TorusGeometry(opts))}function createCapsule(device,opts){return Mesh.fromGeometry(device,new CapsuleGeometry(opts))}function createCone(device,opts){return Mesh.fromGeometry(device,new ConeGeometry(opts))}function createCylinder(device,opts){return Mesh.fromGeometry(device,new CylinderGeometry(opts))}function createMesh(device,positions,opts={}){const geom=new Geometry;geom.positions=positions;geom.normals=opts.normals;geom.tangents=opts.tangents;geom.colors=opts.colors;geom.uvs=opts.uvs;geom.uvs1=opts.uvs1;geom.blendIndices=opts.blendIndices;geom.blendWeights=opts.blendWeights;geom.indices=opts.indices;return Mesh.fromGeometry(device,geom,opts)}function drawFullscreenQuad(device,target,vertexBuffer,shader,rect){let viewport;if(rect){const w=target?target.width:device.width;const h=target?target.height:device.height;viewport=_viewport.set(rect.x*w,rect.y*h,rect.z*w,rect.w*h);}drawQuadWithShader(device,target,shader,viewport);}const posteffect={createFullscreenQuad:device=>{return device.quadVertexBuffer},drawFullscreenQuad:drawFullscreenQuad,PostEffect:PostEffect,PostEffectQueue:PostEffectQueue};Object.defineProperty(shaderChunks,"transformSkinnedVS",{get:function(){return `#define SKIN
${shaderChunks.transformVS}`}});const deprecatedChunks={"ambientPrefilteredCube.frag":"ambientEnv.frag","ambientPrefilteredCubeLod.frag":"ambientEnv.frag","dpAtlasQuad.frag":null,"genParaboloid.frag":null,"prefilterCubemap.frag":null,"reflectionDpAtlas.frag":"reflectionEnv.frag","reflectionPrefilteredCube.frag":"reflectionEnv.frag","reflectionPrefilteredCubeLod.frag":"reflectionEnv.frag"};Object.keys(deprecatedChunks).forEach(chunkName=>{Object.defineProperty(shaderChunks,chunkName,{get:function(){return null},set:function(){}});});Object.defineProperties(RenderTarget.prototype,{_glFrameBuffer:{get:function(){return this.impl._glFrameBuffer},set:function(rgbm){}}});Object.defineProperty(VertexFormat,"defaultInstancingFormat",{get:function(){return null}});Object.defineProperties(Texture.prototype,{rgbm:{get:function(){return this.type===TEXTURETYPE_RGBM},set:function(rgbm){this.type=rgbm?TEXTURETYPE_RGBM:TEXTURETYPE_DEFAULT;}},swizzleGGGR:{get:function(){return this.type===TEXTURETYPE_SWIZZLEGGGR},set:function(swizzleGGGR){this.type=swizzleGGGR?TEXTURETYPE_SWIZZLEGGGR:TEXTURETYPE_DEFAULT;}},_glTexture:{get:function(){return this.impl._glTexture}},autoMipmap:{get:function(){return this._mipmaps},set:function(value){this._mipmaps=value;}}});Object.defineProperty(GraphicsDevice.prototype,"webgl2",{get:function(){return this.isWebGL2}});GraphicsDevice.prototype.getProgramLibrary=function(){return getProgramLibrary(this)};GraphicsDevice.prototype.setProgramLibrary=function(lib){setProgramLibrary(this,lib);};GraphicsDevice.prototype.removeShaderFromCache=function(shader){getProgramLibrary(this).removeFromCache(shader);};BlendState.DEFAULT=Object.freeze(new BlendState);const _tempBlendState=new BlendState;const _tempDepthState=new DepthState;GraphicsDevice.prototype.setBlendFunction=function(blendSrc,blendDst){const currentBlendState=this.blendState;_tempBlendState.copy(currentBlendState);_tempBlendState.setColorBlend(currentBlendState.colorOp,blendSrc,blendDst);_tempBlendState.setAlphaBlend(currentBlendState.alphaOp,blendSrc,blendDst);this.setBlendState(_tempBlendState);};GraphicsDevice.prototype.setBlendFunctionSeparate=function(blendSrc,blendDst,blendSrcAlpha,blendDstAlpha){const currentBlendState=this.blendState;_tempBlendState.copy(currentBlendState);_tempBlendState.setColorBlend(currentBlendState.colorOp,blendSrc,blendDst);_tempBlendState.setAlphaBlend(currentBlendState.alphaOp,blendSrcAlpha,blendDstAlpha);this.setBlendState(_tempBlendState);};GraphicsDevice.prototype.setBlendEquation=function(blendEquation){const currentBlendState=this.blendState;_tempBlendState.copy(currentBlendState);_tempBlendState.setColorBlend(blendEquation,currentBlendState.colorSrcFactor,currentBlendState.colorDstFactor);_tempBlendState.setAlphaBlend(blendEquation,currentBlendState.alphaSrcFactor,currentBlendState.alphaDstFactor);this.setBlendState(_tempBlendState);};GraphicsDevice.prototype.setBlendEquationSeparate=function(blendEquation,blendAlphaEquation){const currentBlendState=this.blendState;_tempBlendState.copy(currentBlendState);_tempBlendState.setColorBlend(blendEquation,currentBlendState.colorSrcFactor,currentBlendState.colorDstFactor);_tempBlendState.setAlphaBlend(blendAlphaEquation,currentBlendState.alphaSrcFactor,currentBlendState.alphaDstFactor);this.setBlendState(_tempBlendState);};GraphicsDevice.prototype.setColorWrite=function(redWrite,greenWrite,blueWrite,alphaWrite){const currentBlendState=this.blendState;_tempBlendState.copy(currentBlendState);_tempBlendState.setColorWrite(redWrite,greenWrite,blueWrite,alphaWrite);this.setBlendState(_tempBlendState);};GraphicsDevice.prototype.getBlending=function(){return this.blendState.blend};GraphicsDevice.prototype.setBlending=function(blending){_tempBlendState.copy(this.blendState);_tempBlendState.blend=blending;this.setBlendState(_tempBlendState);};GraphicsDevice.prototype.setDepthWrite=function(write){_tempDepthState.copy(this.depthState);_tempDepthState.write=write;this.setDepthState(_tempDepthState);};GraphicsDevice.prototype.setDepthFunc=function(func){_tempDepthState.copy(this.depthState);_tempDepthState.func=func;this.setDepthState(_tempDepthState);};GraphicsDevice.prototype.setDepthTest=function(test){_tempDepthState.copy(this.depthState);_tempDepthState.test=test;this.setDepthState(_tempDepthState);};GraphicsDevice.prototype.getCullMode=function(){return this.cullMode};const PhongMaterial=StandardMaterial;const LitOptions=LitShaderOptions;const scene={procedural:{calculateTangents:calculateTangents,createMesh:createMesh,createTorus:createTorus,createCylinder:createCylinder,createCapsule:createCapsule,createCone:createCone,createSphere:createSphere,createPlane:createPlane,createBox:createBox},BasicMaterial:BasicMaterial,ForwardRenderer:ForwardRenderer,GraphNode:GraphNode,Material:Material,Mesh:Mesh,MeshInstance:MeshInstance,Model:Model,ParticleEmitter:ParticleEmitter,PhongMaterial:StandardMaterial,Picker:Picker,Projection:{ORTHOGRAPHIC:PROJECTION_ORTHOGRAPHIC,PERSPECTIVE:PROJECTION_PERSPECTIVE},Scene:Scene,Skin:Skin,SkinInstance:SkinInstance};Object.defineProperty(Scene.prototype,"defaultMaterial",{get:function(){return getDefaultMaterial(getApplication().graphicsDevice)}});Object.defineProperty(LayerComposition.prototype,"_meshInstances",{get:function(){return null}});Object.defineProperty(Scene.prototype,"drawCalls",{get:function(){return null}});["128","64","32","16","8","4"].forEach((size,index)=>{Object.defineProperty(Scene.prototype,`skyboxPrefiltered${size}`,{get:function(){return this._prefilteredCubemaps[index]},set:function(value){this._prefilteredCubemaps[index]=value;this.updateShaders=true;}});});Object.defineProperty(Scene.prototype,"models",{get:function(){if(!this._models){this._models=[];}return this._models}});Object.defineProperty(Layer.prototype,"renderTarget",{set:function(rt){this._renderTarget=rt;this._dirtyComposition=true;},get:function(){return this._renderTarget}});Scene.prototype.addModel=function(model){if(this.containsModel(model))return;const layer=this.layers.getLayerById(LAYERID_WORLD);if(!layer)return;layer.addMeshInstances(model.meshInstances);this.models.push(model);};Scene.prototype.addShadowCaster=function(model){const layer=this.layers.getLayerById(LAYERID_WORLD);if(!layer)return;layer.addShadowCasters(model.meshInstances);};Scene.prototype.removeModel=function(model){const index=this.models.indexOf(model);if(index!==-1){const layer=this.layers.getLayerById(LAYERID_WORLD);if(!layer)return;layer.removeMeshInstances(model.meshInstances);this.models.splice(index,1);}};Scene.prototype.removeShadowCasters=function(model){const layer=this.layers.getLayerById(LAYERID_WORLD);if(!layer)return;layer.removeShadowCasters(model.meshInstances);};Scene.prototype.containsModel=function(model){return this.models.indexOf(model)>=0};Scene.prototype.getModels=function(model){return this.models};Object.defineProperty(Batch.prototype,"model",{get:function(){return null}});ForwardRenderer.prototype.renderComposition=function(comp){getApplication().renderComposition(comp);};MeshInstance.prototype.syncAabb=function(){};Morph.prototype.getTarget=function(index){return this.targets[index]};GraphNode.prototype._dirtify=function(local){if(local){this._dirtifyLocal();}else {this._dirtifyWorld();}};GraphNode.prototype.addLabel=function(label){this._labels[label]=true;};GraphNode.prototype.getLabels=function(){return Object.keys(this._labels)};GraphNode.prototype.hasLabel=function(label){return !!this._labels[label]};GraphNode.prototype.removeLabel=function(label){delete this._labels[label];};GraphNode.prototype.findByLabel=function(label,results=[]){if(this.hasLabel(label)){results.push(this);}for(let i=0;i<this._children.length;++i){results=this._children[i].findByLabel(label,results);}return results};GraphNode.prototype.getChildren=function(){return this.children};GraphNode.prototype.getName=function(){return this.name};GraphNode.prototype.getPath=function(){return this.path};GraphNode.prototype.getRoot=function(){return this.root};GraphNode.prototype.getParent=function(){return this.parent};GraphNode.prototype.setName=function(name){this.name=name;};Material.prototype.getName=function(){return this.name};Material.prototype.setName=function(name){this.name=name;};Material.prototype.getShader=function(){return this.shader};Material.prototype.setShader=function(shader){this.shader=shader;};Object.defineProperty(Material.prototype,"blend",{set:function(value){this.blendState.blend=value;},get:function(){return this.blendState.blend}});Object.defineProperty(Material.prototype,"blendSrc",{set:function(value){const currentBlendState=this.blendState;_tempBlendState.copy(currentBlendState);_tempBlendState.setColorBlend(currentBlendState.colorOp,value,currentBlendState.colorDstFactor);_tempBlendState.setAlphaBlend(currentBlendState.alphaOp,value,currentBlendState.alphaDstFactor);this.blendState=_tempBlendState;},get:function(){return this.blendState.colorSrcFactor}});Object.defineProperty(Material.prototype,"blendDst",{set:function(value){const currentBlendState=this.blendState;_tempBlendState.copy(currentBlendState);_tempBlendState.setColorBlend(currentBlendState.colorOp,currentBlendState.colorSrcFactor,value);_tempBlendState.setAlphaBlend(currentBlendState.alphaOp,currentBlendState.alphaSrcFactor,value);this.blendState=_tempBlendState;},get:function(){return this.blendState.colorDstFactor}});Object.defineProperty(StandardMaterial.prototype,"shininess",{get:function(){return this.gloss*100},set:function(value){this.gloss=value*.01;}});function _defineAlias(newName,oldName){Object.defineProperty(StandardMaterial.prototype,oldName,{get:function(){return this[newName]},set:function(value){this[newName]=value;}});}_defineAlias("diffuseTint","diffuseMapTint");_defineAlias("specularTint","specularMapTint");_defineAlias("emissiveTint","emissiveMapTint");_defineAlias("aoVertexColor","aoMapVertexColor");_defineAlias("diffuseVertexColor","diffuseMapVertexColor");_defineAlias("specularVertexColor","specularMapVertexColor");_defineAlias("emissiveVertexColor","emissiveMapVertexColor");_defineAlias("metalnessVertexColor","metalnessMapVertexColor");_defineAlias("glossVertexColor","glossMapVertexColor");_defineAlias("opacityVertexColor","opacityMapVertexColor");_defineAlias("lightVertexColor","lightMapVertexColor");_defineAlias("sheenGloss","sheenGlossiess");_defineAlias("clearCoatGloss","clearCostGlossiness");function _defineOption(name,newName){if(name!=="pass"){Object.defineProperty(StandardMaterialOptions.prototype,name,{get:function(){return this.litOptions[newName||name]},set:function(value){this.litOptions[newName||name]=value;}});}}_defineOption("refraction","useRefraction");const tempOptions=new LitShaderOptions;const litOptionProperties=Object.getOwnPropertyNames(tempOptions);for(const litOption in litOptionProperties){_defineOption(litOptionProperties[litOption]);}const anim={Animation:Animation,Key:Key,Node:Node,Skeleton:Skeleton};Animation.prototype.getDuration=function(){return this.duration};Animation.prototype.getName=function(){return this.name};Animation.prototype.getNodes=function(){return this.nodes};Animation.prototype.setDuration=function(duration){this.duration=duration;};Animation.prototype.setName=function(name){this.name=name;};Skeleton.prototype.getAnimation=function(){return this.animation};Skeleton.prototype.getCurrentTime=function(){return this.currentTime};Skeleton.prototype.getLooping=function(){return this.looping};Skeleton.prototype.getNumNodes=function(){return this.numNodes};Skeleton.prototype.setAnimation=function(animation){this.animation=animation;};Skeleton.prototype.setCurrentTime=function(time){this.currentTime=time;};Skeleton.prototype.setLooping=function(looping){this.looping=looping;};const audio={AudioManager:SoundManager,Channel:Channel,Channel3d:Channel3d,Listener:Listener,Sound:Sound};SoundManager.prototype.getListener=function(){return this.listener};SoundManager.prototype.getVolume=function(){return this.volume};SoundManager.prototype.setVolume=function(volume){this.volume=volume;};const asset={ASSET_ANIMATION:"animation",ASSET_AUDIO:"audio",ASSET_IMAGE:"image",ASSET_JSON:"json",ASSET_MODEL:"model",ASSET_MATERIAL:"material",ASSET_TEXT:"text",ASSET_TEXTURE:"texture",ASSET_CUBEMAP:"cubemap",ASSET_SCRIPT:"script"};AssetRegistry.prototype.getAssetById=function(id){return this.get(id)};Object.defineProperty(XrInputSource.prototype,"ray",{get:function(){return this._rayLocal}});Object.defineProperty(XrInputSource.prototype,"position",{get:function(){return this._localPosition}});Object.defineProperty(XrInputSource.prototype,"rotation",{get:function(){return this._localRotation}});const input={getTouchTargetCoords:getTouchTargetCoords,Controller:Controller,GamePads:GamePads,Keyboard:Keyboard,KeyboardEvent:KeyboardEvent,Mouse:Mouse,MouseEvent:MouseEvent,Touch:Touch,TouchDevice:TouchDevice,TouchEvent:TouchEvent};Object.defineProperty(ElementInput.prototype,"wheel",{get:function(){return this.wheelDelta*-2}});Object.defineProperty(MouseEvent.prototype,"wheel",{get:function(){return this.wheelDelta*-2}});const RIGIDBODY_TYPE_STATIC=BODYTYPE_STATIC;const RIGIDBODY_TYPE_DYNAMIC=BODYTYPE_DYNAMIC;const RIGIDBODY_TYPE_KINEMATIC=BODYTYPE_KINEMATIC;const RIGIDBODY_CF_STATIC_OBJECT=BODYFLAG_STATIC_OBJECT;const RIGIDBODY_CF_KINEMATIC_OBJECT=BODYFLAG_KINEMATIC_OBJECT;const RIGIDBODY_CF_NORESPONSE_OBJECT=BODYFLAG_NORESPONSE_OBJECT;const RIGIDBODY_ACTIVE_TAG=BODYSTATE_ACTIVE_TAG;const RIGIDBODY_ISLAND_SLEEPING=BODYSTATE_ISLAND_SLEEPING;const RIGIDBODY_WANTS_DEACTIVATION=BODYSTATE_WANTS_DEACTIVATION;const RIGIDBODY_DISABLE_DEACTIVATION=BODYSTATE_DISABLE_DEACTIVATION;const RIGIDBODY_DISABLE_SIMULATION=BODYSTATE_DISABLE_SIMULATION;AppBase.prototype.isFullscreen=function(){return !!document.fullscreenElement};AppBase.prototype.enableFullscreen=function(element,success,error){element=element||this.graphicsDevice.canvas;const s=function s(){success();document.removeEventListener("fullscreenchange",s);};const e=function e(){error();document.removeEventListener("fullscreenerror",e);};if(success){document.addEventListener("fullscreenchange",s,false);}if(error){document.addEventListener("fullscreenerror",e,false);}if(element.requestFullscreen){element.requestFullscreen(Element.ALLOW_KEYBOARD_INPUT);}else {error();}};AppBase.prototype.disableFullscreen=function(success){const s=function s(){success();document.removeEventListener("fullscreenchange",s);};if(success){document.addEventListener("fullscreenchange",s,false);}document.exitFullscreen();};AppBase.prototype.getSceneUrl=function(name){const entry=this.scenes.find(name);if(entry){return entry.url}return null};AppBase.prototype.loadScene=function(url,callback){this.scenes.loadScene(url,callback);};AppBase.prototype.loadSceneHierarchy=function(url,callback){this.scenes.loadSceneHierarchy(url,callback);};AppBase.prototype.loadSceneSettings=function(url,callback){this.scenes.loadSceneSettings(url,callback);};AppBase.prototype.renderMeshInstance=function(meshInstance,options){const layer=options!=null&&options.layer?options.layer:this.scene.defaultDrawLayer;this.scene.immediate.drawMesh(null,null,null,meshInstance,layer);};AppBase.prototype.renderMesh=function(mesh,material,matrix,options){const layer=options!=null&&options.layer?options.layer:this.scene.defaultDrawLayer;this.scene.immediate.drawMesh(material,matrix,mesh,null,layer);};AppBase.prototype._addLines=function(positions,colors,options){const layer=options&&options.layer?options.layer:this.scene.layers.getLayerById(LAYERID_IMMEDIATE);const depthTest=options&&options.depthTest!==undefined?options.depthTest:true;const batch=this.scene.immediate.getBatch(layer,depthTest);batch.addLines(positions,colors);};AppBase.prototype.renderLine=function(start,end,color){let endColor=color;let options;const arg3=arguments[3];const arg4=arguments[4];if(arg3 instanceof Color){endColor=arg3;if(typeof arg4==="number"){if(arg4===LINEBATCH_OVERLAY){options={layer:this.scene.layers.getLayerById(LAYERID_IMMEDIATE),depthTest:false};}else {options={layer:this.scene.layers.getLayerById(LAYERID_IMMEDIATE),depthTest:true};}}else {options=arg4;}}else if(typeof arg3==="number"){endColor=color;if(arg3===LINEBATCH_OVERLAY){options={layer:this.scene.layers.getLayerById(LAYERID_IMMEDIATE),depthTest:false};}else {options={layer:this.scene.layers.getLayerById(LAYERID_IMMEDIATE),depthTest:true};}}else if(arg3){options=arg3;}this._addLines([start,end],[color,endColor],options);};AppBase.prototype.renderLines=function(position,color,options){if(!options){options={layer:this.scene.layers.getLayerById(LAYERID_IMMEDIATE),depthTest:true};}else if(typeof options==="number"){if(options===LINEBATCH_OVERLAY){options={layer:this.scene.layers.getLayerById(LAYERID_IMMEDIATE),depthTest:false};}else {options={layer:this.scene.layers.getLayerById(LAYERID_IMMEDIATE),depthTest:true};}}const multiColor=!!color.length;if(multiColor){if(position.length!==color.length){console.error("renderLines: position/color arrays have different lengths");return}}if(position.length%2!==0){console.error("renderLines: array length is not divisible by 2");return}this._addLines(position,color,options);};AppBase.prototype.enableVr=function(){};Object.defineProperty(CameraComponent.prototype,"node",{get:function(){return this.entity}});Object.defineProperty(LightComponent.prototype,"enable",{get:function(){return this.enabled},set:function(value){this.enabled=value;}});ModelComponent.prototype.setVisible=function(visible){this.enabled=visible;};Object.defineProperty(ModelComponent.prototype,"aabb",{get:function(){return null},set:function(type){}});Object.defineProperty(RenderComponent.prototype,"aabb",{get:function(){return null},set:function(type){}});Object.defineProperty(RigidBodyComponent.prototype,"bodyType",{get:function(){return this.type},set:function(type){this.type=type;}});RigidBodyComponent.prototype.syncBodyToEntity=function(){this._updateDynamic();};RigidBodyComponentSystem.prototype.setGravity=function(){if(arguments.length===1){this.gravity.copy(arguments[0]);}else {this.gravity.set(arguments[0],arguments[1],arguments[2]);}};function basisSetDownloadConfig(glueUrl,wasmUrl,fallbackUrl){basisInitialize({glueUrl:glueUrl,wasmUrl:wasmUrl,fallbackUrl:fallbackUrl,lazyInit:true});}function prefilterCubemap(options){}Object.defineProperty(StandardMaterial.prototype,"useGamma",{get:function(){return this.useGammaTonemap},set:function(value){this.useGammaTonemap=value;}});Object.defineProperty(StandardMaterial.prototype,"aoIntensity",{get:function(){return 1},set:function(value){}});function __dummyFunction(){}class CpuTimer{begin(name){if(!this.enabled){return}if(this._frameIndex<this._frameTimings.length){this._frameTimings.splice(this._frameIndex);}const tmp=this._prevTimings;this._prevTimings=this._timings;this._timings=this._frameTimings;this._frameTimings=tmp;this._frameIndex=0;this.mark(name);}mark(name){if(!this.enabled){return}const timestamp=now();if(this._frameIndex>0){const prev=this._frameTimings[this._frameIndex-1];prev[1]=timestamp-prev[1];}else if(this._timings.length>0){const prev=this._timings[this._timings.length-1];prev[1]=timestamp-prev[1];}if(this._frameIndex>=this._frameTimings.length){this._frameTimings.push([name,timestamp]);}else {const timing=this._frameTimings[this._frameIndex];timing[0]=name;timing[1]=timestamp;}this._frameIndex++;}get timings(){return this._timings.slice(0,-1).map(v=>v[1])}constructor(app){this._frameIndex=0;this._frameTimings=[];this._timings=[];this._prevTimings=[];this.unitsName="ms";this.decimalPlaces=1;this.enabled=true;app.on("frameupdate",this.begin.bind(this,"update"));app.on("framerender",this.mark.bind(this,"render"));app.on("frameend",this.mark.bind(this,"other"));}}class GpuTimer{get timings(){this._timings[0]=this.device.gpuProfiler._frameTime;return this._timings}constructor(device){this.device=device;device.gpuProfiler.enabled=true;this.enabled=true;this.unitsName="ms";this.decimalPlaces=1;this._timings=[];}}class StatsTimer{get timings(){return this.values}constructor(app,statNames,decimalPlaces,unitsName,multiplier){this.app=app;this.values=[];this.statNames=statNames;if(this.statNames.length>3){this.statNames.length=3;}this.unitsName=unitsName;this.decimalPlaces=decimalPlaces;this.multiplier=multiplier||1;const resolve=(path,obj)=>{return path.split(".").reduce((prev,curr)=>{return prev?prev[curr]:null},obj||this)};app.on("frameupdate",ms=>{for(let i=0;i<this.statNames.length;i++){this.values[i]=resolve(this.statNames[i],this.app.stats)*this.multiplier;}});}}class Graph{destroy(){this.app.off("frameupdate",this.update,this);}loseContext(){if(this.timer&&typeof this.timer.loseContext==="function"){this.timer.loseContext();}}update(ms){const timings=this.timer.timings;const total=timings.reduce((a,v)=>a+v,0);this.avgTotal+=total;this.avgTimer+=ms;this.avgCount++;if(this.avgTimer>this.textRefreshRate){this.timingText=(this.avgTotal/this.avgCount).toFixed(this.timer.decimalPlaces);this.avgTimer=0;this.avgTotal=0;this.avgCount=0;}if(this.enabled){let value=0;const range=1.5*this.watermark;for(let i=0;i<timings.length;++i){value+=Math.floor(timings[i]/range*255);this.sample[i]=value;}this.sample[3]=this.watermark/range*255;const data=this.texture.lock();data.set(this.sample,(this.cursor+this.yOffset*this.texture.width)*4);this.texture.unlock();this.cursor++;if(this.cursor===this.texture.width){this.cursor=0;}}}render(render2d,x,y,w,h){render2d.quad(x+w,y,-w,h,this.enabled?this.cursor:0,this.enabled?.5+this.yOffset:this.texture.height-1,-w,0,this.texture,0);}constructor(name,app,watermark,textRefreshRate,timer){this.app=app;this.name=name;this.device=app.graphicsDevice;this.timer=timer;this.watermark=watermark;this.enabled=false;this.textRefreshRate=textRefreshRate;this.avgTotal=0;this.avgTimer=0;this.avgCount=0;this.timingText="";this.texture=null;this.yOffset=0;this.cursor=0;this.sample=new Uint8ClampedArray(4);this.sample.set([0,0,0,255]);this.counter=0;this.app.on("frameupdate",this.update,this);}}class WordAtlas{destroy(){this.texture.destroy();this.texture=null;}render(render2d,word,x,y){const p=this.placements.get(word);if(p){const padding=1;render2d.quad(x+p.l-padding,y-p.d+padding,p.w+padding*2,p.h+padding*2,p.x-padding,this.texture.height-p.y-p.h-padding,undefined,undefined,this.texture,1);return p.w}return 0}constructor(device,words){const initContext=context=>{context.font='10px "Lucida Console", Monaco, monospace';context.textAlign="left";context.textBaseline="alphabetic";};const isNumber=word=>{return word==="."||word.length===1&&word.charCodeAt(0)>=48&&word.charCodeAt(0)<=57};const canvas=document.createElement("canvas");const context=canvas.getContext("2d",{alpha:true});initContext(context);const placements=new Map;const padding=5;const width=512;let x=padding;let y=padding;words.forEach(word=>{const measurement=context.measureText(word);const l=Math.ceil(-measurement.actualBoundingBoxLeft);const r=Math.ceil(measurement.actualBoundingBoxRight);const a=Math.ceil(measurement.actualBoundingBoxAscent);const d=Math.ceil(measurement.actualBoundingBoxDescent);const w=l+r;const h=a+d;if(x+w+padding>=width){x=padding;y+=16;}placements.set(word,{l,r,a,d,w,h,x:x,y:y});x+=w+padding;});canvas.width=512;canvas.height=math.nextPowerOfTwo(y+16+padding);initContext(context);context.fillStyle="rgb(0, 0, 0)";context.fillRect(0,0,canvas.width,canvas.height);placements.forEach((m,word)=>{context.fillStyle=isNumber(word)?"rgb(255, 255, 255)":"rgb(170, 170, 170)";context.fillText(word,m.x-m.l,m.y+m.a);});this.placements=placements;const data=context.getImageData(0,0,canvas.width,canvas.height).data;for(let i=0;i<data.length;i+=4){data[i+3]=data[i+0];data[i+0]=255;data[i+1]=255;data[i+2]=255;}this.texture=new Texture(device,{name:"mini-stats-word-atlas",width:canvas.width,height:canvas.height,mipmaps:false,minFilter:FILTER_NEAREST,magFilter:FILTER_NEAREST,levels:[data]});}}const vertexShader=`
attribute vec3 vertex_position;
attribute vec4 vertex_texCoord0;
varying vec4 uv0;
varying float wordFlag;
void main(void) {
	gl_Position = vec4(vertex_position.xy * 2.0 - 1.0, 0.5, 1.0);
	uv0 = vertex_texCoord0;
	wordFlag = vertex_position.z;
}`;const fragmentShader$1=`
varying vec4 uv0;
varying float wordFlag;
uniform vec4 clr;
uniform sampler2D graphTex;
uniform sampler2D wordsTex;
void main (void) {
	vec4 graphSample = texture2D(graphTex, uv0.xy);
	vec4 graph;
	if (uv0.w < graphSample.r)
		graph = vec4(0.7, 0.2, 0.2, 1.0);
	else if (uv0.w < graphSample.g)
		graph = vec4(0.2, 0.7, 0.2, 1.0);
	else if (uv0.w < graphSample.b)
		graph = vec4(0.2, 0.2, 0.7, 1.0);
	else
		graph = vec4(0.0, 0.0, 0.0, 1.0 - 0.25 * sin(uv0.w * 3.14159));
	vec4 words = texture2D(wordsTex, vec2(uv0.x, 1.0 - uv0.y));
	gl_FragColor = mix(graph, words, wordFlag) * clr;
}`;class Render2d{quad(x,y,w,h,u,v,uw,uh,texture,wordFlag=0){const rw=this.targetSize.width;const rh=this.targetSize.height;const x0=x/rw;const y0=y/rh;const x1=(x+w)/rw;const y1=(y+h)/rh;const tw=texture.width;const th=texture.height;const u0=u/tw;const v0=v/th;const u1=(u+(uw!=null?uw:w))/tw;const v1=(v+(uh!=null?uh:h))/th;this.data.set([x0,y0,wordFlag,u0,v0,0,0,x1,y0,wordFlag,u1,v0,1,0,x1,y1,wordFlag,u1,v1,1,1,x0,y1,wordFlag,u0,v1,0,1],4*7*this.quads);this.quads++;this.prim.count+=6;}startFrame(){this.quads=0;this.prim.count=0;this.targetSize.width=this.device.canvas.scrollWidth;this.targetSize.height=this.device.canvas.scrollHeight;}render(app,layer,graphTexture,wordsTexture,clr,height){this.buffer.setData(this.data.buffer);this.uniforms.clr.set(clr,0);this.material.setParameter("clr",this.uniforms.clr);this.material.setParameter("graphTex",graphTexture);this.material.setParameter("wordsTex",wordsTexture);app.drawMeshInstance(this.meshInstance,layer);}constructor(device,maxQuads=512){const format=new VertexFormat(device,[{semantic:SEMANTIC_POSITION,components:3,type:TYPE_FLOAT32},{semantic:SEMANTIC_TEXCOORD0,components:4,type:TYPE_FLOAT32}]);const indices=new Uint16Array(maxQuads*6);for(let i=0;i<maxQuads;++i){indices[i*6+0]=i*4;indices[i*6+1]=i*4+1;indices[i*6+2]=i*4+2;indices[i*6+3]=i*4;indices[i*6+4]=i*4+2;indices[i*6+5]=i*4+3;}const shader=shaderChunks.createShaderFromCode(device,vertexShader,fragmentShader$1,"mini-stats");this.device=device;this.buffer=new VertexBuffer(device,format,maxQuads*4,{usage:BUFFER_STREAM});this.data=new Float32Array(this.buffer.numBytes/4);this.indexBuffer=new IndexBuffer(device,INDEXFORMAT_UINT16,maxQuads*6,BUFFER_STATIC,indices);this.prim={type:PRIMITIVE_TRIANGLES,indexed:true,base:0,count:0};this.quads=0;this.mesh=new Mesh(device);this.mesh.vertexBuffer=this.buffer;this.mesh.indexBuffer[0]=this.indexBuffer;this.mesh.primitive=[this.prim];const material=new Material;this.material=material;material.cull=CULLFACE_NONE;material.shader=shader;material.depthState=DepthState.NODEPTH;material.blendState=new BlendState(true,BLENDEQUATION_ADD,BLENDMODE_SRC_ALPHA,BLENDMODE_ONE_MINUS_SRC_ALPHA,BLENDEQUATION_ADD,BLENDMODE_ONE,BLENDMODE_ONE);material.update();this.meshInstance=new MeshInstance(this.mesh,material,new GraphNode("MiniStatsMesh"));this.uniforms={clr:new Float32Array(4)};this.targetSize={width:device.width,height:device.height};}}class MiniStats{destroy(){this.device.off("resizecanvas",this.updateDiv,this);this.device.off("losecontext",this.loseContext,this);this.app.off("postrender",this.postRender,this);this.graphs.forEach(graph=>graph.destroy());this.wordAtlas.destroy();this.texture.destroy();}static getDefaultOptions(){return {sizes:[{width:100,height:16,spacing:0,graphs:false},{width:128,height:32,spacing:2,graphs:true},{width:256,height:64,spacing:2,graphs:true}],startSizeIndex:0,textRefreshRate:500,cpu:{enabled:true,watermark:33},gpu:{enabled:true,watermark:33},stats:[{name:"Frame",stats:["frame.ms"],decimalPlaces:1,unitsName:"ms",watermark:33},{name:"DrawCalls",stats:["drawCalls.total"],watermark:1e3}]}}set activeSizeIndex(value){this._activeSizeIndex=value;this.gspacing=this.sizes[value].spacing;this.resize(this.sizes[value].width,this.sizes[value].height,this.sizes[value].graphs);}get activeSizeIndex(){return this._activeSizeIndex}set opacity(value){this.clr[3]=value;}get opacity(){return this.clr[3]}get overallHeight(){const graphs=this.graphs;const spacing=this.gspacing;return this.height*graphs.length+spacing*(graphs.length-1)}set enabled(value){if(value!==this._enabled){this._enabled=value;for(let i=0;i<this.graphs.length;++i){this.graphs[i].enabled=value;this.graphs[i].timer.enabled=value;}}}get enabled(){return this._enabled}initGraphs(app,device,options){this.graphs=[];if(options.cpu.enabled){const timer=new CpuTimer(app);const graph=new Graph("CPU",app,options.cpu.watermark,options.textRefreshRate,timer);this.graphs.push(graph);}if(options.gpu.enabled){const timer=new GpuTimer(device);const graph=new Graph("GPU",app,options.gpu.watermark,options.textRefreshRate,timer);this.graphs.push(graph);}if(options.stats){options.stats.forEach(entry=>{const timer=new StatsTimer(app,entry.stats,entry.decimalPlaces,entry.unitsName,entry.multiplier);const graph=new Graph(entry.name,app,entry.watermark,options.textRefreshRate,timer);this.graphs.push(graph);});}const maxWidth=options.sizes.reduce((max,v)=>{return v.width>max?v.width:max},0);this.texture=new Texture(device,{name:"mini-stats-graph-texture",width:math.nextPowerOfTwo(maxWidth),height:math.nextPowerOfTwo(this.graphs.length),mipmaps:false,minFilter:FILTER_NEAREST,magFilter:FILTER_NEAREST,addressU:ADDRESS_REPEAT,addressV:ADDRESS_REPEAT});this.graphs.forEach((graph,i)=>{graph.texture=this.texture;graph.yOffset=i;});}render(){const graphs=this.graphs;const wordAtlas=this.wordAtlas;const render2d=this.render2d;const width=this.width;const height=this.height;const gspacing=this.gspacing;render2d.startFrame();for(let i=0;i<graphs.length;++i){const graph=graphs[i];let y=i*(height+gspacing);graph.render(render2d,0,y,width,height);let x=1;y+=height-13;x+=wordAtlas.render(render2d,graph.name,x,y)+10;const timingText=graph.timingText;for(let j=0;j<timingText.length;++j){x+=wordAtlas.render(render2d,timingText[j],x,y);}if(graph.timer.unitsName){x+=3;wordAtlas.render(render2d,graph.timer.unitsName,x,y);}}render2d.render(this.app,this.drawLayer,this.texture,this.wordAtlas.texture,this.clr,height);}resize(width,height,showGraphs){const graphs=this.graphs;for(let i=0;i<graphs.length;++i){graphs[i].enabled=showGraphs;}this.width=width;this.height=height;this.updateDiv();}updateDiv(){const rect=this.device.canvas.getBoundingClientRect();this.div.style.left=`${rect.left}px`;this.div.style.bottom=`${window.innerHeight-rect.bottom}px`;this.div.style.width=`${this.width}px`;this.div.style.height=`${this.overallHeight}px`;}loseContext(){this.graphs.forEach(graph=>graph.loseContext());}postRender(){if(this._enabled){this.render();}}constructor(app,options){const device=app.graphicsDevice;options=options||MiniStats.getDefaultOptions();this.initGraphs(app,device,options);const words=new Set(["","ms","0","1","2","3","4","5","6","7","8","9","."].concat(this.graphs.map(graph=>graph.name)).concat(options.stats?options.stats.map(stat=>stat.unitsName):[]).filter(item=>!!item));this.wordAtlas=new WordAtlas(device,words);this.sizes=options.sizes;this._activeSizeIndex=options.startSizeIndex;const div=document.createElement("div");div.setAttribute("id","mini-stats");div.style.cssText="position:fixed;bottom:0;left:0;background:transparent;";document.body.appendChild(div);div.addEventListener("mouseenter",event=>{this.opacity=1;});div.addEventListener("mouseleave",event=>{this.opacity=.7;});div.addEventListener("click",event=>{event.preventDefault();if(this._enabled){this.activeSizeIndex=(this.activeSizeIndex+1)%this.sizes.length;this.resize(this.sizes[this.activeSizeIndex].width,this.sizes[this.activeSizeIndex].height,this.sizes[this.activeSizeIndex].graphs);}});device.on("resizecanvas",this.updateDiv,this);device.on("losecontext",this.loseContext,this);app.on("postrender",this.postRender,this);this.app=app;this.drawLayer=app.scene.layers.getLayerById(LAYERID_UI);this.device=device;this.render2d=new Render2d(device);this.div=div;this.width=0;this.height=0;this.gspacing=2;this.clr=[1,1,1,.5];this._enabled=true;this.activeSizeIndex=this._activeSizeIndex;}}const textureBlitVertexShader=`
	attribute vec2 vertex_position;
	varying vec2 uv0;
	void main(void) {
		gl_Position = vec4(vertex_position, 0.5, 1.0);
		uv0 = vertex_position.xy * 0.5 + 0.5;
	}`;const textureBlitFragmentShader=`
	varying vec2 uv0;
	uniform sampler2D blitTexture;
	void main(void) {
		gl_FragColor = texture2D(blitTexture, uv0);
	}`;class CoreExporter{textureToCanvas(texture,options={}){const image=texture.getSource();if(typeof HTMLImageElement!=="undefined"&&image instanceof HTMLImageElement||typeof HTMLCanvasElement!=="undefined"&&image instanceof HTMLCanvasElement||typeof OffscreenCanvas!=="undefined"&&image instanceof OffscreenCanvas||typeof ImageBitmap!=="undefined"&&image instanceof ImageBitmap){const{width:_width,height:_height}=this.calcTextureSize(image.width,image.height,options.maxTextureSize);const _canvas=document.createElement("canvas");_canvas.width=_width;_canvas.height=_height;const context=_canvas.getContext("2d");if(context===null){return Promise.resolve(undefined)}context.drawImage(image,0,0,_canvas.width,_canvas.height);if(options.color){const{r,g,b}=options.color;const imagedata=context.getImageData(0,0,_width,_height);const data=imagedata.data;for(let i=0;i<data.length;i+=4){data[i+0]=data[i+0]*r;data[i+1]=data[i+1]*g;data[i+2]=data[i+2]*b;}context.putImageData(imagedata,0,0);}return Promise.resolve(_canvas)}const device=texture.device;const{width,height}=this.calcTextureSize(texture.width,texture.height,options.maxTextureSize);const dstTexture=new Texture(device,{name:"ExtractedTexture",width,height,format:texture.format,cubemap:false,mipmaps:false,minFilter:FILTER_LINEAR,magFilter:FILTER_LINEAR,addressU:ADDRESS_CLAMP_TO_EDGE,addressV:ADDRESS_CLAMP_TO_EDGE});const renderTarget=new RenderTarget({colorBuffer:dstTexture,depth:false});const shader=createShaderFromCode(device,textureBlitVertexShader,textureBlitFragmentShader,"ShaderCoreExporterBlit");device.scope.resolve("blitTexture").setValue(texture);device.setBlendState(BlendState.NOBLEND);drawQuadWithShader(device,renderTarget,shader);const pixels=new Uint8ClampedArray(width*height*4);device.readPixels(0,0,width,height,pixels);dstTexture.destroy();renderTarget.destroy();const newImage=new ImageData(pixels,width,height);const canvas=document.createElement("canvas");canvas.width=width;canvas.height=height;const newContext=canvas.getContext("2d");if(!newContext){return Promise.resolve(undefined)}newContext.putImageData(newImage,0,0);return Promise.resolve(canvas)}calcTextureSize(width,height,maxTextureSize){if(maxTextureSize){const scale=Math.min(maxTextureSize/Math.max(width,height),1);width=Math.round(width*scale);height=Math.round(height*scale);}return {width,height}}constructor(){}}var u8=Uint8Array,u16=Uint16Array,i32=Int32Array;var fleb=new u8([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]);var fdeb=new u8([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]);var clim=new u8([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);var freb=function freb(eb,start){var b=new u16(31);for(var i=0;i<31;++i){b[i]=start+=1<<eb[i-1];}var r=new i32(b[30]);for(var i=1;i<30;++i){for(var j=b[i];j<b[i+1];++j){r[j]=j-b[i]<<5|i;}}return {b:b,r:r}};var _a=freb(fleb,2),fl=_a.b,revfl=_a.r;fl[28]=258,revfl[258]=28;var _b=freb(fdeb,0),revfd=_b.r;var rev=new u16(32768);for(var i=0;i<32768;++i){var x=(i&43690)>>1|(i&21845)<<1;x=(x&52428)>>2|(x&13107)<<2;x=(x&61680)>>4|(x&3855)<<4;rev[i]=((x&65280)>>8|(x&255)<<8)>>1;}var hMap=function hMap(cd,mb,r){var s=cd.length;var i=0;var l=new u16(mb);for(;i<s;++i){if(cd[i])++l[cd[i]-1];}var le=new u16(mb);for(i=1;i<mb;++i){le[i]=le[i-1]+l[i-1]<<1;}var co;if(r){co=new u16(1<<mb);var rvb=15-mb;for(i=0;i<s;++i){if(cd[i]){var sv=i<<4|cd[i];var r_1=mb-cd[i];var v=le[cd[i]-1]++<<r_1;for(var m=v|(1<<r_1)-1;v<=m;++v){co[rev[v]>>rvb]=sv;}}}}else {co=new u16(s);for(i=0;i<s;++i){if(cd[i]){co[i]=rev[le[cd[i]-1]++]>>15-cd[i];}}}return co};var flt=new u8(288);for(var i=0;i<144;++i)flt[i]=8;for(var i=144;i<256;++i)flt[i]=9;for(var i=256;i<280;++i)flt[i]=7;for(var i=280;i<288;++i)flt[i]=8;var fdt=new u8(32);for(var i=0;i<32;++i)fdt[i]=5;var flm=hMap(flt,9,0);hMap(flt,9,1);var fdm=hMap(fdt,5,0);hMap(fdt,5,1);var shft=function shft(p){return (p+7)/8|0};var slc=function slc(v,s,e){if(e==null||e>v.length)e=v.length;return new u8(v.subarray(s,e))};var ec=["unexpected EOF","invalid block type","invalid length/literal","invalid distance","stream finished","no stream handler",,"no callback","invalid UTF-8 data","extra field too long","date not in range 1980-2099","filename too long","stream finishing","invalid zip data"];var err=function err(ind,msg,nt){var e=new Error(msg||ec[ind]);e.code=ind;if(Error.captureStackTrace)Error.captureStackTrace(e,err);if(!nt)throw e;return e};var wbits=function wbits(d,p,v){v<<=p&7;var o=p/8|0;d[o]|=v;d[o+1]|=v>>8;};var wbits16=function wbits16(d,p,v){v<<=p&7;var o=p/8|0;d[o]|=v;d[o+1]|=v>>8;d[o+2]|=v>>16;};var hTree=function hTree(d,mb){var t=[];for(var i=0;i<d.length;++i){if(d[i])t.push({s:i,f:d[i]});}var s=t.length;var t2=t.slice();if(!s)return {t:et,l:0};if(s==1){var v=new u8(t[0].s+1);v[t[0].s]=1;return {t:v,l:1}}t.sort(function(a,b){return a.f-b.f});t.push({s:-1,f:25001});var l=t[0],r=t[1],i0=0,i1=1,i2=2;t[0]={s:-1,f:l.f+r.f,l:l,r:r};while(i1!=s-1){l=t[t[i0].f<t[i2].f?i0++:i2++];r=t[i0!=i1&&t[i0].f<t[i2].f?i0++:i2++];t[i1++]={s:-1,f:l.f+r.f,l:l,r:r};}var maxSym=t2[0].s;for(var i=1;i<s;++i){if(t2[i].s>maxSym)maxSym=t2[i].s;}var tr=new u16(maxSym+1);var mbt=ln(t[i1-1],tr,0);if(mbt>mb){var i=0,dt=0;var lft=mbt-mb,cst=1<<lft;t2.sort(function(a,b){return tr[b.s]-tr[a.s]||a.f-b.f});for(;i<s;++i){var i2_1=t2[i].s;if(tr[i2_1]>mb){dt+=cst-(1<<mbt-tr[i2_1]);tr[i2_1]=mb;}else break}dt>>=lft;while(dt>0){var i2_2=t2[i].s;if(tr[i2_2]<mb)dt-=1<<mb-tr[i2_2]++-1;else ++i;}for(;i>=0&&dt;--i){var i2_3=t2[i].s;if(tr[i2_3]==mb){--tr[i2_3];++dt;}}mbt=mb;}return {t:new u8(tr),l:mbt}};var ln=function ln(n,l,d){return n.s==-1?Math.max(ln(n.l,l,d+1),ln(n.r,l,d+1)):l[n.s]=d};var lc=function lc(c){var s=c.length;while(s&&!c[--s]);var cl=new u16(++s);var cli=0,cln=c[0],cls=1;var w=function w(v){cl[cli++]=v;};for(var i=1;i<=s;++i){if(c[i]==cln&&i!=s)++cls;else {if(!cln&&cls>2){for(;cls>138;cls-=138)w(32754);if(cls>2){w(cls>10?cls-11<<5|28690:cls-3<<5|12305);cls=0;}}else if(cls>3){w(cln),--cls;for(;cls>6;cls-=6)w(8304);if(cls>2)w(cls-3<<5|8208),cls=0;}while(cls--)w(cln);cls=1;cln=c[i];}}return {c:cl.subarray(0,cli),n:s}};var clen=function clen(cf,cl){var l=0;for(var i=0;i<cl.length;++i)l+=cf[i]*cl[i];return l};var wfblk=function wfblk(out,pos,dat){var s=dat.length;var o=shft(pos+2);out[o]=s&255;out[o+1]=s>>8;out[o+2]=out[o]^255;out[o+3]=out[o+1]^255;for(var i=0;i<s;++i)out[o+i+4]=dat[i];return (o+4+s)*8};var wblk=function wblk(dat,out,final,syms,lf,df,eb,li,bs,bl,p){wbits(out,p++,final);++lf[256];var _a=hTree(lf,15),dlt=_a.t,mlb=_a.l;var _b=hTree(df,15),ddt=_b.t,mdb=_b.l;var _c=lc(dlt),lclt=_c.c,nlc=_c.n;var _d=lc(ddt),lcdt=_d.c,ndc=_d.n;var lcfreq=new u16(19);for(var i=0;i<lclt.length;++i)++lcfreq[lclt[i]&31];for(var i=0;i<lcdt.length;++i)++lcfreq[lcdt[i]&31];var _e=hTree(lcfreq,7),lct=_e.t,mlcb=_e.l;var nlcc=19;for(;nlcc>4&&!lct[clim[nlcc-1]];--nlcc);var flen=bl+5<<3;var ftlen=clen(lf,flt)+clen(df,fdt)+eb;var dtlen=clen(lf,dlt)+clen(df,ddt)+eb+14+3*nlcc+clen(lcfreq,lct)+2*lcfreq[16]+3*lcfreq[17]+7*lcfreq[18];if(bs>=0&&flen<=ftlen&&flen<=dtlen)return wfblk(out,p,dat.subarray(bs,bs+bl));var lm,ll,dm,dl;wbits(out,p,1+(dtlen<ftlen)),p+=2;if(dtlen<ftlen){lm=hMap(dlt,mlb,0),ll=dlt,dm=hMap(ddt,mdb,0),dl=ddt;var llm=hMap(lct,mlcb,0);wbits(out,p,nlc-257);wbits(out,p+5,ndc-1);wbits(out,p+10,nlcc-4);p+=14;for(var i=0;i<nlcc;++i)wbits(out,p+3*i,lct[clim[i]]);p+=3*nlcc;var lcts=[lclt,lcdt];for(var it=0;it<2;++it){var clct=lcts[it];for(var i=0;i<clct.length;++i){var len=clct[i]&31;wbits(out,p,llm[len]),p+=lct[len];if(len>15)wbits(out,p,clct[i]>>5&127),p+=clct[i]>>12;}}}else {lm=flm,ll=flt,dm=fdm,dl=fdt;}for(var i=0;i<li;++i){var sym=syms[i];if(sym>255){var len=sym>>18&31;wbits16(out,p,lm[len+257]),p+=ll[len+257];if(len>7)wbits(out,p,sym>>23&31),p+=fleb[len];var dst=sym&31;wbits16(out,p,dm[dst]),p+=dl[dst];if(dst>3)wbits16(out,p,sym>>5&8191),p+=fdeb[dst];}else {wbits16(out,p,lm[sym]),p+=ll[sym];}}wbits16(out,p,lm[256]);return p+ll[256]};var deo=new i32([65540,131080,131088,131104,262176,1048704,1048832,2114560,2117632]);var et=new u8(0);var dflt=function dflt(dat,lvl,plvl,pre,post,st){var s=st.z||dat.length;var o=new u8(pre+s+5*(1+Math.ceil(s/7e3))+post);var w=o.subarray(pre,o.length-post);var lst=st.l;var pos=(st.r||0)&7;if(lvl){if(pos)w[0]=st.r>>3;var opt=deo[lvl-1];var n=opt>>13,c=opt&8191;var msk_1=(1<<plvl)-1;var prev=st.p||new u16(32768),head=st.h||new u16(msk_1+1);var bs1_1=Math.ceil(plvl/3),bs2_1=2*bs1_1;var hsh=function hsh(i){return (dat[i]^dat[i+1]<<bs1_1^dat[i+2]<<bs2_1)&msk_1};var syms=new i32(25e3);var lf=new u16(288),df=new u16(32);var lc_1=0,eb=0,i=st.i||0,li=0,wi=st.w||0,bs=0;for(;i+2<s;++i){var hv=hsh(i);var imod=i&32767,pimod=head[hv];prev[imod]=pimod;head[hv]=imod;if(wi<=i){var rem=s-i;if((lc_1>7e3||li>24576)&&(rem>423||!lst)){pos=wblk(dat,w,0,syms,lf,df,eb,li,bs,i-bs,pos);li=lc_1=eb=0,bs=i;for(var j=0;j<286;++j)lf[j]=0;for(var j=0;j<30;++j)df[j]=0;}var l=2,d=0,ch_1=c,dif=imod-pimod&32767;if(rem>2&&hv==hsh(i-dif)){var maxn=Math.min(n,rem)-1;var maxd=Math.min(32767,i);var ml=Math.min(258,rem);while(dif<=maxd&&--ch_1&&imod!=pimod){if(dat[i+l]==dat[i+l-dif]){var nl=0;for(;nl<ml&&dat[i+nl]==dat[i+nl-dif];++nl);if(nl>l){l=nl,d=dif;if(nl>maxn)break;var mmd=Math.min(dif,nl-2);var md=0;for(var j=0;j<mmd;++j){var ti=i-dif+j&32767;var pti=prev[ti];var cd=ti-pti&32767;if(cd>md)md=cd,pimod=ti;}}}imod=pimod,pimod=prev[imod];dif+=imod-pimod&32767;}}if(d){syms[li++]=268435456|revfl[l]<<18|revfd[d];var lin=revfl[l]&31,din=revfd[d]&31;eb+=fleb[lin]+fdeb[din];++lf[257+lin];++df[din];wi=i+l;++lc_1;}else {syms[li++]=dat[i];++lf[dat[i]];}}}for(i=Math.max(i,wi);i<s;++i){syms[li++]=dat[i];++lf[dat[i]];}pos=wblk(dat,w,lst,syms,lf,df,eb,li,bs,i-bs,pos);if(!lst){st.r=pos&7|w[pos/8|0]<<3;pos-=7;st.h=head,st.p=prev,st.i=i,st.w=wi;}}else {for(var i=st.w||0;i<s+lst;i+=65535){var e=i+65535;if(e>=s){w[pos/8|0]=lst;e=s;}pos=wfblk(w,pos+1,dat.subarray(i,e));}st.i=s;}return slc(o,0,pre+shft(pos)+post)};var crct=function(){var t=new Int32Array(256);for(var i=0;i<256;++i){var c=i,k=9;while(--k)c=(c&1&&-306674912)^c>>>1;t[i]=c;}return t}();var crc=function crc(){var c=-1;return {p:function(d){var cr=c;for(var i=0;i<d.length;++i)cr=crct[cr&255^d[i]]^cr>>>8;c=cr;},d:function(){return ~c}}};var dopt=function dopt(dat,opt,pre,post,st){if(!st){st={l:1};if(opt.dictionary){var dict=opt.dictionary.subarray(-32768);var newDat=new u8(dict.length+dat.length);newDat.set(dict);newDat.set(dat,dict.length);dat=newDat;st.w=dict.length;}}return dflt(dat,opt.level==null?6:opt.level,opt.mem==null?st.l?Math.ceil(Math.max(8,Math.min(13,Math.log(dat.length)))*1.5):20:12+opt.mem,pre,post,st)};var mrg=function mrg(a,b){var o={};for(var k in a)o[k]=a[k];for(var k in b)o[k]=b[k];return o};var wbytes=function wbytes(d,b,v){for(;v;++b)d[b]=v,v>>>=8;};function deflateSync(data,opts){return dopt(data,opts||{},0,0)}var fltn=function fltn(d,p,t,o){for(var k in d){var val=d[k],n=p+k,op=o;if(Array.isArray(val))op=mrg(o,val[1]),val=val[0];if(val instanceof u8)t[n]=[val,op];else {t[n+="/"]=[new u8(0),op];fltn(val,n,t,o);}}};var te=typeof TextEncoder!="undefined"&&new TextEncoder;var td=typeof TextDecoder!="undefined"&&new TextDecoder;var tds=0;try{td.decode(et,{stream:true});tds=1;}catch(e){}function strToU8(str,latin1){var i;if(te)return te.encode(str);var l=str.length;var ar=new u8(str.length+(str.length>>1));var ai=0;var w=function w(v){ar[ai++]=v;};for(var i=0;i<l;++i){if(ai+5>ar.length){var n=new u8(ai+8+(l-i<<1));n.set(ar);ar=n;}var c=str.charCodeAt(i);if(c<128||latin1)w(c);else if(c<2048)w(192|c>>6),w(128|c&63);else if(c>55295&&c<57344)c=65536+(c&1023<<10)|str.charCodeAt(++i)&1023,w(240|c>>18),w(128|c>>12&63),w(128|c>>6&63),w(128|c&63);else w(224|c>>12),w(128|c>>6&63),w(128|c&63);}return slc(ar,0,ai)}var exfl=function exfl(ex){var le=0;if(ex){for(var k in ex){var l=ex[k].length;if(l>65535)err(9);le+=l+4;}}return le};var wzh=function wzh(d,b,f,fn,u,c,ce,co){var fl=fn.length,ex=f.extra,col=co&&co.length;var exl=exfl(ex);wbytes(d,b,ce!=null?33639248:67324752),b+=4;if(ce!=null)d[b++]=20,d[b++]=f.os;d[b]=20,b+=2;d[b++]=f.flag<<1|(c<0&&8),d[b++]=u&&8;d[b++]=f.compression&255,d[b++]=f.compression>>8;var dt=new Date(f.mtime==null?Date.now():f.mtime),y=dt.getFullYear()-1980;if(y<0||y>119)err(10);wbytes(d,b,y<<25|dt.getMonth()+1<<21|dt.getDate()<<16|dt.getHours()<<11|dt.getMinutes()<<5|dt.getSeconds()>>1),b+=4;if(c!=-1){wbytes(d,b,f.crc);wbytes(d,b+4,c<0?-c-2:c);wbytes(d,b+8,f.size);}wbytes(d,b+12,fl);wbytes(d,b+14,exl),b+=16;if(ce!=null){wbytes(d,b,col);wbytes(d,b+6,f.attrs);wbytes(d,b+10,ce),b+=14;}d.set(fn,b);b+=fl;if(exl){for(var k in ex){var exf=ex[k],l=exf.length;wbytes(d,b,+k);wbytes(d,b+2,l);d.set(exf,b+4),b+=4+l;}}if(col)d.set(co,b),b+=col;return b};var wzf=function wzf(o,b,c,d,e){wbytes(o,b,101010256);wbytes(o,b+8,c);wbytes(o,b+10,c);wbytes(o,b+12,d);wbytes(o,b+16,e);};function zipSync(data,opts){if(!opts)opts={};var r={};var files=[];fltn(data,"",r,opts);var o=0;var tot=0;for(var fn in r){var _a=r[fn],file=_a[0],p=_a[1];var compression=p.level==0?0:8;var f=strToU8(fn),s=f.length;var com=p.comment,m=com&&strToU8(com),ms=m&&m.length;var exl=exfl(p.extra);if(s>65535)err(11);var d=compression?deflateSync(file,p):file,l=d.length;var c=crc();c.p(file);files.push(mrg(p,{size:file.length,crc:c.d(),c:d,f:f,m:m,u:s!=fn.length||m&&com.length!=ms,o:o,compression:compression}));o+=30+s+exl+l;tot+=76+2*(s+exl)+(ms||0)+l;}var out=new u8(tot+22),oe=o,cdl=tot-o;for(var i=0;i<files.length;++i){var f=files[i];wzh(out,f.o,f,f.f,f.u,f.c.length);var badd=30+f.f.length+exfl(f.extra);out.set(f.c,f.o+badd);wzh(out,o,f,f.f,f.u,f.c.length,f.o,f.m),o+=16+badd+(f.m?f.m.length:0);}wzf(out,o,files.length,cdl,oe);return out}const ROOT_FILE_NAME="root";const header=`#usda 1.0
(
		customLayerData = {
				string creator = "PlayCanvas UsdzExporter"
		}
		metersPerUnit = 1
		upAxis = "Y"
)
`;const materialListTemplate=materials=>`
def "Materials"
{
		${materials.join("\n")}
}
`;const meshTemplate=(faceVertexCounts,indices,normals,positions,uv0,uv1)=>`
def "Mesh"
{
		def Mesh "Mesh"
		{
				int[] faceVertexCounts = [${faceVertexCounts}]
				int[] faceVertexIndices = [${indices}]
				normal3f[] normals = [${normals}] (
						interpolation = "vertex"
				)
				point3f[] points = [${positions}]
				texCoord2f[] primvars:st = [${uv0}] (
						interpolation = "vertex"
				)
				texCoord2f[] primvars:st1 = [${uv1}] (
						interpolation = "vertex"
				)
				uniform token subdivisionScheme = "none"
		}
}
`;const meshInstanceTemplate=(nodeName,meshRefPath,worldMatrix,materialRefPath)=>`
def Xform "${nodeName}" (
		prepend references = ${meshRefPath}
)
{
		matrix4d xformOp:transform = ${worldMatrix}
		uniform token[] xformOpOrder = ["xformOp:transform"]

		rel material:binding = ${materialRefPath}
}
`;const materialValueTemplate=(type,name,value)=>`                    ${type} inputs:${name} = ${value}`;class UsdzExporter extends CoreExporter{init(){this.meshMap=new Map;this.textureMap=new Map;this.materialMap=new Map;this.materials=[];this.files={};this.nodeNames=new Set;}done(){this.meshMap=null;this.textureMap=null;this.materialMap=null;this.materials=null;this.files=null;this.nodeNames=null;}build(entity,options={}){this.init();this.addFile(null,ROOT_FILE_NAME);const allMeshInstances=[];if(entity){const renders=entity.findComponents("render");renders.forEach(render=>{allMeshInstances.push(...render.meshInstances);});}let rootContent="";allMeshInstances.forEach(meshInstance=>{rootContent+=this.buildMeshInstance(meshInstance);});rootContent+=materialListTemplate(this.materials);this.addFile(null,ROOT_FILE_NAME,"",rootContent);const textureOptions={maxTextureSize:options.maxTextureSize};const textureArray=Array.from(this.textureMap.keys());const promises=[];for(let i=0;i<textureArray.length;i++){const mimeType="image/png";const texture=textureArray[i];const texturePromise=this.textureToCanvas(texture,textureOptions).then(canvas=>{if(canvas){return new Promise(resolve=>canvas.toBlob(resolve,mimeType,1)).then(blob=>blob.arrayBuffer())}console.warn(`Export of texture ${texture.name} is not currently supported.`);return new Promise(resolve=>resolve(null))});promises.push(texturePromise);}const finalData=Promise.all(promises).then(values=>{values.forEach((textureArrayBuffer,index)=>{const texture=textureArray[index];const ids=this.getTextureFileIds(texture);this.files[ids.fileName]=new Uint8Array(textureArrayBuffer);});this.alignFiles();const arraybuffer=zipSync(this.files,{level:0});this.done();return arraybuffer});return finalData}alignFiles(){let offset=0;for(const filename in this.files){const file=this.files[filename];const headerSize=34+filename.length;offset+=headerSize;const offsetMod64=offset&63;if(offsetMod64!==4){const padLength=64-offsetMod64;const padding=new Uint8Array(padLength);this.files[filename]=[file,{extra:{12345:padding}}];}offset=file.length;}}getFileIds(category,name,ref,extension="usda"){const fileName=`${category?`${category}/`:""}${name}.${extension}`;const refName=`@./${fileName}@</${ref}>`;return {name,fileName,refName}}getTextureFileIds(texture){return this.getFileIds("texture",`Texture_${texture.id}`,"Texture","png")}addFile(category,uniqueId,refName="",content=""){let contentU8=null;if(content){content=`${header}
${content}`;contentU8=strToU8(content);}const ids=this.getFileIds(category,uniqueId,refName);this.files[ids.fileName]=contentU8;return ids.refName}getMaterialRef(material){let materialRef=this.materialMap.get(material);if(!materialRef){materialRef=this.buildMaterial(material);this.materialMap.set(material,materialRef);}return materialRef}getMeshRef(mesh){let meshRef=this.meshMap.get(mesh);if(!meshRef){meshRef=this.buildMesh(mesh);this.meshMap.set(mesh,meshRef);}return meshRef}buildArray2(array){const components=[];const count=array.length;for(let i=0;i<count;i+=2){components.push(`(${array[i]}, ${1-array[i+1]})`);}return components.join(", ")}buildArray3(array){const components=[];const count=array.length;for(let i=0;i<count;i+=3){components.push(`(${array[i]}, ${array[i+1]}, ${array[i+2]})`);}return components.join(", ")}buildMat4(mat){const data=mat.data;const vectors=[];for(let i=0;i<16;i+=4){vectors.push(`(${data[i]}, ${data[i+1]}, ${data[i+2]}, ${data[i+3]})`);}return `( ${vectors.join(", ")} )`}buildMaterial(material){const materialName=`Material_${material.id}`;const materialPath=`/Materials/${materialName}`;const materialPropertyPath=property=>`<${materialPath}${property}>`;const buildTexture=(texture,textureIds,mapType,uvChannel,tiling,offset,rotation,tintColor)=>{return `
								def Shader "Transform2d_${mapType}" (
										sdrMetadata = {
												string role = "math"
										}
								)
								{
										uniform token info:id = "UsdTransform2d"
										float2 inputs:in.connect = ${materialPropertyPath(`/uvReader_${uvChannel}.outputs:result`)}
										float inputs:rotation = ${rotation}
										float2 inputs:scale = (${tiling.x}, ${tiling.y})
										float2 inputs:translation = (${offset.x}, ${offset.y})
										float2 outputs:result
								}

								def Shader "Texture_${texture.id}_${mapType}"
								{
										uniform token info:id = "UsdUVTexture"
										asset inputs:file = @${textureIds.fileName}@
										float2 inputs:st.connect = ${materialPropertyPath(`/Transform2d_${mapType}.outputs:result`)}
										token inputs:wrapS = "repeat"
										token inputs:wrapT = "repeat"
										float4 inputs:scale = (${tintColor.r}, ${tintColor.g}, ${tintColor.b}, ${tintColor.a})
										float outputs:r
										float outputs:g
										float outputs:b
										float3 outputs:rgb
										float outputs:a
								}
						`};const inputs=[];const samplers=[];const addTexture=(textureSlot,uniform,propType,propName,valueName,handleOpacity=false,tintTexture=false)=>{const texture=material[textureSlot];if(texture){const textureIds=this.getTextureFileIds(texture);this.textureMap.set(texture,textureIds.refName);const channel=material[`${textureSlot}Channel`]||"rgb";const textureValue=materialPropertyPath(`/${textureIds.name}_${valueName}.outputs:${channel}`);inputs.push(materialValueTemplate(propType,`${propName}.connect`,textureValue));if(handleOpacity){if(material.alphaTest>0);}const tiling=material[`${textureSlot}Tiling`];const offset=material[`${textureSlot}Offset`];const rotation=material[`${textureSlot}Rotation`];const uvChannel=material[`${textureSlot}Uv`]===1?"st1":"st";const tintColor=tintTexture&&uniform?uniform:Color.WHITE;samplers.push(buildTexture(texture,textureIds,valueName,uvChannel,tiling,offset,rotation,tintColor));}else if(uniform){const value=propType==="float"?`${uniform}`:`(${uniform.r}, ${uniform.g}, ${uniform.b})`;inputs.push(materialValueTemplate(propType,propName,value));}};addTexture("diffuseMap",material.diffuse,"color3f","diffuseColor","diffuse",false,true);if(material.transparent||material.alphaTest>0){addTexture("opacityMap",material.opacity,"float","opacity","opacity",true);}addTexture("normalMap",null,"normal3f","normal","normal");addTexture("emissiveMap",material.emissive,"color3f","emissiveColor","emissive",false,true);addTexture("aoMap",null,"float","occlusion","occlusion");addTexture("metalnessMap",material.metalness,"float","metallic","metallic");addTexture("glossMap",material.gloss,"float","roughness","roughness");const materialObject=`
						def Material "${materialName}"
						{
								def Shader "PreviewSurface"
								{
										uniform token info:id = "UsdPreviewSurface"
${inputs.join("\n")}
										int inputs:useSpecularWorkflow = 0
										token outputs:surface
								}

								token outputs:surface.connect = ${materialPropertyPath("/PreviewSurface.outputs:surface")}

								def Shader "uvReader_st"
								{
										uniform token info:id = "UsdPrimvarReader_float2"
										token inputs:varname = "st"
										float2 inputs:fallback = (0.0, 0.0)
										float2 outputs:result
								}

								def Shader "uvReader_st1"
								{
										uniform token info:id = "UsdPrimvarReader_float2"
										token inputs:varname = "st1"
										float2 inputs:fallback = (0.0, 0.0)
										float2 outputs:result
								}

								${samplers.join("\n")}
						}
				`;this.materials.push(materialObject);return materialPropertyPath("")}buildMesh(mesh){let positions=[];const indices=[];let normals=[];let uv0=[];let uv1=[];mesh.getVertexStream(SEMANTIC_POSITION,positions);mesh.getVertexStream(SEMANTIC_NORMAL,normals);mesh.getVertexStream(SEMANTIC_TEXCOORD0,uv0);mesh.getVertexStream(SEMANTIC_TEXCOORD1,uv1);mesh.getIndices(indices);const indicesCount=indices.length||positions.length;const faceVertexCounts=Array(indicesCount/3).fill(3).join(", ");if(!indices.length){for(let i=0;i<indicesCount;i++){indices[i]=i;}}const numVerts=positions.length/3;normals=normals.length?normals:Array(numVerts*3).fill(0);uv0=uv0.length?uv0:Array(numVerts*2).fill(0);uv1=uv1.length?uv1:Array(numVerts*2).fill(0);positions=this.buildArray3(positions);normals=this.buildArray3(normals);uv0=this.buildArray2(uv0);uv1=this.buildArray2(uv1);const meshObject=meshTemplate(faceVertexCounts,indices,normals,positions,uv0,uv1);const refPath=this.addFile("mesh",`Mesh_${mesh.id}`,"Mesh",meshObject);return refPath}buildMeshInstance(meshInstance){const meshRefPath=this.getMeshRef(meshInstance.mesh);const materialRefPath=this.getMaterialRef(meshInstance.material);const worldMatrix=this.buildMat4(meshInstance.node.getWorldTransform());const name=meshInstance.node.name.replace(/[^a-z0-9]/gi,"_");let nodeName=name;while(this.nodeNames.has(nodeName)){nodeName=`${name}_${Math.random().toString(36).slice(2,7)}`;}this.nodeNames.add(nodeName);return meshInstanceTemplate(nodeName,meshRefPath,worldMatrix,materialRefPath)}constructor(...args){super(...args);this.meshMap=void 0;this.materialMap=void 0;this.materials=void 0;this.textureMap=void 0;this.nodeNames=void 0;this.files=void 0;}}const ARRAY_BUFFER=34962;const ELEMENT_ARRAY_BUFFER=34963;const getIndexComponentType=indexFormat=>{switch(indexFormat){case INDEXFORMAT_UINT8:return 5121;case INDEXFORMAT_UINT16:return 5123;case INDEXFORMAT_UINT32:return 5125}return 0};const getComponentType=dataType=>{switch(dataType){case TYPE_INT8:return 5120;case TYPE_UINT8:return 5121;case TYPE_INT16:return 5122;case TYPE_UINT16:return 5123;case TYPE_INT32:return 5124;case TYPE_UINT32:return 5125;case TYPE_FLOAT32:return 5126}return 0};const getAccessorType=componentCount=>{switch(componentCount){case 1:return "SCALAR";case 2:return "VEC2";case 3:return "VEC3";case 4:return "VEC4"}return 0};const getSemantic=engineSemantic=>{switch(engineSemantic){case SEMANTIC_POSITION:return "POSITION";case SEMANTIC_NORMAL:return "NORMAL";case SEMANTIC_TANGENT:return "TANGENT";case SEMANTIC_COLOR:return "COLOR_0";case SEMANTIC_BLENDINDICES:return "JOINTS_0";case SEMANTIC_BLENDWEIGHT:return "WEIGHTS_0";case SEMANTIC_TEXCOORD0:return "TEXCOORD_0";case SEMANTIC_TEXCOORD1:return "TEXCOORD_1";case SEMANTIC_TEXCOORD2:return "TEXCOORD_2";case SEMANTIC_TEXCOORD3:return "TEXCOORD_3";case SEMANTIC_TEXCOORD4:return "TEXCOORD_4";case SEMANTIC_TEXCOORD5:return "TEXCOORD_5";case SEMANTIC_TEXCOORD6:return "TEXCOORD_6";case SEMANTIC_TEXCOORD7:return "TEXCOORD_7"}return ""};const getFilter=function getFilter(filter){switch(filter){case FILTER_NEAREST:return 9728;case FILTER_LINEAR:return 9729;case FILTER_NEAREST_MIPMAP_NEAREST:return 9984;case FILTER_LINEAR_MIPMAP_NEAREST:return 9985;case FILTER_NEAREST_MIPMAP_LINEAR:return 9986;case FILTER_LINEAR_MIPMAP_LINEAR:return 9987}return 0};const getWrap=function getWrap(wrap){switch(wrap){case ADDRESS_CLAMP_TO_EDGE:return 33071;case ADDRESS_MIRRORED_REPEAT:return 33648;case ADDRESS_REPEAT:return 10497}return 0};function isCanvasTransparent(canvas){const context=canvas.getContext("2d");const pixelData=context.getImageData(0,0,canvas.width,canvas.height).data;for(let i=3;i<pixelData.length;i+=4){if(pixelData[i]<255){return true}}return false}const textureSemantics=["diffuseMap","colorMap","normalMap","metalnessMap","emissiveMap"];class GltfExporter extends CoreExporter{collectResources(root){const resources={buffers:[],cameras:[],entities:[],materials:[],textures:[],entityMeshInstances:[],bufferViewMap:new Map,compressableTexture:new Set};const{materials,buffers,entityMeshInstances,textures}=resources;root.forEach(entity=>{resources.entities.push(entity);});const collectMeshInstances=meshInstances=>{meshInstances.forEach(meshInstance=>{const material=meshInstance.material;if(materials.indexOf(material)<0){resources.materials.push(material);textureSemantics.forEach(semantic=>{const texture=material[semantic];if(texture&&textures.indexOf(texture)<0){if(semantic!=="normalMap"){resources.compressableTexture.add(texture);}textures.push(texture);}});}const node=meshInstance.node;let nodeMeshInstances=entityMeshInstances.find(e=>e.node===node);if(!nodeMeshInstances){nodeMeshInstances={node:node,meshInstances:[]};entityMeshInstances.push(nodeMeshInstances);}nodeMeshInstances.meshInstances.push(meshInstance);const mesh=meshInstance.mesh;const vertexBuffer=mesh.vertexBuffer;if(buffers.indexOf(vertexBuffer)<0){buffers.unshift(vertexBuffer);}const indexBuffer=mesh.indexBuffer[0];if(buffers.indexOf(indexBuffer)<0){buffers.push(indexBuffer);}});};resources.entities.forEach(entity=>{if(entity.camera){resources.cameras.push(entity.camera);}if(entity.render&&entity.render.enabled){collectMeshInstances(entity.render.meshInstances);}if(entity.model&&entity.model.enabled&&entity.model.meshInstances){collectMeshInstances(entity.model.meshInstances);}});return resources}writeBufferViews(resources,json){json.bufferViews=[];for(const buffer of resources.buffers){GltfExporter.writeBufferView(resources,json,buffer);}}static writeBufferView(resources,json,buffer){var _json$buffers,_json$buffers$;json.buffers=(_json$buffers=json.buffers)!=null?_json$buffers:[];json.buffers[0]=(_json$buffers$=json.buffers[0])!=null?_json$buffers$:{byteLength:0};const bufferInfo=json.buffers[0];bufferInfo.byteLength=math.roundUp(bufferInfo.byteLength,4);const offset=bufferInfo.byteLength;const addBufferView=(target,byteLength,byteOffset,byteStride)=>{const bufferView={target:target,buffer:0,byteLength:byteLength,byteOffset:byteOffset,byteStride:byteStride};return json.bufferViews.push(bufferView)-1};let arrayBuffer;if(buffer instanceof VertexBuffer){arrayBuffer=buffer.lock();const format=buffer.getFormat();if(format.interleaved){const bufferViewIndex=addBufferView(ARRAY_BUFFER,arrayBuffer.byteLength,offset,format.size);resources.bufferViewMap.set(buffer,[bufferViewIndex]);}else {const bufferViewIndices=[];for(const element of format.elements){const bufferViewIndex=addBufferView(ARRAY_BUFFER,element.size*format.vertexCount,offset+element.offset,element.size);bufferViewIndices.push(bufferViewIndex);}resources.bufferViewMap.set(buffer,bufferViewIndices);}}else if(buffer instanceof IndexBuffer){arrayBuffer=buffer.lock();const bufferViewIndex=addBufferView(ARRAY_BUFFER,arrayBuffer.byteLength,offset);resources.bufferViewMap.set(buffer,[bufferViewIndex]);}else {arrayBuffer=buffer;const bufferViewIndex=addBufferView(ELEMENT_ARRAY_BUFFER,arrayBuffer.byteLength,offset);resources.bufferViewMap.set(buffer,[bufferViewIndex]);}bufferInfo.byteLength+=arrayBuffer.byteLength;}writeCameras(resources,json){if(resources.cameras.length>0){json.cameras=resources.cameras.map(cam=>{const projection=cam.projection;const nearClip=cam.nearClip;const farClip=cam.farClip;const camera={};if(projection===PROJECTION_ORTHOGRAPHIC){camera.type="orthographic";camera.orthographic={xmag:1,ymag:1,znear:nearClip,zfar:farClip};}else {const fov=cam.fov;camera.type="perspective";camera.perspective={yfov:fov*Math.PI/180,znear:nearClip,zfar:farClip};}return camera});}}attachTexture(resources,material,destination,name,textureSemantic,json){const texture=material[textureSemantic];if(texture){const textureIndex=resources.textures.indexOf(texture);if(textureIndex<0)console.warn(`Texture ${texture.name} wasn't collected.`);destination[name]={index:textureIndex};const scale=material[`${textureSemantic}Tiling`];const offset=material[`${textureSemantic}Offset`];const rotation=material[`${textureSemantic}Rotation`];if(scale&&!scale.equals(Vec2.ONE)||offset&&!offset.equals(Vec2.ZERO)||rotation!==0){var _json$extensionsUsed,_json$extensionsRequi;destination[name].extensions={KHR_texture_transform:{}};json.extensionsUsed=(_json$extensionsUsed=json.extensionsUsed)!=null?_json$extensionsUsed:[];if(json.extensionsUsed.indexOf("KHR_texture_transform")<0){json.extensionsUsed.push("KHR_texture_transform");}json.extensionsRequired=(_json$extensionsRequi=json.extensionsRequired)!=null?_json$extensionsRequi:[];if(json.extensionsRequired.indexOf("KHR_texture_transform")<0){json.extensionsRequired.push("KHR_texture_transform");}if(scale&&!scale.equals(Vec2.ONE)){destination[name].extensions.KHR_texture_transform.scale=[scale.x,scale.y];}if(offset&&!offset.equals(Vec2.ZERO)){destination[name].extensions.KHR_texture_transform.offset=[offset.x,offset.y-1+scale.y];}if(rotation!==0){destination[name].extensions.KHR_texture_transform.rotation=rotation*math.DEG_TO_RAD;}}}}writeStandardMaterial(resources,mat,output,json){const{diffuse,emissive,opacity,metalness,gloss,glossInvert}=mat;const pbr=output.pbrMetallicRoughness;if(!diffuse.equals(Color.WHITE)||opacity!==1){pbr.baseColorFactor=[diffuse.r,diffuse.g,diffuse.b,opacity];}if(metalness!==1){pbr.metallicFactor=metalness;}const roughness=glossInvert?gloss:1-gloss;if(roughness!==1){pbr.roughnessFactor=roughness;}this.attachTexture(resources,mat,pbr,"baseColorTexture","diffuseMap",json);this.attachTexture(resources,mat,pbr,"metallicRoughnessTexture","metalnessMap",json);if(!emissive.equals(Color.BLACK)){output.emissiveFactor=[emissive.r,emissive.g,emissive.b];}}writeBasicMaterial(resources,mat,output,json){const{color}=mat;const pbr=output.pbrMetallicRoughness;if(!color.equals(Color.WHITE)){pbr.baseColorFactor=[color.r,color.g,color.b,color];}this.attachTexture(resources,mat,pbr,"baseColorTexture","colorMap",json);}writeMaterials(resources,json){if(resources.materials.length>0){json.materials=resources.materials.map(mat=>{const{name,blendType,cull,alphaTest}=mat;const material={pbrMetallicRoughness:{}};if(name&&name.length>0){material.name=name;}if(mat instanceof StandardMaterial){this.writeStandardMaterial(resources,mat,material,json);}if(mat instanceof BasicMaterial){this.writeBasicMaterial(resources,mat,material,json);}if(blendType===BLEND_NORMAL){material.alphaMode="BLEND";}else if(blendType===BLEND_NONE){if(alphaTest!==0){material.alphaMode="MASK";material.alphaCutoff=alphaTest;}}if(cull===CULLFACE_NONE){material.doubleSided=true;}this.attachTexture(resources,mat,material,"normalTexture","normalMap",json);this.attachTexture(resources,mat,material,"occlusionTexture","aoMap",json);this.attachTexture(resources,mat,material,"emissiveTexture","emissiveMap",json);return material});}}writeNodes(resources,json){if(resources.entities.length>0){json.nodes=resources.entities.map(entity=>{const name=entity.name;const t=entity.getLocalPosition();const r=entity.getLocalRotation();const s=entity.getLocalScale();const node={};if(name&&name.length>0){node.name=name;}if(!t.equals(Vec3.ZERO)){node.translation=[t.x,t.y,t.z];}if(!r.equals(Quat.IDENTITY)){node.rotation=[r.x,r.y,r.z,r.w];}if(!s.equals(Vec3.ONE)){node.scale=[s.x,s.y,s.z];}if(entity.camera&&entity.camera.enabled){node.camera=resources.cameras.indexOf(entity.camera);}const entityMeshInstance=resources.entityMeshInstances.find(e=>e.node===entity);if(entityMeshInstance){node.mesh=resources.entityMeshInstances.indexOf(entityMeshInstance);}if(entity.children.length>0){node.children=[];entity.children.forEach(child=>{node.children.push(resources.entities.indexOf(child));});}return node});}}writeMeshes(resources,json){if(resources.entityMeshInstances.length>0){json.accessors=[];json.meshes=[];resources.entityMeshInstances.forEach(entityMeshInstances=>{const mesh={primitives:[]};const meshInstances=entityMeshInstances.meshInstances;meshInstances.forEach(meshInstance=>{const primitive=GltfExporter.createPrimitive(resources,json,meshInstance.mesh);primitive.material=resources.materials.indexOf(meshInstance.material);mesh.primitives.push(primitive);});json.meshes.push(mesh);});}}static createPrimitive(resources,json,mesh){const primitive={attributes:{}};const{vertexBuffer}=mesh;const{format}=vertexBuffer;const{interleaved,elements}=format;const numVertices=vertexBuffer.getNumVertices();elements.forEach((element,elementIndex)=>{let bufferView=resources.bufferViewMap.get(vertexBuffer);if(!bufferView){GltfExporter.writeBufferView(resources,json,vertexBuffer);resources.buffers.push(vertexBuffer);bufferView=resources.bufferViewMap.get(vertexBuffer);}const viewIndex=bufferView[interleaved?0:elementIndex];const accessor={bufferView:viewIndex,byteOffset:interleaved?element.offset:0,componentType:getComponentType(element.dataType),type:getAccessorType(element.numComponents),count:numVertices};const idx=json.accessors.push(accessor)-1;primitive.attributes[getSemantic(element.name)]=idx;if(element.name===SEMANTIC_POSITION){const positions=[];mesh.getPositions(positions);const min=new Vec3;const max=new Vec3;BoundingBox.computeMinMax(positions,min,max);accessor.min=[min.x,min.y,min.z];accessor.max=[max.x,max.y,max.z];}});const indexBuffer=mesh.indexBuffer[0];if(indexBuffer){let bufferView=resources.bufferViewMap.get(indexBuffer);if(!bufferView){GltfExporter.writeBufferView(resources,json,indexBuffer);resources.buffers.push(indexBuffer);bufferView=resources.bufferViewMap.get(indexBuffer);}const viewIndex=bufferView[0];const accessor={bufferView:viewIndex,componentType:getIndexComponentType(indexBuffer.getFormat()),count:indexBuffer.getNumIndices(),type:"SCALAR"};const idx=json.accessors.push(accessor)-1;primitive.indices=idx;}return primitive}convertTextures(srcTextures,options){const textureOptions={maxTextureSize:options.maxTextureSize};const promises=[];srcTextures.forEach(srcTexture=>{const promise=this.textureToCanvas(srcTexture,textureOptions);promise.then(canvas=>{return new Promise(resolve=>resolve(canvas))});promises.push(promise);});return promises}writeTextures(resources,textureCanvases,json,options){const textures=resources.textures;const promises=[];for(let i=0;i<textureCanvases.length;i++){const texture=textures[i];const canvas=textureCanvases[i];const isRGBA=isCanvasTransparent(canvas)||!resources.compressableTexture.has(texture);const mimeType=isRGBA?"image/png":"image/jpeg";promises.push(this.getBlob(canvas,mimeType).then(blob=>{const reader=new FileReader;reader.readAsArrayBuffer(blob);return new Promise(resolve=>{reader.onloadend=()=>{resolve(reader);};})}).then(reader=>{const buffer=this.getPaddedArrayBuffer(reader.result);GltfExporter.writeBufferView(resources,json,buffer);resources.buffers.push(buffer);const bufferView=resources.bufferViewMap.get(buffer);json.images[i]={mimeType:mimeType,bufferView:bufferView[0]};json.samplers[i]={minFilter:getFilter(texture.minFilter),magFilter:getFilter(texture.magFilter),wrapS:getWrap(texture.addressU),wrapT:getWrap(texture.addressV)};json.textures[i]={sampler:i,source:i};}));}return Promise.all(promises)}getBlob(canvas,mimeType){if(canvas.toBlob!==undefined){return new Promise(resolve=>{canvas.toBlob(resolve,mimeType);})}let quality=1;if(mimeType==="image/jpeg"){quality=.92;}return canvas.convertToBlob({type:mimeType,quality:quality})}getPaddedArrayBuffer(arrayBuffer,paddingByte=0){const paddedLength=math.roundUp(arrayBuffer.byteLength,4);if(paddedLength!==arrayBuffer.byteLength){const array=new Uint8Array(paddedLength);array.set(new Uint8Array(arrayBuffer));if(paddingByte!==0){for(let i=arrayBuffer.byteLength;i<paddedLength;i++){array[i]=paddingByte;}}return array.buffer}return arrayBuffer}buildJson(resources,options){var _this=this;const promises=this.convertTextures(resources.textures,options);return Promise.all(promises).then(async function(textureCanvases){const json={asset:{version:"2.0",generator:"PlayCanvas GltfExporter"},scenes:[{nodes:[0]}],images:[],samplers:[],textures:[],scene:0};_this.writeBufferViews(resources,json);_this.writeCameras(resources,json);_this.writeMeshes(resources,json);_this.writeMaterials(resources,json);_this.writeNodes(resources,json,options);await _this.writeTextures(resources,textureCanvases,json,options);if(!json.images.length)delete json.images;if(!json.samplers.length)delete json.samplers;if(!json.textures.length)delete json.textures;return json})}build(entity,options={}){const resources=this.collectResources(entity);return this.buildJson(resources,options).then(json=>{const encoder=new TextEncoder;const jsonData=encoder.encode(JSON.stringify(json));const headerLength=12;const jsonHeaderLength=8;const jsonDataLength=jsonData.length;const jsonPaddingLength=4-(jsonDataLength&3)&3;const binaryHeaderLength=8;const binaryDataLength=json.buffers.reduce((total,buffer)=>math.roundUp(total+buffer.byteLength,4),0);let totalLength=headerLength+jsonHeaderLength+jsonDataLength+jsonPaddingLength;if(binaryDataLength>0){totalLength+=binaryHeaderLength+binaryDataLength;}const glbBuffer=new ArrayBuffer(totalLength);const glbView=new DataView(glbBuffer);glbView.setUint32(0,1179937895,true);glbView.setUint32(4,2,true);glbView.setUint32(8,totalLength,true);glbView.setUint32(12,jsonDataLength+jsonPaddingLength,true);glbView.setUint32(16,1313821514,true);let offset=headerLength+jsonHeaderLength;new Uint8Array(glbBuffer,offset,jsonDataLength).set(jsonData);offset+=jsonDataLength;for(let i=0;i<jsonPaddingLength;i++){glbView.setUint8(offset+i,32);}offset+=jsonPaddingLength;if(binaryDataLength>0){glbView.setUint32(offset,binaryDataLength,true);glbView.setUint32(offset+4,5130562,true);offset+=binaryHeaderLength;resources.buffers.forEach(buffer=>{let src;const bufferViewId=resources.bufferViewMap.get(buffer)[0];const bufferOffset=json.bufferViews[bufferViewId].byteOffset;if(buffer instanceof ArrayBuffer){src=new Uint8Array(buffer);}else {const srcBuffer=buffer.lock();if(srcBuffer instanceof ArrayBuffer){src=new Uint8Array(srcBuffer);}else {src=new Uint8Array(srcBuffer.buffer,srcBuffer.byteOffset,srcBuffer.byteLength);}}const dst=new Uint8Array(glbBuffer,offset+bufferOffset,src.byteLength);dst.set(src);});}return Promise.resolve(glbBuffer)})}}class RenderPassDownsample extends RenderPassShaderQuad{execute(){this.sourceTextureId.setValue(this.sourceTexture);this.sourceInvResolutionValue[0]=1/this.sourceTexture.width;this.sourceInvResolutionValue[1]=1/this.sourceTexture.height;this.sourceInvResolutionId.setValue(this.sourceInvResolutionValue);super.execute();}constructor(device,sourceTexture){super(device);this.sourceTexture=sourceTexture;this.shader=this.createQuadShader("DownSampleShader",`
			uniform sampler2D sourceTexture;
			uniform vec2 sourceInvResolution;
			varying vec2 uv0;
			void main()
			{
				float x = sourceInvResolution.x;
				float y = sourceInvResolution.y;
				vec3 a = texture2D (sourceTexture, vec2 (uv0.x - 2.0 * x, uv0.y + 2.0 * y)).rgb;
				vec3 b = texture2D (sourceTexture, vec2 (uv0.x,		   uv0.y + 2.0 * y)).rgb;
				vec3 c = texture2D (sourceTexture, vec2 (uv0.x + 2.0 * x, uv0.y + 2.0 * y)).rgb;
				vec3 d = texture2D (sourceTexture, vec2 (uv0.x - 2.0 * x, uv0.y)).rgb;
				vec3 e = texture2D (sourceTexture, vec2 (uv0.x,		   uv0.y)).rgb;
				vec3 f = texture2D (sourceTexture, vec2 (uv0.x + 2.0 * x, uv0.y)).rgb;
				vec3 g = texture2D (sourceTexture, vec2 (uv0.x - 2.0 * x, uv0.y - 2.0 * y)).rgb;
				vec3 h = texture2D (sourceTexture, vec2 (uv0.x,		   uv0.y - 2.0 * y)).rgb;
				vec3 i = texture2D (sourceTexture, vec2 (uv0.x + 2.0 * x, uv0.y - 2.0 * y)).rgb;
				vec3 j = texture2D (sourceTexture, vec2 (uv0.x - x, uv0.y + y)).rgb;
				vec3 k = texture2D (sourceTexture, vec2 (uv0.x + x, uv0.y + y)).rgb;
				vec3 l = texture2D (sourceTexture, vec2 (uv0.x - x, uv0.y - y)).rgb;
				vec3 m = texture2D (sourceTexture, vec2 (uv0.x + x, uv0.y - y)).rgb;
				vec3 value = e * 0.125;
				value += (a + c + g + i) * 0.03125;
				value += (b + d + f + h) * 0.0625;
				value += (j + k + l + m) * 0.125;
				gl_FragColor = vec4(value, 1.0);
			}`);this.sourceTextureId=device.scope.resolve("sourceTexture");this.sourceInvResolutionId=device.scope.resolve("sourceInvResolution");this.sourceInvResolutionValue=new Float32Array(2);}}class RenderPassUpsample extends RenderPassShaderQuad{execute(){this.sourceTextureId.setValue(this.sourceTexture);this.sourceInvResolutionValue[0]=1/this.sourceTexture.width;this.sourceInvResolutionValue[1]=1/this.sourceTexture.height;this.sourceInvResolutionId.setValue(this.sourceInvResolutionValue);super.execute();}constructor(device,sourceTexture){super(device);this.sourceTexture=sourceTexture;this.shader=this.createQuadShader("UpSampleShader",`
			uniform sampler2D sourceTexture;
			uniform vec2 sourceInvResolution;
			varying vec2 uv0;
			void main()
			{
				float x = sourceInvResolution.x;
				float y = sourceInvResolution.y;
				vec3 a = texture2D (sourceTexture, vec2 (uv0.x - x, uv0.y + y)).rgb;
				vec3 b = texture2D (sourceTexture, vec2 (uv0.x,	 uv0.y + y)).rgb;
				vec3 c = texture2D (sourceTexture, vec2 (uv0.x + x, uv0.y + y)).rgb;
				vec3 d = texture2D (sourceTexture, vec2 (uv0.x - x, uv0.y)).rgb;
				vec3 e = texture2D (sourceTexture, vec2 (uv0.x,	 uv0.y)).rgb;
				vec3 f = texture2D (sourceTexture, vec2 (uv0.x + x, uv0.y)).rgb;
				vec3 g = texture2D (sourceTexture, vec2 (uv0.x - x, uv0.y - y)).rgb;
				vec3 h = texture2D (sourceTexture, vec2 (uv0.x,	 uv0.y - y)).rgb;
				vec3 i = texture2D (sourceTexture, vec2 (uv0.x + x, uv0.y - y)).rgb;
				vec3 value = e * 4.0;
				value += (b + d + f + h) * 2.0;
				value += (a + c + g + i);
				value *= 1.0 / 16.0;
				gl_FragColor = vec4(value, 1.0);
			}`);this.sourceTextureId=device.scope.resolve("sourceTexture");this.sourceInvResolutionId=device.scope.resolve("sourceInvResolution");this.sourceInvResolutionValue=new Float32Array(2);}}class RenderPassBloom extends RenderPass{destroy(){this.destroyRenderPasses();this.destroyRenderTargets();}destroyRenderTargets(startIndex=0){for(let i=startIndex;i<this.renderTargets.length;i++){const rt=this.renderTargets[i];rt.destroyTextureBuffers();rt.destroy();}this.renderTargets.length=0;}destroyRenderPasses(){for(let i=0;i<this.beforePasses.length;i++){this.beforePasses[i].destroy();}this.beforePasses.length=0;}createRenderTarget(index){return new RenderTarget({depth:false,colorBuffer:new Texture(this.device,{name:`BloomTexture${index}`,width:1,height:1,format:this.textureFormat,mipmaps:false,minFilter:FILTER_LINEAR,magFilter:FILTER_LINEAR,addressU:ADDRESS_CLAMP_TO_EDGE,addressV:ADDRESS_CLAMP_TO_EDGE})})}createRenderTargets(count){for(let i=0;i<count;i++){const rt=i===0?this.bloomRenderTarget:this.createRenderTarget(i);this.renderTargets.push(rt);}}calcMipLevels(width,height,minSize){const min=Math.min(width,height);return Math.floor(Math.log2(min)-Math.log2(minSize))}createRenderPasses(numPasses){const device=this.device;let passSourceTexture=this._sourceTexture;for(let i=0;i<numPasses;i++){const pass=new RenderPassDownsample(device,passSourceTexture);const rt=this.renderTargets[i];pass.init(rt,{resizeSource:passSourceTexture,scaleX:.5,scaleY:.5});pass.setClearColor(Color.BLACK);this.beforePasses.push(pass);passSourceTexture=rt.colorBuffer;}passSourceTexture=this.renderTargets[numPasses-1].colorBuffer;for(let i=numPasses-2;i>=0;i--){const pass=new RenderPassUpsample(device,passSourceTexture);const rt=this.renderTargets[i];pass.init(rt);pass.blendState=BlendState.ADDBLEND;this.beforePasses.push(pass);passSourceTexture=rt.colorBuffer;}}onDisable(){var _this$renderTargets$;(_this$renderTargets$=this.renderTargets[0])==null||_this$renderTargets$.resize(1,1);this.destroyRenderPasses();this.destroyRenderTargets(1);}set sourceTexture(value){this._sourceTexture=value;if(this.beforePasses.length>0){const firstPass=this.beforePasses[0];firstPass.options.resizeSource=value;firstPass.sourceTexture=value;}}get sourceTexture(){return this._sourceTexture}frameUpdate(){super.frameUpdate();let numPasses=this.calcMipLevels(this._sourceTexture.width,this._sourceTexture.height,2**this.lastMipLevel);numPasses=Math.max(1,numPasses);if(this.renderTargets.length!==numPasses){this.destroyRenderPasses();this.destroyRenderTargets(1);this.createRenderTargets(numPasses);this.createRenderPasses(numPasses);}}constructor(device,sourceTexture,format){super(device);this.bloomTexture=void 0;this.lastMipLevel=1;this.bloomRenderTarget=void 0;this.textureFormat=void 0;this.renderTargets=[];this._sourceTexture=sourceTexture;this.textureFormat=format;this.bloomRenderTarget=this.createRenderTarget(0);this.bloomTexture=this.bloomRenderTarget.colorBuffer;}}const fragmentShader=`
	varying vec2 uv0;
	uniform sampler2D sceneTexture;
	uniform vec2 sceneTextureInvRes;
	#ifdef BLOOM
		uniform sampler2D bloomTexture;
		uniform float bloomIntensity;
	#endif
	#ifdef GRADING
		uniform vec3 brightnessContrastSaturation;
		vec3 contrastSaturationBrightness(vec3 color, float brt, float sat, float con)
		{
			color = color * brt;
			float grey = dot(color, vec3(0.3, 0.59, 0.11));
			color  = mix(vec3(grey), color, sat);
			return max(mix(vec3(0.5), color, con), 0.0);
		}
	
	#endif
	#ifdef VIGNETTE
		uniform vec4 vignetterParams;
		float vignette(vec2 uv) {
			float inner = vignetterParams.x;
			float outer = vignetterParams.y;
			float curvature = vignetterParams.z;
			float intensity = vignetterParams.w;
			vec2 curve = pow(abs(uv * 2.0 -1.0), vec2(1.0 / curvature));
			float edge = pow(length(curve), curvature);
			return 1.0 - intensity * smoothstep(inner, outer, edge);
		}		
	#endif
	#ifdef FRINGING
		uniform float fringingIntensity;
		vec3 fringing(vec2 uv, vec3 color) {
			vec2 centerDistance = uv0 - 0.5;
			vec2 offset = fringingIntensity * pow(centerDistance, vec2(2.0, 2.0));
			color.r = texture2D(sceneTexture, uv0 - offset).r;
			color.b = texture2D(sceneTexture, uv0 + offset).b;
			return color;
		}
	#endif
	#ifdef CAS
		uniform float sharpness;
		float maxComponent(float x, float y, float z) { return max(x, max(y, z)); }
		vec3 toSDR(vec3 c) { return c / (1.0 + maxComponent(c.r, c.g, c.b)); }
		vec3 toHDR(vec3 c) { return c / (1.0 - maxComponent(c.r, c.g, c.b)); }
		vec3 cas(vec3 color, vec2 uv, float sharpness) {
			float x = sceneTextureInvRes.x;
			float y = sceneTextureInvRes.y;
			vec3 a = toSDR(texture2DLodEXT(sceneTexture, uv + vec2(0.0, -y), 0.0).rgb);
			vec3 b = toSDR(texture2DLodEXT(sceneTexture, uv + vec2(-x, 0.0), 0.0).rgb);
			vec3 c = toSDR(color.rgb);
			vec3 d = toSDR(texture2DLodEXT(sceneTexture, uv + vec2(x, 0.0), 0.0).rgb);
			vec3 e = toSDR(texture2DLodEXT(sceneTexture, uv + vec2(0.0, y), 0.0).rgb);
			float min_g = min(a.g, min(b.g, min(c.g, min(d.g, e.g))));
			float max_g = max(a.g, max(b.g, max(c.g, max(d.g, e.g))));
			float sharpening_amount = sqrt(min(1.0 - max_g, min_g) / max_g);
			float w = sharpening_amount * sharpness;
			vec3 res = (w * (a + b + d + e) + c) / (4.0 * w + 1.0);
			return toHDR(res);
		}
	#endif
	void main() {
		vec2 uv = uv0;
		#ifdef TAA
		#ifdef WEBGPU
			uv.y = 1.0 - uv.y;
		#endif
		#endif
		vec4 scene = texture2DLodEXT(sceneTexture, uv, 0.0);
		vec3 result = scene.rgb;
		#ifdef CAS
			result = cas(result, uv, sharpness);
		#endif
		#ifdef FRINGING
			result = fringing(uv, result);
		#endif
		#ifdef BLOOM
			vec3 bloom = texture2DLodEXT(bloomTexture, uv, 0.0).rgb;
			result += bloom * bloomIntensity;
		#endif
		#ifdef GRADING
			result = contrastSaturationBrightness(result, brightnessContrastSaturation.x, brightnessContrastSaturation.z, brightnessContrastSaturation.y);
		#endif
		result = toneMap(result);
		#ifdef VIGNETTE
			result *= vignette(uv);
		#endif
		result = gammaCorrectOutput(result);
		gl_FragColor = vec4(result, scene.a);
	}
`;class RenderPassCompose extends RenderPassShaderQuad{set bloomTexture(value){if(this._bloomTexture!==value){this._bloomTexture=value;this._shaderDirty=true;}}get bloomTexture(){return this._bloomTexture}set taaEnabled(value){if(this._taaEnabled!==value){this._taaEnabled=value;this._shaderDirty=true;}}get taaEnabled(){return this._taaEnabled}set gradingEnabled(value){if(this._gradingEnabled!==value){this._gradingEnabled=value;this._shaderDirty=true;}}get gradingEnabled(){return this._gradingEnabled}set vignetteEnabled(value){if(this._vignetteEnabled!==value){this._vignetteEnabled=value;this._shaderDirty=true;}}get vignetteEnabled(){return this._vignetteEnabled}set fringingEnabled(value){if(this._fringingEnabled!==value){this._fringingEnabled=value;this._shaderDirty=true;}}get fringingEnabled(){return this._fringingEnabled}set toneMapping(value){if(this._toneMapping!==value){this._toneMapping=value;this._shaderDirty=true;}}get toneMapping(){return this._toneMapping}get toneMapChunk(){switch(this.toneMapping){case TONEMAP_LINEAR:return shaderChunks.tonemappingLinearPS;case TONEMAP_FILMIC:return shaderChunks.tonemappingFilmicPS;case TONEMAP_HEJL:return shaderChunks.tonemappingHejlPS;case TONEMAP_ACES:return shaderChunks.tonemappingAcesPS;case TONEMAP_ACES2:return shaderChunks.tonemappingAces2PS;case TONEMAP_NEUTRAL:return shaderChunks.tonemappingNeutralPS}return shaderChunks.tonemappingNonePS}set sharpness(value){if(this._sharpness!==value){this._sharpness=value;this._shaderDirty=true;}}get sharpness(){return this._sharpness}get isSharpnessEnabled(){return this._sharpness>0}postInit(){this.setClearColor(Color.BLACK);this.setClearDepth(1);this.setClearStencil(0);}frameUpdate(){if(this._shaderDirty){this._shaderDirty=false;const key=`${this.toneMapping}`+`-${this.bloomTexture?"bloom":"nobloom"}`+`-${this.gradingEnabled?"grading":"nograding"}`+`-${this.vignetteEnabled?"vignette":"novignette"}`+`-${this.fringingEnabled?"fringing":"nofringing"}`+`-${this.taaEnabled?"taa":"notaa"}`+`-${this.isSharpnessEnabled?"cas":"nocas"}`;if(this._key!==key){this._key=key;const defines=(this.bloomTexture?"#define BLOOM\n":"")+(this.gradingEnabled?"#define GRADING\n":"")+(this.vignetteEnabled?"#define VIGNETTE\n":"")+(this.fringingEnabled?"#define FRINGING\n":"")+(this.taaEnabled?"#define TAA\n":"")+(this.isSharpnessEnabled?"#define CAS\n":"");const fsChunks=shaderChunks.decodePS+shaderChunks.gamma2_2PS+this.toneMapChunk;this.shader=this.createQuadShader(`ComposeShader-${key}`,defines+fsChunks+fragmentShader);}}}execute(){this.sceneTextureId.setValue(this.sceneTexture);this.sceneTextureInvResValue[0]=1/this.sceneTexture.width;this.sceneTextureInvResValue[1]=1/this.sceneTexture.height;this.sceneTextureInvResId.setValue(this.sceneTextureInvResValue);if(this._bloomTexture){this.bloomTextureId.setValue(this._bloomTexture);this.bloomIntensityId.setValue(this.bloomIntensity);}if(this._gradingEnabled){this.bcsId.setValue([this.gradingBrightness,this.gradingContrast,this.gradingSaturation]);}if(this._vignetteEnabled){this.vignetterParamsId.setValue([this.vignetteInner,this.vignetteOuter,this.vignetteCurvature,this.vignetteIntensity]);}if(this._fringingEnabled){this.fringingIntensityId.setValue(this.fringingIntensity/1024);}if(this.isSharpnessEnabled){this.sharpnessId.setValue(math.lerp(-.125,-.2,this.sharpness));}super.execute();}constructor(graphicsDevice){super(graphicsDevice);this.sceneTexture=null;this.bloomIntensity=.01;this._bloomTexture=null;this._toneMapping=TONEMAP_ACES2;this._gradingEnabled=false;this.gradingSaturation=1;this.gradingContrast=1;this.gradingBrightness=1;this._shaderDirty=true;this._vignetteEnabled=false;this.vignetteInner=.5;this.vignetteOuter=1;this.vignetteCurvature=.5;this.vignetteIntensity=.3;this._fringingEnabled=false;this.fringingIntensity=10;this._taaEnabled=false;this._sharpness=.5;this._key="";const{scope}=graphicsDevice;this.sceneTextureId=scope.resolve("sceneTexture");this.bloomTextureId=scope.resolve("bloomTexture");this.bloomIntensityId=scope.resolve("bloomIntensity");this.bcsId=scope.resolve("brightnessContrastSaturation");this.vignetterParamsId=scope.resolve("vignetterParams");this.fringingIntensityId=scope.resolve("fringingIntensity");this.sceneTextureInvResId=scope.resolve("sceneTextureInvRes");this.sceneTextureInvResValue=new Float32Array(2);this.sharpnessId=scope.resolve("sharpness");}}const fs=`
	uniform highp sampler2D uSceneDepthMap;
	uniform sampler2D sourceTexture;
	uniform sampler2D historyTexture;
	uniform mat4 matrix_viewProjectionPrevious;
	uniform mat4 matrix_viewProjectionInverse;
	uniform vec4 jitters;
	uniform vec2 textureSize;
	varying vec2 uv0;
	vec2 reproject(vec2 uv, float depth) {
		#ifndef WEBGPU
			depth = depth * 2.0 - 1.0;
		#endif
		vec4 ndc = vec4(uv * 2.0 - 1.0, depth, 1.0);
		ndc.xy -= jitters.xy;
		vec4 worldPosition = matrix_viewProjectionInverse * ndc;
		worldPosition /= worldPosition.w;
	
		vec4 screenPrevious = matrix_viewProjectionPrevious * worldPosition;
		return (screenPrevious.xy / screenPrevious.w) * 0.5 + 0.5;
	}
	vec4 colorClamp(vec2 uv, vec4 historyColor) {
		vec3 minColor = vec3(9999.0);
		vec3 maxColor = vec3(-9999.0);
 
		for(float x = -1.0; x <= 1.0; ++x)
		{
			for(float y = -1.0; y <= 1.0; ++y)
			{
				vec3 color = texture2D(sourceTexture, uv + vec2(x, y) / textureSize).rgb;
				minColor = min(minColor, color);
				maxColor = max(maxColor, color);
			}
		}
 
		vec3 clamped = clamp(historyColor.rgb, minColor, maxColor);
		return vec4(clamped, historyColor.a);
	}
	void main()
	{
		vec2 uv = uv0;
		#ifdef WEBGPU
			uv.y = 1.0 - uv.y;
		#endif
		vec4 srcColor = texture2D(sourceTexture, uv);
		float depth = texture2DLodEXT(uSceneDepthMap, uv, 0.0).r;
		vec2 historyUv = reproject(uv0, depth);
		#ifdef QUALITY_HIGH
			vec4 historyColor = SampleTextureCatmullRom(TEXTURE_PASS(historyTexture), historyUv, textureSize);
		#else
			vec4 historyColor = texture2D(historyTexture, historyUv);
		#endif
		vec4 historyColorClamped = colorClamp(uv, historyColor);
		float mixFactor = (historyUv.x < 0.0 || historyUv.x > 1.0 || historyUv.y < 0.0 || historyUv.y > 1.0) ?
			1.0 : 0.05;
		gl_FragColor = mix(historyColorClamped, srcColor, mixFactor);
	}
`;class RenderPassTAA extends RenderPassShaderQuad{destroy(){if(this.renderTarget){this.renderTarget.destroyTextureBuffers();this.renderTarget.destroy();this.renderTarget=null;}}setup(){for(let i=0;i<2;++i){this.historyTextures[i]=new Texture(this.device,{name:`TAA-History-${i}`,width:4,height:4,format:this.sourceTexture.format,mipmaps:false,minFilter:FILTER_LINEAR,magFilter:FILTER_LINEAR,addressU:ADDRESS_CLAMP_TO_EDGE,addressV:ADDRESS_CLAMP_TO_EDGE});this.historyRenderTargets[i]=new RenderTarget({colorBuffer:this.historyTextures[i],depth:false});}this.historyTexture=this.historyTextures[0];this.init(this.historyRenderTargets[0],{resizeSource:this.sourceTexture});}before(){this.sourceTextureId.setValue(this.sourceTexture);this.historyTextureId.setValue(this.historyTextures[1-this.historyIndex]);this.textureSize[0]=this.sourceTexture.width;this.textureSize[1]=this.sourceTexture.height;this.textureSizeId.setValue(this.textureSize);const camera=this.cameraComponent.camera;this.viewProjPrevId.setValue(camera._viewProjPrevious.data);this.viewProjInvId.setValue(camera._viewProjInverse.data);this.jittersId.setValue(camera._jitters);}update(){this.historyIndex=1-this.historyIndex;this.historyTexture=this.historyTextures[this.historyIndex];this.renderTarget=this.historyRenderTargets[this.historyIndex];return this.historyTexture}constructor(device,sourceTexture,cameraComponent){super(device);this.historyIndex=0;this.historyTexture=null;this.historyTextures=[];this.historyRenderTargets=[];this.sourceTexture=sourceTexture;this.cameraComponent=cameraComponent;const defines=`
			#define QUALITY_HIGH
		`;const fsChunks=shaderChunks.sampleCatmullRomPS;this.shader=this.createQuadShader("TaaResolveShader",defines+fsChunks+fs);const{scope}=device;this.sourceTextureId=scope.resolve("sourceTexture");this.textureSizeId=scope.resolve("textureSize");this.textureSize=new Float32Array(2);this.historyTextureId=scope.resolve("historyTexture");this.viewProjPrevId=scope.resolve("matrix_viewProjectionPrevious");this.viewProjInvId=scope.resolve("matrix_viewProjectionInverse");this.jittersId=scope.resolve("jitters");this.setup();}}const tempMeshInstances=[];const DEPTH_UNIFORM_NAME="uSceneDepthMap";const VELOCITY_UNIFORM_NAME="uSceneVelocityMap";class RenderPassPrepass extends RenderPass{destroy(){var _this$renderTarget,_this$velocityTexture;super.destroy();(_this$renderTarget=this.renderTarget)==null||_this$renderTarget.destroy();this.renderTarget=null;(_this$velocityTexture=this.velocityTexture)==null||_this$velocityTexture.destroy();this.velocityTexture=null;this.viewBindGroups.forEach(bg=>{bg.defaultUniformBuffer.destroy();bg.destroy();});this.viewBindGroups.length=0;}setupRenderTarget(depthBuffer,options){const{device}=this;const velocityFormat=device.getRenderableHdrFormat([PIXELFORMAT_RGBA32F,PIXELFORMAT_RGBA16F]);this.velocityTexture=new Texture(device,{name:"VelocityTexture",width:4,height:4,format:velocityFormat,mipmaps:false,minFilter:FILTER_NEAREST,magFilter:FILTER_NEAREST,addressU:ADDRESS_CLAMP_TO_EDGE,addressV:ADDRESS_CLAMP_TO_EDGE});const renderTarget=new RenderTarget({name:"PrepassRT",depthBuffer:depthBuffer});this.init(renderTarget,options);this.depthStencilOps.storeDepth=true;}after(){this.device.scope.resolve(DEPTH_UNIFORM_NAME).setValue(this.renderTarget.depthBuffer);this.device.scope.resolve(VELOCITY_UNIFORM_NAME).setValue(this.velocityTexture);}execute(){const{renderer,scene,renderTarget}=this;const camera=this.camera.camera;const layers=scene.layers.layerList;const subLayerEnabled=scene.layers.subLayerEnabled;const isTransparent=scene.layers.subLayerList;for(let i=0;i<layers.length;i++){const layer=layers[i];if(layer.enabled&&subLayerEnabled[i]){if(layer.camerasSet.has(camera)){if(layer.id===LAYERID_DEPTH){break}const culledInstances=layer.getCulledInstances(camera);const meshInstances=isTransparent[i]?culledInstances.transparent:culledInstances.opaque;for(let j=0;j<meshInstances.length;j++){var _meshInstance$materia;const meshInstance=meshInstances[j];if((_meshInstance$materia=meshInstance.material)!=null&&_meshInstance$materia.depthWrite){tempMeshInstances.push(meshInstance);}}renderer.renderForwardLayer(camera,renderTarget,null,undefined,SHADER_PREPASS_VELOCITY,this.viewBindGroups,{meshInstances:tempMeshInstances});tempMeshInstances.length=0;}}}}frameUpdate(){super.frameUpdate();const{camera}=this;this.setClearDepth(camera.clearDepthBuffer?1:undefined);}constructor(device,scene,renderer,camera,depthBuffer,options){super(device);this.viewBindGroups=[];this.velocityTexture=void 0;this.scene=scene;this.renderer=renderer;this.camera=camera;this.setupRenderTarget(depthBuffer,options);}}class RenderPassCameraFrame extends RenderPass{destroy(){if(this._rt){this._rt.destroyTextureBuffers();this._rt.destroy();this._rt=null;}this.beforePasses.forEach(pass=>pass.destroy());this.beforePasses=null;}sanitizeOptions(options){const defaults={camera:null,samples:2,sceneColorMap:true,lastGrabLayerId:LAYERID_SKYBOX,lastGrabLayerIsTransparent:false,lastSceneLayerId:LAYERID_IMMEDIATE,lastSceneLayerIsTransparent:true,taaEnabled:false};return Object.assign({},defaults,options)}set renderTargetScale(value){this._renderTargetScale=value;if(this.scenePass){this.scenePass.options.scaleX=value;this.scenePass.options.scaleY=value;}}get renderTargetScale(){return this._renderTargetScale}set bloomEnabled(value){if(this._bloomEnabled!==value){this._bloomEnabled=value;this.composePass.bloomTexture=value?this.bloomPass.bloomTexture:null;this.bloomPass.enabled=value;}}get bloomEnabled(){return this._bloomEnabled}set lastMipLevel(value){this.bloomPass.lastMipLevel=value;}get lastMipLevel(){return this.bloomPass.lastMipLevel}setupRenderPasses(options){const{app,device}=this;const{scene,renderer}=app;const composition=scene.layers;const cameraComponent=options.camera;const targetRenderTarget=cameraComponent.renderTarget;const format=device.getRenderableHdrFormat()||PIXELFORMAT_RGBA8;const sceneTexture=new Texture(device,{name:"SceneColor",width:4,height:4,format:format,mipmaps:false,minFilter:FILTER_LINEAR,magFilter:FILTER_LINEAR,addressU:ADDRESS_CLAMP_TO_EDGE,addressV:ADDRESS_CLAMP_TO_EDGE});const sceneDepth=new Texture(device,{name:"SceneDepth",width:4,height:4,format:PIXELFORMAT_DEPTH,mipmaps:false,minFilter:FILTER_NEAREST,magFilter:FILTER_NEAREST,addressU:ADDRESS_CLAMP_TO_EDGE,addressV:ADDRESS_CLAMP_TO_EDGE});const rt=new RenderTarget({colorBuffer:sceneTexture,depthBuffer:sceneDepth,samples:options.samples});this._rt=rt;const sceneOptions={resizeSource:targetRenderTarget,scaleX:this.renderTargetScale,scaleY:this.renderTargetScale};if(options.prepassEnabled){this.prePass=new RenderPassPrepass(device,scene,renderer,cameraComponent,sceneDepth,sceneOptions);}this.scenePass=new RenderPassForward(device,composition,scene,renderer);this.scenePass.init(rt,sceneOptions);if(options.prepassEnabled){this.scenePass.noDepthClear=true;this.scenePass.depthStencilOps.storeDepth=true;}const lastLayerId=options.sceneColorMap?options.lastGrabLayerId:options.lastSceneLayerId;const lastLayerIsTransparent=options.sceneColorMap?options.lastGrabLayerIsTransparent:options.lastSceneLayerIsTransparent;let clearRenderTarget=true;let lastAddedIndex=0;lastAddedIndex=this.scenePass.addLayers(composition,cameraComponent,lastAddedIndex,clearRenderTarget,lastLayerId,lastLayerIsTransparent);clearRenderTarget=false;let colorGrabPass;let scenePassTransparent;if(options.sceneColorMap){colorGrabPass=new RenderPassColorGrab(device);colorGrabPass.source=rt;scenePassTransparent=new RenderPassForward(device,composition,scene,renderer);scenePassTransparent.init(rt);lastAddedIndex=scenePassTransparent.addLayers(composition,cameraComponent,lastAddedIndex,clearRenderTarget,options.lastSceneLayerId,options.lastSceneLayerIsTransparent);if(options.prepassEnabled){scenePassTransparent.depthStencilOps.storeDepth=true;}}let sceneTextureWithTaa=sceneTexture;if(options.taaEnabled){this.taaPass=new RenderPassTAA(device,sceneTexture,cameraComponent);sceneTextureWithTaa=this.taaPass.historyTexture;}this.bloomPass=new RenderPassBloom(app.graphicsDevice,sceneTextureWithTaa,format);this.composePass=new RenderPassCompose(app.graphicsDevice);this.composePass.bloomTexture=this.bloomPass.bloomTexture;this.composePass.taaEnabled=options.taaEnabled;this.composePass.init(targetRenderTarget);const afterPass=new RenderPassForward(device,composition,scene,renderer);afterPass.init(targetRenderTarget);afterPass.addLayers(composition,cameraComponent,lastAddedIndex,clearRenderTarget);const allPasses=[this.prePass,this.scenePass,colorGrabPass,scenePassTransparent,this.taaPass,this.bloomPass,this.composePass,afterPass];this.beforePasses=allPasses.filter(element=>element!==undefined);}frameUpdate(){var _this$taaPass$update,_this$taaPass;super.frameUpdate();const sceneTexture=(_this$taaPass$update=(_this$taaPass=this.taaPass)==null?void 0:_this$taaPass.update())!=null?_this$taaPass$update:this._rt.colorBuffer;this.composePass.sceneTexture=sceneTexture;if(this.bloomEnabled){this.bloomPass.sourceTexture=sceneTexture;}}constructor(app,options={}){super(app.graphicsDevice);this.app=void 0;this.prePass=void 0;this.scenePass=void 0;this.composePass=void 0;this.bloomPass=void 0;this.taaPass=void 0;this._bloomEnabled=true;this._renderTargetScale=1;this._rt=null;this.app=app;this.options=this.sanitizeOptions(options);this.setupRenderPasses(this.options);}}const GIZMOSPACE_LOCAL="local";const GIZMOSPACE_WORLD="world";const GIZMOAXIS_X="x";const GIZMOAXIS_Y="y";const GIZMOAXIS_Z="z";const GIZMOAXIS_YZ="yz";const GIZMOAXIS_XZ="xz";const GIZMOAXIS_XY="xy";const GIZMOAXIS_XYZ="xyz";const GIZMOAXIS_FACE="face";const tmpV1$8=new Vec3;const tmpV2$8=new Vec3;const tmpM1$2=new Mat4;const tmpM2=new Mat4;const tmpR1$1=new Ray;const LAYER_NAME="Gizmo";const MIN_SCALE=1e-4;const PERS_SCALE_RATIO=.3;const ORTHO_SCALE_RATIO=.32;const UPDATE_EPSILON$1=1e-6;class Gizmo extends EventHandler{static createLayer(app,layerName=LAYER_NAME,layerIndex){const layer=new Layer({name:layerName,clearDepthBuffer:true,opaqueSortMode:SORTMODE_NONE,transparentSortMode:SORTMODE_NONE});app.scene.layers.insert(layer,layerIndex!=null?layerIndex:app.scene.layers.layerList.length);return layer}get layer(){return this._layer}set coordSpace(value){this._coordSpace=value!=null?value:GIZMOSPACE_WORLD;this._updateRotation();}get coordSpace(){return this._coordSpace}set size(value){this._size=value;this._updateScale();}get size(){return this._size}get facing(){if(this._camera.projection===PROJECTION_PERSPECTIVE){const gizmoPos=this.root.getPosition();const cameraPos=this._camera.entity.getPosition();return tmpV2$8.sub2(cameraPos,gizmoPos).normalize()}return tmpV2$8.copy(this._camera.entity.forward).mulScalar(-1)}_onPointerDown(e){if(!this.root.enabled||document.pointerLockElement){return}const selection=this._getSelection(e.offsetX,e.offsetY);if(selection[0]){e.preventDefault();e.stopPropagation();}const{canvas}=this._device;canvas.setPointerCapture(e.pointerId);this.fire(Gizmo.EVENT_POINTERDOWN,e.offsetX,e.offsetY,selection[0]);}_onPointerMove(e){if(!this.root.enabled||document.pointerLockElement){return}const selection=this._getSelection(e.offsetX,e.offsetY);if(selection[0]){e.preventDefault();e.stopPropagation();}this.fire(Gizmo.EVENT_POINTERMOVE,e.offsetX,e.offsetY,selection[0]);}_onPointerUp(e){if(!this.root.enabled||document.pointerLockElement){return}const selection=this._getSelection(e.offsetX,e.offsetY);if(selection[0]){e.preventDefault();e.stopPropagation();}const{canvas}=this._device;canvas.releasePointerCapture(e.pointerId);this.fire(Gizmo.EVENT_POINTERUP,e.offsetX,e.offsetY,selection[0]);}_updatePosition(){tmpV1$8.set(0,0,0);for(let i=0;i<this.nodes.length;i++){const node=this.nodes[i];tmpV1$8.add(node.getPosition());}tmpV1$8.mulScalar(1/(this.nodes.length||1));if(tmpV1$8.distance(this.root.getPosition())<UPDATE_EPSILON$1){return}this.root.setPosition(tmpV1$8);this.fire(Gizmo.EVENT_POSITIONUPDATE,tmpV1$8);}_updateRotation(){tmpV1$8.set(0,0,0);if(this._coordSpace===GIZMOSPACE_LOCAL&&this.nodes.length!==0){tmpV1$8.copy(this.nodes[this.nodes.length-1].getEulerAngles());}if(tmpV1$8.distance(this.root.getEulerAngles())<UPDATE_EPSILON$1){return}this.root.setEulerAngles(tmpV1$8);this.fire(Gizmo.EVENT_ROTATIONUPDATE,tmpV1$8);}_updateScale(){if(this._camera.projection===PROJECTION_PERSPECTIVE){const gizmoPos=this.root.getPosition();const cameraPos=this._camera.entity.getPosition();const dist=gizmoPos.distance(cameraPos);this._scale=Math.tan(.5*this._camera.fov*math.DEG_TO_RAD)*dist*PERS_SCALE_RATIO;}else {this._scale=this._camera.orthoHeight*ORTHO_SCALE_RATIO;}this._scale=Math.max(this._scale*this._size,MIN_SCALE);if(Math.abs(this._scale-this.root.getLocalScale().x)<UPDATE_EPSILON$1){return}this.root.setLocalScale(this._scale,this._scale,this._scale);this.fire(Gizmo.EVENT_SCALEUPDATE,this._scale);}_getSelection(x,y){const start=this._camera.screenToWorld(x,y,0);const end=this._camera.screenToWorld(x,y,this._camera.farClip-this._camera.nearClip);const dir=tmpV1$8.copy(end).sub(start).normalize();const selection=[];for(let i=0;i<this.intersectShapes.length;i++){const shape=this.intersectShapes[i];if(shape.disabled||!shape.entity.enabled){continue}const parentTM=shape.entity.getWorldTransform();for(let j=0;j<shape.triData.length;j++){const{tris,transform,priority}=shape.triData[j];const triWTM=tmpM1$2.copy(parentTM).mul(transform);const invTriWTM=tmpM2.copy(triWTM).invert();const ray=tmpR1$1;invTriWTM.transformPoint(start,ray.origin);invTriWTM.transformVector(dir,ray.direction);ray.direction.normalize();for(let k=0;k<tris.length;k++){if(tris[k].intersectsRay(ray,tmpV1$8)){selection.push({dist:triWTM.transformPoint(tmpV1$8).sub(start).length(),meshInstances:shape.meshInstances,priority:priority});}}}}if(selection.length){selection.sort((s0,s1)=>{if(s0.priority!==0&&s1.priority!==0){return s1.priority-s0.priority}return s0.dist-s1.dist});return selection[0].meshInstances}return []}attach(nodes=[]){if(Array.isArray(nodes)){if(nodes.length===0){return}this.nodes=nodes;}else {this.nodes=[nodes];}this._updatePosition();this._updateRotation();this._updateScale();this.fire(Gizmo.EVENT_NODESATTACH);this.root.enabled=true;this.fire(Gizmo.EVENT_RENDERUPDATE);}detach(){this.root.enabled=false;this.fire(Gizmo.EVENT_RENDERUPDATE);this.fire(Gizmo.EVENT_NODESDETACH);this.nodes=[];}destroy(){this.detach();this._device.canvas.removeEventListener("pointerdown",this._onPointerDown);this._device.canvas.removeEventListener("pointermove",this._onPointerMove);this._device.canvas.removeEventListener("pointerup",this._onPointerUp);this.root.destroy();}constructor(camera,layer){super();this._size=1;this._scale=1;this._coordSpace=GIZMOSPACE_WORLD;this._app=void 0;this._device=void 0;this._camera=void 0;this._layer=void 0;this.nodes=[];this.root=void 0;this.intersectShapes=[];this._camera=camera;this._app=camera.system.app;this._device=this._app.graphicsDevice;this._layer=layer;camera.layers=camera.layers.concat(layer.id);this.root=new Entity("gizmo");this._app.root.addChild(this.root);this.root.enabled=false;this._updateScale();this._onPointerDown=this._onPointerDown.bind(this);this._onPointerMove=this._onPointerMove.bind(this);this._onPointerUp=this._onPointerUp.bind(this);this._device.canvas.addEventListener("pointerdown",this._onPointerDown);this._device.canvas.addEventListener("pointermove",this._onPointerMove);this._device.canvas.addEventListener("pointerup",this._onPointerUp);this._app.on("update",()=>{this._updatePosition();this._updateRotation();this._updateScale();});this._app.on("destroy",()=>this.destroy());}}Gizmo.EVENT_POINTERDOWN="pointer:down";Gizmo.EVENT_POINTERMOVE="pointer:move";Gizmo.EVENT_POINTERUP="pointer:up";Gizmo.EVENT_POSITIONUPDATE="position:update";Gizmo.EVENT_ROTATIONUPDATE="rotation:update";Gizmo.EVENT_SCALEUPDATE="scale:update";Gizmo.EVENT_NODESATTACH="nodes:attach";Gizmo.EVENT_NODESDETACH="nodes:detach";Gizmo.EVENT_RENDERUPDATE="render:update";const COLOR_RED=Object.freeze(new Color(1,.3,.3));const COLOR_GREEN=Object.freeze(new Color(.3,1,.3));const COLOR_BLUE=Object.freeze(new Color(.3,.3,1));const COLOR_YELLOW=Object.freeze(new Color(1,1,.5));const COLOR_GRAY=Object.freeze(new Color(.5,.5,.5,.5));const color3from4=color=>{return new Color(color.r,color.g,color.b)};const color4from3=(color,a)=>{return new Color(color.r,color.g,color.b,a)};const tmpV1$7=new Vec3;const tmpV2$7=new Vec3;const tmpQ1$5=new Quat;const tmpR1=new Ray;const tmpP1=new Plane;const VEC3_AXES=Object.keys(tmpV1$7);class TransformGizmo extends Gizmo{set shading(value){this._shading=this.root.enabled&&value;for(const name in this._shapes){this._shapes[name].shading=this._shading;}}get shading(){return this._shading}set snap(value){this._snap=this.root.enabled&&value;}get snap(){return this._snap}set xAxisColor(value){this._updateAxisColor(GIZMOAXIS_X,value);}get xAxisColor(){return this._meshColors.axis.x}set yAxisColor(value){this._updateAxisColor(GIZMOAXIS_Y,value);}get yAxisColor(){return this._meshColors.axis.y}set zAxisColor(value){this._updateAxisColor(GIZMOAXIS_Z,value);}get zAxisColor(){return this._meshColors.axis.z}set colorAlpha(value){this._colorAlpha=math.clamp(value,0,1);this._meshColors.axis.x.copy(this._colorSemi(this._meshColors.axis.x));this._meshColors.axis.y.copy(this._colorSemi(this._meshColors.axis.y));this._meshColors.axis.z.copy(this._colorSemi(this._meshColors.axis.z));this._meshColors.axis.xyz.copy(this._colorSemi(this._meshColors.axis.xyz));this._meshColors.axis.f.copy(this._colorSemi(this._meshColors.axis.f));for(const name in this._shapes){this._shapes[name].hover(!!this._hoverAxis);}}get colorAlpha(){return this._colorAlpha}_colorSemi(color){return color4from3(color,this._colorAlpha)}_updateAxisColor(axis,value){const color3=color3from4(value);const color4=this._colorSemi(value);this._guideColors[axis].copy(color3);this._meshColors.axis[axis].copy(color4);this._meshColors.hover[axis].copy(color3);for(const name in this._shapes){this._shapes[name].hover(!!this._hoverAxis);}}_getAxis(meshInstance){if(!meshInstance){return ""}return meshInstance.node.name.split(":")[1]}_getIsPlane(meshInstance){if(!meshInstance){return false}return meshInstance.node.name.indexOf("plane")!==-1}_hover(meshInstance){var _this$_shapeMap$get;if(this._dragging){return}this._hoverAxis=this._getAxis(meshInstance);this._hoverIsPlane=this._getIsPlane(meshInstance);const shape=meshInstance?(_this$_shapeMap$get=this._shapeMap.get(meshInstance))!=null?_this$_shapeMap$get:null:null;if(shape===this._hoverShape){return}if(this._hoverShape){this._hoverShape.hover(false);this._hoverShape=null;}if(shape){shape.hover(true);this._hoverShape=shape;}this.fire(Gizmo.EVENT_RENDERUPDATE);}_createRay(mouseWPos){if(this._camera.projection===PROJECTION_PERSPECTIVE){tmpR1.origin.copy(this._camera.entity.getPosition());tmpR1.direction.sub2(mouseWPos,tmpR1.origin).normalize();return tmpR1}const orthoDepth=this._camera.farClip-this._camera.nearClip;tmpR1.origin.sub2(mouseWPos,tmpV1$7.copy(this._camera.entity.forward).mulScalar(orthoDepth));tmpR1.direction.copy(this._camera.entity.forward);return tmpR1}_createPlane(axis,isFacing,isLine){const facingDir=tmpV1$7.copy(this.facing);const normal=tmpP1.normal.set(0,0,0);if(isFacing){normal.copy(facingDir);}else {normal[axis]=1;this._rootStartRot.transformVector(normal,normal);if(isLine){tmpV2$7.cross(normal,facingDir).normalize();normal.cross(tmpV2$7,normal).normalize();}}return tmpP1.setFromPointNormal(this._rootStartPos,normal)}_dirFromAxis(axis,dir){if(axis===GIZMOAXIS_FACE){dir.copy(this._camera.entity.forward).mulScalar(-1);}else {dir.set(0,0,0);dir[axis]=1;}return dir}_projectToAxis(point,axis){tmpV1$7.set(0,0,0);tmpV1$7[axis]=1;point.copy(tmpV1$7.mulScalar(tmpV1$7.dot(point)));const v=point[axis];point.set(0,0,0);point[axis]=v;}_screenToPoint(x,y,isFacing=false,isLine=false){const mouseWPos=this._camera.screenToWorld(x,y,1);const axis=this._selectedAxis;const ray=this._createRay(mouseWPos);const plane=this._createPlane(axis,isFacing,isLine);const point=new Vec3;plane.intersectsRay(ray,point);return point}_drawGuideLines(){const gizmoPos=this.root.getPosition();const gizmoRot=tmpQ1$5.copy(this.root.getRotation());const checkAxis=this._hoverAxis||this._selectedAxis;const checkIsPlane=this._hoverIsPlane||this._selectedIsPlane;for(let i=0;i<VEC3_AXES.length;i++){const axis=VEC3_AXES[i];if(checkAxis===GIZMOAXIS_XYZ){this._drawSpanLine(gizmoPos,gizmoRot,axis);continue}if(checkIsPlane){if(axis!==checkAxis){this._drawSpanLine(gizmoPos,gizmoRot,axis);}}else {if(axis===checkAxis){this._drawSpanLine(gizmoPos,gizmoRot,axis);}}}}_drawSpanLine(pos,rot,axis){tmpV1$7.set(0,0,0);tmpV1$7[axis]=1;tmpV1$7.mulScalar(this._camera.farClip-this._camera.nearClip);tmpV2$7.copy(tmpV1$7).mulScalar(-1);rot.transformVector(tmpV1$7,tmpV1$7);rot.transformVector(tmpV2$7,tmpV2$7);this._app.drawLine(tmpV1$7.add(pos),tmpV2$7.add(pos),this._guideColors[axis],true);}_createTransform(){for(const key in this._shapes){const shape=this._shapes[key];this.root.addChild(shape.entity);this.intersectShapes.push(shape);for(let i=0;i<shape.meshInstances.length;i++){this._shapeMap.set(shape.meshInstances[i],shape);}}}enableShape(shapeAxis,enabled){if(!this._shapes.hasOwnProperty(shapeAxis)){return}this._shapes[shapeAxis].disabled=!enabled;}isShapeEnabled(shapeAxis){if(!this._shapes.hasOwnProperty(shapeAxis)){return false}return !this._shapes[shapeAxis].disabled}destroy(){super.destroy();for(const key in this._shapes){this._shapes[key].destroy();}}constructor(camera,layer){super(camera,layer);this._colorAlpha=.6;this._meshColors={axis:{x:this._colorSemi(COLOR_RED),y:this._colorSemi(COLOR_GREEN),z:this._colorSemi(COLOR_BLUE),xyz:this._colorSemi(Color.WHITE),f:this._colorSemi(Color.WHITE)},hover:{x:COLOR_RED.clone(),y:COLOR_GREEN.clone(),z:COLOR_BLUE.clone(),xyz:Color.WHITE.clone(),f:COLOR_YELLOW.clone()},disabled:COLOR_GRAY.clone()};this._guideColors={x:COLOR_RED.clone(),y:COLOR_GREEN.clone(),z:COLOR_BLUE.clone(),f:COLOR_YELLOW.clone()};this._rootStartPos=new Vec3;this._rootStartRot=new Quat;this._shading=false;this._shapes={};this._shapeMap=new Map;this._hoverShape=null;this._hoverAxis="";this._hoverIsPlane=false;this._noSelection=false;this._selectedAxis="";this._selectedIsPlane=false;this._selectionStartPoint=new Vec3;this._dragging=false;this._snap=false;this.snapIncrement=1;this._app.on("prerender",()=>{if(!this.root.enabled){return}this._drawGuideLines();});this.on(Gizmo.EVENT_POINTERDOWN,(x,y,meshInstance)=>{const shape=this._shapeMap.get(meshInstance);if(shape!=null&&shape.disabled){return}if(this._dragging){return}if(!meshInstance){this._noSelection=true;return}this._selectedAxis=this._getAxis(meshInstance);this._selectedIsPlane=this._getIsPlane(meshInstance);this._rootStartPos.copy(this.root.getPosition());this._rootStartRot.copy(this.root.getRotation());const point=this._screenToPoint(x,y);this._selectionStartPoint.copy(point);this._dragging=true;this.fire(TransformGizmo.EVENT_TRANSFORMSTART,point,x,y);});this.on(Gizmo.EVENT_POINTERMOVE,(x,y,meshInstance)=>{const shape=this._shapeMap.get(meshInstance);if(shape!=null&&shape.disabled){return}if(!this._noSelection){this._hover(meshInstance);}if(!this._dragging){return}const point=this._screenToPoint(x,y);this.fire(TransformGizmo.EVENT_TRANSFORMMOVE,point,x,y);this._hoverAxis="";this._hoverIsPlane=false;});this.on(Gizmo.EVENT_POINTERUP,(x,y,meshInstance)=>{this._noSelection=false;this._hover(meshInstance);if(!this._dragging){return}this._dragging=false;this.fire(TransformGizmo.EVENT_TRANSFORMEND);this._selectedAxis="";this._selectedIsPlane=false;});this.on(Gizmo.EVENT_NODESDETACH,()=>{this.snap=false;this._hoverAxis="";this._hoverIsPlane=false;this._hover();this.fire(Gizmo.EVENT_POINTERUP);});}}TransformGizmo.EVENT_TRANSFORMSTART="transform:start";TransformGizmo.EVENT_TRANSFORMMOVE="transform:move";TransformGizmo.EVENT_TRANSFORMEND="transform:end";const tmpV1$6=new Vec3;const tmpV2$6=new Vec3;const tmpV3$3=new Vec3;class TriData{get transform(){return this._transform}get priority(){return this._priority}setTransform(pos=new Vec3,rot=new Quat,scale=new Vec3){this.transform.setTRS(pos,rot,scale);}fromGeometry(geometry){var _geometry$positions,_geometry$indices;if(!geometry||!(geometry instanceof Geometry)){throw new Error("No geometry provided.")}const positions=(_geometry$positions=geometry.positions)!=null?_geometry$positions:[];const indices=(_geometry$indices=geometry.indices)!=null?_geometry$indices:[];this.tris=[];for(let k=0;k<indices.length;k+=3){const i1=indices[k];const i2=indices[k+1];const i3=indices[k+2];tmpV1$6.set(positions[i1*3],positions[i1*3+1],positions[i1*3+2]);tmpV2$6.set(positions[i2*3],positions[i2*3+1],positions[i2*3+2]);tmpV3$3.set(positions[i3*3],positions[i3*3+1],positions[i3*3+2]);const tri=new Tri(tmpV1$6,tmpV2$6,tmpV3$3);this.tris.push(tri);}}constructor(geometry,priority=0){this._priority=0;this._transform=new Mat4;this.tris=[];this.fromGeometry(geometry);this._priority=priority;}}const SHADING_DAMP_SCALE=.25;const SHADING_DAMP_OFFSET=.75;const LIGHT_DIR=new Vec3(1,2,3);const GEOMETRIES={box:BoxGeometry,cone:ConeGeometry,cylinder:CylinderGeometry,plane:PlaneGeometry,sphere:SphereGeometry,torus:TorusGeometry};const shaderDesc={uniqueName:"axis-shape",attributes:{vertex_position:SEMANTIC_POSITION,vertex_color:SEMANTIC_COLOR},vertexCode:`
		attribute vec3 vertex_position;
		attribute vec4 vertex_color;
		varying vec4 vColor;
		uniform mat4 matrix_model;
		uniform mat4 matrix_viewProjection;
		void main(void) {
			gl_Position = matrix_viewProjection * matrix_model * vec4(vertex_position, 1.0);
			gl_Position.z = clamp(gl_Position.z, -abs(gl_Position.w), abs(gl_Position.w));
			vColor = vertex_color;
		}
	`,fragmentCode:`
		precision highp float;
		varying vec4 vColor;
		void main(void) {
			gl_FragColor = vColor;
		}
	`};const shadingMeshMap=new Map;const tmpV1$5=new Vec3;const tmpV2$5=new Vec3;const tmpM1$1=new Mat4;const tmpG=new Geometry;tmpG.positions=[];tmpG.normals=[];const applyShadowColor=(geom,color,transform)=>{if(!geom.normals||!geom.positions){return []}let localLightDir;if(transform){localLightDir=tmpM1$1.copy(transform).invert().transformVector(tmpV1$5.copy(LIGHT_DIR),tmpV1$5).normalize();}geom.colors=[];const shading=[];const numVertices=geom.positions.length/3;for(let i=0;i<numVertices;i++){let strength=1;if(localLightDir){const x=geom.normals[i*3];const y=geom.normals[i*3+1];const z=geom.normals[i*3+2];const normal=tmpV2$5.set(x,y,z);const dot=localLightDir.dot(normal);strength=dot*SHADING_DAMP_SCALE+SHADING_DAMP_OFFSET;}shading.push(strength);geom.colors.push(strength*color.r*255,strength*color.g*255,strength*color.b*255,color.a*255);}return shading};const setMeshColor=(mesh,color)=>{const shading=shadingMeshMap.get(mesh);const colors=[];for(let i=0;i<shading.length;i++){colors.push(shading[i]*color.r*255,shading[i]*color.g*255,shading[i]*color.b*255,color.a*255);}mesh.setColors32(colors);mesh.update();};class Shape{set disabled(value){for(let i=0;i<this.meshInstances.length;i++){setMeshColor(this.meshInstances[i].mesh,value?this._disabledColor:this._defaultColor);}this._disabled=value!=null?value:false;}get disabled(){return this._disabled}set shading(value){this._shading=value!=null?value:true;const color=this._disabled?this._disabledColor:this._defaultColor;for(let i=0;i<this.meshInstances.length;i++){const mesh=this.meshInstances[i].mesh;mesh.getPositions(tmpG.positions);mesh.getNormals(tmpG.normals);const shadow=applyShadowColor(tmpG,color,this._shading?this.entity.getWorldTransform():undefined);shadingMeshMap.set(mesh,shadow);setMeshColor(mesh,color);}}get shading(){return this._shading}_createRoot(name){this.entity=new Entity(`${name}:${this.axis}`);this.entity.setLocalPosition(this._position);this.entity.setLocalEulerAngles(this._rotation);this.entity.setLocalScale(this._scale);}_createMesh(geom,shading=true){const color=this._disabled?this._disabledColor:this._defaultColor;const shadow=applyShadowColor(geom,color,shading?this.entity.getWorldTransform():undefined);const mesh=Mesh.fromGeometry(this.device,geom);shadingMeshMap.set(mesh,shadow);return mesh}_createRenderComponent(entity,meshes){const shader=createShaderFromCode(this.device,shaderDesc.vertexCode,shaderDesc.fragmentCode,shaderDesc.uniqueName,{vertex_position:SEMANTIC_POSITION,vertex_color:SEMANTIC_COLOR});const material=new Material;material.shader=shader;material.cull=this._cull;material.blendType=BLEND_NORMAL;if(material.chunks){material.chunks.debugOutputPS="";}material.update();const meshInstances=[];for(let i=0;i<meshes.length;i++){const mi=new MeshInstance(meshes[i],material);mi.cull=false;meshInstances.push(mi);this.meshInstances.push(mi);}entity.addComponent("render",{meshInstances:meshInstances,layers:this._layers,castShadows:false});}_addRenderMesh(entity,type,shading){const Geometry=GEOMETRIES[type];if(!Geometry){throw new Error("Invalid primitive type.")}this._createRenderComponent(entity,[this._createMesh(new Geometry,shading)]);}hover(state){if(this._disabled){return}for(let i=0;i<this.meshInstances.length;i++){const color=state?this._hoverColor:this._defaultColor;const mesh=this.meshInstances[i].mesh;setMeshColor(mesh,color);}}destroy(){this.entity.destroy();}constructor(device,options){var _options$axis,_options$position,_options$rotation,_options$scale,_options$disabled,_options$layers,_options$shading;this._position=void 0;this._rotation=void 0;this._scale=void 0;this._layers=[];this._shading=true;this._disabled=void 0;this._defaultColor=Color.WHITE;this._hoverColor=Color.BLACK;this._disabledColor=COLOR_GRAY;this._cull=CULLFACE_BACK;this.device=void 0;this.axis=void 0;this.entity=void 0;this.triData=[];this.meshInstances=[];this.device=device;this.axis=(_options$axis=options.axis)!=null?_options$axis:"x";this._position=(_options$position=options.position)!=null?_options$position:new Vec3;this._rotation=(_options$rotation=options.rotation)!=null?_options$rotation:new Vec3;this._scale=(_options$scale=options.scale)!=null?_options$scale:new Vec3(1,1,1);this._disabled=(_options$disabled=options.disabled)!=null?_options$disabled:false;this._layers=(_options$layers=options.layers)!=null?_options$layers:this._layers;this._shading=(_options$shading=options.shading)!=null?_options$shading:this._shading;if(options.defaultColor instanceof Color){this._defaultColor=options.defaultColor;}if(options.hoverColor instanceof Color){this._hoverColor=options.hoverColor;}if(options.disabledColor instanceof Color){this._disabledColor=options.disabledColor;}}}const UPDATE_EPSILON=1e-6;class PlaneShape extends Shape{set size(value){this._size=value!=null?value:1;this._updateTransform();}get size(){return this._size}set gap(value){this._gap=value!=null?value:0;this._updateTransform();}get gap(){return this._gap}set flipped(value){if(this._flipped.distance(value)<UPDATE_EPSILON){return}this._flipped.copy(value);this.entity.setLocalPosition(this._getPosition());}get flipped(){return this._flipped}_getPosition(){const offset=this._size/2+this._gap;const position=new Vec3(this._flipped.x?-offset:offset,this._flipped.y?-offset:offset,this._flipped.z?-offset:offset);position[this.axis]=0;return position}_createPlane(){this._createRoot("plane");this._updateTransform();this._addRenderMesh(this.entity,"plane",this._shading);}_updateTransform(){this.entity.setLocalPosition(this._getPosition());this.entity.setLocalEulerAngles(this._rotation);this.entity.setLocalScale(this._size,this._size,this._size);}constructor(device,options={}){super(device,options);this._cull=CULLFACE_NONE;this._size=.2;this._gap=.1;this._flipped=new Vec3;this.triData=[new TriData(new PlaneGeometry)];this._createPlane();}}const tmpV1$4=new Vec3;const tmpV2$4=new Vec3;const tmpQ1$4=new Quat;class ArrowShape extends Shape{set gap(value){this._gap=value!=null?value:0;this._updateHead();this._updateLine();}get gap(){return this._gap}set lineThickness(value){this._lineThickness=value!=null?value:1;this._updateHead();this._updateLine();}get lineThickness(){return this._lineThickness}set lineLength(value){this._lineLength=value!=null?value:1;this._updateHead();this._updateLine();}get lineLength(){return this._lineLength}set arrowThickness(value){this._arrowThickness=value!=null?value:1;this._updateHead();}get arrowThickness(){return this._arrowThickness}set arrowLength(value){this._arrowLength=value!=null?value:1;this._updateHead();}get arrowLength(){return this._arrowLength}set tolerance(value){this._tolerance=value;this._updateLine();}get tolerance(){return this._tolerance}set flipped(value){if(this._flipped===value){return}this._flipped=value;if(this._rotation.equals(Vec3.ZERO)){tmpV1$4.set(0,0,this._flipped?180:0);}else {tmpV1$4.copy(this._rotation).mulScalar(this._flipped?-1:1);}this._line.enabled=!this._flipped;this.entity.setLocalEulerAngles(tmpV1$4);}get flipped(){return this._flipped}_createArrow(){this._createRoot("arrow");this._head=new Entity(`head:${this.axis}`);this.entity.addChild(this._head);this._updateHead();this._addRenderMesh(this._head,"cone",this._shading);this._line=new Entity(`line:${this.axis}`);this.entity.addChild(this._line);this._updateLine();this._addRenderMesh(this._line,"cylinder",this._shading);}_updateHead(){tmpV1$4.set(0,this._gap+this._arrowLength*.5+this._lineLength,0);tmpQ1$4.set(0,0,0,1);tmpV2$4.set(this._arrowThickness,this._arrowLength,this._arrowThickness);this.triData[0].setTransform(tmpV1$4,tmpQ1$4,tmpV2$4);this._head.setLocalPosition(0,this._gap+this._arrowLength*.5+this._lineLength,0);this._head.setLocalScale(this._arrowThickness,this._arrowLength,this._arrowThickness);}_updateLine(){tmpV1$4.set(0,this._gap+this._lineLength*.5,0);tmpQ1$4.set(0,0,0,1);tmpV2$4.set(this._lineThickness+this._tolerance,this._lineLength,this._lineThickness+this._tolerance);this.triData[1].setTransform(tmpV1$4,tmpQ1$4,tmpV2$4);this._line.setLocalPosition(0,this._gap+this._lineLength*.5,0);this._line.setLocalScale(this._lineThickness,this._lineLength,this._lineThickness);}constructor(device,options={}){super(device,options);this._gap=0;this._lineThickness=.02;this._lineLength=.5;this._arrowThickness=.12;this._arrowLength=.18;this._tolerance=.1;this._head=void 0;this._line=void 0;this._flipped=false;this.triData=[new TriData(new ConeGeometry),new TriData(new CylinderGeometry,1)];this._createArrow();}}class SphereShape extends Shape{_createCenter(){this._createRoot("sphereCenter");this._updateTransform();this._addRenderMesh(this.entity,"sphere",this._shading);}set size(value){this._size=value!=null?value:1;this._updateTransform();}get size(){return this._size}set tolerance(value){this._tolerance=value;this._updateTransform();}get tolerance(){return this._tolerance}_updateTransform(){this.entity.setLocalScale(this._size,this._size,this._size);}constructor(device,options={}){super(device,options);this._size=.12;this._tolerance=.05;this.triData=[new TriData(new SphereGeometry,2)];this._createCenter();}}const tmpV1$3=new Vec3;const tmpV2$3=new Vec3;const tmpV3$2=new Vec3;const tmpQ1$3=new Quat;const GLANCE_EPSILON$1=.98;class TranslateGizmo extends TransformGizmo{set axisGap(value){this._setArrowProp("gap",value);}get axisGap(){return this._shapes.x.gap}set axisLineThickness(value){this._setArrowProp("lineThickness",value);}get axisLineThickness(){return this._shapes.x.lineThickness}set axisLineLength(value){this._setArrowProp("lineLength",value);}get axisLineLength(){return this._shapes.x.lineLength}set axisLineTolerance(value){this._setArrowProp("tolerance",value);}get axisLineTolerance(){return this._shapes.x.tolerance}set axisArrowThickness(value){this._setArrowProp("arrowThickness",value);}get axisArrowThickness(){return this._shapes.x.arrowThickness}set axisArrowLength(value){this._setArrowProp("arrowLength",value);}get axisArrowLength(){return this._shapes.x.arrowLength}set axisPlaneSize(value){this._setPlaneProp("size",value);}get axisPlaneSize(){return this._shapes.yz.size}set axisPlaneGap(value){this._setPlaneProp("gap",value);}get axisPlaneGap(){return this._shapes.yz.gap}set axisCenterSize(value){this._shapes.face.size=value;}get axisCenterSize(){return this._shapes.face.size}set axisCenterTolerance(value){this._shapes.face.tolerance=value;}get axisCenterTolerance(){return this._shapes.face.tolerance}_setArrowProp(prop,value){this._shapes.x[prop]=value;this._shapes.y[prop]=value;this._shapes.z[prop]=value;}_setPlaneProp(prop,value){this._shapes.yz[prop]=value;this._shapes.xz[prop]=value;this._shapes.xy[prop]=value;}_shapesLookAtCamera(){const facingDir=this.facing;let dot=facingDir.dot(this.root.right);this._shapes.x.entity.enabled=Math.abs(dot)<GLANCE_EPSILON$1;if(this.flipShapes){this._shapes.x.flipped=dot<0;}dot=facingDir.dot(this.root.up);this._shapes.y.entity.enabled=Math.abs(dot)<GLANCE_EPSILON$1;if(this.flipShapes){this._shapes.y.flipped=dot<0;}dot=facingDir.dot(this.root.forward);this._shapes.z.entity.enabled=Math.abs(dot)<GLANCE_EPSILON$1;if(this.flipShapes){this._shapes.z.flipped=dot>0;}tmpV1$3.cross(facingDir,this.root.right);this._shapes.yz.entity.enabled=tmpV1$3.length()<GLANCE_EPSILON$1;if(this.flipShapes){this._shapes.yz.flipped=tmpV2$3.set(0,+(tmpV1$3.dot(this.root.forward)<0),+(tmpV1$3.dot(this.root.up)<0));}tmpV1$3.cross(facingDir,this.root.forward);this._shapes.xy.entity.enabled=tmpV1$3.length()<GLANCE_EPSILON$1;if(this.flipShapes){this._shapes.xy.flipped=tmpV2$3.set(+(tmpV1$3.dot(this.root.up)<0),+(tmpV1$3.dot(this.root.right)>0),0);}tmpV1$3.cross(facingDir,this.root.up);this._shapes.xz.entity.enabled=tmpV1$3.length()<GLANCE_EPSILON$1;if(this.flipShapes){this._shapes.xz.flipped=tmpV2$3.set(+(tmpV1$3.dot(this.root.forward)>0),0,+(tmpV1$3.dot(this.root.right)>0));}}_storeNodePositions(){for(let i=0;i<this.nodes.length;i++){const node=this.nodes[i];this._nodeLocalPositions.set(node,node.getLocalPosition().clone());this._nodePositions.set(node,node.getPosition().clone());}}_setNodePositions(pointDelta){for(let i=0;i<this.nodes.length;i++){const node=this.nodes[i];if(this._coordSpace===GIZMOSPACE_LOCAL){var _node$parent;const pos=this._nodeLocalPositions.get(node);if(!pos){continue}tmpV1$3.copy(pointDelta);(_node$parent=node.parent)==null||_node$parent.getWorldTransform().getScale(tmpV2$3);tmpV2$3.x=1/tmpV2$3.x;tmpV2$3.y=1/tmpV2$3.y;tmpV2$3.z=1/tmpV2$3.z;tmpQ1$3.copy(node.getLocalRotation()).transformVector(tmpV1$3,tmpV1$3);tmpV1$3.mul(tmpV2$3);node.setLocalPosition(tmpV1$3.add(pos));}else {const pos=this._nodePositions.get(node);if(!pos){continue}node.setPosition(tmpV1$3.copy(pointDelta).add(pos));}}this._updatePosition();}_screenToPoint(x,y){const mouseWPos=this._camera.screenToWorld(x,y,1);const axis=this._selectedAxis;const isPlane=this._selectedIsPlane;const ray=this._createRay(mouseWPos);const plane=this._createPlane(axis,axis===GIZMOAXIS_FACE,!isPlane);const point=new Vec3;plane.intersectsRay(ray,point);tmpQ1$3.copy(this._rootStartRot).invert().transformVector(point,point);if(!isPlane&&axis!==GIZMOAXIS_FACE){this._projectToAxis(point,axis);}return point}constructor(camera,layer){super(camera,layer);this._shapes={face:new SphereShape(this._device,{axis:GIZMOAXIS_FACE,layers:[this._layer.id],shading:this._shading,defaultColor:this._meshColors.axis.xyz,hoverColor:this._meshColors.hover.xyz}),yz:new PlaneShape(this._device,{axis:GIZMOAXIS_X,layers:[this._layer.id],shading:this._shading,rotation:new Vec3(0,0,-90),defaultColor:this._meshColors.axis.x,hoverColor:this._meshColors.hover.x}),xz:new PlaneShape(this._device,{axis:GIZMOAXIS_Y,layers:[this._layer.id],shading:this._shading,rotation:new Vec3(0,0,0),defaultColor:this._meshColors.axis.y,hoverColor:this._meshColors.hover.y}),xy:new PlaneShape(this._device,{axis:GIZMOAXIS_Z,layers:[this._layer.id],shading:this._shading,rotation:new Vec3(90,0,0),defaultColor:this._meshColors.axis.z,hoverColor:this._meshColors.hover.z}),x:new ArrowShape(this._device,{axis:GIZMOAXIS_X,layers:[this._layer.id],shading:this._shading,rotation:new Vec3(0,0,-90),defaultColor:this._meshColors.axis.x,hoverColor:this._meshColors.hover.x}),y:new ArrowShape(this._device,{axis:GIZMOAXIS_Y,layers:[this._layer.id],shading:this._shading,rotation:new Vec3(0,0,0),defaultColor:this._meshColors.axis.y,hoverColor:this._meshColors.hover.y}),z:new ArrowShape(this._device,{axis:GIZMOAXIS_Z,layers:[this._layer.id],shading:this._shading,rotation:new Vec3(90,0,0),defaultColor:this._meshColors.axis.z,hoverColor:this._meshColors.hover.z})};this._nodeLocalPositions=new Map;this._nodePositions=new Map;this._forward=new Vec3;this.snapIncrement=1;this.flipShapes=true;this._createTransform();this.on(TransformGizmo.EVENT_TRANSFORMSTART,()=>{this._storeNodePositions();});this.on(TransformGizmo.EVENT_TRANSFORMMOVE,point=>{const pointDelta=tmpV3$2.copy(point).sub(this._selectionStartPoint);if(this.snap){pointDelta.mulScalar(1/this.snapIncrement);pointDelta.round();pointDelta.mulScalar(this.snapIncrement);}this._setNodePositions(pointDelta);});this.on(TransformGizmo.EVENT_NODESDETACH,()=>{this._nodeLocalPositions.clear();this._nodePositions.clear();});this._app.on("prerender",()=>{this._shapesLookAtCamera();});}}const TORUS_RENDER_SEGMENTS=80;const TORUS_INTERSECT_SEGMENTS=20;class ArcShape extends Shape{_createTorusGeometry(){return new TorusGeometry({tubeRadius:this._tubeRadius+this._tolerance,ringRadius:this._ringRadius,sectorAngle:this._sectorAngle,segments:TORUS_INTERSECT_SEGMENTS})}_createTorusMesh(sectorAngle){const geom=new TorusGeometry({tubeRadius:this._tubeRadius,ringRadius:this._ringRadius,sectorAngle:sectorAngle,segments:TORUS_RENDER_SEGMENTS});return this._createMesh(geom,this._shading)}_createDisk(){this._createRoot("disk");this._createRenderComponent(this.entity,[this._createTorusMesh(this._sectorAngle),this._createTorusMesh(360)]);this.drag(false);}set tubeRadius(value){this._tubeRadius=value!=null?value:.1;this._updateTransform();}get tubeRadius(){return this._tubeRadius}set ringRadius(value){this._ringRadius=value!=null?value:.1;this._updateTransform();}get ringRadius(){return this._ringRadius}set tolerance(value){this._tolerance=value;this._updateTransform();}get tolerance(){return this._tolerance}_updateTransform(){this.triData[0].fromGeometry(this._createTorusGeometry());this.meshInstances[0].mesh=this._createTorusMesh(this._sectorAngle);this.meshInstances[1].mesh=this._createTorusMesh(360);}drag(state){this.meshInstances[0].visible=!state;this.meshInstances[1].visible=state;}hide(state){if(state){this.meshInstances[0].visible=false;this.meshInstances[1].visible=false;return}this.drag(false);}constructor(device,options={}){var _options$tubeRadius,_options$ringRadius,_options$sectorAngle;super(device,options);this._tubeRadius=.01;this._ringRadius=.5;this._sectorAngle=void 0;this._lightDir=void 0;this._tolerance=.05;this._tubeRadius=(_options$tubeRadius=options.tubeRadius)!=null?_options$tubeRadius:this._tubeRadius;this._ringRadius=(_options$ringRadius=options.ringRadius)!=null?_options$ringRadius:this._ringRadius;this._sectorAngle=(_options$sectorAngle=options.sectorAngle)!=null?_options$sectorAngle:this._sectorAngle;this.triData=[new TriData(this._createTorusGeometry())];this._createDisk();}}const tmpV1$2=new Vec3;const tmpV2$2=new Vec3;const tmpV3$1=new Vec3;const tmpV4=new Vec3;const tmpM1=new Mat4;const tmpQ1$2=new Quat;const tmpQ2=new Quat;const FACING_THRESHOLD=.9;const GUIDE_ANGLE_COLOR=new Color(0,0,0,.3);class RotateGizmo extends TransformGizmo{set xyzTubeRadius(value){this._setDiskProp("tubeRadius",value);}get xyzTubeRadius(){return this._shapes.x.tubeRadius}set xyzRingRadius(value){this._setDiskProp("ringRadius",value);}get xyzRingRadius(){return this._shapes.x.ringRadius}set faceTubeRadius(value){this._shapes.face.tubeRadius=value;}get faceTubeRadius(){return this._shapes.face.tubeRadius}set faceRingRadius(value){this._shapes.face.ringRadius=value;}get faceRingRadius(){return this._shapes.face.ringRadius}set ringTolerance(value){this._setDiskProp("tolerance",value);this._shapes.face.tolerance=value;}get ringTolerance(){return this._shapes.x.tolerance}_setDiskProp(prop,value){this._shapes.x[prop]=value;this._shapes.y[prop]=value;this._shapes.z[prop]=value;}_storeGuidePoints(){const gizmoPos=this.root.getPosition();const axis=this._selectedAxis;const isFacing=axis===GIZMOAXIS_FACE;const scale=isFacing?this.faceRingRadius:this.xyzRingRadius;this._guideAngleStart.copy(this._selectionStartPoint).sub(gizmoPos).normalize();this._guideAngleStart.mulScalar(scale);this._guideAngleEnd.copy(this._guideAngleStart);}_updateGuidePoints(angleDelta){const axis=this._selectedAxis;const isFacing=axis===GIZMOAXIS_FACE;if(isFacing){tmpV1$2.copy(this.facing);}else {tmpV1$2.set(0,0,0);tmpV1$2[axis]=1;this._rootStartRot.transformVector(tmpV1$2,tmpV1$2);}tmpQ1$2.setFromAxisAngle(tmpV1$2,angleDelta);tmpQ1$2.transformVector(this._guideAngleStart,this._guideAngleEnd);}_drawGuideAngleLine(pos,axis,point,color=this._guideColors[axis]){tmpV1$2.set(0,0,0);tmpV2$2.copy(point).mulScalar(this._scale);this._app.drawLine(tmpV1$2.add(pos),tmpV2$2.add(pos),color,false,this._layer);}_getLookAtEulerAngles(position){tmpV1$2.set(0,0,0);tmpM1.setLookAt(tmpV1$2,position,Vec3.UP);tmpQ1$2.setFromMat4(tmpM1);tmpQ1$2.getEulerAngles(tmpV1$2);tmpV1$2.x+=90;return tmpV1$2}_shapesLookAtCamera(){if(this._camera.projection===PROJECTION_PERSPECTIVE){this._shapes.face.entity.lookAt(this._camera.entity.getPosition());this._shapes.face.entity.rotateLocal(90,0,0);}else {tmpQ1$2.copy(this._camera.entity.getRotation()).getEulerAngles(tmpV1$2);this._shapes.face.entity.setEulerAngles(tmpV1$2);this._shapes.face.entity.rotateLocal(-90,0,0);}const facingDir=tmpV1$2.copy(this.facing);tmpQ1$2.copy(this.root.getRotation()).invert().transformVector(facingDir,facingDir);let angle=Math.atan2(facingDir.z,facingDir.y)*math.RAD_TO_DEG;this._shapes.x.entity.setLocalEulerAngles(0,angle-90,-90);angle=Math.atan2(facingDir.x,facingDir.z)*math.RAD_TO_DEG;this._shapes.y.entity.setLocalEulerAngles(0,angle,0);angle=Math.atan2(facingDir.y,facingDir.x)*math.RAD_TO_DEG;this._shapes.z.entity.setLocalEulerAngles(90,0,angle+90);}_drag(state){for(const axis in this._shapes){const shape=this._shapes[axis];if(axis===this._selectedAxis){shape.drag(state);}else {shape.hide(state);}}this.fire(TransformGizmo.EVENT_RENDERUPDATE);}_storeNodeRotations(){const gizmoPos=this.root.getPosition();for(let i=0;i<this.nodes.length;i++){const node=this.nodes[i];this._nodeLocalRotations.set(node,node.getLocalRotation().clone());this._nodeRotations.set(node,node.getRotation().clone());this._nodeOffsets.set(node,node.getPosition().clone().sub(gizmoPos));}}_setNodeRotations(axis,angleDelta){const gizmoPos=this.root.getPosition();const isFacing=axis===GIZMOAXIS_FACE;tmpQ1$2.setFromAxisAngle(this._dirFromAxis(axis,tmpV1$2),angleDelta);for(let i=0;i<this.nodes.length;i++){const node=this.nodes[i];if(!isFacing&&this._coordSpace===GIZMOSPACE_LOCAL){const rot=this._nodeLocalRotations.get(node);if(!rot){continue}tmpQ2.copy(rot).mul(tmpQ1$2);node.setLocalRotation(tmpQ2);}else {const rot=this._nodeRotations.get(node);if(!rot){continue}const offset=this._nodeOffsets.get(node);if(!offset){continue}tmpV1$2.copy(offset);tmpQ1$2.transformVector(tmpV1$2,tmpV1$2);tmpQ2.copy(tmpQ1$2).mul(rot);node.setEulerAngles(tmpQ2.getEulerAngles());node.setPosition(tmpV1$2.add(gizmoPos));}}if(this._coordSpace===GIZMOSPACE_LOCAL){this._updateRotation();}}_screenToPoint(x,y){const mouseWPos=this._camera.screenToWorld(x,y,1);const axis=this._selectedAxis;const ray=this._createRay(mouseWPos);const plane=this._createPlane(axis,axis===GIZMOAXIS_FACE,false);const point=new Vec3;plane.intersectsRay(ray,point);return point}_calculateAngle(point,x,y){const gizmoPos=this.root.getPosition();const axis=this._selectedAxis;const plane=this._createPlane(axis,axis===GIZMOAXIS_FACE,false);let angle=0;const facingDir=tmpV2$2.copy(this.facing);const facingDot=plane.normal.dot(facingDir);if(this.orbitRotation||Math.abs(facingDot)>FACING_THRESHOLD){tmpV1$2.sub2(point,gizmoPos);tmpQ1$2.copy(this._camera.entity.getRotation()).invert().transformVector(tmpV1$2,tmpV1$2);angle=Math.sign(facingDot)*Math.atan2(tmpV1$2.y,tmpV1$2.x)*math.RAD_TO_DEG;}else {tmpV1$2.copy(gizmoPos);tmpV2$2.cross(plane.normal,facingDir).normalize().add(gizmoPos);this._camera.worldToScreen(tmpV1$2,tmpV3$1);this._camera.worldToScreen(tmpV2$2,tmpV4);tmpV1$2.sub2(tmpV4,tmpV3$1).normalize();tmpV2$2.set(x,y,0);angle=tmpV1$2.dot(tmpV2$2);}return angle}constructor(camera,layer){super(camera,layer);this._shapes={z:new ArcShape(this._device,{axis:GIZMOAXIS_Z,layers:[this._layer.id],shading:this._shading,rotation:new Vec3(90,0,90),defaultColor:this._meshColors.axis.z,hoverColor:this._meshColors.hover.z,sectorAngle:180}),x:new ArcShape(this._device,{axis:GIZMOAXIS_X,layers:[this._layer.id],shading:this._shading,rotation:new Vec3(0,0,-90),defaultColor:this._meshColors.axis.x,hoverColor:this._meshColors.hover.x,sectorAngle:180}),y:new ArcShape(this._device,{axis:GIZMOAXIS_Y,layers:[this._layer.id],shading:this._shading,rotation:new Vec3(0,0,0),defaultColor:this._meshColors.axis.y,hoverColor:this._meshColors.hover.y,sectorAngle:180}),face:new ArcShape(this._device,{axis:GIZMOAXIS_FACE,layers:[this._layer.id],shading:this._shading,rotation:this._getLookAtEulerAngles(this._camera.entity.getPosition()),defaultColor:this._meshColors.axis.f,hoverColor:this._meshColors.hover.f,ringRadius:.55})};this._selectionStartAngle=0;this._nodeLocalRotations=new Map;this._nodeRotations=new Map;this._nodeOffsets=new Map;this._guideAngleStartColor=GUIDE_ANGLE_COLOR.clone();this._guideAngleStart=new Vec3;this._guideAngleEnd=new Vec3;this.snapIncrement=5;this.orbitRotation=false;this._createTransform();this.on(TransformGizmo.EVENT_TRANSFORMSTART,(point,x,y)=>{this._selectionStartAngle=this._calculateAngle(point,x,y);this._storeNodeRotations();this._storeGuidePoints();this._drag(true);});this.on(TransformGizmo.EVENT_TRANSFORMMOVE,(point,x,y)=>{const axis=this._selectedAxis;let angleDelta=this._calculateAngle(point,x,y)-this._selectionStartAngle;if(this.snap){angleDelta=Math.round(angleDelta/this.snapIncrement)*this.snapIncrement;}this._setNodeRotations(axis,angleDelta);this._updateGuidePoints(angleDelta);});this.on(TransformGizmo.EVENT_TRANSFORMEND,()=>{this._drag(false);});this.on(TransformGizmo.EVENT_NODESDETACH,()=>{this._nodeLocalRotations.clear();this._nodeRotations.clear();this._nodeOffsets.clear();});this._app.on("prerender",()=>{this._shapesLookAtCamera();if(this._dragging){const gizmoPos=this.root.getPosition();this._drawGuideAngleLine(gizmoPos,this._selectedAxis,this._guideAngleStart,this._guideAngleStartColor);this._drawGuideAngleLine(gizmoPos,this._selectedAxis,this._guideAngleEnd);}});}}class BoxShape extends Shape{_createCenter(){this._createRoot("boxCenter");this._updateTransform();this._addRenderMesh(this.entity,"box",this._shading);}set size(value){this._size=value!=null?value:1;this._updateTransform();}get size(){return this._size}set tolerance(value){this._tolerance=value;this._updateTransform();}get tolerance(){return this._tolerance}_updateTransform(){this.entity.setLocalScale(this._size,this._size,this._size);}constructor(device,options={}){super(device,options);this._size=.12;this._tolerance=.05;this.triData=[new TriData(new BoxGeometry,2)];this._createCenter();}}const tmpV1$1=new Vec3;const tmpV2$1=new Vec3;const tmpQ1$1=new Quat;class BoxLineShape extends Shape{set gap(value){this._gap=value!=null?value:0;this._updateLine();this._updateBox();}get gap(){return this._gap}set lineThickness(value){this._lineThickness=value!=null?value:1;this._updateLine();this._updateBox();}get lineThickness(){return this._lineThickness}set lineLength(value){this._lineLength=value!=null?value:1;this._updateLine();this._updateBox();}get lineLength(){return this._lineLength}set boxSize(value){this._boxSize=value!=null?value:1;this._updateBox();}get boxSize(){return this._boxSize}set tolerance(value){this._tolerance=value;this._updateLine();}get tolerance(){return this._tolerance}set flipped(value){if(this._flipped===value){return}this._flipped=value;if(this._rotation.equals(Vec3.ZERO)){tmpV1$1.set(0,0,this._flipped?180:0);}else {tmpV1$1.copy(this._rotation).mulScalar(this._flipped?-1:1);}this._line.enabled=!this._flipped;this.entity.setLocalEulerAngles(tmpV1$1);}get flipped(){return this._flipped}_createBoxLine(){this._createRoot("boxLine");this._box=new Entity(`box:${this.axis}`);this.entity.addChild(this._box);this._updateBox();this._addRenderMesh(this._box,"box",this._shading);this._line=new Entity(`line:${this.axis}`);this.entity.addChild(this._line);this._updateLine();this._addRenderMesh(this._line,"cylinder",this._shading);}_updateBox(){tmpV1$1.set(0,this._gap+this._boxSize*.5+this._lineLength,0);tmpQ1$1.set(0,0,0,1);tmpV2$1.set(this._boxSize,this._boxSize,this._boxSize);this.triData[0].setTransform(tmpV1$1,tmpQ1$1,tmpV2$1);this._box.setLocalPosition(0,this._gap+this._boxSize*.5+this._lineLength,0);this._box.setLocalScale(this._boxSize,this._boxSize,this._boxSize);}_updateLine(){tmpV1$1.set(0,this._gap+this._lineLength*.5,0);tmpQ1$1.set(0,0,0,1);tmpV2$1.set(this._lineThickness+this._tolerance,this._lineLength,this._lineThickness+this._tolerance);this.triData[1].setTransform(tmpV1$1,tmpQ1$1,tmpV2$1);this._line.setLocalPosition(0,this._gap+this._lineLength*.5,0);this._line.setLocalScale(this._lineThickness,this._lineLength,this._lineThickness);}constructor(device,options={}){super(device,options);this._gap=0;this._lineThickness=.02;this._lineLength=.5;this._boxSize=.12;this._tolerance=.1;this._box=void 0;this._line=void 0;this._flipped=false;this.triData=[new TriData(new BoxGeometry),new TriData(new CylinderGeometry,1)];this._createBoxLine();}}const tmpV1=new Vec3;const tmpV2=new Vec3;const tmpV3=new Vec3;const tmpQ1=new Quat;const GLANCE_EPSILON=.98;class ScaleGizmo extends TransformGizmo{set coordSpace(value){}get coordSpace(){return this._coordSpace}set uniform(value){this._useUniformScaling=value!=null?value:true;}get uniform(){return this._useUniformScaling}set axisGap(value){this._setArrowProp("gap",value);}get axisGap(){return this._shapes.x.gap}set axisLineThickness(value){this._setArrowProp("lineThickness",value);}get axisLineThickness(){return this._shapes.x.lineThickness}set axisLineLength(value){this._setArrowProp("lineLength",value);}get axisLineLength(){return this._shapes.x.lineLength}set axisLineTolerance(value){this._setArrowProp("tolerance",value);}get axisLineTolerance(){return this._shapes.x.tolerance}set axisBoxSize(value){this._setArrowProp("boxSize",value);}get axisBoxSize(){return this._shapes.x.boxSize}set axisPlaneSize(value){this._setPlaneProp("size",value);}get axisPlaneSize(){return this._shapes.yz.size}set axisPlaneGap(value){this._setPlaneProp("gap",value);}get axisPlaneGap(){return this._shapes.yz.gap}set axisCenterSize(value){this._shapes.xyz.size=value;}get axisCenterSize(){return this._shapes.xyz.size}set axisCenterTolerance(value){this._shapes.xyz.tolerance=value;}get axisCenterTolerance(){return this._shapes.xyz.tolerance}_setArrowProp(prop,value){this._shapes.x[prop]=value;this._shapes.y[prop]=value;this._shapes.z[prop]=value;}_setPlaneProp(prop,value){this._shapes.yz[prop]=value;this._shapes.xz[prop]=value;this._shapes.xy[prop]=value;}_shapesLookAtCamera(){const facingDir=this.facing;let dot=facingDir.dot(this.root.right);this._shapes.x.entity.enabled=Math.abs(dot)<GLANCE_EPSILON;if(this.flipShapes){this._shapes.x.flipped=dot<0;}dot=facingDir.dot(this.root.up);this._shapes.y.entity.enabled=Math.abs(dot)<GLANCE_EPSILON;if(this.flipShapes){this._shapes.y.flipped=dot<0;}dot=facingDir.dot(this.root.forward);this._shapes.z.entity.enabled=Math.abs(dot)<GLANCE_EPSILON;if(this.flipShapes){this._shapes.z.flipped=dot>0;}tmpV1.cross(facingDir,this.root.right);this._shapes.yz.entity.enabled=tmpV1.length()<GLANCE_EPSILON;if(this.flipShapes){this._shapes.yz.flipped=tmpV2.set(0,+(tmpV1.dot(this.root.forward)<0),+(tmpV1.dot(this.root.up)<0));}tmpV1.cross(facingDir,this.root.forward);this._shapes.xy.entity.enabled=tmpV1.length()<GLANCE_EPSILON;if(this.flipShapes){this._shapes.xy.flipped=tmpV2.set(+(tmpV1.dot(this.root.up)<0),+(tmpV1.dot(this.root.right)>0),0);}tmpV1.cross(facingDir,this.root.up);this._shapes.xz.entity.enabled=tmpV1.length()<GLANCE_EPSILON;if(this.flipShapes){this._shapes.xz.flipped=tmpV2.set(+(tmpV1.dot(this.root.forward)>0),0,+(tmpV1.dot(this.root.right)>0));}}_storeNodeScales(){for(let i=0;i<this.nodes.length;i++){const node=this.nodes[i];this._nodeScales.set(node,node.getLocalScale().clone());}}_setNodeScales(pointDelta){for(let i=0;i<this.nodes.length;i++){const node=this.nodes[i];const scale=this._nodeScales.get(node);if(!scale){continue}node.setLocalScale(tmpV1.copy(scale).mul(pointDelta).max(this.lowerBoundScale));}}_screenToPoint(x,y){const gizmoPos=this.root.getPosition();const mouseWPos=this._camera.screenToWorld(x,y,1);const axis=this._selectedAxis;const isPlane=this._selectedIsPlane;const isScaleUniform=this._useUniformScaling&&isPlane||axis===GIZMOAXIS_XYZ;const ray=this._createRay(mouseWPos);const plane=this._createPlane(axis,isScaleUniform,!isPlane);const point=new Vec3;plane.intersectsRay(ray,point);if(isScaleUniform){switch(axis){case GIZMOAXIS_X:tmpV1.copy(this.root.up);tmpV2.copy(this.root.forward).mulScalar(-1);break;case GIZMOAXIS_Y:tmpV1.copy(this.root.right);tmpV2.copy(this.root.forward).mulScalar(-1);break;case GIZMOAXIS_Z:tmpV1.copy(this.root.up);tmpV2.copy(this.root.right);break;default:tmpV1.copy(this._camera.entity.up);tmpV2.copy(this._camera.entity.right);break}tmpV2.add(tmpV1).normalize();tmpV1.sub2(point,gizmoPos);const length=tmpV1.length();const v=length*tmpV1.normalize().dot(tmpV2);point.set(v,v,v);if(axis!==GIZMOAXIS_XYZ){point[axis]=1;}return point}tmpQ1.copy(this._rootStartRot).invert().transformVector(point,point);if(!isPlane){this._projectToAxis(point,axis);}return point}constructor(camera,layer){super(camera,layer);this._shapes={xyz:new BoxShape(this._device,{axis:GIZMOAXIS_XYZ,layers:[this._layer.id],shading:this._shading,defaultColor:this._meshColors.axis.xyz,hoverColor:this._meshColors.hover.xyz}),yz:new PlaneShape(this._device,{axis:GIZMOAXIS_X,layers:[this._layer.id],shading:this._shading,rotation:new Vec3(0,0,-90),defaultColor:this._meshColors.axis.x,hoverColor:this._meshColors.hover.x}),xz:new PlaneShape(this._device,{axis:GIZMOAXIS_Y,layers:[this._layer.id],shading:this._shading,rotation:new Vec3(0,0,0),defaultColor:this._meshColors.axis.y,hoverColor:this._meshColors.hover.y}),xy:new PlaneShape(this._device,{axis:GIZMOAXIS_Z,layers:[this._layer.id],shading:this._shading,rotation:new Vec3(90,0,0),defaultColor:this._meshColors.axis.z,hoverColor:this._meshColors.hover.z}),x:new BoxLineShape(this._device,{axis:GIZMOAXIS_X,layers:[this._layer.id],shading:this._shading,rotation:new Vec3(0,0,-90),defaultColor:this._meshColors.axis.x,hoverColor:this._meshColors.hover.x}),y:new BoxLineShape(this._device,{axis:GIZMOAXIS_Y,layers:[this._layer.id],shading:this._shading,rotation:new Vec3(0,0,0),defaultColor:this._meshColors.axis.y,hoverColor:this._meshColors.hover.y}),z:new BoxLineShape(this._device,{axis:GIZMOAXIS_Z,layers:[this._layer.id],shading:this._shading,rotation:new Vec3(90,0,0),defaultColor:this._meshColors.axis.z,hoverColor:this._meshColors.hover.z})};this._coordSpace=GIZMOSPACE_LOCAL;this._nodeScales=new Map;this._forward=new Vec3;this._useUniformScaling=false;this.snapIncrement=1;this.flipShapes=true;this.lowerBoundScale=new Vec3(-Infinity,-Infinity,-Infinity);this._createTransform();this.on(TransformGizmo.EVENT_TRANSFORMSTART,()=>{this._storeNodeScales();});this.on(TransformGizmo.EVENT_TRANSFORMMOVE,point=>{const pointDelta=tmpV3.copy(point).sub(this._selectionStartPoint);if(this.snap){pointDelta.mulScalar(1/this.snapIncrement);pointDelta.round();pointDelta.mulScalar(this.snapIncrement);}pointDelta.mulScalar(1/this._scale);this._setNodeScales(pointDelta.add(Vec3.ONE));});this.on(TransformGizmo.EVENT_NODESDETACH,()=>{this._nodeScales.clear();});this._app.on("prerender",()=>{this._shapesLookAtCamera();});}}

var pc = /*#__PURE__*/Object.freeze({
	__proto__: null,
	ABSOLUTE_URL: ABSOLUTE_URL,
	ACTION_GAMEPAD: ACTION_GAMEPAD,
	ACTION_KEYBOARD: ACTION_KEYBOARD,
	ACTION_MOUSE: ACTION_MOUSE,
	ADDRESS_CLAMP_TO_EDGE: ADDRESS_CLAMP_TO_EDGE,
	ADDRESS_MIRRORED_REPEAT: ADDRESS_MIRRORED_REPEAT,
	ADDRESS_REPEAT: ADDRESS_REPEAT,
	ANIM_BLEND_1D: ANIM_BLEND_1D,
	ANIM_BLEND_2D_CARTESIAN: ANIM_BLEND_2D_CARTESIAN,
	ANIM_BLEND_2D_DIRECTIONAL: ANIM_BLEND_2D_DIRECTIONAL,
	ANIM_BLEND_DIRECT: ANIM_BLEND_DIRECT,
	ANIM_CONTROL_STATES: ANIM_CONTROL_STATES,
	ANIM_EQUAL_TO: ANIM_EQUAL_TO,
	ANIM_GREATER_THAN: ANIM_GREATER_THAN,
	ANIM_GREATER_THAN_EQUAL_TO: ANIM_GREATER_THAN_EQUAL_TO,
	ANIM_INTERRUPTION_NEXT: ANIM_INTERRUPTION_NEXT,
	ANIM_INTERRUPTION_NEXT_PREV: ANIM_INTERRUPTION_NEXT_PREV,
	ANIM_INTERRUPTION_NONE: ANIM_INTERRUPTION_NONE,
	ANIM_INTERRUPTION_PREV: ANIM_INTERRUPTION_PREV,
	ANIM_INTERRUPTION_PREV_NEXT: ANIM_INTERRUPTION_PREV_NEXT,
	ANIM_LAYER_ADDITIVE: ANIM_LAYER_ADDITIVE,
	ANIM_LAYER_OVERWRITE: ANIM_LAYER_OVERWRITE,
	ANIM_LESS_THAN: ANIM_LESS_THAN,
	ANIM_LESS_THAN_EQUAL_TO: ANIM_LESS_THAN_EQUAL_TO,
	ANIM_NOT_EQUAL_TO: ANIM_NOT_EQUAL_TO,
	ANIM_PARAMETER_BOOLEAN: ANIM_PARAMETER_BOOLEAN,
	ANIM_PARAMETER_FLOAT: ANIM_PARAMETER_FLOAT,
	ANIM_PARAMETER_INTEGER: ANIM_PARAMETER_INTEGER,
	ANIM_PARAMETER_TRIGGER: ANIM_PARAMETER_TRIGGER,
	ANIM_STATE_ANY: ANIM_STATE_ANY,
	ANIM_STATE_END: ANIM_STATE_END,
	ANIM_STATE_START: ANIM_STATE_START,
	ASPECT_AUTO: ASPECT_AUTO,
	ASPECT_MANUAL: ASPECT_MANUAL,
	ASSET_ANIMATION: ASSET_ANIMATION,
	ASSET_AUDIO: ASSET_AUDIO,
	ASSET_CONTAINER: ASSET_CONTAINER,
	ASSET_CSS: ASSET_CSS,
	ASSET_CUBEMAP: ASSET_CUBEMAP,
	ASSET_HTML: ASSET_HTML,
	ASSET_IMAGE: ASSET_IMAGE,
	ASSET_JSON: ASSET_JSON,
	ASSET_MATERIAL: ASSET_MATERIAL,
	ASSET_MODEL: ASSET_MODEL,
	ASSET_SCRIPT: ASSET_SCRIPT,
	ASSET_SHADER: ASSET_SHADER,
	ASSET_TEXT: ASSET_TEXT,
	ASSET_TEXTURE: ASSET_TEXTURE,
	ASSET_TEXTUREATLAS: ASSET_TEXTUREATLAS,
	AXIS_KEY: AXIS_KEY,
	AXIS_MOUSE_X: AXIS_MOUSE_X,
	AXIS_MOUSE_Y: AXIS_MOUSE_Y,
	AXIS_PAD_L_X: AXIS_PAD_L_X,
	AXIS_PAD_L_Y: AXIS_PAD_L_Y,
	AXIS_PAD_R_X: AXIS_PAD_R_X,
	AXIS_PAD_R_Y: AXIS_PAD_R_Y,
	AnimBinder: AnimBinder,
	AnimClip: AnimClip,
	AnimClipHandler: AnimClipHandler,
	AnimComponent: AnimComponent,
	AnimComponentLayer: AnimComponentLayer,
	AnimComponentSystem: AnimComponentSystem,
	AnimController: AnimController,
	AnimCurve: AnimCurve,
	AnimData: AnimData,
	AnimEvaluator: AnimEvaluator,
	AnimEvents: AnimEvents,
	AnimSnapshot: AnimSnapshot,
	AnimStateGraph: AnimStateGraph,
	AnimStateGraphHandler: AnimStateGraphHandler,
	AnimTarget: AnimTarget,
	AnimTrack: AnimTrack,
	Animation: Animation,
	AnimationComponent: AnimationComponent,
	AnimationComponentSystem: AnimationComponentSystem,
	AnimationHandler: AnimationHandler,
	AppBase: AppBase,
	AppOptions: AppOptions,
	Application: Application,
	Asset: Asset,
	AssetListLoader: AssetListLoader,
	AssetReference: AssetReference,
	AssetRegistry: AssetRegistry,
	AudioHandler: AudioHandler,
	AudioListenerComponent: AudioListenerComponent,
	AudioListenerComponentSystem: AudioListenerComponentSystem,
	AudioSourceComponent: AudioSourceComponent,
	AudioSourceComponentSystem: AudioSourceComponentSystem,
	BAKE_COLOR: BAKE_COLOR,
	BAKE_COLORDIR: BAKE_COLORDIR,
	BINDGROUP_MESH: BINDGROUP_MESH,
	BINDGROUP_VIEW: BINDGROUP_VIEW,
	BLENDEQUATION_ADD: BLENDEQUATION_ADD,
	BLENDEQUATION_MAX: BLENDEQUATION_MAX,
	BLENDEQUATION_MIN: BLENDEQUATION_MIN,
	BLENDEQUATION_REVERSE_SUBTRACT: BLENDEQUATION_REVERSE_SUBTRACT,
	BLENDEQUATION_SUBTRACT: BLENDEQUATION_SUBTRACT,
	BLENDMODE_CONSTANT: BLENDMODE_CONSTANT,
	BLENDMODE_CONSTANT_ALPHA: BLENDMODE_CONSTANT_ALPHA,
	BLENDMODE_CONSTANT_COLOR: BLENDMODE_CONSTANT_COLOR,
	BLENDMODE_DST_ALPHA: BLENDMODE_DST_ALPHA,
	BLENDMODE_DST_COLOR: BLENDMODE_DST_COLOR,
	BLENDMODE_ONE: BLENDMODE_ONE,
	BLENDMODE_ONE_MINUS_CONSTANT: BLENDMODE_ONE_MINUS_CONSTANT,
	BLENDMODE_ONE_MINUS_CONSTANT_ALPHA: BLENDMODE_ONE_MINUS_CONSTANT_ALPHA,
	BLENDMODE_ONE_MINUS_CONSTANT_COLOR: BLENDMODE_ONE_MINUS_CONSTANT_COLOR,
	BLENDMODE_ONE_MINUS_DST_ALPHA: BLENDMODE_ONE_MINUS_DST_ALPHA,
	BLENDMODE_ONE_MINUS_DST_COLOR: BLENDMODE_ONE_MINUS_DST_COLOR,
	BLENDMODE_ONE_MINUS_SRC_ALPHA: BLENDMODE_ONE_MINUS_SRC_ALPHA,
	BLENDMODE_ONE_MINUS_SRC_COLOR: BLENDMODE_ONE_MINUS_SRC_COLOR,
	BLENDMODE_SRC_ALPHA: BLENDMODE_SRC_ALPHA,
	BLENDMODE_SRC_ALPHA_SATURATE: BLENDMODE_SRC_ALPHA_SATURATE,
	BLENDMODE_SRC_COLOR: BLENDMODE_SRC_COLOR,
	BLENDMODE_ZERO: BLENDMODE_ZERO,
	BLEND_ADDITIVE: BLEND_ADDITIVE,
	BLEND_ADDITIVEALPHA: BLEND_ADDITIVEALPHA,
	BLEND_MAX: BLEND_MAX,
	BLEND_MIN: BLEND_MIN,
	BLEND_MULTIPLICATIVE: BLEND_MULTIPLICATIVE,
	BLEND_MULTIPLICATIVE2X: BLEND_MULTIPLICATIVE2X,
	BLEND_NONE: BLEND_NONE,
	BLEND_NORMAL: BLEND_NORMAL,
	BLEND_PREMULTIPLIED: BLEND_PREMULTIPLIED,
	BLEND_SCREEN: BLEND_SCREEN,
	BLEND_SUBTRACTIVE: BLEND_SUBTRACTIVE,
	BLUR_BOX: BLUR_BOX,
	BLUR_GAUSSIAN: BLUR_GAUSSIAN,
	BODYFLAG_KINEMATIC_OBJECT: BODYFLAG_KINEMATIC_OBJECT,
	BODYFLAG_NORESPONSE_OBJECT: BODYFLAG_NORESPONSE_OBJECT,
	BODYFLAG_STATIC_OBJECT: BODYFLAG_STATIC_OBJECT,
	BODYGROUP_DEFAULT: BODYGROUP_DEFAULT,
	BODYGROUP_DYNAMIC: BODYGROUP_DYNAMIC,
	BODYGROUP_ENGINE_1: BODYGROUP_ENGINE_1,
	BODYGROUP_ENGINE_2: BODYGROUP_ENGINE_2,
	BODYGROUP_ENGINE_3: BODYGROUP_ENGINE_3,
	BODYGROUP_KINEMATIC: BODYGROUP_KINEMATIC,
	BODYGROUP_NONE: BODYGROUP_NONE,
	BODYGROUP_STATIC: BODYGROUP_STATIC,
	BODYGROUP_TRIGGER: BODYGROUP_TRIGGER,
	BODYGROUP_USER_1: BODYGROUP_USER_1,
	BODYGROUP_USER_2: BODYGROUP_USER_2,
	BODYGROUP_USER_3: BODYGROUP_USER_3,
	BODYGROUP_USER_4: BODYGROUP_USER_4,
	BODYGROUP_USER_5: BODYGROUP_USER_5,
	BODYGROUP_USER_6: BODYGROUP_USER_6,
	BODYGROUP_USER_7: BODYGROUP_USER_7,
	BODYGROUP_USER_8: BODYGROUP_USER_8,
	BODYMASK_ALL: BODYMASK_ALL,
	BODYMASK_NONE: BODYMASK_NONE,
	BODYMASK_NOT_STATIC: BODYMASK_NOT_STATIC,
	BODYMASK_NOT_STATIC_KINEMATIC: BODYMASK_NOT_STATIC_KINEMATIC,
	BODYMASK_STATIC: BODYMASK_STATIC,
	BODYSTATE_ACTIVE_TAG: BODYSTATE_ACTIVE_TAG,
	BODYSTATE_DISABLE_DEACTIVATION: BODYSTATE_DISABLE_DEACTIVATION,
	BODYSTATE_DISABLE_SIMULATION: BODYSTATE_DISABLE_SIMULATION,
	BODYSTATE_ISLAND_SLEEPING: BODYSTATE_ISLAND_SLEEPING,
	BODYSTATE_WANTS_DEACTIVATION: BODYSTATE_WANTS_DEACTIVATION,
	BODYTYPE_DYNAMIC: BODYTYPE_DYNAMIC,
	BODYTYPE_KINEMATIC: BODYTYPE_KINEMATIC,
	BODYTYPE_STATIC: BODYTYPE_STATIC,
	BUFFERUSAGE_COPY_DST: BUFFERUSAGE_COPY_DST,
	BUFFERUSAGE_COPY_SRC: BUFFERUSAGE_COPY_SRC,
	BUFFERUSAGE_INDEX: BUFFERUSAGE_INDEX,
	BUFFERUSAGE_INDIRECT: BUFFERUSAGE_INDIRECT,
	BUFFERUSAGE_READ: BUFFERUSAGE_READ,
	BUFFERUSAGE_STORAGE: BUFFERUSAGE_STORAGE,
	BUFFERUSAGE_UNIFORM: BUFFERUSAGE_UNIFORM,
	BUFFERUSAGE_VERTEX: BUFFERUSAGE_VERTEX,
	BUFFERUSAGE_WRITE: BUFFERUSAGE_WRITE,
	BUFFER_DYNAMIC: BUFFER_DYNAMIC,
	BUFFER_GPUDYNAMIC: BUFFER_GPUDYNAMIC,
	BUFFER_STATIC: BUFFER_STATIC,
	BUFFER_STREAM: BUFFER_STREAM,
	BUTTON_TRANSITION_MODE_SPRITE_CHANGE: BUTTON_TRANSITION_MODE_SPRITE_CHANGE,
	BUTTON_TRANSITION_MODE_TINT: BUTTON_TRANSITION_MODE_TINT,
	BasicMaterial: BasicMaterial,
	Batch: Batch,
	BatchGroup: BatchGroup,
	BatchManager: BatchManager,
	BinaryHandler: BinaryHandler,
	BindGroupFormat: BindGroupFormat,
	BindStorageBufferFormat: BindStorageBufferFormat,
	BindStorageTextureFormat: BindStorageTextureFormat,
	BindTextureFormat: BindTextureFormat,
	BindUniformBufferFormat: BindUniformBufferFormat,
	BlendState: BlendState,
	BoundingBox: BoundingBox,
	BoundingSphere: BoundingSphere,
	BoxGeometry: BoxGeometry,
	Bundle: Bundle,
	BundleHandler: BundleHandler,
	BundleRegistry: BundleRegistry,
	ButtonComponent: ButtonComponent,
	ButtonComponentSystem: ButtonComponentSystem,
	CHUNKAPI_1_51: CHUNKAPI_1_51,
	CHUNKAPI_1_55: CHUNKAPI_1_55,
	CHUNKAPI_1_56: CHUNKAPI_1_56,
	CHUNKAPI_1_57: CHUNKAPI_1_57,
	CHUNKAPI_1_58: CHUNKAPI_1_58,
	CHUNKAPI_1_60: CHUNKAPI_1_60,
	CHUNKAPI_1_62: CHUNKAPI_1_62,
	CHUNKAPI_1_65: CHUNKAPI_1_65,
	CHUNKAPI_1_70: CHUNKAPI_1_70,
	CLEARFLAG_COLOR: CLEARFLAG_COLOR,
	CLEARFLAG_DEPTH: CLEARFLAG_DEPTH,
	CLEARFLAG_STENCIL: CLEARFLAG_STENCIL,
	CUBEFACE_NEGX: CUBEFACE_NEGX,
	CUBEFACE_NEGY: CUBEFACE_NEGY,
	CUBEFACE_NEGZ: CUBEFACE_NEGZ,
	CUBEFACE_POSX: CUBEFACE_POSX,
	CUBEFACE_POSY: CUBEFACE_POSY,
	CUBEFACE_POSZ: CUBEFACE_POSZ,
	CUBEPROJ_BOX: CUBEPROJ_BOX,
	CUBEPROJ_NONE: CUBEPROJ_NONE,
	CULLFACE_BACK: CULLFACE_BACK,
	CULLFACE_FRONT: CULLFACE_FRONT,
	CULLFACE_FRONTANDBACK: CULLFACE_FRONTANDBACK,
	CULLFACE_NONE: CULLFACE_NONE,
	CURVE_CARDINAL: CURVE_CARDINAL,
	CURVE_CATMULL: CURVE_CATMULL,
	CURVE_LINEAR: CURVE_LINEAR,
	CURVE_SMOOTHSTEP: CURVE_SMOOTHSTEP,
	CURVE_SPLINE: CURVE_SPLINE,
	CURVE_STEP: CURVE_STEP,
	Camera: Camera,
	CameraComponent: CameraComponent,
	CameraComponentSystem: CameraComponentSystem,
	CanvasFont: CanvasFont,
	CapsuleGeometry: CapsuleGeometry,
	ChunkBuilder: ChunkBuilder,
	CollisionComponent: CollisionComponent,
	CollisionComponentSystem: CollisionComponentSystem,
	Color: Color,
	Component: Component,
	ComponentSystem: ComponentSystem,
	ComponentSystemRegistry: ComponentSystemRegistry,
	Compute: Compute,
	ConeGeometry: ConeGeometry,
	ContactPoint: ContactPoint,
	ContactResult: ContactResult,
	ContainerHandler: ContainerHandler,
	ContainerResource: ContainerResource,
	ContextCreationError: ContextCreationError,
	Controller: Controller,
	CssHandler: CssHandler,
	CubemapHandler: CubemapHandler,
	Curve: Curve,
	CurveSet: CurveSet,
	CylinderGeometry: CylinderGeometry,
	DETAILMODE_ADD: DETAILMODE_ADD,
	DETAILMODE_MAX: DETAILMODE_MAX,
	DETAILMODE_MIN: DETAILMODE_MIN,
	DETAILMODE_MUL: DETAILMODE_MUL,
	DETAILMODE_OVERLAY: DETAILMODE_OVERLAY,
	DETAILMODE_SCREEN: DETAILMODE_SCREEN,
	DEVICETYPE_NULL: DEVICETYPE_NULL,
	DEVICETYPE_WEBGL1: DEVICETYPE_WEBGL1,
	DEVICETYPE_WEBGL2: DEVICETYPE_WEBGL2,
	DEVICETYPE_WEBGPU: DEVICETYPE_WEBGPU,
	DISTANCE_EXPONENTIAL: DISTANCE_EXPONENTIAL,
	DISTANCE_INVERSE: DISTANCE_INVERSE,
	DISTANCE_LINEAR: DISTANCE_LINEAR,
	DITHER_BAYER8: DITHER_BAYER8,
	DITHER_BLUENOISE: DITHER_BLUENOISE,
	DITHER_IGNNOISE: DITHER_IGNNOISE,
	DITHER_NONE: DITHER_NONE,
	DefaultAnimBinder: DefaultAnimBinder,
	DepthState: DepthState,
	DomeGeometry: DomeGeometry,
	ELEMENTTYPE_FLOAT32: ELEMENTTYPE_FLOAT32,
	ELEMENTTYPE_GROUP: ELEMENTTYPE_GROUP,
	ELEMENTTYPE_IMAGE: ELEMENTTYPE_IMAGE,
	ELEMENTTYPE_INT16: ELEMENTTYPE_INT16,
	ELEMENTTYPE_INT32: ELEMENTTYPE_INT32,
	ELEMENTTYPE_INT8: ELEMENTTYPE_INT8,
	ELEMENTTYPE_TEXT: ELEMENTTYPE_TEXT,
	ELEMENTTYPE_UINT16: ELEMENTTYPE_UINT16,
	ELEMENTTYPE_UINT32: ELEMENTTYPE_UINT32,
	ELEMENTTYPE_UINT8: ELEMENTTYPE_UINT8,
	EMITTERSHAPE_BOX: EMITTERSHAPE_BOX,
	EMITTERSHAPE_SPHERE: EMITTERSHAPE_SPHERE,
	EVENT_GAMEPADCONNECTED: EVENT_GAMEPADCONNECTED,
	EVENT_GAMEPADDISCONNECTED: EVENT_GAMEPADDISCONNECTED,
	EVENT_KEYDOWN: EVENT_KEYDOWN,
	EVENT_KEYUP: EVENT_KEYUP,
	EVENT_MOUSEDOWN: EVENT_MOUSEDOWN,
	EVENT_MOUSEMOVE: EVENT_MOUSEMOVE,
	EVENT_MOUSEUP: EVENT_MOUSEUP,
	EVENT_MOUSEWHEEL: EVENT_MOUSEWHEEL,
	EVENT_SELECT: EVENT_SELECT,
	EVENT_SELECTEND: EVENT_SELECTEND,
	EVENT_SELECTSTART: EVENT_SELECTSTART,
	EVENT_TOUCHCANCEL: EVENT_TOUCHCANCEL,
	EVENT_TOUCHEND: EVENT_TOUCHEND,
	EVENT_TOUCHMOVE: EVENT_TOUCHMOVE,
	EVENT_TOUCHSTART: EVENT_TOUCHSTART,
	ElementComponent: ElementComponent,
	ElementComponentSystem: ElementComponentSystem,
	ElementDragHelper: ElementDragHelper,
	ElementInput: ElementInput,
	ElementInputEvent: ElementInputEvent,
	ElementMouseEvent: ElementMouseEvent,
	ElementSelectEvent: ElementSelectEvent,
	ElementTouchEvent: ElementTouchEvent,
	Entity: Entity,
	EnvLighting: EnvLighting,
	EventHandle: EventHandle,
	EventHandler: EventHandler,
	FILLMODE_FILL_WINDOW: FILLMODE_FILL_WINDOW,
	FILLMODE_KEEP_ASPECT: FILLMODE_KEEP_ASPECT,
	FILLMODE_NONE: FILLMODE_NONE,
	FILTER_LINEAR: FILTER_LINEAR,
	FILTER_LINEAR_MIPMAP_LINEAR: FILTER_LINEAR_MIPMAP_LINEAR,
	FILTER_LINEAR_MIPMAP_NEAREST: FILTER_LINEAR_MIPMAP_NEAREST,
	FILTER_NEAREST: FILTER_NEAREST,
	FILTER_NEAREST_MIPMAP_LINEAR: FILTER_NEAREST_MIPMAP_LINEAR,
	FILTER_NEAREST_MIPMAP_NEAREST: FILTER_NEAREST_MIPMAP_NEAREST,
	FITMODE_CONTAIN: FITMODE_CONTAIN,
	FITMODE_COVER: FITMODE_COVER,
	FITMODE_STRETCH: FITMODE_STRETCH,
	FITTING_BOTH: FITTING_BOTH,
	FITTING_NONE: FITTING_NONE,
	FITTING_SHRINK: FITTING_SHRINK,
	FITTING_STRETCH: FITTING_STRETCH,
	FOG_EXP: FOG_EXP,
	FOG_EXP2: FOG_EXP2,
	FOG_LINEAR: FOG_LINEAR,
	FOG_NONE: FOG_NONE,
	FONT_BITMAP: FONT_BITMAP,
	FONT_MSDF: FONT_MSDF,
	FRESNEL_NONE: FRESNEL_NONE,
	FRESNEL_SCHLICK: FRESNEL_SCHLICK,
	FUNC_ALWAYS: FUNC_ALWAYS,
	FUNC_EQUAL: FUNC_EQUAL,
	FUNC_GREATER: FUNC_GREATER,
	FUNC_GREATEREQUAL: FUNC_GREATEREQUAL,
	FUNC_LESS: FUNC_LESS,
	FUNC_LESSEQUAL: FUNC_LESSEQUAL,
	FUNC_NEVER: FUNC_NEVER,
	FUNC_NOTEQUAL: FUNC_NOTEQUAL,
	FloatPacking: FloatPacking,
	FolderHandler: FolderHandler,
	Font: Font,
	FontHandler: FontHandler,
	ForwardRenderer: ForwardRenderer,
	Frustum: Frustum,
	GAMMA_NONE: GAMMA_NONE,
	GAMMA_SRGB: GAMMA_SRGB,
	GAMMA_SRGBFAST: GAMMA_SRGBFAST,
	GAMMA_SRGBHDR: GAMMA_SRGBHDR,
	GIZMOAXIS_FACE: GIZMOAXIS_FACE,
	GIZMOAXIS_X: GIZMOAXIS_X,
	GIZMOAXIS_XY: GIZMOAXIS_XY,
	GIZMOAXIS_XYZ: GIZMOAXIS_XYZ,
	GIZMOAXIS_XZ: GIZMOAXIS_XZ,
	GIZMOAXIS_Y: GIZMOAXIS_Y,
	GIZMOAXIS_YZ: GIZMOAXIS_YZ,
	GIZMOAXIS_Z: GIZMOAXIS_Z,
	GIZMOSPACE_LOCAL: GIZMOSPACE_LOCAL,
	GIZMOSPACE_WORLD: GIZMOSPACE_WORLD,
	GSplat: GSplat,
	GSplatComponent: GSplatComponent,
	GSplatComponentSystem: GSplatComponentSystem,
	GSplatData: GSplatData,
	GSplatHandler: GSplatHandler,
	GSplatInstance: GSplatInstance,
	GSplatResource: GSplatResource,
	GamePads: GamePads,
	Geometry: Geometry,
	Gizmo: Gizmo,
	GltfExporter: GltfExporter,
	GraphNode: GraphNode,
	GraphicsDevice: GraphicsDevice,
	HierarchyHandler: HierarchyHandler,
	HtmlHandler: HtmlHandler,
	Http: Http,
	I18n: I18n,
	INDEXFORMAT_UINT16: INDEXFORMAT_UINT16,
	INDEXFORMAT_UINT32: INDEXFORMAT_UINT32,
	INDEXFORMAT_UINT8: INDEXFORMAT_UINT8,
	INTERPOLATION_CUBIC: INTERPOLATION_CUBIC,
	INTERPOLATION_LINEAR: INTERPOLATION_LINEAR,
	INTERPOLATION_STEP: INTERPOLATION_STEP,
	ImageElement: ImageElement,
	IndexBuffer: IndexBuffer,
	IndexedList: IndexedList,
	JointComponent: JointComponent,
	JointComponentSystem: JointComponentSystem,
	JsonHandler: JsonHandler,
	JsonStandardMaterialParser: JsonStandardMaterialParser,
	KEY_0: KEY_0,
	KEY_1: KEY_1,
	KEY_2: KEY_2,
	KEY_3: KEY_3,
	KEY_4: KEY_4,
	KEY_5: KEY_5,
	KEY_6: KEY_6,
	KEY_7: KEY_7,
	KEY_8: KEY_8,
	KEY_9: KEY_9,
	KEY_A: KEY_A,
	KEY_ADD: KEY_ADD,
	KEY_ALT: KEY_ALT,
	KEY_B: KEY_B,
	KEY_BACKSPACE: KEY_BACKSPACE,
	KEY_BACK_SLASH: KEY_BACK_SLASH,
	KEY_C: KEY_C,
	KEY_CAPS_LOCK: KEY_CAPS_LOCK,
	KEY_CLOSE_BRACKET: KEY_CLOSE_BRACKET,
	KEY_COMMA: KEY_COMMA,
	KEY_CONTEXT_MENU: KEY_CONTEXT_MENU,
	KEY_CONTROL: KEY_CONTROL,
	KEY_D: KEY_D,
	KEY_DECIMAL: KEY_DECIMAL,
	KEY_DELETE: KEY_DELETE,
	KEY_DIVIDE: KEY_DIVIDE,
	KEY_DOWN: KEY_DOWN,
	KEY_E: KEY_E,
	KEY_END: KEY_END,
	KEY_ENTER: KEY_ENTER,
	KEY_EQUAL: KEY_EQUAL,
	KEY_ESCAPE: KEY_ESCAPE,
	KEY_F: KEY_F,
	KEY_F1: KEY_F1,
	KEY_F10: KEY_F10,
	KEY_F11: KEY_F11,
	KEY_F12: KEY_F12,
	KEY_F2: KEY_F2,
	KEY_F3: KEY_F3,
	KEY_F4: KEY_F4,
	KEY_F5: KEY_F5,
	KEY_F6: KEY_F6,
	KEY_F7: KEY_F7,
	KEY_F8: KEY_F8,
	KEY_F9: KEY_F9,
	KEY_G: KEY_G,
	KEY_H: KEY_H,
	KEY_HOME: KEY_HOME,
	KEY_I: KEY_I,
	KEY_INSERT: KEY_INSERT,
	KEY_J: KEY_J,
	KEY_K: KEY_K,
	KEY_L: KEY_L,
	KEY_LEFT: KEY_LEFT,
	KEY_M: KEY_M,
	KEY_META: KEY_META,
	KEY_MULTIPLY: KEY_MULTIPLY,
	KEY_N: KEY_N,
	KEY_NUMPAD_0: KEY_NUMPAD_0,
	KEY_NUMPAD_1: KEY_NUMPAD_1,
	KEY_NUMPAD_2: KEY_NUMPAD_2,
	KEY_NUMPAD_3: KEY_NUMPAD_3,
	KEY_NUMPAD_4: KEY_NUMPAD_4,
	KEY_NUMPAD_5: KEY_NUMPAD_5,
	KEY_NUMPAD_6: KEY_NUMPAD_6,
	KEY_NUMPAD_7: KEY_NUMPAD_7,
	KEY_NUMPAD_8: KEY_NUMPAD_8,
	KEY_NUMPAD_9: KEY_NUMPAD_9,
	KEY_O: KEY_O,
	KEY_OPEN_BRACKET: KEY_OPEN_BRACKET,
	KEY_P: KEY_P,
	KEY_PAGE_DOWN: KEY_PAGE_DOWN,
	KEY_PAGE_UP: KEY_PAGE_UP,
	KEY_PAUSE: KEY_PAUSE,
	KEY_PERIOD: KEY_PERIOD,
	KEY_PRINT_SCREEN: KEY_PRINT_SCREEN,
	KEY_Q: KEY_Q,
	KEY_R: KEY_R,
	KEY_RETURN: KEY_RETURN,
	KEY_RIGHT: KEY_RIGHT,
	KEY_S: KEY_S,
	KEY_SEMICOLON: KEY_SEMICOLON,
	KEY_SEPARATOR: KEY_SEPARATOR,
	KEY_SHIFT: KEY_SHIFT,
	KEY_SLASH: KEY_SLASH,
	KEY_SPACE: KEY_SPACE,
	KEY_SUBTRACT: KEY_SUBTRACT,
	KEY_T: KEY_T,
	KEY_TAB: KEY_TAB,
	KEY_U: KEY_U,
	KEY_UP: KEY_UP,
	KEY_V: KEY_V,
	KEY_W: KEY_W,
	KEY_WINDOWS: KEY_WINDOWS,
	KEY_X: KEY_X,
	KEY_Y: KEY_Y,
	KEY_Z: KEY_Z,
	Key: Key,
	Keyboard: Keyboard,
	KeyboardEvent: KeyboardEvent,
	LAYERID_DEPTH: LAYERID_DEPTH,
	LAYERID_IMMEDIATE: LAYERID_IMMEDIATE,
	LAYERID_SKYBOX: LAYERID_SKYBOX,
	LAYERID_UI: LAYERID_UI,
	LAYERID_WORLD: LAYERID_WORLD,
	LAYER_FX: LAYER_FX,
	LAYER_GIZMO: LAYER_GIZMO,
	LAYER_HUD: LAYER_HUD,
	LAYER_WORLD: LAYER_WORLD,
	LIGHTFALLOFF_INVERSESQUARED: LIGHTFALLOFF_INVERSESQUARED,
	LIGHTFALLOFF_LINEAR: LIGHTFALLOFF_LINEAR,
	LIGHTSHAPE_DISK: LIGHTSHAPE_DISK,
	LIGHTSHAPE_PUNCTUAL: LIGHTSHAPE_PUNCTUAL,
	LIGHTSHAPE_RECT: LIGHTSHAPE_RECT,
	LIGHTSHAPE_SPHERE: LIGHTSHAPE_SPHERE,
	LIGHTTYPE_COUNT: LIGHTTYPE_COUNT,
	LIGHTTYPE_DIRECTIONAL: LIGHTTYPE_DIRECTIONAL,
	LIGHTTYPE_OMNI: LIGHTTYPE_OMNI,
	LIGHTTYPE_POINT: LIGHTTYPE_POINT,
	LIGHTTYPE_SPOT: LIGHTTYPE_SPOT,
	LINEBATCH_GIZMO: LINEBATCH_GIZMO,
	LINEBATCH_OVERLAY: LINEBATCH_OVERLAY,
	LINEBATCH_WORLD: LINEBATCH_WORLD,
	Layer: Layer,
	LayerComposition: LayerComposition,
	LayoutCalculator: LayoutCalculator,
	LayoutChildComponent: LayoutChildComponent,
	LayoutChildComponentSystem: LayoutChildComponentSystem,
	LayoutGroupComponent: LayoutGroupComponent,
	LayoutGroupComponentSystem: LayoutGroupComponentSystem,
	Light: Light,
	LightComponent: LightComponent,
	LightComponentSystem: LightComponentSystem,
	LightingParams: LightingParams,
	Lightmapper: Lightmapper,
	LitMaterial: LitMaterial,
	LitOptions: LitOptions,
	LitShaderOptions: LitShaderOptions,
	LocalizedAsset: LocalizedAsset,
	MASK_AFFECT_DYNAMIC: MASK_AFFECT_DYNAMIC,
	MASK_AFFECT_LIGHTMAPPED: MASK_AFFECT_LIGHTMAPPED,
	MASK_BAKE: MASK_BAKE,
	MOTION_FREE: MOTION_FREE,
	MOTION_LIMITED: MOTION_LIMITED,
	MOTION_LOCKED: MOTION_LOCKED,
	MOUSEBUTTON_LEFT: MOUSEBUTTON_LEFT,
	MOUSEBUTTON_MIDDLE: MOUSEBUTTON_MIDDLE,
	MOUSEBUTTON_NONE: MOUSEBUTTON_NONE,
	MOUSEBUTTON_RIGHT: MOUSEBUTTON_RIGHT,
	Mat3: Mat3,
	Mat4: Mat4,
	Material: Material,
	MaterialHandler: MaterialHandler,
	Mesh: Mesh,
	MeshInstance: MeshInstance,
	MiniStats: MiniStats,
	Model: Model,
	ModelComponent: ModelComponent,
	ModelComponentSystem: ModelComponentSystem,
	ModelHandler: ModelHandler,
	Morph: Morph,
	MorphInstance: MorphInstance,
	MorphTarget: MorphTarget,
	Mouse: Mouse,
	MouseEvent: MouseEvent,
	Node: Node,
	NullGraphicsDevice: NullGraphicsDevice,
	ORIENTATION_HORIZONTAL: ORIENTATION_HORIZONTAL,
	ORIENTATION_VERTICAL: ORIENTATION_VERTICAL,
	OrientedBox: OrientedBox,
	PAD_1: PAD_1,
	PAD_2: PAD_2,
	PAD_3: PAD_3,
	PAD_4: PAD_4,
	PAD_DOWN: PAD_DOWN,
	PAD_FACE_1: PAD_FACE_1,
	PAD_FACE_2: PAD_FACE_2,
	PAD_FACE_3: PAD_FACE_3,
	PAD_FACE_4: PAD_FACE_4,
	PAD_LEFT: PAD_LEFT,
	PAD_L_SHOULDER_1: PAD_L_SHOULDER_1,
	PAD_L_SHOULDER_2: PAD_L_SHOULDER_2,
	PAD_L_STICK_BUTTON: PAD_L_STICK_BUTTON,
	PAD_L_STICK_X: PAD_L_STICK_X,
	PAD_L_STICK_Y: PAD_L_STICK_Y,
	PAD_RIGHT: PAD_RIGHT,
	PAD_R_SHOULDER_1: PAD_R_SHOULDER_1,
	PAD_R_SHOULDER_2: PAD_R_SHOULDER_2,
	PAD_R_STICK_BUTTON: PAD_R_STICK_BUTTON,
	PAD_R_STICK_X: PAD_R_STICK_X,
	PAD_R_STICK_Y: PAD_R_STICK_Y,
	PAD_SELECT: PAD_SELECT,
	PAD_START: PAD_START,
	PAD_UP: PAD_UP,
	PAD_VENDOR: PAD_VENDOR,
	PARTICLEMODE_CPU: PARTICLEMODE_CPU,
	PARTICLEMODE_GPU: PARTICLEMODE_GPU,
	PARTICLEORIENTATION_EMITTER: PARTICLEORIENTATION_EMITTER,
	PARTICLEORIENTATION_SCREEN: PARTICLEORIENTATION_SCREEN,
	PARTICLEORIENTATION_WORLD: PARTICLEORIENTATION_WORLD,
	PARTICLESORT_DISTANCE: PARTICLESORT_DISTANCE,
	PARTICLESORT_NEWER_FIRST: PARTICLESORT_NEWER_FIRST,
	PARTICLESORT_NONE: PARTICLESORT_NONE,
	PARTICLESORT_OLDER_FIRST: PARTICLESORT_OLDER_FIRST,
	PIXELFORMAT_111110F: PIXELFORMAT_111110F,
	PIXELFORMAT_A8: PIXELFORMAT_A8,
	PIXELFORMAT_ASTC_4x4: PIXELFORMAT_ASTC_4x4,
	PIXELFORMAT_ATC_RGB: PIXELFORMAT_ATC_RGB,
	PIXELFORMAT_ATC_RGBA: PIXELFORMAT_ATC_RGBA,
	PIXELFORMAT_BGRA8: PIXELFORMAT_BGRA8,
	PIXELFORMAT_DEPTH: PIXELFORMAT_DEPTH,
	PIXELFORMAT_DEPTHSTENCIL: PIXELFORMAT_DEPTHSTENCIL,
	PIXELFORMAT_DXT1: PIXELFORMAT_DXT1,
	PIXELFORMAT_DXT3: PIXELFORMAT_DXT3,
	PIXELFORMAT_DXT5: PIXELFORMAT_DXT5,
	PIXELFORMAT_ETC1: PIXELFORMAT_ETC1,
	PIXELFORMAT_ETC2_RGB: PIXELFORMAT_ETC2_RGB,
	PIXELFORMAT_ETC2_RGBA: PIXELFORMAT_ETC2_RGBA,
	PIXELFORMAT_L8: PIXELFORMAT_L8,
	PIXELFORMAT_L8_A8: PIXELFORMAT_L8_A8,
	PIXELFORMAT_LA8: PIXELFORMAT_LA8,
	PIXELFORMAT_PVRTC_2BPP_RGBA_1: PIXELFORMAT_PVRTC_2BPP_RGBA_1,
	PIXELFORMAT_PVRTC_2BPP_RGB_1: PIXELFORMAT_PVRTC_2BPP_RGB_1,
	PIXELFORMAT_PVRTC_4BPP_RGBA_1: PIXELFORMAT_PVRTC_4BPP_RGBA_1,
	PIXELFORMAT_PVRTC_4BPP_RGB_1: PIXELFORMAT_PVRTC_4BPP_RGB_1,
	PIXELFORMAT_R16F: PIXELFORMAT_R16F,
	PIXELFORMAT_R16I: PIXELFORMAT_R16I,
	PIXELFORMAT_R16U: PIXELFORMAT_R16U,
	PIXELFORMAT_R32F: PIXELFORMAT_R32F,
	PIXELFORMAT_R32I: PIXELFORMAT_R32I,
	PIXELFORMAT_R32U: PIXELFORMAT_R32U,
	PIXELFORMAT_R4_G4_B4_A4: PIXELFORMAT_R4_G4_B4_A4,
	PIXELFORMAT_R5_G5_B5_A1: PIXELFORMAT_R5_G5_B5_A1,
	PIXELFORMAT_R5_G6_B5: PIXELFORMAT_R5_G6_B5,
	PIXELFORMAT_R8I: PIXELFORMAT_R8I,
	PIXELFORMAT_R8U: PIXELFORMAT_R8U,
	PIXELFORMAT_R8_G8_B8: PIXELFORMAT_R8_G8_B8,
	PIXELFORMAT_R8_G8_B8_A8: PIXELFORMAT_R8_G8_B8_A8,
	PIXELFORMAT_RG16F: PIXELFORMAT_RG16F,
	PIXELFORMAT_RG16I: PIXELFORMAT_RG16I,
	PIXELFORMAT_RG16U: PIXELFORMAT_RG16U,
	PIXELFORMAT_RG32I: PIXELFORMAT_RG32I,
	PIXELFORMAT_RG32U: PIXELFORMAT_RG32U,
	PIXELFORMAT_RG8I: PIXELFORMAT_RG8I,
	PIXELFORMAT_RG8U: PIXELFORMAT_RG8U,
	PIXELFORMAT_RGB16F: PIXELFORMAT_RGB16F,
	PIXELFORMAT_RGB32F: PIXELFORMAT_RGB32F,
	PIXELFORMAT_RGB565: PIXELFORMAT_RGB565,
	PIXELFORMAT_RGB8: PIXELFORMAT_RGB8,
	PIXELFORMAT_RGBA16F: PIXELFORMAT_RGBA16F,
	PIXELFORMAT_RGBA16I: PIXELFORMAT_RGBA16I,
	PIXELFORMAT_RGBA16U: PIXELFORMAT_RGBA16U,
	PIXELFORMAT_RGBA32F: PIXELFORMAT_RGBA32F,
	PIXELFORMAT_RGBA32I: PIXELFORMAT_RGBA32I,
	PIXELFORMAT_RGBA32U: PIXELFORMAT_RGBA32U,
	PIXELFORMAT_RGBA4: PIXELFORMAT_RGBA4,
	PIXELFORMAT_RGBA5551: PIXELFORMAT_RGBA5551,
	PIXELFORMAT_RGBA8: PIXELFORMAT_RGBA8,
	PIXELFORMAT_RGBA8I: PIXELFORMAT_RGBA8I,
	PIXELFORMAT_RGBA8U: PIXELFORMAT_RGBA8U,
	PIXELFORMAT_SRGB: PIXELFORMAT_SRGB,
	PIXELFORMAT_SRGBA: PIXELFORMAT_SRGBA,
	PRIMITIVE_LINELOOP: PRIMITIVE_LINELOOP,
	PRIMITIVE_LINES: PRIMITIVE_LINES,
	PRIMITIVE_LINESTRIP: PRIMITIVE_LINESTRIP,
	PRIMITIVE_POINTS: PRIMITIVE_POINTS,
	PRIMITIVE_TRIANGLES: PRIMITIVE_TRIANGLES,
	PRIMITIVE_TRIFAN: PRIMITIVE_TRIFAN,
	PRIMITIVE_TRISTRIP: PRIMITIVE_TRISTRIP,
	PROJECTION_ORTHOGRAPHIC: PROJECTION_ORTHOGRAPHIC,
	PROJECTION_PERSPECTIVE: PROJECTION_PERSPECTIVE,
	ParticleEmitter: ParticleEmitter,
	ParticleSystemComponent: ParticleSystemComponent,
	ParticleSystemComponentSystem: ParticleSystemComponentSystem,
	PhongMaterial: PhongMaterial,
	Picker: Picker,
	Plane: Plane,
	PlaneGeometry: PlaneGeometry,
	PostEffect: PostEffect,
	PostEffectQueue: PostEffectQueue,
	ProgramLibrary: ProgramLibrary,
	QuadRender: QuadRender,
	Quat: Quat,
	RENDERSTYLE_POINTS: RENDERSTYLE_POINTS,
	RENDERSTYLE_SOLID: RENDERSTYLE_SOLID,
	RENDERSTYLE_WIREFRAME: RENDERSTYLE_WIREFRAME,
	RESOLUTION_AUTO: RESOLUTION_AUTO,
	RESOLUTION_FIXED: RESOLUTION_FIXED,
	RIGIDBODY_ACTIVE_TAG: RIGIDBODY_ACTIVE_TAG,
	RIGIDBODY_CF_KINEMATIC_OBJECT: RIGIDBODY_CF_KINEMATIC_OBJECT,
	RIGIDBODY_CF_NORESPONSE_OBJECT: RIGIDBODY_CF_NORESPONSE_OBJECT,
	RIGIDBODY_CF_STATIC_OBJECT: RIGIDBODY_CF_STATIC_OBJECT,
	RIGIDBODY_DISABLE_DEACTIVATION: RIGIDBODY_DISABLE_DEACTIVATION,
	RIGIDBODY_DISABLE_SIMULATION: RIGIDBODY_DISABLE_SIMULATION,
	RIGIDBODY_ISLAND_SLEEPING: RIGIDBODY_ISLAND_SLEEPING,
	RIGIDBODY_TYPE_DYNAMIC: RIGIDBODY_TYPE_DYNAMIC,
	RIGIDBODY_TYPE_KINEMATIC: RIGIDBODY_TYPE_KINEMATIC,
	RIGIDBODY_TYPE_STATIC: RIGIDBODY_TYPE_STATIC,
	RIGIDBODY_WANTS_DEACTIVATION: RIGIDBODY_WANTS_DEACTIVATION,
	Ray: Ray,
	RaycastResult: RaycastResult,
	ReadStream: ReadStream,
	RenderComponent: RenderComponent,
	RenderComponentSystem: RenderComponentSystem,
	RenderHandler: RenderHandler,
	RenderPass: RenderPass,
	RenderPassBloom: RenderPassBloom,
	RenderPassCameraFrame: RenderPassCameraFrame,
	RenderPassColorGrab: RenderPassColorGrab,
	RenderPassCompose: RenderPassCompose,
	RenderPassDownsample: RenderPassDownsample,
	RenderPassForward: RenderPassForward,
	RenderPassShaderQuad: RenderPassShaderQuad,
	RenderPassTAA: RenderPassTAA,
	RenderPassUpsample: RenderPassUpsample,
	RenderTarget: RenderTarget,
	ResourceHandler: ResourceHandler,
	ResourceLoader: ResourceLoader,
	RigidBodyComponent: RigidBodyComponent,
	RigidBodyComponentSystem: RigidBodyComponentSystem,
	RotateGizmo: RotateGizmo,
	SAMPLETYPE_DEPTH: SAMPLETYPE_DEPTH,
	SAMPLETYPE_FLOAT: SAMPLETYPE_FLOAT,
	SAMPLETYPE_INT: SAMPLETYPE_INT,
	SAMPLETYPE_UINT: SAMPLETYPE_UINT,
	SAMPLETYPE_UNFILTERABLE_FLOAT: SAMPLETYPE_UNFILTERABLE_FLOAT,
	SCALEMODE_BLEND: SCALEMODE_BLEND,
	SCALEMODE_NONE: SCALEMODE_NONE,
	SCROLLBAR_VISIBILITY_SHOW_ALWAYS: SCROLLBAR_VISIBILITY_SHOW_ALWAYS,
	SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED: SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED,
	SCROLL_MODE_BOUNCE: SCROLL_MODE_BOUNCE,
	SCROLL_MODE_CLAMP: SCROLL_MODE_CLAMP,
	SCROLL_MODE_INFINITE: SCROLL_MODE_INFINITE,
	SEMANTIC_ATTR: SEMANTIC_ATTR,
	SEMANTIC_ATTR0: SEMANTIC_ATTR0,
	SEMANTIC_ATTR1: SEMANTIC_ATTR1,
	SEMANTIC_ATTR10: SEMANTIC_ATTR10,
	SEMANTIC_ATTR11: SEMANTIC_ATTR11,
	SEMANTIC_ATTR12: SEMANTIC_ATTR12,
	SEMANTIC_ATTR13: SEMANTIC_ATTR13,
	SEMANTIC_ATTR14: SEMANTIC_ATTR14,
	SEMANTIC_ATTR15: SEMANTIC_ATTR15,
	SEMANTIC_ATTR2: SEMANTIC_ATTR2,
	SEMANTIC_ATTR3: SEMANTIC_ATTR3,
	SEMANTIC_ATTR4: SEMANTIC_ATTR4,
	SEMANTIC_ATTR5: SEMANTIC_ATTR5,
	SEMANTIC_ATTR6: SEMANTIC_ATTR6,
	SEMANTIC_ATTR7: SEMANTIC_ATTR7,
	SEMANTIC_ATTR8: SEMANTIC_ATTR8,
	SEMANTIC_ATTR9: SEMANTIC_ATTR9,
	SEMANTIC_BLENDINDICES: SEMANTIC_BLENDINDICES,
	SEMANTIC_BLENDWEIGHT: SEMANTIC_BLENDWEIGHT,
	SEMANTIC_COLOR: SEMANTIC_COLOR,
	SEMANTIC_NORMAL: SEMANTIC_NORMAL,
	SEMANTIC_POSITION: SEMANTIC_POSITION,
	SEMANTIC_TANGENT: SEMANTIC_TANGENT,
	SEMANTIC_TEXCOORD: SEMANTIC_TEXCOORD,
	SEMANTIC_TEXCOORD0: SEMANTIC_TEXCOORD0,
	SEMANTIC_TEXCOORD1: SEMANTIC_TEXCOORD1,
	SEMANTIC_TEXCOORD2: SEMANTIC_TEXCOORD2,
	SEMANTIC_TEXCOORD3: SEMANTIC_TEXCOORD3,
	SEMANTIC_TEXCOORD4: SEMANTIC_TEXCOORD4,
	SEMANTIC_TEXCOORD5: SEMANTIC_TEXCOORD5,
	SEMANTIC_TEXCOORD6: SEMANTIC_TEXCOORD6,
	SEMANTIC_TEXCOORD7: SEMANTIC_TEXCOORD7,
	SHADERDEF_DIRLM: SHADERDEF_DIRLM,
	SHADERDEF_INSTANCING: SHADERDEF_INSTANCING,
	SHADERDEF_LM: SHADERDEF_LM,
	SHADERDEF_LMAMBIENT: SHADERDEF_LMAMBIENT,
	SHADERDEF_MORPH_NORMAL: SHADERDEF_MORPH_NORMAL,
	SHADERDEF_MORPH_POSITION: SHADERDEF_MORPH_POSITION,
	SHADERDEF_MORPH_TEXTURE_BASED: SHADERDEF_MORPH_TEXTURE_BASED,
	SHADERDEF_NOSHADOW: SHADERDEF_NOSHADOW,
	SHADERDEF_SCREENSPACE: SHADERDEF_SCREENSPACE,
	SHADERDEF_SKIN: SHADERDEF_SKIN,
	SHADERDEF_TANGENTS: SHADERDEF_TANGENTS,
	SHADERDEF_UV0: SHADERDEF_UV0,
	SHADERDEF_UV1: SHADERDEF_UV1,
	SHADERDEF_VCOLOR: SHADERDEF_VCOLOR,
	SHADERLANGUAGE_GLSL: SHADERLANGUAGE_GLSL,
	SHADERLANGUAGE_WGSL: SHADERLANGUAGE_WGSL,
	SHADERPASS_ALBEDO: SHADERPASS_ALBEDO,
	SHADERPASS_AO: SHADERPASS_AO,
	SHADERPASS_EMISSION: SHADERPASS_EMISSION,
	SHADERPASS_FORWARD: SHADERPASS_FORWARD,
	SHADERPASS_GLOSS: SHADERPASS_GLOSS,
	SHADERPASS_LIGHTING: SHADERPASS_LIGHTING,
	SHADERPASS_METALNESS: SHADERPASS_METALNESS,
	SHADERPASS_OPACITY: SHADERPASS_OPACITY,
	SHADERPASS_SPECULARITY: SHADERPASS_SPECULARITY,
	SHADERPASS_UV0: SHADERPASS_UV0,
	SHADERPASS_WORLDNORMAL: SHADERPASS_WORLDNORMAL,
	SHADERSTAGE_COMPUTE: SHADERSTAGE_COMPUTE,
	SHADERSTAGE_FRAGMENT: SHADERSTAGE_FRAGMENT,
	SHADERSTAGE_VERTEX: SHADERSTAGE_VERTEX,
	SHADERTAG_MATERIAL: SHADERTAG_MATERIAL,
	SHADER_DEPTH: SHADER_DEPTH,
	SHADER_FORWARD: SHADER_FORWARD,
	SHADER_FORWARDHDR: SHADER_FORWARDHDR,
	SHADER_PICK: SHADER_PICK,
	SHADER_PREPASS_VELOCITY: SHADER_PREPASS_VELOCITY,
	SHADER_SHADOW: SHADER_SHADOW,
	SHADOWUPDATE_NONE: SHADOWUPDATE_NONE,
	SHADOWUPDATE_REALTIME: SHADOWUPDATE_REALTIME,
	SHADOWUPDATE_THISFRAME: SHADOWUPDATE_THISFRAME,
	SHADOW_DEPTH: SHADOW_DEPTH,
	SHADOW_PCF1: SHADOW_PCF1,
	SHADOW_PCF3: SHADOW_PCF3,
	SHADOW_PCF5: SHADOW_PCF5,
	SHADOW_PCSS: SHADOW_PCSS,
	SHADOW_VSM16: SHADOW_VSM16,
	SHADOW_VSM32: SHADOW_VSM32,
	SHADOW_VSM8: SHADOW_VSM8,
	SKYTYPE_BOX: SKYTYPE_BOX,
	SKYTYPE_DOME: SKYTYPE_DOME,
	SKYTYPE_INFINITE: SKYTYPE_INFINITE,
	SORTKEY_DEPTH: SORTKEY_DEPTH,
	SORTKEY_FORWARD: SORTKEY_FORWARD,
	SORTMODE_BACK2FRONT: SORTMODE_BACK2FRONT,
	SORTMODE_CUSTOM: SORTMODE_CUSTOM,
	SORTMODE_FRONT2BACK: SORTMODE_FRONT2BACK,
	SORTMODE_MANUAL: SORTMODE_MANUAL,
	SORTMODE_MATERIALMESH: SORTMODE_MATERIALMESH,
	SORTMODE_NONE: SORTMODE_NONE,
	SPECOCC_AO: SPECOCC_AO,
	SPECOCC_GLOSSDEPENDENT: SPECOCC_GLOSSDEPENDENT,
	SPECOCC_NONE: SPECOCC_NONE,
	SPECULAR_BLINN: SPECULAR_BLINN,
	SPECULAR_PHONG: SPECULAR_PHONG,
	SPRITETYPE_ANIMATED: SPRITETYPE_ANIMATED,
	SPRITETYPE_SIMPLE: SPRITETYPE_SIMPLE,
	SPRITE_RENDERMODE_SIMPLE: SPRITE_RENDERMODE_SIMPLE,
	SPRITE_RENDERMODE_SLICED: SPRITE_RENDERMODE_SLICED,
	SPRITE_RENDERMODE_TILED: SPRITE_RENDERMODE_TILED,
	STENCILOP_DECREMENT: STENCILOP_DECREMENT,
	STENCILOP_DECREMENTWRAP: STENCILOP_DECREMENTWRAP,
	STENCILOP_INCREMENT: STENCILOP_INCREMENT,
	STENCILOP_INCREMENTWRAP: STENCILOP_INCREMENTWRAP,
	STENCILOP_INVERT: STENCILOP_INVERT,
	STENCILOP_KEEP: STENCILOP_KEEP,
	STENCILOP_REPLACE: STENCILOP_REPLACE,
	STENCILOP_ZERO: STENCILOP_ZERO,
	ScaleGizmo: ScaleGizmo,
	Scene: Scene,
	SceneHandler: SceneHandler,
	SceneRegistry: SceneRegistry,
	SceneRegistryItem: SceneRegistryItem,
	SceneSettingsHandler: SceneSettingsHandler,
	ScopeId: ScopeId,
	ScopeSpace: ScopeSpace,
	ScreenComponent: ScreenComponent,
	ScreenComponentSystem: ScreenComponentSystem,
	Script: Script,
	ScriptAttributes: ScriptAttributes,
	ScriptComponent: ScriptComponent,
	ScriptComponentSystem: ScriptComponentSystem,
	ScriptHandler: ScriptHandler,
	ScriptLegacyComponent: ScriptLegacyComponent,
	ScriptLegacyComponentSystem: ScriptLegacyComponentSystem,
	ScriptRegistry: ScriptRegistry,
	ScriptType: ScriptType,
	ScrollViewComponent: ScrollViewComponent,
	ScrollViewComponentSystem: ScrollViewComponentSystem,
	ScrollbarComponent: ScrollbarComponent,
	ScrollbarComponentSystem: ScrollbarComponentSystem,
	Shader: Shader,
	ShaderGenerator: ShaderGenerator,
	ShaderHandler: ShaderHandler,
	ShaderPass: ShaderPass,
	ShaderProcessorOptions: ShaderProcessorOptions,
	ShaderUtils: ShaderUtils,
	SingleContactResult: SingleContactResult,
	Skeleton: Skeleton,
	Skin: Skin,
	SkinBatchInstance: SkinBatchInstance,
	SkinInstance: SkinInstance,
	SortedLoopArray: SortedLoopArray,
	Sound: Sound,
	SoundComponent: SoundComponent,
	SoundComponentSystem: SoundComponentSystem,
	SoundInstance: SoundInstance,
	SoundInstance3d: SoundInstance3d,
	SoundManager: SoundManager,
	SoundSlot: SoundSlot,
	SphereGeometry: SphereGeometry,
	Sprite: Sprite,
	SpriteAnimationClip: SpriteAnimationClip,
	SpriteComponent: SpriteComponent,
	SpriteComponentSystem: SpriteComponentSystem,
	SpriteHandler: SpriteHandler,
	StandardMaterial: StandardMaterial,
	StandardMaterialOptions: StandardMaterialOptions,
	StencilParameters: StencilParameters,
	StorageBuffer: StorageBuffer,
	TEXHINT_ASSET: TEXHINT_ASSET,
	TEXHINT_LIGHTMAP: TEXHINT_LIGHTMAP,
	TEXHINT_NONE: TEXHINT_NONE,
	TEXHINT_SHADOWMAP: TEXHINT_SHADOWMAP,
	TEXTUREDIMENSION_1D: TEXTUREDIMENSION_1D,
	TEXTUREDIMENSION_2D: TEXTUREDIMENSION_2D,
	TEXTUREDIMENSION_2D_ARRAY: TEXTUREDIMENSION_2D_ARRAY,
	TEXTUREDIMENSION_3D: TEXTUREDIMENSION_3D,
	TEXTUREDIMENSION_CUBE: TEXTUREDIMENSION_CUBE,
	TEXTUREDIMENSION_CUBE_ARRAY: TEXTUREDIMENSION_CUBE_ARRAY,
	TEXTURELOCK_NONE: TEXTURELOCK_NONE,
	TEXTURELOCK_READ: TEXTURELOCK_READ,
	TEXTURELOCK_WRITE: TEXTURELOCK_WRITE,
	TEXTUREPROJECTION_CUBE: TEXTUREPROJECTION_CUBE,
	TEXTUREPROJECTION_EQUIRECT: TEXTUREPROJECTION_EQUIRECT,
	TEXTUREPROJECTION_NONE: TEXTUREPROJECTION_NONE,
	TEXTUREPROJECTION_OCTAHEDRAL: TEXTUREPROJECTION_OCTAHEDRAL,
	TEXTURETYPE_DEFAULT: TEXTURETYPE_DEFAULT,
	TEXTURETYPE_RGBE: TEXTURETYPE_RGBE,
	TEXTURETYPE_RGBM: TEXTURETYPE_RGBM,
	TEXTURETYPE_RGBP: TEXTURETYPE_RGBP,
	TEXTURETYPE_SWIZZLEGGGR: TEXTURETYPE_SWIZZLEGGGR,
	TONEMAP_ACES: TONEMAP_ACES,
	TONEMAP_ACES2: TONEMAP_ACES2,
	TONEMAP_FILMIC: TONEMAP_FILMIC,
	TONEMAP_HEJL: TONEMAP_HEJL,
	TONEMAP_LINEAR: TONEMAP_LINEAR,
	TONEMAP_NEUTRAL: TONEMAP_NEUTRAL,
	TRACEID_BINDGROUPFORMAT_ALLOC: TRACEID_BINDGROUPFORMAT_ALLOC,
	TRACEID_BINDGROUP_ALLOC: TRACEID_BINDGROUP_ALLOC,
	TRACEID_COMPUTEPIPELINE_ALLOC: TRACEID_COMPUTEPIPELINE_ALLOC,
	TRACEID_GPU_TIMINGS: TRACEID_GPU_TIMINGS,
	TRACEID_PIPELINELAYOUT_ALLOC: TRACEID_PIPELINELAYOUT_ALLOC,
	TRACEID_RENDERPIPELINE_ALLOC: TRACEID_RENDERPIPELINE_ALLOC,
	TRACEID_RENDER_ACTION: TRACEID_RENDER_ACTION,
	TRACEID_RENDER_FRAME: TRACEID_RENDER_FRAME,
	TRACEID_RENDER_FRAME_TIME: TRACEID_RENDER_FRAME_TIME,
	TRACEID_RENDER_PASS: TRACEID_RENDER_PASS,
	TRACEID_RENDER_PASS_DETAIL: TRACEID_RENDER_PASS_DETAIL,
	TRACEID_RENDER_QUEUE: TRACEID_RENDER_QUEUE,
	TRACEID_RENDER_TARGET_ALLOC: TRACEID_RENDER_TARGET_ALLOC,
	TRACEID_SHADER_ALLOC: TRACEID_SHADER_ALLOC,
	TRACEID_SHADER_COMPILE: TRACEID_SHADER_COMPILE,
	TRACEID_TEXTURES: TRACEID_TEXTURES,
	TRACEID_TEXTURE_ALLOC: TRACEID_TEXTURE_ALLOC,
	TRACEID_VRAM_IB: TRACEID_VRAM_IB,
	TRACEID_VRAM_SB: TRACEID_VRAM_SB,
	TRACEID_VRAM_TEXTURE: TRACEID_VRAM_TEXTURE,
	TRACEID_VRAM_VB: TRACEID_VRAM_VB,
	TRACE_ID_ELEMENT: TRACE_ID_ELEMENT,
	TYPE_FLOAT16: TYPE_FLOAT16,
	TYPE_FLOAT32: TYPE_FLOAT32,
	TYPE_INT16: TYPE_INT16,
	TYPE_INT32: TYPE_INT32,
	TYPE_INT8: TYPE_INT8,
	TYPE_UINT16: TYPE_UINT16,
	TYPE_UINT32: TYPE_UINT32,
	TYPE_UINT8: TYPE_UINT8,
	Tags: Tags,
	Template: Template,
	TemplateHandler: TemplateHandler,
	TextElement: TextElement,
	TextHandler: TextHandler,
	Texture: Texture,
	TextureAtlas: TextureAtlas,
	TextureAtlasHandler: TextureAtlasHandler,
	TextureHandler: TextureHandler,
	TextureUtils: TextureUtils,
	TorusGeometry: TorusGeometry,
	Touch: Touch,
	TouchDevice: TouchDevice,
	TouchEvent: TouchEvent,
	Tracing: Tracing,
	TransformFeedback: TransformFeedback,
	TransformGizmo: TransformGizmo,
	TranslateGizmo: TranslateGizmo,
	Tri: Tri,
	UNIFORMTYPE_BOOL: UNIFORMTYPE_BOOL,
	UNIFORMTYPE_BOOLARRAY: UNIFORMTYPE_BOOLARRAY,
	UNIFORMTYPE_BVEC2: UNIFORMTYPE_BVEC2,
	UNIFORMTYPE_BVEC2ARRAY: UNIFORMTYPE_BVEC2ARRAY,
	UNIFORMTYPE_BVEC3: UNIFORMTYPE_BVEC3,
	UNIFORMTYPE_BVEC3ARRAY: UNIFORMTYPE_BVEC3ARRAY,
	UNIFORMTYPE_BVEC4: UNIFORMTYPE_BVEC4,
	UNIFORMTYPE_BVEC4ARRAY: UNIFORMTYPE_BVEC4ARRAY,
	UNIFORMTYPE_FLOAT: UNIFORMTYPE_FLOAT,
	UNIFORMTYPE_FLOATARRAY: UNIFORMTYPE_FLOATARRAY,
	UNIFORMTYPE_INT: UNIFORMTYPE_INT,
	UNIFORMTYPE_INTARRAY: UNIFORMTYPE_INTARRAY,
	UNIFORMTYPE_ITEXTURE2D: UNIFORMTYPE_ITEXTURE2D,
	UNIFORMTYPE_ITEXTURE2D_ARRAY: UNIFORMTYPE_ITEXTURE2D_ARRAY,
	UNIFORMTYPE_ITEXTURE3D: UNIFORMTYPE_ITEXTURE3D,
	UNIFORMTYPE_ITEXTURECUBE: UNIFORMTYPE_ITEXTURECUBE,
	UNIFORMTYPE_IVEC2: UNIFORMTYPE_IVEC2,
	UNIFORMTYPE_IVEC2ARRAY: UNIFORMTYPE_IVEC2ARRAY,
	UNIFORMTYPE_IVEC3: UNIFORMTYPE_IVEC3,
	UNIFORMTYPE_IVEC3ARRAY: UNIFORMTYPE_IVEC3ARRAY,
	UNIFORMTYPE_IVEC4: UNIFORMTYPE_IVEC4,
	UNIFORMTYPE_IVEC4ARRAY: UNIFORMTYPE_IVEC4ARRAY,
	UNIFORMTYPE_MAT2: UNIFORMTYPE_MAT2,
	UNIFORMTYPE_MAT3: UNIFORMTYPE_MAT3,
	UNIFORMTYPE_MAT4: UNIFORMTYPE_MAT4,
	UNIFORMTYPE_MAT4ARRAY: UNIFORMTYPE_MAT4ARRAY,
	UNIFORMTYPE_TEXTURE2D: UNIFORMTYPE_TEXTURE2D,
	UNIFORMTYPE_TEXTURE2D_ARRAY: UNIFORMTYPE_TEXTURE2D_ARRAY,
	UNIFORMTYPE_TEXTURE2D_SHADOW: UNIFORMTYPE_TEXTURE2D_SHADOW,
	UNIFORMTYPE_TEXTURE3D: UNIFORMTYPE_TEXTURE3D,
	UNIFORMTYPE_TEXTURECUBE: UNIFORMTYPE_TEXTURECUBE,
	UNIFORMTYPE_TEXTURECUBE_SHADOW: UNIFORMTYPE_TEXTURECUBE_SHADOW,
	UNIFORMTYPE_UINT: UNIFORMTYPE_UINT,
	UNIFORMTYPE_UINTARRAY: UNIFORMTYPE_UINTARRAY,
	UNIFORMTYPE_UTEXTURE2D: UNIFORMTYPE_UTEXTURE2D,
	UNIFORMTYPE_UTEXTURE2D_ARRAY: UNIFORMTYPE_UTEXTURE2D_ARRAY,
	UNIFORMTYPE_UTEXTURE3D: UNIFORMTYPE_UTEXTURE3D,
	UNIFORMTYPE_UTEXTURECUBE: UNIFORMTYPE_UTEXTURECUBE,
	UNIFORMTYPE_UVEC2: UNIFORMTYPE_UVEC2,
	UNIFORMTYPE_UVEC2ARRAY: UNIFORMTYPE_UVEC2ARRAY,
	UNIFORMTYPE_UVEC3: UNIFORMTYPE_UVEC3,
	UNIFORMTYPE_UVEC3ARRAY: UNIFORMTYPE_UVEC3ARRAY,
	UNIFORMTYPE_UVEC4: UNIFORMTYPE_UVEC4,
	UNIFORMTYPE_UVEC4ARRAY: UNIFORMTYPE_UVEC4ARRAY,
	UNIFORMTYPE_VEC2: UNIFORMTYPE_VEC2,
	UNIFORMTYPE_VEC2ARRAY: UNIFORMTYPE_VEC2ARRAY,
	UNIFORMTYPE_VEC3: UNIFORMTYPE_VEC3,
	UNIFORMTYPE_VEC3ARRAY: UNIFORMTYPE_VEC3ARRAY,
	UNIFORMTYPE_VEC4: UNIFORMTYPE_VEC4,
	UNIFORMTYPE_VEC4ARRAY: UNIFORMTYPE_VEC4ARRAY,
	UNIFORM_BUFFER_DEFAULT_SLOT_NAME: UNIFORM_BUFFER_DEFAULT_SLOT_NAME,
	URI: URI,
	UniformBufferFormat: UniformBufferFormat,
	UniformFormat: UniformFormat,
	UnsupportedBrowserError: UnsupportedBrowserError,
	UsdzExporter: UsdzExporter,
	VIEW_CENTER: VIEW_CENTER,
	VIEW_LEFT: VIEW_LEFT,
	VIEW_RIGHT: VIEW_RIGHT,
	Vec2: Vec2,
	Vec3: Vec3,
	Vec4: Vec4,
	VertexBuffer: VertexBuffer,
	VertexFormat: VertexFormat,
	VertexIterator: VertexIterator,
	WasmModule: WasmModule,
	WebglGraphicsDevice: WebglGraphicsDevice,
	WebgpuGraphicsDevice: WebgpuGraphicsDevice,
	WorldClusters: WorldClusters,
	XRDEPTHSENSINGFORMAT_F32: XRDEPTHSENSINGFORMAT_F32,
	XRDEPTHSENSINGFORMAT_L8A8: XRDEPTHSENSINGFORMAT_L8A8,
	XRDEPTHSENSINGUSAGE_CPU: XRDEPTHSENSINGUSAGE_CPU,
	XRDEPTHSENSINGUSAGE_GPU: XRDEPTHSENSINGUSAGE_GPU,
	XREYE_LEFT: XREYE_LEFT,
	XREYE_NONE: XREYE_NONE,
	XREYE_RIGHT: XREYE_RIGHT,
	XRHAND_LEFT: XRHAND_LEFT,
	XRHAND_NONE: XRHAND_NONE,
	XRHAND_RIGHT: XRHAND_RIGHT,
	XRPAD_A: XRPAD_A,
	XRPAD_B: XRPAD_B,
	XRPAD_SQUEEZE: XRPAD_SQUEEZE,
	XRPAD_STICK_BUTTON: XRPAD_STICK_BUTTON,
	XRPAD_STICK_X: XRPAD_STICK_X,
	XRPAD_STICK_Y: XRPAD_STICK_Y,
	XRPAD_TOUCHPAD_BUTTON: XRPAD_TOUCHPAD_BUTTON,
	XRPAD_TOUCHPAD_X: XRPAD_TOUCHPAD_X,
	XRPAD_TOUCHPAD_Y: XRPAD_TOUCHPAD_Y,
	XRPAD_TRIGGER: XRPAD_TRIGGER,
	XRSPACE_BOUNDEDFLOOR: XRSPACE_BOUNDEDFLOOR,
	XRSPACE_LOCAL: XRSPACE_LOCAL,
	XRSPACE_LOCALFLOOR: XRSPACE_LOCALFLOOR,
	XRSPACE_UNBOUNDED: XRSPACE_UNBOUNDED,
	XRSPACE_VIEWER: XRSPACE_VIEWER,
	XRTARGETRAY_GAZE: XRTARGETRAY_GAZE,
	XRTARGETRAY_POINTER: XRTARGETRAY_POINTER,
	XRTARGETRAY_SCREEN: XRTARGETRAY_SCREEN,
	XRTRACKABLE_MESH: XRTRACKABLE_MESH,
	XRTRACKABLE_PLANE: XRTRACKABLE_PLANE,
	XRTRACKABLE_POINT: XRTRACKABLE_POINT,
	XRTYPE_AR: XRTYPE_AR,
	XRTYPE_INLINE: XRTYPE_INLINE,
	XRTYPE_VR: XRTYPE_VR,
	XrAnchor: XrAnchor,
	XrAnchors: XrAnchors,
	XrDepthSensing: XrDepthSensing,
	XrDomOverlay: XrDomOverlay,
	XrFinger: XrFinger,
	XrHand: XrHand,
	XrHitTest: XrHitTest,
	XrHitTestSource: XrHitTestSource,
	XrImageTracking: XrImageTracking,
	XrInput: XrInput,
	XrInputSource: XrInputSource,
	XrJoint: XrJoint,
	XrLightEstimation: XrLightEstimation,
	XrManager: XrManager,
	XrMeshDetection: XrMeshDetection,
	XrPlane: XrPlane,
	XrPlaneDetection: XrPlaneDetection,
	XrTrackedImage: XrTrackedImage,
	XrView: XrView,
	XrViews: XrViews,
	ZoneComponent: ZoneComponent,
	ZoneComponentSystem: ZoneComponentSystem,
	__adjustStandardMaterialData: __adjustStandardMaterialData,
	__adjustStandardMaterialParameterTypes: __adjustStandardMaterialParameterTypes,
	__dummyFunction: __dummyFunction,
	anim: anim,
	get app () { return app$1; },
	apps: apps,
	asset: asset,
	audio: audio,
	basisInitialize: basisInitialize,
	basisSetDownloadConfig: basisSetDownloadConfig,
	bindGroupNames: bindGroupNames,
	calculateNormals: calculateNormals,
	calculateTangents: calculateTangents,
	common: common,
	config: config,
	createBox: createBox,
	createCapsule: createCapsule,
	createCone: createCone,
	createCylinder: createCylinder,
	createGraphicsDevice: createGraphicsDevice,
	createMesh: createMesh,
	createPlane: createPlane,
	createScript: createScript,
	createShader: createShader,
	createShaderFromCode: createShaderFromCode,
	createSphere: createSphere,
	createStyle: createStyle,
	createTorus: createTorus,
	createURI: createURI,
	data: data$1,
	dracoInitialize: dracoInitialize,
	drawFullscreenQuad: drawFullscreenQuad,
	drawQuadWithShader: drawQuadWithShader,
	drawTexture: drawTexture,
	events: events,
	extend: extend,
	getPixelFormatArrayType: getPixelFormatArrayType,
	getProgramLibrary: getProgramLibrary,
	getReservedScriptNames: getReservedScriptNames,
	getTouchTargetCoords: getTouchTargetCoords,
	gfx: gfx,
	guid: guid,
	http: http,
	inherits: inherits,
	input: input,
	isCompressedPixelFormat: isCompressedPixelFormat,
	isIntegerPixelFormat: isIntegerPixelFormat,
	log: log,
	makeArray: makeArray,
	math: math,
	now: now,
	path: path,
	pixelFormatInfo: pixelFormatInfo,
	platform: platform,
	posteffect: posteffect,
	prefilterCubemap: prefilterCubemap,
	programlib: programlib,
	registerScript: registerScript,
	reprojectTexture: reprojectTexture,
	revision: revision,
	scene: scene,
	script: script,
	semanticToLocation: semanticToLocation,
	shFromCubemap: shFromCubemap,
	shaderChunks: shaderChunks,
	shaderChunksLightmapper: shaderChunksLightmapper,
	shadowTypeToString: shadowTypeToString,
	shape: shape,
	string: string,
	time: time,
	type: type,
	typedArrayIndexFormats: typedArrayIndexFormats,
	typedArrayIndexFormatsByteSize: typedArrayIndexFormatsByteSize,
	typedArrayToType: typedArrayToType,
	typedArrayTypes: typedArrayTypes,
	typedArrayTypesByteSize: typedArrayTypesByteSize,
	uniformTypeToName: uniformTypeToName,
	uniformTypeToStorage: uniformTypeToStorage,
	version: version,
	vertexTypesNames: vertexTypesNames
});

const loadModules=function(modules,urlPrefix){return new Promise(resolve=>{if(typeof modules==="undefined"||modules.length===0){resolve();}else {let remaining=modules.length;const moduleLoaded=()=>{if(--remaining===0){resolve();}};modules.forEach(function(m){WasmModule.setConfig(m.moduleName,{glueUrl:urlPrefix+m.glueUrl,wasmUrl:urlPrefix+m.wasmUrl,fallbackUrl:urlPrefix+m.fallbackUrl});if(!m.hasOwnProperty("preload")||m.preload){if(m.moduleName==="BASIS"){basisInitialize();moduleLoaded();}else if(m.moduleName==="DracoDecoderModule"){if(dracoInitialize){dracoInitialize();moduleLoaded();}else {WasmModule.getInstance(m.moduleName,moduleLoaded);}}else {WasmModule.getInstance(m.moduleName,moduleLoaded);}}else {moduleLoaded();}});}})};

const ASSET_PREFIX="";const SCRIPT_PREFIX="";const SCENE_PATH="2294334.json";const CONTEXT_OPTIONS={"antialias":true,"alpha":false,"preserveDrawingBuffer":false,"deviceTypes":[`webgl2`,`webgl1`],"powerPreference":"high-performance"};const SCRIPTS=[244954992,244966412,244891621,245062515,244920249,244865047,245106235,245059617,245062516,244920203,244954986,245181059,245204566,245236366,245457625,245543565,245606271,245712352,245718559,245755666,245982318,246266400,246266405,246307574,246309301,247026678,247026754,247026770,247255136,247257465,247369361,247520220,247545230,247545267,247545268,247545277,247545779,247546540,247547473,247616590,247616593];const CONFIG_FILENAME="config.json";const INPUT_SETTINGS={useKeyboard:true,useMouse:true,useGamepads:false,useTouch:true};const PRELOAD_MODULES=[{"moduleName":"Box2D","glueUrl":"files/assets/244864514/1/Box2D_v2.3.1_min.wasm.js","wasmUrl":"files/assets/244864515/1/Box2D_v2.3.1_min.wasm.wasm","fallbackUrl":"files/assets/244864516/1/Box2D_v2.3.1_min.js","preload":true},{"moduleName":"DracoDecoderModule","glueUrl":"files/assets/245251814/1/draco.wasm.js","wasmUrl":"files/assets/245251815/1/draco.wasm.wasm","fallbackUrl":"files/assets/245251813/1/draco.js","preload":true}];script.legacy=false;

const CANVAS_ID="application-canvas";const getIosVersion=()=>{if(/iP(hone|od|ad)/.test(navigator.platform)){const v=navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/);return [parseInt(v[1],10),parseInt(v[2],10),parseInt(v[3]||0,10)]}return null};let lastWindowHeight=window.innerHeight;let lastWindowWidth=window.innerWidth;let windowSizeChangeIntervalHandler=null;const pcBootstrap={reflowHandler:null,iosVersion:getIosVersion(),createCanvas:function(){const canvas=document.createElement("canvas");canvas.setAttribute("id",CANVAS_ID);canvas.setAttribute("tabindex",0);canvas.onselectstart=function(){return false};canvas.style["-webkit-user-select"]="none";document.body.appendChild(canvas);return canvas},resizeCanvas:function(app,canvas){canvas.style.width="";canvas.style.height="";app.resizeCanvas(canvas.width,canvas.height);const fillMode=app._fillMode;if(fillMode===FILLMODE_NONE||fillMode===FILLMODE_KEEP_ASPECT){if(fillMode===FILLMODE_NONE&&canvas.clientHeight<window.innerHeight||canvas.clientWidth/canvas.clientHeight>=window.innerWidth/window.innerHeight){canvas.style.marginTop=Math.floor((window.innerHeight-canvas.clientHeight)/2)+"px";}else {canvas.style.marginTop="";}}lastWindowHeight=window.innerHeight;lastWindowWidth=window.innerWidth;if(this.iosVersion&&this.iosVersion[0]<=12){window.scrollTo(0,0);}},reflow:function(app,canvas){this.resizeCanvas(app,canvas);if(windowSizeChangeIntervalHandler===null){windowSizeChangeIntervalHandler=setInterval(()=>{if(lastWindowHeight!==window.innerHeight||lastWindowWidth!==window.innerWidth){this.resizeCanvas(app,canvas);}},100);setTimeout(function(){if(!!windowSizeChangeIntervalHandler){clearInterval(windowSizeChangeIntervalHandler);windowSizeChangeIntervalHandler=null;}},2e3);}}};window.pcBootstrap=pcBootstrap;const LTC_MAT_1=[];const LTC_MAT_2=[];const canvas=pcBootstrap.createCanvas();const app=new AppBase(canvas);function initCSS(){if(document.head.querySelector){var css=`@media screen and (min-aspect-ratio: ${app._width}/${app._height}) {
            #application-canvas.fill-mode-KEEP_ASPECT {
                width: auto;
                height: 100%;
                margin: 0 auto;
            }
        }`;document.head.querySelector("style").innerHTML+=css;}if(canvas.classList){canvas.classList.add(`fill-mode-${app.fillMode}`);}}function displayError(html){const div=document.createElement("div");div.innerHTML=`<table style="background-color: #8CE; width: 100%; height: 100%;">
    <tr>
        <td align="center">
            <div style="display: table-cell; vertical-align: middle;">
                <div style="">${html}</div>
            </div>
        </td>
    </tr>
</table>`;document.body.appendChild(div);}function createLocalGraphicsDevice(){const deviceOptions=CONTEXT_OPTIONS??{};var LEGACY_WEBGL="webgl";var deviceTypes=[...deviceOptions.deviceTypes,LEGACY_WEBGL];const gpuLibPath="";const gfxOptions={deviceTypes:deviceTypes,glslangUrl:gpuLibPath+"glslang.js",twgslUrl:gpuLibPath+"twgsl.js",powerPreference:deviceOptions.powerPreference,antialias:deviceOptions.antialias!==false,alpha:deviceOptions.alpha===true,preserveDrawingBuffer:!!deviceOptions.preserveDrawingBuffer};return createGraphicsDevice(canvas,gfxOptions)}function initApp(device){try{var createOptions=new AppOptions;createOptions.graphicsDevice=device;createOptions.componentSystems=[RigidBodyComponentSystem,CollisionComponentSystem,JointComponentSystem,AnimationComponentSystem,AnimComponentSystem,ModelComponentSystem,RenderComponentSystem,CameraComponentSystem,LightComponentSystem,ScriptComponentSystem,SoundComponentSystem,AudioListenerComponentSystem,ParticleSystemComponentSystem,ScreenComponentSystem,ElementComponentSystem,ButtonComponentSystem,ScrollViewComponentSystem,ScrollbarComponentSystem,SpriteComponentSystem,LayoutGroupComponentSystem,LayoutChildComponentSystem,ZoneComponentSystem,GSplatComponentSystem];createOptions.resourceHandlers=[RenderHandler,AnimationHandler,AnimClipHandler,AnimStateGraphHandler,ModelHandler,MaterialHandler,TextureHandler,TextHandler,JsonHandler,AudioHandler,ScriptHandler,SceneHandler,CubemapHandler,HtmlHandler,CssHandler,ShaderHandler,HierarchyHandler,FolderHandler,FontHandler,BinaryHandler,TextureAtlasHandler,SpriteHandler,TemplateHandler,ContainerHandler,GSplatHandler];createOptions.elementInput=new ElementInput(canvas,{useMouse:INPUT_SETTINGS.useMouse,useTouch:INPUT_SETTINGS.useTouch});createOptions.keyboard=INPUT_SETTINGS.useKeyboard?new Keyboard(window):null;createOptions.mouse=INPUT_SETTINGS.useMouse?new Mouse(canvas):null;createOptions.gamepads=INPUT_SETTINGS.useGamepads?new GamePads:null;createOptions.touch=INPUT_SETTINGS.useTouch&&platform.touch?new TouchDevice(canvas):null;createOptions.assetPrefix=ASSET_PREFIX??"";createOptions.scriptPrefix=SCRIPT_PREFIX??"";createOptions.scriptsOrder=SCRIPTS??[];createOptions.soundManager=new SoundManager;createOptions.lightmapper=Lightmapper;createOptions.batchManager=BatchManager;createOptions.xr=XrManager;app.init(createOptions);return true}catch(e){displayError("Could not initialize application. Error: "+e);console.error(e);return false}}function configure(){app.configure(CONFIG_FILENAME,err=>{if(err){console.error(err);return}initCSS(canvas,app._fillMode,app._width,app._height);if(LTC_MAT_1.length&&LTC_MAT_2.length&&app.setAreaLightLuts.length===2){app.setAreaLightLuts(LTC_MAT_1,LTC_MAT_2);}setTimeout(()=>{pcBootstrap.reflow(app,canvas);pcBootstrap.reflowHandler=function(){pcBootstrap.reflow(app,canvas);};window.addEventListener("resize",pcBootstrap.reflowHandler,false);window.addEventListener("orientationchange",pcBootstrap.reflowHandler,false);app.preload(()=>{app.scenes.loadScene(SCENE_PATH,err=>{if(err){console.error(err);return}app.start();});});});});}async function main(){try{const device=await createLocalGraphicsDevice();if(initApp(device)){await loadModules(PRELOAD_MODULES,ASSET_PREFIX);configure();}}catch(e){console.error("Device creation error:",e);}}main();Promise.resolve().then(function () { return __loading__; });window.pc=pc;

script.createLoadingScreen(function(app){var showSplash=function(){var wrapper=document.createElement("div");wrapper.id="application-splash-wrapper";document.body.appendChild(wrapper);var splash=document.createElement("div");splash.id="application-splash";wrapper.appendChild(splash);splash.style.display="none";var logo=document.createElement("img");logo.src="https://playcanvas.com/static-assets/images/play_text_252_white.png";splash.appendChild(logo);logo.onload=function(){splash.style.display="block";};var container=document.createElement("div");container.id="progress-bar-container";splash.appendChild(container);var bar=document.createElement("div");bar.id="progress-bar";container.appendChild(bar);};var hideSplash=function(){var splash=document.getElementById("application-splash-wrapper");splash.parentElement.removeChild(splash);};var setProgress=function(value){var bar=document.getElementById("progress-bar");if(bar){value=Math.min(1,Math.max(0,value));bar.style.width=value*100+"%";}};var createCss=function(){var css=["body {","    background-color: #283538;","}","","#application-splash-wrapper {","    position: absolute;","    top: 0;","    left: 0;","    height: 100%;","    width: 100%;","    background-color: #283538;","}","","#application-splash {","    position: absolute;","    top: calc(50% - 28px);","    width: 264px;","    left: calc(50% - 132px);","}","","#application-splash img {","    width: 100%;","}","","#progress-bar-container {","    margin: 20px auto 0 auto;","    height: 2px;","    width: 100%;","    background-color: #1d292c;","}","","#progress-bar {","    width: 0%;","    height: 100%;","    background-color: #f60;","}","","@media (max-width: 480px) {","    #application-splash {","        width: 170px;","        left: calc(50% - 85px);","    }","}"].join("\n");var style=document.createElement("style");style.type="text/css";if(style.styleSheet){style.styleSheet.cssText=css;}else {style.appendChild(document.createTextNode(css));}document.head.appendChild(style);};createCss();showSplash();app.on("preload:end",function(){app.off("preload:progress");});app.on("preload:progress",setProgress);app.on("start",hideSplash);});

var __loading__ = /*#__PURE__*/Object.freeze({
	__proto__: null
});

export { BLEND_NORMAL as B, Color as C, Mesh as M, PRIMITIVE_TRISTRIP as P, Quat as Q, Script as S, Vec2 as V, WasmModule as W, Vec3 as a, Shader as b, Material as c, CULLFACE_NONE as d, BoundingBox as e, MeshInstance as f, SEMANTIC_POSITION as g, SEMANTIC_COLOR as h };
